import{_ as n,o as s,c as a,f as t}from"./app-2a9bb723.js";const e={},p=t(`<p>控制反转（IOC）和依赖注入（DI）是面向对象编程中的重要设计原则，用于降低代码间的耦合度，并提高可维护性和可测试性。本文将介绍 IOC 和 DI 的概念、解决的问题、实现思路以及在 Nest 框架中的具体实现。</p><h2 id="什么是-ioc" tabindex="-1"><a class="header-anchor" href="#什么是-ioc" aria-hidden="true">#</a> 什么是 IOC</h2><p>IOC（Inversion of Control，控制反转）是一种设计原则，通过将对象的创建和管理交给一个容器来实现。在非 IOC 模式下，对象之间的依赖关系由调用者来控制和管理。而在 IOC 模式下，对象的创建和依赖关系的管理都由容器来完成，从而实现了对象之间的解耦。</p><h3 id="要解决的问题" tabindex="-1"><a class="header-anchor" href="#要解决的问题" aria-hidden="true">#</a> 要解决的问题</h3><p>在非 IOC 模式下，如果一个类 B 需要使用类 A 的实例，通常会在 B 中创建 A 的实例对象。而如果类 C 又依赖于类 B，这种控制权的嵌套会持续下去，导致依赖关系变得复杂。例如，在一个典型的三层架构中，Controller 依赖于 Service 来实现业务逻辑，Service 依赖于 Repository 来进行数据库操作，Repository 又依赖于 DataSource 来建立数据库连接，而 DataSource 需要从 Config 对象中获取用户名密码等信息。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">{</span> username<span class="token operator">:</span> <span class="token string">&#39;xxx&#39;</span><span class="token punctuation">,</span> password<span class="token operator">:</span> <span class="token string">&#39;xxx&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> dataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataSource</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> repository <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Repository</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Service</span><span class="token punctuation">(</span>repository<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> controller <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Controller</span><span class="token punctuation">(</span>service<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>上述代码存在两个问题： <ol><li>依赖关系复杂，对象的创建必须按照特定顺序实例化。</li><li>这些对象不需要每次都创建新的实例，应该使用单例模式。</li></ol></li></ul><h3 id="实现思路" tabindex="-1"><a class="header-anchor" href="#实现思路" aria-hidden="true">#</a> 实现思路</h3><p>在 IOC 模式下，不再由调用者来查找和创建类的实例，而是将这些职责交给一个容器来管理，以实现类与类之间的解耦。</p><h2 id="di" tabindex="-1"><a class="header-anchor" href="#di" aria-hidden="true">#</a> DI</h2><p>依赖注入（Dependency Injection，DI）是实现控制反转的一种常用方式。在 DI 中，程序会在初始化时扫描类之间的依赖关系，并将这些类的实例注入到容器中。</p><h3 id="思路" tabindex="-1"><a class="header-anchor" href="#思路" aria-hidden="true">#</a> 思路</h3><p>在初始化时，程序会扫描类之间的依赖关系，并将这些类的实例放入容器中。在创建对象时，程序会根据类的依赖关系，将相应的依赖对象注入到类中。</p><h3 id="具体实现" tabindex="-1"><a class="header-anchor" href="#具体实现" aria-hidden="true">#</a> 具体实现</h3><p>IOC 模式是与语言无关的，不同的框架对 DI 的实现方式也有所不同。</p><ul><li>在 Java 的 Spring 框架中，可以通过定义 XML 文件来决定类之间的依赖关系。</li><li>在 Nest 框架中，可以通过装饰器和元数据来实现 DI。在 Nest 框架中，基于 Reflect 的 MetaData 实现了自动分析模块之间的依赖关系。可以使用 Reflect.defineMetadata 和 Reflect.getMetadata 方法来设置和读取类或类属性的元数据。通过配合装饰器语法，可以实现依赖注入。</li></ul><p>以下是一个使用 Nest 框架的装饰器实现的例子：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable<span class="token punctuation">,</span> NestInterceptor<span class="token punctuation">,</span> Inject<span class="token punctuation">,</span> CallHandler<span class="token punctuation">,</span> ExecutionContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;@nestjs/common&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable<span class="token punctuation">,</span> NestInterceptor<span class="token punctuation">,</span> Inject<span class="token punctuation">,</span> CallHandler<span class="token punctuation">,</span> ExecutionContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;@nestjs/common&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Reflector <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;@nestjs/core&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;rxjs&#39;</span><span class="token punctuation">;</span>

<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">NestInterceptor</span> <span class="token punctuation">{</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span>Reflector<span class="token punctuation">)</span>
  <span class="token keyword">private</span> reflector<span class="token operator">:</span> Reflector<span class="token punctuation">;</span>

  <span class="token function">intercept</span><span class="token punctuation">(</span>context<span class="token operator">:</span> ExecutionContext<span class="token punctuation">,</span> next<span class="token operator">:</span> CallHandler<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Observable<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Observable<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reflector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;roles&#39;</span><span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reflector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;roles&#39;</span><span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> next<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="ioc-和-di-的关系" tabindex="-1"><a class="header-anchor" href="#ioc-和-di-的关系" aria-hidden="true">#</a> IOC 和 DI 的关系</h2><p>控制反转是一种设计原则，而依赖注入是实现 IOC 的一种常用方式。除了依赖注入，还有其他实现 IOC 的方式，比如依赖查找（Dependency Lookup）等。</p><h2 id="解决循环引用问题" tabindex="-1"><a class="header-anchor" href="#解决循环引用问题" aria-hidden="true">#</a> 解决循环引用问题</h2><p>在模块和服务之间可能存在相互引用的情况，这样就会出现循环依赖。Nest 框架通过使用 forwardRef 来解决循环引用的问题。forwardRef 可以在模块之间创建一个转发引用，Nest 会单独创建这两个模块，并将它们关联起来。</p><h3 id="模块中的使用示例" tabindex="-1"><a class="header-anchor" href="#模块中的使用示例" aria-hidden="true">#</a> 模块中的使用示例：</h3><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> BModule<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="服务中的使用示例" tabindex="-1"><a class="header-anchor" href="#服务中的使用示例" aria-hidden="true">#</a> 服务中的使用示例：</h3><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Service</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Inject</span></span><span class="token punctuation">(</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> BService<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">private</span> bService<span class="token operator">:</span> BService<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是关于控制反转（IOC）与依赖注入（DI）的更深入介绍。通过 IOC 和 DI 的应用，可以实现代码的解耦和提高可维护性。在 Nest 框架中，通过装饰器和元数据的使用，可以更便捷地实现依赖注入。同时，使用 forwardRef 可以解决循环引用的问题，确保模块和服务之间的依赖关系正确建立。</p>`,27),o=[p];function c(l,i){return s(),a("div",null,o)}const u=n(e,[["render",c],["__file","IOC-DL.html.vue"]]);export{u as default};
