import{_ as n,r as s,o as c,c as o,d as t,f as a}from"./app-2a9bb723.js";const i={},l=a(`<h2 id="实现-requestidlecallback" tabindex="-1"><a class="header-anchor" href="#实现-requestidlecallback" aria-hidden="true">#</a> 实现 requestIdleCallback</h2><h3 id="浏览器一帧" tabindex="-1"><a class="header-anchor" href="#浏览器一帧" aria-hidden="true">#</a> 浏览器一帧</h3><p>当前大多数的屏幕刷新率都是 <code>60hz</code>，也就是每秒屏幕刷新 <code>60</code> 次，低于 <code>60hz</code> 人眼就会感知卡顿掉帧等情况，同样我们前端浏览器所说的 <code>FPS（frame per second）</code>是浏览器每秒刷新的次数，理论上 <code>FPS</code> 越高人眼觉得界面越流畅，在两次屏幕硬件刷新之间，浏览器正好进行一次刷新（重绘），网页也会很流畅，当然这种是理想模式， 如果两次硬件刷新之间浏览器重绘多次是没意义的，只会消耗资源，如果浏览器重绘一次的时间是硬件多次刷新的时间，那么人眼将感知卡顿掉帧等， 所以浏览器对一次重绘的渲染工作需要在 <code>16ms（1000ms/60）</code>之内完成，也就是说每一次重绘小于 16ms 才不会卡顿掉帧。</p><p><strong>浏览器的一帧说的就是一次完整的重绘。</strong></p><p>一次重绘浏览器需要做哪些事情？</p><figure><img src="https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/browser-frame.awebp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="认识-requestidlecallback" tabindex="-1"><a class="header-anchor" href="#认识-requestidlecallback" aria-hidden="true">#</a> 认识 requestIdleCallback</h3><p>在执行优先级较低的任务时，可以考虑使用 <code>window.requestIdleCallback()</code>，意为交予任务给浏览器，浏览器有空闲的时候执行而不是立即执行这些任务。</p><p>这样这些优先级较低的任务就不阻碍主线程的任务，以达到性能优化的效果。</p><figure><img src="https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/browser-frame2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>workLoop<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">50</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 优先级较低的工作</span>
<span class="token keyword">function</span> <span class="token function">workLoop</span><span class="token punctuation">(</span><span class="token parameter">deadline</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果帧内有富余的时间，或者超时 则执行任务</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">||</span> deadline<span class="token punctuation">.</span>didTimeout<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> works<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行的函数....</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 有未完成的任务 则重新调度</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>works<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>workLoop<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">50</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>callback</code>: 一个在事件循环空闲时即将被调用的函数的引用。函数会接收到一个名为 <code>IdleDeadline</code> 的参数，这个参数可以获取当前空闲时间以及回调是否在超时时间前已经执行的状态。其中 <code>IdleDeadline</code> 对象包含： <ul><li><code>didTimeout</code>，布尔值，表示任务是否超时，结合 <code>timeRemaining</code> 使用。</li><li><code>timeRemaining()</code>，表示当前帧剩余的时间，也可理解为留给任务的时间还有多少。</li></ul></li><li><code>timeout</code>: 表示超过这个时间后，如果任务还没执行，则强制执行，不必等待空闲。尚未通过超时毫秒数调用回调，那么回调会在下一次空闲时期被强制执行。如果明确在某段时间内执行回调，可以设置 <code>timeout</code> <code>值。在浏览器繁忙的时候，requestIdleCallback</code> 超时执行就和 <code>setTimeout</code> 效果一样。</li></ul><h3 id="浏览器什么时候有空闲时段" tabindex="-1"><a class="header-anchor" href="#浏览器什么时候有空闲时段" aria-hidden="true">#</a> 浏览器什么时候有空闲时段</h3><h5 id="场景一" tabindex="-1"><a class="header-anchor" href="#场景一" aria-hidden="true">#</a> 场景一</h5><p>当浏览器一帧渲染所用时间小于屏幕刷新率（对于具有 60Hz 的设备，一帧间隔应该小于 16ms）时间，到下一帧渲染渲染开始时出现的空闲时间，如图 idle period，</p><figure><img src="https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/browser-frame2.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="场景二" tabindex="-1"><a class="header-anchor" href="#场景二" aria-hidden="true">#</a> 场景二</h5><p>当浏览器没有可渲染的任务，主线程一直处于空闲状态，事件队列为空。为了避免在不可预测的任务（例如用户输入的处理）中引起用户可察觉的延迟，这些空闲周期的长度应限制为最大值 <code>50ms</code>，也就是 <code>timeRemaining</code> 最大不超过 50（也就是 20fps，这也是 <code>react polyfill</code> 的原因之一），当空闲时段结束时，可以调度另一个空闲时段，如果它保持空闲，那么空闲时段将更长，后台任务可以在更长时间段内发生。如图:</p><figure><img src="https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/browser-frame3.awebp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="react-如何实现-requestidlecallback" tabindex="-1"><a class="header-anchor" href="#react-如何实现-requestidlecallback" aria-hidden="true">#</a> react 如何实现 requestIdleCallback</h3><p>前面提到 <code>requestIdleCallback</code> 工作只有 <code>20FPS</code>，一般对用户来感觉来说，需要到 <code>60FPS</code> 才是流畅的, 即一帧时间为 <code>16.7 ms</code>，所以这也是 react 团队自己实现 <code>requestIdleCallback</code> 的原因。</p><p><strong>实现大致思路是在 requestAnimationFrame 获取一桢的开始时间，触发一个 postMessage，在空闲的时候调用 idleTick 来完成异步任务。</strong></p>`,22),p=a('<h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p><code>requestIdleCallback</code> 需要注意的：</p><ul><li><code>requestIdleCallback</code> 是屏幕渲染之后执行的。</li><li>一些低优先级的任务可使用 <code>requestIdleCallback</code> 等浏览器不忙的时候来执行，同时因为时间有限，它所执行的任务应该尽量是能够量化，细分的微任务（micro task）比较适合 <code>requestIdleCallback</code>。</li><li><code>requestIdleCallback</code> 不会和帧对齐，所以涉及到 DOM 的操作和动画最好放在 <code>requestAnimationFrame</code> 中执行，<code>requestAnimationFrame</code> 在重新渲染屏幕之前执行。</li><li><code>Promise</code> 也不建议在这里面进行，因为 <code>Promise</code> 的回调属性 <code>Event loop</code> 中优先级较高的一种微任务，会在 <code>requestIdleCallback</code> 结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms。</li></ul>',3);function d(r,u){const e=s("Tabs");return c(),o("div",null,[l,t(e,{id:"85",data:[]}),p])}const m=n(i,[["render",d],["__file","requestIdleCallback.html.vue"]]);export{m as default};
