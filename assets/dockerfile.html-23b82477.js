import{_ as o,r as c,o as t,c as r,a as e,b as a,d as n,f as i}from"./app-2a9bb723.js";const d={},l=e("h2",{id:"dockerfile",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#dockerfile","aria-hidden":"true"},"#"),a(" DockerFile")],-1),p={href:"https://docs.docker.com/engine/reference/builder",target:"_blank",rel:"noopener noreferrer"},g=i(`<figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221025173147579.png" alt="image-20221025173147579" tabindex="0" loading="lazy"><figcaption>image-20221025173147579</figcaption></figure><p>构建三步骤</p><ul><li>编写 Dockerfile 文件</li><li>docker build 命令构建镜像</li><li>docker run 依镜像运行容器实例</li></ul><h2 id="dockerfile-构建过程解析" tabindex="-1"><a class="header-anchor" href="#dockerfile-构建过程解析" aria-hidden="true">#</a> DockerFile 构建过程解析</h2><h3 id="dockerfile-内容基础知识" tabindex="-1"><a class="header-anchor" href="#dockerfile-内容基础知识" aria-hidden="true">#</a> Dockerfile 内容基础知识</h3><ol><li>每条保留字指令都<strong>必须为大写字母</strong>且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层并对镜像进行提交</li></ol><h3 id="docker-执行-dockerfile-的大致流程" tabindex="-1"><a class="header-anchor" href="#docker-执行-dockerfile-的大致流程" aria-hidden="true">#</a> Docker 执行 Dockerfile 的大致流程</h3><ul><li>（1）<code>docker</code>从基础镜像运行一个容器</li><li>（2）执行一条指令并对容器作出修改</li><li>（3）执行类似<code>docker commit</code>的操作提交一个新的镜像层</li><li>（4）<code>docker</code>再基于刚提交的镜像运行一个新容器</li><li>（5）执行<code>dockerfile</code>中的下一条指令直到所有指令都执行完成</li></ul><h3 id="小总结" tabindex="-1"><a class="header-anchor" href="#小总结" aria-hidden="true">#</a> 小总结</h3><p>从应用软件的角度来看，<code>Dockerfile</code>、<code>Docker</code>镜像与<code>Docker</code>容器分别代表软件的三个不同阶段，</p><ul><li><code>Dockerfile</code>是软件的原材料</li><li><code>Docker</code>镜像是软件的交付品</li><li><code>Docker</code>容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例</li></ul><p><code>Dockerfile</code>面向开发，<code>Docker</code>镜像成为交付标准，<code>Docker</code>容器则涉及部署与运维，三者缺一不可，合力充当 Docker 体系的基石。</p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221025174124972.png" alt="image-20221025174124972" tabindex="0" loading="lazy"><figcaption>image-20221025174124972</figcaption></figure><p>1、<code>Dockerfile</code>，需要定义一个<code>Dockerfile</code>，<code>Dockerfile</code>定义了进程需要的一切东西。<code>Dockerfile</code>涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计<code>namespace</code>的权限控制)等等;</p><p>2、<code>Docker</code>镜像，在用<code>Dockerfile</code>定义一个文件之后，<code>docker build</code>时会产生一个 Docker 镜像，当运行 <code>Docker</code>镜像时会真正开始提供服务;</p><p>3、<code>Docker</code>容器，容器是直接提供服务的。</p><h2 id="dockerfile-常用保留字指令" tabindex="-1"><a class="header-anchor" href="#dockerfile-常用保留字指令" aria-hidden="true">#</a> DockerFile 常用保留字指令</h2><h3 id="from" tabindex="-1"><a class="header-anchor" href="#from" aria-hidden="true">#</a> FROM</h3><p>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是 from</p><h3 id="maintainer" tabindex="-1"><a class="header-anchor" href="#maintainer" aria-hidden="true">#</a> MAINTAINER</h3><p>镜像维护者的姓名和邮箱地址</p><h3 id="rum" tabindex="-1"><a class="header-anchor" href="#rum" aria-hidden="true">#</a> RUM</h3><p>容器构建时需要运行的命令</p><ul><li>shell 格式</li></ul><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221025175142566.png" alt="image-20221025175142566" tabindex="0" loading="lazy"><figcaption>image-20221025175142566</figcaption></figure><ul><li>exec 格式</li></ul><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221025175157422.png" alt="image-20221025175157422" tabindex="0" loading="lazy"><figcaption>image-20221025175157422</figcaption></figure><h3 id="expose" tabindex="-1"><a class="header-anchor" href="#expose" aria-hidden="true">#</a> EXPOSE</h3><p>当前容器对外暴露出的端口</p><h3 id="workdir" tabindex="-1"><a class="header-anchor" href="#workdir" aria-hidden="true">#</a> WORKDIR</h3><p>指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p><h3 id="user" tabindex="-1"><a class="header-anchor" href="#user" aria-hidden="true">#</a> USER</h3><p>指定该镜像以什么样的用户去执行，如果都不指定，默认是 root</p><h3 id="env" tabindex="-1"><a class="header-anchor" href="#env" aria-hidden="true">#</a> ENV</h3><p>用来在构建镜像过程中设置环境变量</p><h3 id="add" tabindex="-1"><a class="header-anchor" href="#add" aria-hidden="true">#</a> ADD</h3><p>将宿主机目录下的文件拷贝进镜像且会自动处理 URL 和解压 tar 压缩包</p><h3 id="copy" tabindex="-1"><a class="header-anchor" href="#copy" aria-hidden="true">#</a> COPY</h3><p>类似 ADD，拷贝文件和目录到镜像中。 将从构建上下文目录中 <strong>&lt;源路径&gt;</strong> 的文件/目录复制到新的一层的镜像内的 <strong>&lt;目标路径&gt;</strong> 位置</p><div class="language-crystal line-numbers-mode" data-ext="crystal"><pre class="language-crystal"><code><span class="token constant">COPY</span> src dest
<span class="token constant">COPY</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;src&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;dest&quot;</span></span><span class="token punctuation">]</span>
<span class="token operator">&lt;</span>src源路径<span class="token operator">&gt;</span>：源文件或者源目录
<span class="token operator">&lt;</span>dest目标路径<span class="token operator">&gt;</span>：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="volume" tabindex="-1"><a class="header-anchor" href="#volume" aria-hidden="true">#</a> VOLUME</h3><p>容器数据卷，用于数据保存和持久化工作</p><h3 id="cmd" tabindex="-1"><a class="header-anchor" href="#cmd" aria-hidden="true">#</a> CMD</h3><p>指定容器启动后的要干的事情</p><p><code>CMD</code>指令的格式和<code>RUN</code>相以，也是两种格式：</p><ul><li>shell 格式：<code>CND&lt;命令&gt;</code></li><li>exec 格式：<code>CND[&quot;可执行文件&quot;，&quot;参数1&quot;，&quot;参数2&quot;..]</code></li><li>参数列表格式：<code>CMD[&quot;参数1&quot;，&quot;参数2&quot;..]</code>。在指定了<code>ENTRYPOINT</code>指令后，用 CND 指定具体的参数。</li></ul><p>WARNING</p><p><code>Dockerfile</code> 中可以有多个 <code>CMD</code> 指令，<strong>但只有最后一个生效，<code>CMD</code> 会被 <code>docker run</code> 之后的参数替换</strong></p><p>参考官网<code>Tomcat</code>的<code>dockerfile</code>演示讲解</p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026091950694.png" alt="image-20221026091950694" tabindex="0" loading="lazy"><figcaption>image-20221026091950694</figcaption></figure><p><strong>我们演示自己的覆盖操作</strong></p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026092007321.png" alt="image-20221026092007321" tabindex="0" loading="lazy"><figcaption>image-20221026092007321</figcaption></figure><p><strong>它和前面 RUN 命令的区别</strong></p><ul><li>CMD 是在 <code>docker run</code> 时运行</li><li>RUN 是在 <code>docker build</code> 时运行</li></ul><h3 id="entrypoint" tabindex="-1"><a class="header-anchor" href="#entrypoint" aria-hidden="true">#</a> ENTRYPOINT</h3><p>也是用来指定一个容器启动时要运行的命令</p><p>类似于 <code>CMD</code> 指令，<strong>但是<code>ENTRYPOINT</code>不会被<code>docker run</code>后面的命令覆盖</strong>， 而且这些命令行参数<strong>会被当作参数送给 ENTRYPOINT 指令指定的程序</strong></p><p><strong>命令格式和案例说明：</strong></p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026092602383.png" alt="image-20221026092602383" tabindex="0" loading="lazy"><figcaption>image-20221026092602383</figcaption></figure><p><code>ENTRYPOINT</code>可以和 CMD 一起用，一般是变参才会使用 <code>CMD</code> ，这里的 <code>CMD</code> 等于是在给 <code>ENTRYPOINT</code> 传参。</p><p>当指定了<code>ENTRYPOINT</code>后，CMD 的含义就发生了变化，不再是直接运行其命令而是将 CMD 的内容作为参数传递给<code>ENTRYPOINT</code>指令，他两个组合会变成</p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026092623867.png" alt="image-20221026092623867" tabindex="0" loading="lazy"><figcaption>image-20221026092623867</figcaption></figure><p>**案例如下：**假设已通过 <code>Dockerfile</code> 构建了 <strong><code>nginx:test</code></strong> 镜像：</p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026092655607.png" alt="image-20221026092655607" tabindex="0" loading="lazy"><figcaption>image-20221026092655607</figcaption></figure><table><thead><tr><th>是否传参</th><th>按照 dockerfile 编写执行</th><th>传参运行</th></tr></thead><tbody><tr><td>Docker 命令</td><td>docker run nginx:test</td><td>docker run nginx:test -c /etc/nginx/new.conf</td></tr><tr><td>衍生出的实际命令</td><td>nginx -c /etc/nginx/nginx.conf</td><td>nginx -c /etc/nginx/new.conf</td></tr></tbody></table><p>TIP</p><p>优点：在执行<code>docker run</code>的时候可以指定 <code>ENTRYPOINT</code> 运行所需的参数。</p><p>注意：如果 <code>Dockerfile</code> 中如果存在多个 <code>ENTRYPOINT</code> 指令，仅最后一个生效。</p><h3 id="小总结-1" tabindex="-1"><a class="header-anchor" href="#小总结-1" aria-hidden="true">#</a> 小总结</h3><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026093032611.png" alt="image-20221026093032611" tabindex="0" loading="lazy"><figcaption>image-20221026093032611</figcaption></figure><h2 id="案例" tabindex="-1"><a class="header-anchor" href="#案例" aria-hidden="true">#</a> 案例</h2><p>自定义镜像 mycentosjava8</p><ul><li><p>Centos7 镜像具备 vim+ifconfig+jdk8</p></li><li><p>JDK 的下载镜像地址</p></li></ul>`,73),u={href:"https://www.oracle.com/java/technologies/downloads/#java8",target:"_blank",rel:"noopener noreferrer"},k=e("figure",null,[e("img",{src:"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026102031246.png",alt:"image-20221026102031246",tabindex:"0",loading:"lazy"}),e("figcaption",null,"image-20221026102031246")],-1),m={href:"https://mirrors.yangxingzhen.com/jdk/",target:"_blank",rel:"noopener noreferrer"},h=i(`<p>准备编写 Dockerfile 文件</p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026102052196.png" alt="image-20221026102052196" tabindex="0" loading="lazy"><figcaption>image-20221026102052196</figcaption></figure><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> centos</span>
<span class="token instruction"><span class="token keyword">MAINTAINER</span> zzyy&lt;zzyybs@126.com&gt;</span>

<span class="token instruction"><span class="token keyword">ENV</span> MYPATH /usr/local</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> <span class="token variable">$MYPATH</span></span>

<span class="token comment">#安装vim编辑器</span>
<span class="token instruction"><span class="token keyword">RUN</span> yum -y install vim</span>
<span class="token comment">#安装ifconfig命令查看网络IP</span>
<span class="token instruction"><span class="token keyword">RUN</span> yum -y install net-tools</span>
<span class="token comment">#安装java8及lib库</span>
<span class="token instruction"><span class="token keyword">RUN</span> yum -y install glibc.i686</span>
<span class="token instruction"><span class="token keyword">RUN</span> mkdir /usr/local/java</span>
<span class="token comment">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span>
<span class="token instruction"><span class="token keyword">ADD</span> jdk-8u171-linux-x64.tar.gz /usr/local/java/</span>
<span class="token comment">#配置java环境变量</span>
<span class="token instruction"><span class="token keyword">ENV</span> JAVA_HOME /usr/local/java/jdk1.8.0_171</span>
<span class="token instruction"><span class="token keyword">ENV</span> JRE_HOME <span class="token variable">$JAVA_HOME</span>/jre</span>
<span class="token instruction"><span class="token keyword">ENV</span> CLASSPATH <span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jar:<span class="token variable">$JRE_HOME</span>/lib:<span class="token variable">$CLASSPATH</span></span>
<span class="token instruction"><span class="token keyword">ENV</span> PATH <span class="token variable">$JAVA_HOME</span>/bin:<span class="token variable">$PATH</span></span>

<span class="token instruction"><span class="token keyword">EXPOSE</span> 80</span>

<span class="token instruction"><span class="token keyword">CMD</span> echo <span class="token variable">$MYPATH</span></span>
<span class="token instruction"><span class="token keyword">CMD</span> echo <span class="token string">&quot;success--------------ok&quot;</span></span>
<span class="token instruction"><span class="token keyword">CMD</span> /bin/bash</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大写字母 D、构建</p><div class="language-crystal line-numbers-mode" data-ext="crystal"><pre class="language-crystal"><code>docker build <span class="token operator">-</span>t 新镜像名字<span class="token symbol">:TAG</span> <span class="token punctuation">.</span>
docker build <span class="token operator">-</span>t centosjava8<span class="token operator">:</span><span class="token number">1.5</span> <span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意，上面 TAG 后面有个空格，有个点，代表当前目录</p></blockquote><p>运行</p><div class="language-crystal line-numbers-mode" data-ext="crystal"><pre class="language-crystal"><code>docker run <span class="token operator">-</span>it 新镜像名字<span class="token symbol">:TAG</span>
docker run <span class="token operator">-</span>it centosjava8<span class="token operator">:</span><span class="token number">1.5</span> <span class="token operator">/</span>bin<span class="token operator">/</span>bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026102424772.png" alt="image-20221026102424772" tabindex="0" loading="lazy"><figcaption>image-20221026102424772</figcaption></figure><h2 id="虚悬镜像" tabindex="-1"><a class="header-anchor" href="#虚悬镜像" aria-hidden="true">#</a> 虚悬镜像</h2><p>是什么：仓库名、标签都是<code>&lt;none&gt;</code>的镜像，俗称 dangling image，Dockerfile 写一个。</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">from</span> ubuntu</span>
<span class="token instruction"><span class="token keyword">CMD</span> echo <span class="token string">&#39;action is success&#39;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026103459708.png" alt="image-20221026103459708" tabindex="0" loading="lazy"><figcaption>image-20221026103459708</figcaption></figure><p>查看</p><div class="language-crystal line-numbers-mode" data-ext="crystal"><pre class="language-crystal"><code>docker image ls <span class="token operator">-</span>f dangling<span class="token operator">=</span><span class="token boolean">true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026103518732.png" alt="image-20221026103518732" tabindex="0" loading="lazy"><figcaption>image-20221026103518732</figcaption></figure><p>删除</p><p>虚悬镜像已经失去存在价值，可以删除</p><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026103545644.png" alt="image-20221026103545644" tabindex="0" loading="lazy"><figcaption>image-20221026103545644</figcaption></figure><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><figure><img src="https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026103626226.png" alt="image-20221026103626226" tabindex="0" loading="lazy"><figcaption>image-20221026103626226</figcaption></figure>`,21);function f(v,b){const s=c("ExternalLinkIcon");return t(),r("div",null,[l,e("p",null,[e("a",p,[a("官网 open in new window"),n(s)]),a("，Dockerfile 是用来构建 Docker 镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。")]),g,e("p",null,[e("a",u,[a("https://www.oracle.com/java/technologies/downloads/#java8"),n(s)])]),k,e("p",null,[e("a",m,[a("https://mirrors.yangxingzhen.com/jdk/"),n(s)])]),h])}const y=o(d,[["render",f],["__file","dockerfile.html.vue"]]);export{y as default};
