import{_ as n,r as c,o as a,c as i,e as d,a as e,b as o,d as s,f as l}from"./app-2a9bb723.js";const f={},r=l('<h2 id="useeffect-依赖执行关系" tabindex="-1"><a class="header-anchor" href="#useeffect-依赖执行关系" aria-hidden="true">#</a> useEffect 依赖执行关系</h2><p><code>useEffect</code> 第二个参数[]如何影响 fn 的执行？换句话说，它的第二个参数是如何影响 <code>fiber</code> 创建 <code>Passive Effect</code> 的？</p><ol><li>不包含第二个参数 <code>useEffect(() =&gt; {})</code>，<code>Mount</code> &amp; <code>Update</code> 时，每次 <code>render</code> 时都会创建一个 <code>Passive Effect</code>;</li><li>包含一个空数组[]作为依赖项 <code>useEffect(() =&gt; {}, [])</code>，它会在 <code>mount</code> 时，创建 <code>Passive Effect</code></li><li>包含一个依赖项<code>[dep]</code>，它会在 mount 时，dep 依赖项变化时，创建 Passive Effect</li></ol><h2 id="fn-和-componentdidmount-的执行时机分别是什么" tabindex="-1"><a class="header-anchor" href="#fn-和-componentdidmount-的执行时机分别是什么" aria-hidden="true">#</a> fn 和 componentDidMount 的执行时机分别是什么？</h2><p><strong>过程</strong></p><p>render 阶段到 commit 阶段，传递的时包含不同 fiber 节点的 effect 的链表，commit 阶段时将状态变化（Effect）渲染在视图中</p><ul><li>渲染视图前，beforeMutation 阶段</li><li>渲染视图中，mutation 阶段，Placement 会执行 appendChild，DOM 节点插入到视图中</li><li>渲染视图后，layout 阶段，调用 componentDidMount</li></ul><ol><li>useEffect 时 commit 完成后异步调用</li><li>componentDidMount 是 commit 阶段完成视图更新（mutation 阶段）后，在 layout 阶段同步调用</li><li>useLayoutEffect 和 componentDidMount 调用时机一致，也是在 layout 阶段同步调用</li></ol><figure><img src="https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/hooks-api.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',9),u=e("h2",{id:"相关文章",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#相关文章","aria-hidden":"true"},"#"),o(" 相关文章")],-1),m={href:"https://www.yuque.com/lxylona/note/tlc8hz#RnPvS",target:"_blank",rel:"noopener noreferrer"};function p(h,_){const t=c("ExternalLinkIcon");return a(),i("div",null,[r,d(" `useEffect` 可以看成 `componentDidMount / componentDidUpdate / componentWillUnmount` 这 3 个生命周期函数的替代。\n\n但其实他们并不是完全等价，**useEffect 是在浏览器渲染结束之后才执行的，而这三个生命周期函数是在浏览器渲染之前同步执行的**，React 还有一个官方的 hook 是完全等价于这三个生命周期函数的，叫 useLayoutEffect。 "),u,e("ul",null,[e("li",null,[e("a",m,[o("React Hooks: 深入剖析 useMemo 和 useEffect"),s(t)])])])])}const g=n(f,[["render",p],["__file","hook-api.html.vue"]]);export{g as default};
