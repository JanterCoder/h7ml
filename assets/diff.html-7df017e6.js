import{_ as p,r as o,o as c,c as l,a as s,b as n,d as e,f as t}from"./app-2a9bb723.js";const i={},r=s("h2",{id:"react-diff-原理",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#react-diff-原理","aria-hidden":"true"},"#"),n(" react diff 原理")],-1),u=s("h3",{id:"概念",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#概念","aria-hidden":"true"},"#"),n(" 概念")],-1),d={href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L1274-L1410",target:"_blank",rel:"noopener noreferrer"},k=s("code",null,"fiber树构(对比更新)",-1),v=s("code",null,"旧fiber节点",-1),b=s("code",null,"新reactElement",-1),m=s("code",null,"旧fiber节点",-1),h=s("p",null,[n("调和函数仅是"),s("code",null,"fiber树构造"),n("过程中的一个环节, 所以在深入理解这个函数之前, 建议对"),s("code",null,"fiber树构造"),n("有一个宏观的理解(可以参考前文 fiber 树构造(初次创建), fiber 树构造(对比更新), 本节重点探讨其算法的实现细节.")],-1),f=s("p",null,"它的主要作用:",-1),y=s("li",null,[n("给新增,移动,和删除节点设置"),s("code",null,"fiber.flags"),n("(新增, 移动: "),s("code",null,"Placement"),n(", 删除: "),s("code",null,"Deletion"),n(")")],-1),w=s("code",null,"fiber",-1),F={href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L275-L294",target:"_blank",rel:"noopener noreferrer"},g=s("code",null,"Deletion",-1),C=s("code",null,"effects",-1),_=s("code",null,"completeWork",-1),x=s("code",null,"fiber",-1),I=s("code",null,"completeWork",-1),E=s("code",null,"beginWork",-1),j=t('<h3 id="特性" tabindex="-1"><a class="header-anchor" href="#特性" aria-hidden="true">#</a> 特性</h3><p>算法复杂度低, 从上至下比较整个树形结构, 时间复杂度被缩短到 O(n)</p><h3 id="基本原理" tabindex="-1"><a class="header-anchor" href="#基本原理" aria-hidden="true">#</a> 基本原理</h3><ol><li>比较对象: <code>fiber</code>对象与<code>ReactElement</code>对象相比较. <ul><li>注意: 此处有一个误区, 并不是两棵 fiber 树相比较, 而是<code>旧fiber</code>对象与<code>新ReactElement</code>对象向比较, 结果生成新的<code>fiber子节点</code>.</li><li>可以理解为输入<code>ReactElement</code>, 经过<code>reconcileChildren()</code>之后, 输出<code>fiber</code>.</li></ul></li><li>比较方案: <ul><li>单节点比较</li><li>可迭代节点比较</li></ul></li></ol><h4 id="单节点比较" tabindex="-1"><a class="header-anchor" href="#单节点比较" aria-hidden="true">#</a> 单节点比较</h4>',5),R={href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L1135-L1233",target:"_blank",rel:"noopener noreferrer"},D=t(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 只保留主干逻辑</span>
<span class="token keyword">function</span> <span class="token function">reconcileSingleElement</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">returnFiber</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token literal-property property">currentFirstChild</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">element</span><span class="token operator">:</span> ReactElement<span class="token punctuation">,</span>
  <span class="token literal-property property">lanes</span><span class="token operator">:</span> Lanes</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token punctuation">{</span>
  <span class="token keyword">const</span> key <span class="token operator">=</span> element<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
  <span class="token keyword">let</span> child <span class="token operator">=</span> currentFirstChild<span class="token punctuation">;</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// currentFirstChild !== null, 表明是对比更新阶段</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>key <span class="token operator">===</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 1. key相同, 进一步判断 child.elementType === element.type</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 只看核心逻辑</span>
        <span class="token keyword">default</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>elementType <span class="token operator">===</span> element<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 1.1 已经匹配上了, 如果有兄弟节点, 需要给兄弟节点打上Deletion标记</span>
            <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 1.2 构造fiber节点, 新的fiber对象会复用current.stateNode, 即可复用DOM对象</span>
            <span class="token keyword">const</span> existing <span class="token operator">=</span> <span class="token function">useFiber</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> element<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
            existing<span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token function">coerceRef</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
            existing<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>
            <span class="token keyword">return</span> existing<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// Didn&#39;t match. 给当前节点点打上Deletion标记</span>
      <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 2. key不相同, 匹配失败, 给当前节点打上Deletion标记</span>
      <span class="token function">deleteChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    child <span class="token operator">=</span> child<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token punctuation">{</span>
    <span class="token comment">// ...省略部分代码, 只看核心逻辑</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 新建节点</span>
  <span class="token keyword">const</span> created <span class="token operator">=</span> <span class="token function">createFiberFromElement</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> returnFiber<span class="token punctuation">.</span>mode<span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  created<span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token function">coerceRef</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  created<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>
  <span class="token keyword">return</span> created<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>如果是新增节点, 直接新建 fiber, 没有多余的逻辑</li><li>如果是对比更新 <ul><li>如果<code>key</code>和<code>type</code>都相同(即: <code>ReactElement.key</code> === <code>Fiber.key</code> 且 <code>Fiber.elementType === ReactElement.type</code>), 则复用</li><li>否则新建</li></ul></li></ol><p>注意: 复用过程是调用<code>useFiber(child, element.props)</code>创建<code>新的fiber</code>对象, 这个<code>新fiber对象.stateNode = currentFirstChild.stateNode</code>, 即<code>stateNode</code>属性得到了复用, 故 DOM 节点得到了复用.</p><h3 id="可迭代节点比较-数组类型-symbol-iterator-fn-iterator-fn" tabindex="-1"><a class="header-anchor" href="#可迭代节点比较-数组类型-symbol-iterator-fn-iterator-fn" aria-hidden="true">#</a> 可迭代节点比较(数组类型, [Symbol.iterator]=fn,[@@iterator]=fn)</h3>`,4),L={href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L1346-L1362",target:"_blank",rel:"noopener noreferrer"},N=t(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">returnFiber</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token literal-property property">currentFirstChild</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">newChild</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token literal-property property">lanes</span><span class="token operator">:</span> Lanes</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isArray</span><span class="token punctuation">(</span>newChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">reconcileChildrenArray</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">,</span> newChild<span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getIteratorFn</span><span class="token punctuation">(</span>newChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">reconcileChildrenIterator</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">,</span> newChild<span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),A=s("code",null,"reconcileChildrenArray函数",-1),P=s("code",null,"reconcileChildrenIterator",-1),S={href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L771-L924",target:"_blank",rel:"noopener noreferrer"},T=s("code",null,"reconcileChildrenArray()",-1),O=s("code",null,"对比更新",-1),B=s("code",null,"对比更新",-1),X=t(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">reconcileChildrenArray</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">returnFiber</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token literal-property property">currentFirstChild</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">newChildren</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">lanes</span><span class="token operator">:</span> Lanes</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token literal-property property">resultingFirstChild</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> <span class="token literal-property property">previousNewFiber</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> oldFiber <span class="token operator">=</span> currentFirstChild<span class="token punctuation">;</span>
  <span class="token keyword">let</span> lastPlacedIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> newIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> nextOldFiber <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 1. 第一次循环: 遍历最长公共序列(key相同), 公共序列的节点都视为可复用</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> oldFiber <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 后文分析</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>newIdx <span class="token operator">===</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果newChildren序列被遍历完, 那么oldFiber序列中剩余节点都视为删除(打上Deletion标记)</span>
    <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> resultingFirstChild<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果oldFiber序列被遍历完, 那么newChildren序列中剩余节点都视为新增(打上Placement标记)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 后文分析</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> resultingFirstChild<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// ==================分割线==================</span>
  <span class="token keyword">const</span> existingChildren <span class="token operator">=</span> <span class="token function">mapRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 2. 第二次循环: 遍历剩余非公共序列, 优先复用oldFiber序列中的节点</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// newChildren已经遍历完, 那么oldFiber序列中剩余节点都视为删除(打上Deletion标记)</span>
    existingChildren<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">child</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">deleteChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> resultingFirstChild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>reconcileChildrenArray</code>函数源码看似很长, 梳理其主干之后, 其实非常清晰.</p><p>通过形参, 首先明确比较对象是<code>currentFirstChild: Fiber | null</code>和<code>newChildren: Array&lt;*&gt;</code>:</p><ul><li><code>currentFirstChild</code>: 是一个<code>fiber</code>节点, 通过<code>fiber.sibling</code>可以将兄弟节点全部遍历出来. 所以可以将<code>currentFirstChild</code>理解为链表头部, 它代表一个序列, 源码中被记为<code>oldFiber</code>.</li><li><code>newChildren</code>: 是一个数组, 其中包含了若干个<code>ReactElement</code>对象. 所以<code>newChildren</code>也代表一个序列.</li></ul><p>所以<code>reconcileChildrenArray</code>实际就是 2 个序列之间的比较(<code>链表oldFiber</code>和<code>数组newChildren</code>), 最后返回合理的<code>fiber</code>序列.</p><p>上述代码中, 以注释分割线为界限, 整个核心逻辑分为 2 步骤:</p><ol><li>第一次循环: 遍历最长<code>公共</code>序列(key 相同), 公共序列的节点都视为可复用 <ul><li>如果<code>newChildren序列</code>被遍历完, 那么<code>oldFiber序列</code>中剩余节点都视为删除(打上<code>Deletion</code>标记)</li><li>如果<code>oldFiber序列</code>被遍历完, 那么<code>newChildren序列</code>中剩余节点都视为新增(打上<code>Placement</code>标记)</li></ul></li><li>第二次循环: 遍历剩余<code>非公共</code>序列, 优先复用 oldFiber 序列中的节点 <ul><li>在对比更新阶段(非初次创建<code>fiber</code>, 此时<code>shouldTrackSideEffects</code>被设置为 true). 第二次循环遍历完成之后, <code>oldFiber序列中</code>没有匹配上的节点都视为删除(打上<code>Deletion</code>标记)</li></ul></li></ol><p>假设有如下图所示 2 个初始化序列:</p><figure><img src="https://7kms.github.io/react-illustration-series/static/before-traverse.71633a39.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>接下来第一次循环, 会遍历公共序列<code>A,B</code>, 生成的 fiber 节点<code>fiber(A), fiber(B)</code>可以复用.</p><figure><img src="https://7kms.github.io/react-illustration-series/static/traverse1.a0313cc2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>最后第二次循环, 会遍历剩余序列<code>E,C,X,Y</code>:</p><ul><li>生成的 fiber 节点<code>fiber(E), fiber(C)</code>可以复用. 其中<code>fiber(C)</code>节点发生了位移(打上<code>Placement</code>标记).</li><li><code>fiber(X), fiber(Y)</code>是新增(打上<code>Placement</code>标记).</li><li>同时<code>oldFiber</code>序列中的<code>fiber(D)</code>节点确定被删除(打上<code>Deletion</code>标记).</li></ul><figure><img src="https://7kms.github.io/react-illustration-series/static/traverse2.a5a39d1b.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>整个主干逻辑就介绍完了, 接下来贴上完整源码</p><blockquote><p>第一次循环</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 1. 第一次循环: 遍历最长公共序列(key相同), 公共序列的节点都视为可复用</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> oldFiber <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber<span class="token punctuation">.</span>index <span class="token operator">&gt;</span> newIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    nextOldFiber <span class="token operator">=</span> oldFiber<span class="token punctuation">;</span>
    oldFiber <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    nextOldFiber <span class="token operator">=</span> oldFiber<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// new槽位和old槽位进行比较, 如果key不同, 返回null</span>
  <span class="token comment">// key相同, 比较type是否一致. type一致则执行useFiber(update逻辑), type不一致则运行createXXX(insert逻辑)</span>
  <span class="token keyword">const</span> newFiber <span class="token operator">=</span> <span class="token function">updateSlot</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">,</span> newChildren<span class="token punctuation">[</span>newIdx<span class="token punctuation">]</span><span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果返回null, 表明key不同. 无法满足公共序列条件, 退出循环</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      oldFiber <span class="token operator">=</span> nextOldFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 若是新增节点, 则给老节点打上Deletion标记</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber <span class="token operator">&amp;&amp;</span> newFiber<span class="token punctuation">.</span>alternate <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">deleteChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// lastPlacedIndex 记录被移动的节点索引</span>
  <span class="token comment">// 如果当前节点可复用, 则要判断位置是否移动.</span>
  lastPlacedIndex <span class="token operator">=</span> <span class="token function">placeChild</span><span class="token punctuation">(</span>newFiber<span class="token punctuation">,</span> lastPlacedIndex<span class="token punctuation">,</span> newIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 更新resultingFirstChild结果序列</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>previousNewFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    resultingFirstChild <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    previousNewFiber<span class="token punctuation">.</span>sibling <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  previousNewFiber <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
  oldFiber <span class="token operator">=</span> nextOldFiber<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>第二次循环</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 1. 将第一次循环后, oldFiber剩余序列加入到一个map中. 目的是为了第二次循环能顺利的找到可复用节点</span>
<span class="token keyword">const</span> existingChildren <span class="token operator">=</span> <span class="token function">mapRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2. 第二次循环: 遍历剩余非公共序列, 优先复用oldFiber序列中的节点</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> newFiber <span class="token operator">=</span> <span class="token function">updateFromMap</span><span class="token punctuation">(</span>existingChildren<span class="token punctuation">,</span> returnFiber<span class="token punctuation">,</span> newIdx<span class="token punctuation">,</span> newChildren<span class="token punctuation">[</span>newIdx<span class="token punctuation">]</span><span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber<span class="token punctuation">.</span>alternate <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果newFiber是通过复用创建的, 则清理map中对应的老节点</span>
        existingChildren<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>newFiber<span class="token punctuation">.</span>key <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> newIdx <span class="token operator">:</span> newFiber<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    lastPlacedIndex <span class="token operator">=</span> <span class="token function">placeChild</span><span class="token punctuation">(</span>newFiber<span class="token punctuation">,</span> lastPlacedIndex<span class="token punctuation">,</span> newIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 更新resultingFirstChild结果序列</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>previousNewFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      resultingFirstChild <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      previousNewFiber<span class="token punctuation">.</span>sibling <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    previousNewFiber <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 3. 善后工作, 第二次循环完成之后, existingChildren中剩余的fiber节点就是将要被删除的节点, 打上Deletion标记</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  existingChildren<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">child</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">deleteChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="结果" tabindex="-1"><a class="header-anchor" href="#结果" aria-hidden="true">#</a> 结果</h3><p>无论是单节点还是可迭代节点的比较, 最终的目的都是生成下级子节点. 并在<code>reconcileChildren</code>过程中, 给一些有副作用的节点(新增, 删除, 移动位置等)打上副作用标记, 等待 commit 阶段(参考 fiber 树渲染的处理.</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本节介绍了 React 源码中, <code>fiber构造循环</code>阶段用于生成下级子节点的<code>reconcileChildren</code>函数(函数中的算法被称为调和算法), 并演示了<code>可迭代节点比较</code>的图解示例. 该算法十分巧妙, 其核心逻辑把<code>newChildren序列</code>分为 2 步遍历, 先遍历公共序列, 再遍历非公共部分, 同时复用<code>oldFiber</code>序列中的节点.</p>`,23);function q(V,z){const a=o("ExternalLinkIcon");return c(),l("div",null,[r,u,s("p",null,[n("调和函数("),s("a",d,[n("源码"),e(a)]),n(")是在"),k,n("过程中对"),v,n("与"),b,n("进行比较, 判定"),m,n("是否可以复用的一个比较函数.")]),h,f,s("ol",null,[y,s("li",null,[n("如果是需要删除的"),w,n(", "),s("a",F,[n("除了自身打上"),g,n("之外, 还要将其添加到父节点的"),C,n("链表中"),e(a)]),n("(正常副作用队列的处理是在"),_,n("函数, 但是该节点(被删除)会脱离"),x,n("树, 不会再进入"),I,n("阶段, 所以在"),E,n("阶段提前加入副作用队列).")])]),j,s("p",null,[n("单节点的逻辑比较简明, 先直接看"),s("a",R,[n("源码"),e(a)]),n(":")]),D,s("p",null,[n("可迭代节点比较, 在"),s("a",L,[n("源码中"),e(a)]),n("被分为了 2 个部分:")]),N,s("p",null,[n("其中"),A,n("(针对数组类型)和"),P,n("(针对可迭代类型)的核心逻辑几乎一致, 下文将分析"),s("a",S,[T,n("函数"),e(a)]),n(". 如果是新增节点, 所有的比较逻辑都无法命中, 只有"),O,n("过程, 才有实际作用, 所以下文重点分析"),B,n("的情况.")]),X])}const W=p(i,[["render",q],["__file","diff.html.vue"]]);export{W as default};
