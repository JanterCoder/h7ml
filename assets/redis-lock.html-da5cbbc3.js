const e=JSON.parse('{"key":"v-5a03075a","path":"/posts/redis/redis-lock.html","title":"redis实现分布式可重入锁","lang":"zh-CN","frontmatter":{"icon":"wrap","order":2,"date":"2019-08-05T00:00:00.000Z","author":"h7ml","title":"redis实现分布式可重入锁","category":"redis","tag":"redis","star":false,"description":"不可重入锁 即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到而阻塞，直到当前线程释放锁后才能获取。 可重入锁 可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。 就是同一个线程再次进入同样代码时，可以再次拿到该锁。 可重入锁作用 防止在同一线程中多次获取锁而导致死锁发生 在 java 的编程中 synchronized 和 ReentrantLock 都是可重入锁","head":[["link",{"rel":"canonical","href":"https://www.h7ml.cn/posts/redis/redis-lock.html"}],["meta",{"property":"og:url","content":"https://www.h7ml.cn/posts/redis/redis-lock.html"}],["meta",{"property":"og:site_name","content":"h7ml-前端物语"}],["meta",{"property":"og:title","content":"redis实现分布式可重入锁"}],["meta",{"property":"og:description","content":"不可重入锁 即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到而阻塞，直到当前线程释放锁后才能获取。 可重入锁 可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。 就是同一个线程再次进入同样代码时，可以再次拿到该锁。 可重入锁作用 防止在同一线程中多次获取锁而导致死锁发生 在 java 的编程中 synchronized 和 ReentrantLock 都是可重入锁"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-03T04:52:44.000Z"}],["meta",{"property":"article:author","content":"h7ml"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:published_time","content":"2019-08-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-03T04:52:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"redis实现分布式可重入锁\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-08-05T00:00:00.000Z\\",\\"dateModified\\":\\"2023-05-03T04:52:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"h7ml\\"}]}"]]},"headers":[{"level":2,"title":"不可重入锁","slug":"不可重入锁","link":"#不可重入锁","children":[]},{"level":2,"title":"可重入锁","slug":"可重入锁","link":"#可重入锁","children":[{"level":3,"title":"可重入锁作用","slug":"可重入锁作用","link":"#可重入锁作用","children":[]}]},{"level":2,"title":"ReentrantLock 可重入锁源码思路","slug":"reentrantlock-可重入锁源码思路","link":"#reentrantlock-可重入锁源码思路","children":[{"level":3,"title":"加锁","slug":"加锁","link":"#加锁","children":[]},{"level":3,"title":"解锁","slug":"解锁","link":"#解锁","children":[]}]},{"level":2,"title":"分布式重入锁（redisson 依然实现，但此处注重原理实现）","slug":"分布式重入锁-redisson-依然实现-但此处注重原理实现","link":"#分布式重入锁-redisson-依然实现-但此处注重原理实现","children":[{"level":3,"title":"1.如何保存现有的线程","slug":"_1-如何保存现有的线程","link":"#_1-如何保存现有的线程","children":[]},{"level":3,"title":"2.加锁次数（重入了多少次），怎么记录维护","slug":"_2-加锁次数-重入了多少次-怎么记录维护","link":"#_2-加锁次数-重入了多少次-怎么记录维护","children":[]}]},{"level":2,"title":"Redisson 是如何实现的","slug":"redisson-是如何实现的","link":"#redisson-是如何实现的","children":[{"level":3,"title":"分析一下 redis 命令","slug":"分析一下-redis-命令","link":"#分析一下-redis-命令","children":[]},{"level":3,"title":"lua 脚本的加锁流程","slug":"lua-脚本的加锁流程","link":"#lua-脚本的加锁流程","children":[]}]}],"git":{"createdTime":1683089564000,"updatedTime":1683089564000,"contributors":[{"name":"h7ml","email":"h7ml@qq.com","commits":1}]},"readingTime":{"minutes":5.65,"words":1694},"filePathRelative":"posts/redis/redis-lock.md","localizedDate":"2019年8月5日","excerpt":"<h2> 不可重入锁</h2>\\n<p>即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到而阻塞，直到当前线程释放锁后才能获取。</p>\\n<h2> 可重入锁</h2>\\n<p>可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。 就是同一个线程再次进入同样代码时，可以再次拿到该锁。</p>\\n<h3> 可重入锁作用</h3>\\n<p>防止在同一线程中多次获取锁而导致死锁发生</p>\\n<blockquote>\\n<p>在 java 的编程中 synchronized 和 ReentrantLock 都是可重入锁</p>\\n</blockquote>","autoDesc":true}');export{e as data};
