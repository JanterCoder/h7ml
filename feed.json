{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "h7ml-前端物语",
  "home_page_url": "https://www.h7ml.cn/",
  "feed_url": "https://www.h7ml.cn/feed.json",
  "description": "h7ml是一个专注于前端物语的VuePress博客，致力于分享前端开发的技术和经验。我们涵盖了JavaScript、CSS、HTML5、MySQL等多个方面的编程实践和学习笔记，旨在帮助前端开发者提高技能水平和解决实际问题。此外，我们也开源了多个项目，欢迎加入我们的社区，一起探索前端开发的世界！",
  "icon": "https://www.h7ml.cn/logo.png",
  "favicon": "https://www.h7ml.cn/logo.png",
  "items": [
    {
      "title": "控制反转（IOC）与依赖注入（DI）",
      "url": "https://www.h7ml.cn/posts/Nestjs/IOC-DL.html",
      "id": "https://www.h7ml.cn/posts/Nestjs/IOC-DL.html",
      "summary": "nestjs  控制反转（IOC）与依赖注入（DI）",
      "content_html": "<p>控制反转（IOC）和依赖注入（DI）是面向对象编程中的重要设计原则，用于降低代码间的耦合度，并提高可维护性和可测试性。本文将介绍 IOC 和 DI 的概念、解决的问题、实现思路以及在 Nest 框架中的具体实现。</p>\n<h2> 什么是 IOC</h2>\n<p>IOC（Inversion of Control，控制反转）是一种设计原则，通过将对象的创建和管理交给一个容器来实现。在非 IOC 模式下，对象之间的依赖关系由调用者来控制和管理。而在 IOC 模式下，对象的创建和依赖关系的管理都由容器来完成，从而实现了对象之间的解耦。</p>\n<h3> 要解决的问题</h3>\n<p>在非 IOC 模式下，如果一个类 B 需要使用类 A 的实例，通常会在 B 中创建 A 的实例对象。而如果类 C 又依赖于类 B，这种控制权的嵌套会持续下去，导致依赖关系变得复杂。例如，在一个典型的三层架构中，Controller 依赖于 Service 来实现业务逻辑，Service 依赖于 Repository 来进行数据库操作，Repository 又依赖于 DataSource 来建立数据库连接，而 DataSource 需要从 Config 对象中获取用户名密码等信息。</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>上述代码存在两个问题：\n<ol>\n<li>依赖关系复杂，对象的创建必须按照特定顺序实例化。</li>\n<li>这些对象不需要每次都创建新的实例，应该使用单例模式。</li>\n</ol>\n</li>\n</ul>\n<h3> 实现思路</h3>\n<p>在 IOC 模式下，不再由调用者来查找和创建类的实例，而是将这些职责交给一个容器来管理，以实现类与类之间的解耦。</p>\n<h2> DI</h2>\n<p>依赖注入（Dependency Injection，DI）是实现控制反转的一种常用方式。在 DI 中，程序会在初始化时扫描类之间的依赖关系，并将这些类的实例注入到容器中。</p>\n<h3> 思路</h3>\n<p>在初始化时，程序会扫描类之间的依赖关系，并将这些类的实例放入容器中。在创建对象时，程序会根据类的依赖关系，将相应的依赖对象注入到类中。</p>\n<h3> 具体实现</h3>\n<p>IOC 模式是与语言无关的，不同的框架对 DI 的实现方式也有所不同。</p>\n<ul>\n<li>在 Java 的 Spring 框架中，可以通过定义 XML 文件来决定类之间的依赖关系。</li>\n<li>在 Nest 框架中，可以通过装饰器和元数据来实现 DI。在 Nest 框架中，基于 Reflect 的 MetaData 实现了自动分析模块之间的依赖关系。可以使用 Reflect.defineMetadata 和 Reflect.getMetadata 方法来设置和读取类或类属性的元数据。通过配合装饰器语法，可以实现依赖注入。</li>\n</ul>\n<p>以下是一个使用 Nest 框架的装饰器实现的例子：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> IOC 和 DI 的关系</h2>\n<p>控制反转是一种设计原则，而依赖注入是实现 IOC 的一种常用方式。除了依赖注入，还有其他实现 IOC 的方式，比如依赖查找（Dependency Lookup）等。</p>\n<h2> 解决循环引用问题</h2>\n<p>在模块和服务之间可能存在相互引用的情况，这样就会出现循环依赖。Nest 框架通过使用 forwardRef 来解决循环引用的问题。forwardRef 可以在模块之间创建一个转发引用，Nest 会单独创建这两个模块，并将它们关联起来。</p>\n<h3> 模块中的使用示例：</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 服务中的使用示例：</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上就是关于控制反转（IOC）与依赖注入（DI）的更深入介绍。通过 IOC 和 DI 的应用，可以实现代码的解耦和提高可维护性。在 Nest 框架中，通过装饰器和元数据的使用，可以更便捷地实现依赖注入。同时，使用 forwardRef 可以解决循环引用的问题，确保模块和服务之间的依赖关系正确建立。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2024-07-14T00:00:00.000Z",
      "date_modified": "2023-07-13T20:13:02.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "IOC",
        "DI",
        "nestjs"
      ]
    },
    {
      "title": "Nestjs",
      "url": "https://www.h7ml.cn/posts/Nestjs/",
      "id": "https://www.h7ml.cn/posts/Nestjs/",
      "summary": "Nestjs",
      "content_html": "<ul>\n<li><a href=\"/posts/Nestjs/IOC-DL.html\" target=\"blank\">控制反转（IOC）与依赖注入（DI）</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2020-01-01T00:00:00.000Z",
      "date_modified": "2023-07-13T17:52:33.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "Nestjs"
      ]
    },
    {
      "title": "PostgreSQL的语法知识和常见查询操作",
      "url": "https://www.h7ml.cn/posts/PostgreSQL/PostgreSQL.html",
      "id": "https://www.h7ml.cn/posts/PostgreSQL/PostgreSQL.html",
      "summary": "PostgreSQL的语法知识和常见查询操作",
      "content_html": "<p>PostgreSQL 的语法知识和常见查询操作</p>\n<h2> 1. 数据定义语句（DDL）</h2>\n<h3> 1.1. 登录数据库</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 1.2. 创建数据库</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 1.3. 查看所有数据库</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 1.4. 连接数据库</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 1.5. 查看所有数据表</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 1.6. 删除数据库</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 2. 表操作</h2>\n<h3> 2.1. 创建表</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2.2. 查看表结构</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 2.3. 删除表</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 2.4. 修改表名</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 2.5. 修改表的所有者</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 2.6. 修改表的注释</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 2.7. 修改列名</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 2.8. 修改列的数据类型</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 2.9. 修改列的默认值</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 2.10. 修改列的注释</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 2.11. 删除列</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 2.12. 添加列</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 2.13. 添加主键</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 2.14. 添加外键</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 2.15. 添加唯一约束</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 2.16. 添加检查约束</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 2.17. 删除主键</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 2.18. 删除外键</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 2.19. 删除唯一约束</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 2.20. 删除检查约束</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 2.21 查询列</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 3. 查询操作</h2>\n<h3> 3.1. 查询所有数据</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 3.2. 查询指定列</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 3.3. 查询指定列并去重</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 3.4. 查询指定列并排序</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 3.5. 查询指定列并限制返回行数</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 3.6. 查询指定列并限制返回行数并跳过指定行数</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 3.7. 查询指定列并限制返回行数并跳过指定行数并排序</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 3.8. 查询指定列并限制返回行数并跳过指定行数并排序并去重</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 3.9. 聚合函数</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>常见的聚合函数有：AVG、COUNT、SUM、MIN、MAX。</p>\n</blockquote>\n<h4> 3.10. 聚合函数并分组</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.11. 聚合函数并分组并排序</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.12. 聚合函数并分组并排序并限制返回行数并跳过指定行数</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.13. 聚合函数并分组并排序并限制返回行数并跳过指定行数并去重</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.14. 聚合函数并分组并排序并限制返回行数并跳过指定行数并去重并过滤</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3.13 条件查询</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>常见的条件操作符有：=、&lt;、&gt;、&lt;=、&gt;=、&lt;&gt;等。</p>\n</blockquote>\n<h4> 3.14. 条件查询并分组</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.15. 条件查询并分组并排序</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.16. 条件查询并分组并排序并限制返回行数并跳过指定行数</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>ASC 表示升序，DESC 表示降序。</p>\n</blockquote>\n<h4> 3.17. 条件查询并分组并排序并限制返回行数并跳过指定行数并去重</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3.18. 连接查询</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>常见的连接类型有：INNER JOIN、LEFT JOIN、RIGHT JOIN、FULL JOIN。</p>\n</blockquote>\n<h3> 3.19. 连接查询并分组</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.20. 连接查询并分组并排序</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.21. 连接查询并分组并排序并限制返回行数并跳过指定行数</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3.22. 子查询</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3.23. 分组查询</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>常见的聚合函数有：AVG、COUNT、SUM、MIN、MAX。</p>\n</blockquote>\n<h4> 3.24. 分组查询并排序</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.25. 分组查询并排序并限制返回行数并跳过指定行数</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.26. 分组查询并排序并限制返回行数并跳过指定行数并去重</h4>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3.27 嵌套查询</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3.28 更新操作</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3.29 删除操作</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> PostgreSQL 特有功能</h2>\n<h3> 4.1. JSON 数据类型</h3>\n<p>PostgreSQL 支持存储和查询 JSON 数据类型。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 4.2 全文搜索</h3>\n<p>PostgreSQL 提供全文搜索功能，可以在文本数据中进行高效的关键词搜索。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 4.3. 空间数据类型</h3>\n<p>PostgreSQL 支持空间数据类型和空间索引，用于存储和查询地理位置信息。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文档</h2>\n<ul>\n<li><a href=\"https://www.postgresql.org/docs/\" target=\"_blank\" rel=\"noopener noreferrer\">PostgreSQL Documentation</a></li>\n<li><a href=\"https://www.postgresqltutorial.com/\" target=\"_blank\" rel=\"noopener noreferrer\">PostgreSQL Tutorial</a></li>\n<li><a href=\"https://pgexercises.com/\" target=\"_blank\" rel=\"noopener noreferrer\">PostgreSQL Exercises</a></li>\n<li><a href=\"https://www.runoob.com//postgresql-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2024-07-11T00:00:00.000Z",
      "date_modified": "2023-07-13T20:13:02.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "PostgreSQL",
        "eventsource"
      ]
    },
    {
      "title": "PostgreSQL",
      "url": "https://www.h7ml.cn/posts/PostgreSQL/",
      "id": "https://www.h7ml.cn/posts/PostgreSQL/",
      "summary": "PostgreSQL的语法知识和常见查询操作",
      "content_html": "<ul>\n<li><a href=\"/posts/PostgreSQL/PostgreSQL.html\" target=\"blank\">PostgreSQL</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2020-01-01T00:00:00.000Z",
      "date_modified": "2023-07-13T17:52:33.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "PostgreSQL"
      ]
    },
    {
      "title": "JavaScript 原型，原型链 ? 有什么特点？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/prototype.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/prototype.html",
      "summary": "前端物语|面试物语-JavaScript 原型，原型链 ? 有什么特点？",
      "content_html": "<h1> JavaScript 原型，原型链 ? 有什么特点？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/4500e170-725e-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、原型</h2>\n<p><code>JavaScript</code> 常被描述为一种基于原型的语言——每个对象拥有一个原型对象</p>\n<p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p>\n<p>准确地说，这些属性和方法定义在 Object 的构造器函数（constructor functions）之上的<code>prototype</code>属性上，而非实例对象本身</p>\n<p>下面举个例子：</p>\n<p>函数可以有属性。 每个函数都有一个特殊的属性叫作原型<code>prototype</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>控制台输出</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面这个对象，就是大家常说的原型对象</p>\n<p>可以看到，原型对象有一个自有属性<code>constructor</code>，这个属性指向该函数，如下图关系展示</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/56d87250-725e-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、原型链</h2>\n<p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法</p>\n<p>在对象实例和它的构造器之间建立一个链接（它是<code>__proto__</code>属性，是从构造函数的<code>prototype</code>属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法</p>\n<p>下面举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>根据代码，我们可以得到下图</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/60825aa0-725e-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>下面分析一下：</p>\n<ul>\n<li>\n<p>构造函数<code>Person</code>存在原型对象<code>Person.prototype</code></p>\n</li>\n<li>\n<p>构造函数生成实例对象<code>person</code>，<code>person</code>的<code>__proto__</code>指向构造函数<code>Person</code>原型对象</p>\n</li>\n<li>\n<p><code>Person.prototype.__proto__</code> 指向内置对象，因为 <code>Person.prototype</code> 是个对象，默认是由 <code>Object</code>函数作为类创建的，而 <code>Object.prototype</code> 为内置对象</p>\n</li>\n<li>\n<p><code>Person.__proto__</code> 指向内置匿名函数 <code>anonymous</code>，因为 Person 是个函数对象，默认由 Function 作为类创建</p>\n</li>\n<li>\n<p><code>Function.prototype</code> 和 <code>Function.__proto__</code>同时指向内置匿名函数 <code>anonymous</code>，这样原型链的终点就是 <code>null</code></p>\n</li>\n</ul>\n<h2> 三、总结</h2>\n<p>下面首先要看几个概念：</p>\n<p><code>__proto__</code>作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6a742160-725e-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>每个对象的<code>__proto__</code>都是指向它的构造函数的原型对象<code>prototype</code>的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>构造函数是一个函数对象，是通过 <code>Function</code>构造器产生的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>原型对象本身是一个普通对象，而普通对象的构造函数都是<code>Object</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>刚刚上面说了，所有的构造器都是函数对象，函数对象都是 <code>Function</code>构造产生的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>Object</code>的原型对象也有<code>__proto__</code>属性指向<code>null</code>，<code>null</code>是原型链的顶端</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>下面作出总结：</p>\n<ul>\n<li>\n<p>一切对象都是继承自<code>Object</code>对象，<code>Object</code> 对象直接继承根源对象<code>null</code></p>\n</li>\n<li>\n<p>一切的函数对象（包括 <code>Object</code> 对象），都是继承自 <code>Function</code> 对象</p>\n</li>\n<li>\n<p><code>Object</code> 对象直接继承自 <code>Function</code> 对象</p>\n</li>\n<li>\n<p><code>Function</code>对象的<code>__proto__</code>会指向自己的原型对象，最终还是继承自<code>Object</code>对象</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6870732239556640775#heading-7\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6870732239556640775#heading-7</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-05-26T00:00:00.000Z",
      "date_modified": "2023-05-26T10:13:08.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说你对函数式编程的理解？优缺点？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/functional_programming.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/functional_programming.html",
      "summary": "前端物语|面试物语-说说你对函数式编程的理解？优缺点？",
      "content_html": "<h1> 说说你对函数式编程的理解？优缺点？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ec0f6e80-8534-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>函数式编程是一种\"编程范式\"（programming paradigm），一种编写程序的方法论</p>\n<p>主要的编程范式有三种：命令式编程，声明式编程和函数式编程</p>\n<p>相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程</p>\n<p>举个例子，将数组每个元素进行平方操作，命令式编程与函数式编程如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>简单来讲，就是要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果</p>\n<p>即是一种描述集合和集合之间的转换关系，输入通过函数都会返回有且只有一个输出值</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f9f83900-8534-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>可以看到，函数实际上是一个关系，或者说是一种映射，而这种映射关系是可以组合的，一旦我们知道一个函数的输出类型可以匹配另一个函数的输入，那他们就可以进行组合</p>\n<h2> 二、概念</h2>\n<h3> 纯函数</h3>\n<p>函数式编程旨在尽可能的提高代码的无状态性和不变性。要做到这一点，就要学会使用无副作用的函数，也就是纯函数</p>\n<p>纯函数是对给定的输入返还相同输出的函数，并且要求你所有的数据都是不可变的，即纯函数=无状态+数据不可变</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/04f50720-8535-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>举一个简单的例子</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>特性：</p>\n<ul>\n<li>函数内部传入指定的值，就会返回确定唯一的值</li>\n<li>不会造成超出作用域的变化，例如修改全局变量或引用传递的参数</li>\n</ul>\n<p>优势：</p>\n<ul>\n<li>使用纯函数，我们可以产生可测试的代码</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p>不依赖外部环境计算，不会产生副作用，提高函数的复用性</p>\n</li>\n<li>\n<p>可读性更强 ，函数不管是否是纯函数 都会有一个语义化的名称，更便于阅读</p>\n</li>\n<li>\n<p>可以组装成复杂任务的可能性。符合模块化概念及单一职责原则</p>\n</li>\n</ul>\n<h3> 高阶函数</h3>\n<p>在我们的编程世界中，我们需要处理的其实也只有“数据”和“关系”，而关系就是函数</p>\n<p>编程工作也就是在找一种映射关系，一旦关系找到了，问题就解决了，剩下的事情，就是让数据流过这种关系，然后转换成另一个数据，如下图所示</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/104af1c0-8535-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在这里，就是高阶函数的作用。高级函数，就是以函数作为输入或者输出的函数被称为高阶函数</p>\n<p>通过高阶函数抽象过程，注重结果，如下面例子</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面通过高阶函数 <code>forEach</code>来抽象循环如何做的逻辑，直接关注做了什么</p>\n<p>高阶函数存在缓存的特性，主要是利用闭包作用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 柯里化</h3>\n<p>柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程</p>\n<p>一个二元函数如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>转化成柯里化函数如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的<code>curry</code>函数只能处理二元情况，下面再来实现一个实现多参数的情况</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于柯里化函数的意义如下：</p>\n<ul>\n<li>让纯函数更纯，每次接受一个参数，松散解耦</li>\n<li>惰性执行</li>\n</ul>\n<h3> 组合与管道</h3>\n<p>组合函数，目的是将多个函数组合成一个函数</p>\n<p>举个简单的例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到<code>compose</code>实现一个简单的功能：形成了一个新的函数，而这个函数就是一条从 <code>bfn -&gt; afn</code> 的流水线</p>\n<p>下面再来看看如何实现一个多函数组合：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>compose</code>执行是从右到左的。而管道函数，执行顺序是从左到右执行的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>组合函数与管道函数的意义在于：可以把很多小函数组合起来完成更复杂的逻辑</p>\n<h2> 三、优缺点</h2>\n<h4> 优点</h4>\n<ul>\n<li>\n<p>更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况</p>\n</li>\n<li>\n<p>更简单的复用：固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响</p>\n</li>\n<li>\n<p>更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性</p>\n</li>\n<li>\n<p>隐性好处。减少代码量，提高维护性</p>\n</li>\n</ul>\n<h4> 缺点</h4>\n<ul>\n<li>\n<p>性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销</p>\n</li>\n<li>\n<p>资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式</p>\n</li>\n<li>\n<p>递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/81302150\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/81302150</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-05-26T00:00:00.000Z",
      "date_modified": "2023-05-26T01:01:40.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/BOM.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/BOM.html",
      "summary": "前端物语|面试物语-说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？",
      "content_html": "<h1> 说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3e191c40-8089-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>BOM</code> (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象</p>\n<p>其作用就是跟浏览器做一些交互效果,比如如何进行页面的后退，前进，刷新，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率</p>\n<p>浏览器的全部内容可以看成<code>DOM</code>，整个浏览器可以看成<code>BOM</code>。区别如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/482f33e0-8089-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、window</h2>\n<p><code>Bom</code>的核心对象是<code>window</code>，它表示浏览器的一个实例</p>\n<p>在浏览器中，<code>window</code>对象有双重角色，即是浏览器窗口的一个接口，又是全局对象</p>\n<p>因此所有在全局作用域中声明的变量、函数都会变成<code>window</code>对象的属性和方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于窗口控制方法如下：</p>\n<ul>\n<li><code>moveBy(x,y)</code>：从当前位置水平移动窗体 x 个像素，垂直移动窗体 y 个像素，x 为负数，将向左移动窗体，y 为负数，将向上移动窗体</li>\n<li><code>moveTo(x,y)</code>：移动窗体左上角到相对于屏幕左上角的(x,y)点</li>\n<li><code>resizeBy(w,h)</code>：相对窗体当前的大小，宽度调整 w 个像素，高度调整 h 个像素。如果参数为负值，将缩小窗体，反之扩大窗体</li>\n<li><code>resizeTo(w,h)</code>：把窗体宽度调整为 w 个像素，高度调整为 h 个像素</li>\n<li><code>scrollTo(x,y)</code>：如果有滚动条，将横向滚动条移动到相对于窗体宽度为 x 个像素的位置，将纵向滚动条移动到相对于窗体高度为 y 个像素的位置</li>\n<li><code>scrollBy(x,y)</code>： 如果有滚动条，将横向滚动条向左移动 x 个像素，将纵向滚动条向下移动 y 个像素</li>\n</ul>\n<p><code>window.open()</code> 既可以导航到一个特定的<code>url</code>，也可以打开一个新的浏览器窗口</p>\n<p>如果 <code>window.open()</code> 传递了第二个参数，且该参数是已有窗口或者框架的名称，那么就会在目标窗口加载第一个参数指定的 URL</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>window.open()</code> 会返回新窗口的引用，也就是新窗口的 <code>window</code> 对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>window.close()</code> 仅用于通过 <code>window.open()</code> 打开的窗口</p>\n<p>新创建的 <code>window</code> 对象有一个 <code>opener</code> 属性，该属性指向打开他的原始窗口对象</p>\n<h2> 三、location</h2>\n<p><code>url</code>地址如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>location</code>属性描述如下：</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>例子</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hash</td>\n<td>\"#contents\"</td>\n<td>utl 中#后面的字符，没有则返回空串</td>\n</tr>\n<tr>\n<td>host</td>\n<td><a href=\"http://www.wrox.com:80\" target=\"_blank\" rel=\"noopener noreferrer\">www.wrox.com:80</a></td>\n<td>服务器名称和端口号</td>\n</tr>\n<tr>\n<td>hostname</td>\n<td><a href=\"http://www.wrox.com\" target=\"_blank\" rel=\"noopener noreferrer\">www.wrox.com</a></td>\n<td>域名，不带端口号</td>\n</tr>\n<tr>\n<td>href</td>\n<td><a href=\"http://www.wrox.com:80/WileyCDA/?q=javascript#contents\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.wrox.com:80/WileyCDA/?q=javascript#contents</a></td>\n<td>完整 url</td>\n</tr>\n<tr>\n<td>pathname</td>\n<td>\"/WileyCDA/\"</td>\n<td>服务器下面的文件路径</td>\n</tr>\n<tr>\n<td>port</td>\n<td>80</td>\n<td>url 的端口号，没有则为空</td>\n</tr>\n<tr>\n<td>protocol</td>\n<td>http:</td>\n<td>使用的协议</td>\n</tr>\n<tr>\n<td>search</td>\n<td>?q=javascript</td>\n<td>url 的查询字符串，通常为？后面的内容</td>\n</tr>\n</tbody>\n</table>\n<p>除了 <code>hash</code>之外，只要修改<code>location</code>的一个属性，就会导致页面重新加载新<code>URL</code></p>\n<p><code>location.reload()</code>，此方法可以重新刷新当前页面。这个方法会根据最有效的方式刷新页面，如果页面自上一次请求以来没有改变过，页面就会从浏览器缓存中重新加载</p>\n<p>如果要强制从服务器中重新加载，传递一个参数<code>true</code>即可</p>\n<h2> 四、navigator</h2>\n<p><code>navigator</code> 对象主要用来获取浏览器的属性，区分浏览器类型。属性较多，且兼容性比较复杂</p>\n<p>下表列出了<code>navigator</code>对象接口定义的属性和方法：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6797ab40-8089-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/74096620-8089-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 五、screen</h2>\n<p>保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7d6b21e0-8089-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 六、history</h2>\n<p><code>history</code>对象主要用来操作浏览器<code>URL</code>的历史记录，可以通过参数向前，向后，或者向指定<code>URL</code>跳转</p>\n<p>常用的属性如下：</p>\n<ul>\n<li><code>history.go()</code></li>\n</ul>\n<p>接收一个整数数字或者字符串参数：向最近的一个记录中包含指定字符串的页面跳转，</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>当参数为整数数字的时候，正数表示向前跳转指定的页面，负数为向后跳转指定的页面</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><code>history.forward()</code>：向前跳转一个页面</li>\n<li><code>history.back()</code>：向后跳转一个页面</li>\n<li><code>history.length</code>：获取历史记录数</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-05-25T00:00:00.000Z",
      "date_modified": "2023-05-24T20:12:29.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "什么是单点登录？如何实现？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/single_sign.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/single_sign.html",
      "summary": "前端物语|面试物语-什么是单点登录？如何实现？",
      "content_html": "<h1> 什么是单点登录？如何实现？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8a25a760-8c83-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一</p>\n<p>SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统</p>\n<p>SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过<code>passport</code>，子系统本身将不参与登录操作</p>\n<p>当一个系统成功登录以后，<code>passport</code>将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被<code>passport</code>授权以后，会建立一个局部会话，在一定时间内可以无需再次向<code>passport</code>发起认证</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2b9b0e70-8c4b-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>上图有四个系统，分别是<code>Application1</code>、<code>Application2</code>、<code>Application3</code>、和<code>SSO</code>，当<code>Application1</code>、<code>Application2</code>、<code>Application3</code>需要登录时，将跳到<code>SSO</code>系统，<code>SSO</code>系统完成登录，其他的应用系统也就随之登录了</p>\n<h4> 举个例子</h4>\n<p>淘宝、天猫都属于阿里旗下，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象就属于单点登录</p>\n<h2> 二、如何实现</h2>\n<h3> 同域名下的单点登录</h3>\n<p><code>cookie</code>的<code>domain</code>属性设置为当前域的父域，并且父域的<code>cookie</code>会被子域所共享。<code>path</code>属性默认为<code>web</code>应用的上下文路径</p>\n<p>利用 <code>Cookie</code> 的这个特点，没错，我们只需要将<code>Cookie</code>的<code>domain</code>属性设置为父域的域名（主域名），同时将 <code>Cookie</code>的<code>path</code>属性设置为根路径，将 <code>Session ID</code>（或 <code>Token</code>）保存到父域中。这样所有的子域应用就都可以访问到这个<code>Cookie</code></p>\n<p>不过这要求应用系统的域名需建立在一个共同的主域名之下，如 <code>tieba.baidu.com</code> 和 <code>map.baidu.com</code>，它们都建立在 <code>baidu.com</code>这个主域名之下，那么它们就可以通过这种方式来实现单点登录</p>\n<h3> 不同域名下的单点登录(一)</h3>\n<p>如果是不同域的情况下，<code>Cookie</code>是不共享的，这里我们可以部署一个认证中心，用于专门处理登录请求的独立的 <code>Web</code>服务</p>\n<p>用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 <code>token</code> 写入 <code>Cookie</code>（注意这个 <code>Cookie</code>是认证中心的，应用系统是访问不到的）</p>\n<p>应用系统检查当前请求有没有 <code>Token</code>，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心</p>\n<p>由于这个操作会将认证中心的 <code>Cookie</code> 自动带过去，因此，认证中心能够根据 <code>Cookie</code> 知道用户是否已经登录过了</p>\n<p>如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录</p>\n<p>如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 <code>URL</code>，并在跳转前生成一个 <code>Token</code>，拼接在目标<code>URL</code> 的后面，回传给目标应用系统</p>\n<p>应用系统拿到 <code>Token</code>之后，还需要向认证中心确认下 <code>Token</code> 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 <code>Token</code>写入<code>Cookie</code>，然后给本次访问放行。（注意这个 <code>Cookie</code> 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 <code>Token</code>，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了</p>\n<p>此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法</p>\n<h3> 不同域名下的单点登录(二)</h3>\n<p>可以选择将 <code>Session ID</code> （或 <code>Token</code> ）保存到浏览器的 <code>LocalStorage</code> 中，让前端在每次向后端发送请求时，主动将<code>LocalStorage</code>的数据传递给服务端</p>\n<p>这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 <code>Session ID</code>（或 <code>Token</code>）放在响应体中传递给前端</p>\n<p>单点登录完全可以在前端实现。前端拿到 <code>Session ID</code>（或 <code>Token</code> ）后，除了将它写入自己的 <code>LocalStorage</code> 中之外，还可以通过特殊手段将它写入多个其他域下的 <code>LocalStorage</code> 中</p>\n<p>关键代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>前端通过 <code>iframe</code>+<code>postMessage()</code> 方式，将同一份 <code>Token</code> 写入到了多个域下的 <code>LocalStorage</code> 中，前端每次在向后端发送请求之前，都会主动从 <code>LocalStorage</code> 中读取<code>Token</code>并在请求中携带，这样就实现了同一份<code>Token</code> 被多个域所共享</p>\n<p>此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域</p>\n<h2> 三、流程</h2>\n<p>单点登录的流程图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2422bc40-8c84-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>\n<p>用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</p>\n</li>\n<li>\n<p>sso 认证中心发现用户未登录，将用户引导至登录页面</p>\n</li>\n<li>\n<p>用户输入用户名密码提交登录申请</p>\n</li>\n<li>\n<p>sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌</p>\n</li>\n<li>\n<p>sso 认证中心带着令牌跳转会最初的请求地址（系统 1）</p>\n</li>\n<li>\n<p>系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效</p>\n</li>\n<li>\n<p>sso 认证中心校验令牌，返回有效，注册系统 1</p>\n</li>\n<li>\n<p>系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</p>\n</li>\n<li>\n<p>用户访问系统 2 的受保护资源</p>\n</li>\n<li>\n<p>系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数</p>\n</li>\n<li>\n<p>sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌</p>\n</li>\n<li>\n<p>系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效</p>\n</li>\n<li>\n<p>sso 认证中心校验令牌，返回有效，注册系统 2</p>\n</li>\n<li>\n<p>系统 2 使用该令牌创建与用户的局部会话，返回受保护资源</p>\n</li>\n</ul>\n<p>用户登录成功之后，会与<code>sso</code>认证中心及各个子系统建立会话，用户与<code>sso</code>认证中心建立的会话称为全局会话</p>\n<p>用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过<code>sso</code>认证中心</p>\n<p>全局会话与局部会话有如下约束关系：</p>\n<ul>\n<li>局部会话存在，全局会话一定存在</li>\n<li>全局会话存在，局部会话不一定存在</li>\n<li>全局会话销毁，局部会话必须销毁</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://blog.csdn.net/weixin_36380516/article/details/109006828\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/weixin_36380516/article/details/109006828</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/单点登录</a></li>\n<li><a href=\"https://juejin.cn/post/6844903664985866253\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903664985866253</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-05-24T00:00:00.000Z",
      "date_modified": "2023-05-24T10:13:38.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说 new 操作符具体干了什么？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/new.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/new.html",
      "summary": "前端物语|面试物语-说说 new 操作符具体干了什么？",
      "content_html": "<h1> 说说 new 操作符具体干了什么？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/880d0010-7a39-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在<code>JavaScript</code>中，<code>new</code>操作符用于创建一个给定构造函数的实例对象</p>\n<p>例子</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面可以看到：</p>\n<ul>\n<li><code>new</code> 通过构造函数 <code>Person</code> 创建出来的实例可以访问到构造函数中的属性</li>\n<li><code>new</code> 通过构造函数 <code>Person</code> 创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来）</li>\n</ul>\n<p>现在在构建函数中显式加上返回值，并且这个返回值是一个原始类型</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以发现，构造函数中返回一个原始值，然而这个返回值并没有作用</p>\n<p>下面在构造函数中返回一个对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面可以发现，构造函数如果返回值为一个对象，那么这个返回值会被正常使用</p>\n<h2> 二、流程</h2>\n<p>从上面介绍中，我们可以看到<code>new</code>关键字主要做了以下的工作：</p>\n<ul>\n<li>\n<p>创建一个新的对象<code>obj</code></p>\n</li>\n<li>\n<p>将对象与构建函数通过原型链连接起来</p>\n</li>\n<li>\n<p>将构建函数中的<code>this</code>绑定到新建的对象<code>obj</code>上</p>\n</li>\n<li>\n<p>根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理</p>\n</li>\n</ul>\n<p>举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>流程图如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b429b990-7a39-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、手写 new 操作符</h2>\n<p>现在我们已经清楚地掌握了<code>new</code>的执行过程</p>\n<p>那么我们就动手来实现一下<code>new</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>测试一下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以发现，代码虽然很短，但是能够模拟实现<code>new</code></p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-05-24T00:00:00.000Z",
      "date_modified": "2023-05-24T05:12:08.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "谈谈 this 对象的理解",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/this.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/this.html",
      "summary": "前端物语|面试物语-谈谈 this 对象的理解",
      "content_html": "<h1> 谈谈 this 对象的理解</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/46c820d0-74b7-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、定义</h2>\n<p>函数的 <code>this</code> 关键字在 <code>JavaScript</code> 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别</p>\n<p>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值（运行时绑定）</p>\n<p><code>this</code> 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象</p>\n<p>举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同时，<code>this</code>在函数执行过程中，<code>this</code>一旦被确定了，就不可以再更改</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、绑定规则</h2>\n<p>根据不同的使用场合，<code>this</code>有不同的值，主要分为下面几种情况：</p>\n<ul>\n<li>\n<p>默认绑定</p>\n</li>\n<li>\n<p>隐式绑定</p>\n</li>\n<li>\n<p>new 绑定</p>\n</li>\n<li>\n<p>显示绑定</p>\n</li>\n</ul>\n<h3> 默认绑定</h3>\n<p>全局环境中定义<code>person</code>函数，内部使用<code>this</code>关键字</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码输出<code>Jenny</code>，原因是调用函数的对象在游览器中位<code>window</code>，因此<code>this</code>指向<code>window</code>，所以输出<code>Jenny</code></p>\n<p>注意：</p>\n<p>严格模式下，不能将全局对象用于默认绑定，this 会绑定到<code>undefined</code>，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象</p>\n<h3> 隐式绑定</h3>\n<p>函数还可以作为某个对象的方法调用，这时<code>this</code>就指这个上级对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，<code>this</code>指向的也只是它上一级的对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码中，<code>this</code>的上一级对象为<code>b</code>，<code>b</code>内部并没有<code>a</code>变量的定义，所以输出<code>undefined</code></p>\n<p>这里再举一种特殊情况</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>此时<code>this</code>指向的是<code>window</code>，这里的大家需要记住，<code>this</code>永远指向的是最后调用它的对象，虽然<code>fn</code>是对象<code>b</code>的方法，但是<code>fn</code>赋值给<code>j</code>时候并没有执行，所以最终指向<code>window</code></p>\n<h3> new 绑定</h3>\n<p>通过构建函数<code>new</code>关键字生成一个实例对象，此时<code>this</code>指向这个实例对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码之所以能过输出 1，是因为<code>new</code>关键字改变了<code>this</code>的指向</p>\n<p>这里再列举一些特殊情况：</p>\n<p><code>new</code>过程遇到<code>return</code>一个对象，此时<code>this</code>指向为返回的对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果返回一个简单类型的时候，则<code>this</code>指向实例对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意的是<code>null</code>虽然也是对象，但是此时<code>new</code>仍然指向实例对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 显示修改</h3>\n<p><code>apply()、call()、bind()</code>是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时<code>this</code>指的就是这第一个参数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于<code>apply、call、bind</code>三者的区别，我们后面再详细说</p>\n<h2> 三、箭头函数</h2>\n<p>在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 <code>this</code> 的指向（编译时绑定）</p>\n<p>举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>虽然箭头函数的<code>this</code>能够在编译的时候就确定了<code>this</code>的指向，但也需要注意一些潜在的坑</p>\n<p>下面举个例子：</p>\n<p>绑定事件监听</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述可以看到，我们其实是想要<code>this</code>为点击的<code>button</code>，但此时<code>this</code>指向了<code>window</code></p>\n<p>包括在原型上添加方法时候，此时<code>this</code>指向<code>window</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同样的，箭头函数不能作为构建函数</p>\n<h2> 四、优先级</h2>\n<h3> 隐式绑定 VS 显式绑定</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>显然，显示绑定的优先级更高</p>\n<h3> new 绑定 VS 隐式绑定</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，new 绑定的优先级<code>&gt;</code>隐式绑定</p>\n<h3> <code>new</code>绑定 VS 显式绑定</h3>\n<p>因为<code>new</code>和<code>apply、call</code>无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>bar</code>被绑定到 obj1 上，但是<code>new bar(3)</code> 并没有像我们预计的那样把<code>obj1.a</code>修改为 3。但是，<code>new</code>修改了绑定调用<code>bar()</code>中的<code>this</code></p>\n<p>我们可认为<code>new</code>绑定优先级<code>&gt;</code>显式绑定</p>\n<p>综上，new 绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</p>\n<h2> 相关链接</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-05-24T00:00:00.000Z",
      "date_modified": "2023-05-24T01:03:31.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "DOM 常见的操作有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/Dom.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/Dom.html",
      "summary": "前端物语|面试物语-DOM 常见的操作有哪些？",
      "content_html": "<h1> DOM 常见的操作有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a89c99a0-7fdc-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、DOM</h2>\n<p>文档对象模型 (DOM) 是 <code>HTML</code> 和 <code>XML</code> 文档的编程接口</p>\n<p>它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容</p>\n<p>任何 <code>HTML</code>或<code>XML</code>文档都可以用 <code>DOM</code>表示为一个由节点构成的层级结构</p>\n<p>节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系，如下所示：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>DOM</code>像原子包含着亚原子微粒那样，也有很多类型的<code>DOM</code>节点包含着其他类型的节点。接下来我们先看看其中的三种：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述结构中，<code>div</code>、<code>p</code>就是元素节点，<code>content</code>就是文本节点，<code>title</code>就是属性节点</p>\n<h2> 二、操作</h2>\n<p>日常前端开发，我们都离不开<code>DOM</code>操作</p>\n<p>在以前，我们使用<code>Jquery</code>，<code>zepto</code>等库来操作<code>DOM</code>，之后在<code>vue</code>，<code>Angular</code>，<code>React</code>等框架出现后，我们通过操作数据来控制<code>DOM</code>（绝大多数时候），越来越少的去直接操作<code>DOM</code></p>\n<p>但这并不代表原生操作不重要。相反，<code>DOM</code>操作才能有助于我们理解框架深层的内容</p>\n<p>下面就来分析<code>DOM</code>常见的操作，主要分为：</p>\n<ul>\n<li>创建节点</li>\n<li>查询节点</li>\n<li>更新节点</li>\n<li>添加节点</li>\n<li>删除节点</li>\n</ul>\n<h3> 创建节点</h3>\n<h4> createElement</h4>\n<p>创建新元素，接受一个参数，即要创建元素的标签名</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> createTextNode</h4>\n<p>创建一个文本节点</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> createDocumentFragment</h4>\n<p>用来创建一个文档碎片，它表示一种轻量级的文档，主要是用来存储临时节点，然后把文档碎片的内容一次性添加到<code>DOM</code>中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>当请求把一个<code>DocumentFragment</code> 节点插入文档树时，插入的不是 <code>DocumentFragment</code>自身，而是它的所有子孙节点</p>\n<h4> createAttribute</h4>\n<p>创建属性节点，可以是自定义属性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 获取节点</h3>\n<h4> querySelector</h4>\n<p>传入任何有效的<code>css</code> 选择器，即可选中单个 <code>DOM</code>元素（首个）：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果页面上没有指定的元素时，返回 <code>null</code></p>\n<h4> querySelectorAll</h4>\n<p>返回一个包含节点子树内所有与之相匹配的<code>Element</code>节点列表，如果没有相匹配的，则返回一个空节点列表</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>需要注意的是，该方法返回的是一个 <code>NodeList</code>的静态实例，它是一个静态的“快照”，而非“实时”的查询</p>\n<p>关于获取<code>DOM</code>元素的方法还有如下，就不一一述说</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>除此之外，每个<code>DOM</code>元素还有<code>parentNode</code>、<code>childNodes</code>、<code>firstChild</code>、<code>lastChild</code>、<code>nextSibling</code>、<code>previousSibling</code>属性，关系图如下图所示</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c100f450-7fdc-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 更新节点</h3>\n<h4> innerHTML</h4>\n<p>不但可以修改一个<code>DOM</code>节点的文本内容，还可以直接通过<code>HTML</code>片段修改<code>DOM</code>节点内部的子树</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> innerText、textContent</h4>\n<p>自动对字符串进行<code>HTML</code>编码，保证无法设置任何<code>HTML</code>标签</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>两者的区别在于读取属性时，<code>innerText</code>不返回隐藏元素的文本，而<code>textContent</code>返回所有文本</p>\n<h4> style</h4>\n<p><code>DOM</code>节点的<code>style</code>属性对应所有的<code>CSS</code>，可以直接获取或设置。遇到<code>-</code>需要转化为驼峰命名</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 添加节点</h3>\n<h4> innerHTML</h4>\n<p>如果这个 DOM 节点是空的，例如，<code>&lt;div&gt;&lt;/div&gt;</code>，那么，直接使用<code>innerHTML = '&lt;span&gt;child&lt;/span&gt;'</code>就可以修改<code>DOM</code>节点的内容，相当于添加了新的<code>DOM</code>节点</p>\n<p>如果这个 DOM 节点不是空的，那就不能这么做，因为<code>innerHTML</code>会直接替换掉原来的所有子节点</p>\n<h4> appendChild</h4>\n<p>把一个子节点添加到父节点的最后一个子节点</p>\n<p>举个例子</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>添加一个<code>p</code>元素</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>现在<code>HTML</code>结构变成了下面</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码中，我们是获取<code>DOM</code>元素后再进行添加操作，这个<code>js</code>节点是已经存在当前文档树中，因此这个节点首先会从原先的位置删除，再插入到新的位置</p>\n<p>如果动态添加新的节点，则先创建一个新的节点，然后插入到指定的位置</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> insertBefore</h4>\n<p>把子节点插入到指定的位置，使用方法如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>子节点会插入到<code>referenceElement</code>之前</p>\n<h4> setAttribute</h4>\n<p>在指定元素中添加一个属性节点，如果元素中已有该属性改变属性值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 删除节点</h3>\n<p>删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的<code>removeChild</code>把自己删掉</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置</p>\n<h2> 相关链接</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model</a></p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-05-24T00:00:00.000Z",
      "date_modified": "2023-05-23T20:12:58.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "在 react 中组件间过渡动画如何实现？",
      "url": "https://www.h7ml.cn/posts/interview/React/animation.html",
      "id": "https://www.h7ml.cn/posts/interview/React/animation.html",
      "summary": "前端物语|面试物语-在 react 中组件间过渡动画如何实现？",
      "content_html": "<h1> 在 react 中组件间过渡动画如何实现？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/294f1e00-e4b0-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在日常开发中，页面切换时的转场动画是比较基础的一个场景</p>\n<p>当一个组件在显示与消失过程中存在过渡动画，可以很好的增加用户的体验</p>\n<p>在<code>react</code>中实现过渡动画效果会有很多种选择，如<code>react-transition-group</code>，<code>react-motion</code>，<code>Animated</code>，以及原生的<code>CSS</code>都能完成切换动画</p>\n<h2> 二、如何实现</h2>\n<p>在<code>react</code>中，<code>react-transition-group</code>是一种很好的解决方案，其为元素添加<code>enter</code>，<code>enter-active</code>，<code>exit</code>，<code>exit-active</code>这一系列勾子</p>\n<p>可以帮助我们方便的实现组件的入场和离场动画</p>\n<p>其主要提供了三个主要的组件：</p>\n<ul>\n<li>CSSTransition：在前端开发中，结合 CSS 来完成过渡动画效果</li>\n<li>SwitchTransition：两个组件显示和隐藏切换时，使用该组件</li>\n<li>TransitionGroup：将多个动画组件包裹在其中，一般用于列表中元素的动画</li>\n</ul>\n<h3> CSSTransition</h3>\n<p>其实现动画的原理在于，当<code>CSSTransition</code>的<code>in</code>属性置为<code>true</code>时，<code>CSSTransition</code>首先会给其子组件加上<code>xxx-enter</code>、<code>xxx-enter-active</code>的<code>class</code>执行动画</p>\n<p>当动画执行结束后，会移除两个<code>class</code>，并且添加<code>-enter-done</code>的<code>class</code></p>\n<p>所以可以利用这一点，通过<code>css</code>的<code>transition</code>属性，让元素在两个状态之间平滑过渡，从而得到相应的动画效果</p>\n<p>当<code>in</code>属性置为<code>false</code>时，<code>CSSTransition</code>会给子组件加上<code>xxx-exit</code>和<code>xxx-exit-active</code>的<code>class</code>，然后开始执行动画，当动画结束后，移除两个<code>class</code>，然后添加<code>-enter-done</code>的<code>class</code></p>\n<p>如下例子：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对应<code>css</code>样式如下：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> SwitchTransition</h3>\n<p><code>SwitchTransition</code>可以完成两个组件之间切换的炫酷动画</p>\n<p>比如有一个按钮需要在<code>on</code>和<code>off</code>之间切换，我们希望看到<code>on</code>先从左侧退出，<code>off</code>再从右侧进入</p>\n<p><code>SwitchTransition</code>中主要有一个属性<code>mode</code>，对应两个值：</p>\n<ul>\n<li>in-out：表示新组件先进入，旧组件再移除；</li>\n<li>out-in：表示就组件先移除，新组建再进入</li>\n</ul>\n<p><code>SwitchTransition</code>组件里面要有<code>CSSTransition</code>，不能直接包裹你想要切换的组件</p>\n<p>里面的<code>CSSTransition</code>组件不再像以前那样接受<code>in</code>属性来判断元素是何种状态，取而代之的是<code>key</code>属性</p>\n<p>下面给出一个按钮入场和出场的示例，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>css</code>文件对应如下：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> TransitionGroup</h3>\n<p>当有一组动画的时候，就可将这些<code>CSSTransition</code>放入到一个<code>TransitionGroup</code>中来完成动画</p>\n<p>同样<code>CSSTransition</code>里面没有<code>in</code>属性，用到了<code>key</code>属性</p>\n<p><code>TransitionGroup</code>在感知<code>children</code>发生变化的时候，先保存移除的节点，当动画结束后才真正移除</p>\n<p>其处理方式如下：</p>\n<ul>\n<li>\n<p>插入的节点，先渲染 dom，然后再做动画</p>\n</li>\n<li>\n<p>删除的节点，先做动画，然后再删除 dom</p>\n</li>\n</ul>\n<p>如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对应<code>css</code>如下：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000018861018\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000018861018</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/14HneI7SpfrRHKtqgosIiA\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/14HneI7SpfrRHKtqgosIiA</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-05-23T00:00:00.000Z",
      "date_modified": "2023-05-22T20:12:41.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "什么是防抖和节流？有什么区别？如何实现？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/debounce_throttle.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/debounce_throttle.html",
      "summary": "前端物语|面试物语-什么是防抖和节流？有什么区别？如何实现？",
      "content_html": "<h1> 什么是防抖和节流？有什么区别？如何实现？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/912f1a10-8787-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>本质上是优化高频率执行代码的一种手段</p>\n<p>如：浏览器的 <code>resize</code>、<code>scroll</code>、<code>keypress</code>、<code>mousemove</code> 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</p>\n<p>为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 <strong>防抖（debounce）</strong> 和 <strong>节流（throttle）</strong> 的方式来减少调用频率</p>\n<h4> 定义</h4>\n<ul>\n<li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</li>\n<li>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</li>\n</ul>\n<p>一个经典的比喻:</p>\n<p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应</p>\n<p>假设电梯有两种运行策略 <code>debounce</code> 和 <code>throttle</code>，超时设定为 15 秒，不考虑容量限制</p>\n<p>电梯第一个人进来后，15 秒后准时运送一次，这是节流</p>\n<p>电梯第一个人进来后，等待 15 秒。如果过程中又有人进来，15 秒等待重新计时，直到 15 秒后开始运送，这是防抖</p>\n<h2> 代码实现</h2>\n<h3> 节流</h3>\n<p>完成节流可以使用时间戳与定时器的写法</p>\n<p>使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用定时器写法，<code>delay</code>毫秒后第一次执行，第二次事件停止触发后依然会再一次执行</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 防抖</h3>\n<p>简单版本的实现</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、区别</h2>\n<p>相同点：</p>\n<ul>\n<li>都可以通过使用 <code>setTimeout</code> 实现</li>\n<li>目的都是，降低回调执行频率。节省计算资源</li>\n</ul>\n<p>不同点：</p>\n<ul>\n<li>函数防抖，在一段连续操作结束后，处理回调，利用<code>clearTimeout</code>和 <code>setTimeout</code>实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能</li>\n<li>函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次</li>\n</ul>\n<p>例如，都设置时间频率为 500ms，在 2 秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在 2s 后，只会执行一次</p>\n<p>如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a2c81b50-8787-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、应用场景</h2>\n<p>防抖在连续的事件，只需触发一次回调的场景有：</p>\n<ul>\n<li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li>\n<li>手机号、邮箱验证输入检测</li>\n<li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li>\n</ul>\n<p>节流在间隔一段时间执行一次回调的场景有：</p>\n<ul>\n<li>滚动加载，加载更多或滚到底部监听</li>\n<li>搜索框，搜索联想功能</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-05-22T00:00:00.000Z",
      "date_modified": "2023-05-22T01:05:02.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "举例说明你对尾递归的理解，有哪些应用场景",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/tail_recursion.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/tail_recursion.html",
      "summary": "前端物语|面试物语-举例说明你对尾递归的理解，有哪些应用场景",
      "content_html": "<h1> 举例说明你对尾递归的理解，有哪些应用场景</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/74db8fe0-815d-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、递归</h2>\n<p>递归（英语：Recursion）</p>\n<p>在数学与计算机科学中，是指在函数的定义中使用函数自身的方法</p>\n<p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数</p>\n<p>其核心思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解</p>\n<p>一般来说，递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回</p>\n<p>下面实现一个函数 <code>pow(x, n)</code>，它可以计算 <code>x</code> 的 <code>n</code> 次方</p>\n<p>使用迭代的方式，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用递归的方式，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>pow(x, n)</code> 被调用时，执行分为两个分支：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>也就是说<code>pow</code> 递归地调用自身 直到 <code>n == 1</code></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8002c960-815d-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>为了计算 <code>pow(2, 4)</code>，递归变体经过了下面几个步骤：</p>\n<ol>\n<li><code>pow(2, 4) = 2 * pow(2, 3)</code></li>\n<li><code>pow(2, 3) = 2 * pow(2, 2)</code></li>\n<li><code>pow(2, 2) = 2 * pow(2, 1)</code></li>\n<li><code>pow(2, 1) = 2</code></li>\n</ol>\n<p>因此，递归将函数调用简化为一个更简单的函数调用，然后再将其简化为一个更简单的函数，以此类推，直到结果</p>\n<h2> 二、尾递归</h2>\n<p>尾递归，即在函数尾位置调用自身（或是一个尾调用本身的其他函数等等）。尾递归也是递归的一种特殊情形。尾递归是一种特殊的尾调用，即在尾部直接调用自身的递归函数</p>\n<p>尾递归在普通尾调用的基础上，多出了 2 个特征：</p>\n<ul>\n<li>在尾部调用的是函数自身</li>\n<li>可通过优化，使得计算仅占用常量栈空间</li>\n</ul>\n<p>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归次数过多容易造成栈溢出</p>\n<p>这时候，我们就可以使用尾递归，即一个函数中所有递归形式的调用都出现在函数的末尾，对于尾递归来说，由于只存在一个调用记录，所以永远不会发生\"栈溢出\"错误</p>\n<p>实现一下阶乘，如果用普通的递归，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果<code>n</code>等于 5，这个方法要执行 5 次，才返回最终的计算表达式，这样每次都要保存这个方法，就容易造成栈溢出，复杂度为<code>O(n)</code></p>\n<p>如果我们使用尾递归，则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，每一次返回的就是一个新的函数，不带上一个函数的参数，也就不需要储存上一个函数了。尾递归只需要保存一个调用栈，复杂度 O(1)</p>\n<h2> 二、应用场景</h2>\n<p>数组求和</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用尾递归优化求斐波那契数列</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>数组扁平化</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>数组对象格式化</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/尾调用</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-05-21T00:00:00.000Z",
      "date_modified": "2023-05-21T10:12:27.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说你在使用 React 过程中遇到的常见问题？如何解决?",
      "url": "https://www.h7ml.cn/posts/interview/React/summary.html",
      "id": "https://www.h7ml.cn/posts/interview/React/summary.html",
      "summary": "前端物语|面试物语-说说你在使用 React 过程中遇到的常见问题？如何解决?",
      "content_html": "<h1> 说说你在使用 React 过程中遇到的常见问题？如何解决?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7efcd400-f47d-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、前言</h2>\n<p>在使用<code>react</code>开发项目过程中，每个人或多或少都会遇到一些\"奇怪\"的问题，本质上都是我们对其理解的不够透彻</p>\n<p><code>react</code> 系列，33 个工作日，33 次凌晨还在亮起的台灯，到今天就圆满画上句号了，比心</p>\n<p>在系列中我们列出了很多比较经典的考题，工作中遇到的问题也往往就藏中其中，只是以不同的表现形式存在罢了</p>\n<p>今天的题解不算题解，准确来说是对整个系列的一次贯穿，总结</p>\n<p>目录:</p>\n<ul>\n<li>react 有什么特性</li>\n<li>生命周期有哪些不同阶段？每个阶段对应的方法是？</li>\n<li>state 和 props 有什么区别？</li>\n<li>super()和 super(props)有什么区别？</li>\n<li>setState 执行机制？</li>\n<li>React 的事件机制？</li>\n<li>事件绑定的方式有哪些？</li>\n<li>构建组件的方式有哪些？区别？</li>\n<li>组件之间如何通信？</li>\n<li>key 有什么作用？</li>\n<li>refs 的理解？应用场景？</li>\n<li>Hooks 的理解？解决了什么问题？</li>\n<li>如何引入 css？</li>\n<li>redux 工作原理？</li>\n<li>redux 中间件有哪些？</li>\n<li>react-router 组件有哪些？</li>\n<li>render 触发时机？</li>\n<li>如何减少 render？</li>\n<li>JSX 转化 DOM 过程？</li>\n<li>性能优化手段有哪些</li>\n<li>如何做服务端渲染？</li>\n</ul>\n<h3> react 有什么特性</h3>\n<p>主要的特性分为：</p>\n<ul>\n<li>JSX 语法</li>\n<li>单向数据绑定</li>\n<li>虚拟 DOM</li>\n<li>声明式编程</li>\n<li>Component</li>\n</ul>\n<p>借助这些特性，<code>react</code>整体使用起来更加简单高效，组件式开发提高了代码的复用率</p>\n<h3> 生命周期有哪些不同阶段？每个阶段对应的方法是？</h3>\n<p>主要分成了新的生命周期和旧的生命周期：</p>\n<ul>\n<li>\n<p>新版生命周期整体流程如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/66c999c0-d373-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>旧的生命周期流程图如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d379e420-d374-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n</li>\n</ul>\n<h3> state 和 props 有什么区别？</h3>\n<p>两者相同点：</p>\n<ul>\n<li>两者都是 JavaScript 对象</li>\n<li>两者都是用于保存信息</li>\n<li>props 和 state 都能触发渲染更新</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>props 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化</li>\n<li>props 在组件内部是不可修改的，但 state 在组件内部可以进行修改</li>\n<li>state 是多变的、可以修改</li>\n</ul>\n<h3> super()和 super(props)有什么区别？</h3>\n<p>在<code>React</code>中，类组件基于<code>ES6</code>，所以在<code>constructor</code>中必须使用<code>super</code></p>\n<p>在调用<code>super</code>过程，无论是否传入<code>props</code>，<code>React</code>内部都会将<code>porps</code>赋值给组件实例<code>porps</code>属性中</p>\n<p>如果只调用了<code>super()</code>，那么<code>this.props</code>在<code>super()</code>和构造函数结束之间仍是<code>undefined</code></p>\n<h3> setState 执行机制？</h3>\n<p>在<code>react</code>类组件的状态需要通过<code>setState</code>进行更改，在不同场景下对应不同的执行顺序：</p>\n<ul>\n<li>在组件生命周期或 React 合成事件中，setState 是异步</li>\n<li>在 setTimeout 或者原生 dom 事件中，setState 是同步</li>\n</ul>\n<p>当我们批量更改<code>state</code>的值的时候，<code>react</code>内部会将其进行覆盖，只取最后一次的执行结果</p>\n<p>当需要下一个<code>state</code>依赖当前<code>state</code>的时候，则可以在<code>setState</code>中传递一个回调函数进行下次更新</p>\n<h3> React 的事件机制？</h3>\n<p><code>React</code>基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等</p>\n<p>组件注册的事件最终会绑定在<code>document</code>这个 <code>DOM</code>上，而不是 <code>React</code>组件对应的 <code>DOM</code>，从而节省内存开销</p>\n<p>自身实现了一套事件冒泡机制，阻止不同时间段的冒泡行为，需要对应使用不同的方法</p>\n<h3> 事件绑定的方式有哪些？</h3>\n<p><code>react</code>常见的绑定方式有如下：</p>\n<ul>\n<li>render 方法中使用 bind</li>\n<li>render 方法中使用箭头函数</li>\n<li>constructor 中 bind</li>\n<li>定义阶段使用箭头函数绑定</li>\n</ul>\n<p>前两种方式在每次组件<code>render</code>的时候都会生成新的方法实例，性能问题欠缺</p>\n<h3> 构建组件的方式有哪些？区别？</h3>\n<p>组件的创建主要分成了三种方式：</p>\n<ul>\n<li>函数式创建</li>\n<li>继承 React.Component 创建</li>\n<li>通过 React.createClass 方法创建</li>\n</ul>\n<p>如今一般都是前两种方式，对于一些无状态的组件创建，建议使用函数式创建的方式，再比如<code>hooks</code>的机制下，函数式组件能做类组件对应的事情，所以建议都使用函数式的方式来创建组件</p>\n<h3> 组件之间如何通信？</h3>\n<p>组件间通信可以通过<code>props</code>、传递回调函数、<code>context</code>、<code>redux</code>等形式进行组件之间通讯</p>\n<h3> key 有什么作用？</h3>\n<p>使用<code>key</code>是<code>react</code>性能优化的手段，在一系列数据最前面插入元素，如果没有<code>key</code>的值，则所有的元素都需要进行更换，而有<code>key</code>的情况只需要将最新元素插入到前面，不涉及删除操作</p>\n<p>在使用<code>key</code>的时候应保证：</p>\n<ul>\n<li>key 应该是唯一的</li>\n<li>key 不要使用随机值（随机数在下一次 render 时，会重新生成一个数字）</li>\n<li>避免使用 index 作为 key</li>\n</ul>\n<h3> refs 的理解？应用场景？</h3>\n<p><code>Refs</code>允许我们访问 <code>DOM</code>节点或在 <code>render</code>方法中创建的 <code>React</code>元素</p>\n<p>下面的场景使用<code>refs</code>非常有用：</p>\n<ul>\n<li>对 Dom 元素的焦点控制、内容选择、控制</li>\n<li>对 Dom 元素的内容设置及媒体播放</li>\n<li>对 Dom 元素的操作和对组件实例的操作</li>\n<li>集成第三方 DOM 库</li>\n</ul>\n<h3> Hooks 的理解？解决了什么问题？</h3>\n<p><code>Hook</code> 是 React 16.8 的新增特性。它可以让你在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 <code>React</code> 特性</p>\n<p>解决问题如下：</p>\n<ul>\n<li>难以重用和共享组件中的与状态相关的逻辑</li>\n<li>逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面</li>\n<li>类组件中的 this 增加学习成本，类组件在基于现有工具的优化上存在些许问题</li>\n<li>由于业务变动，函数组件不得不改为类组件等等</li>\n</ul>\n<h3> 如何引入 css？</h3>\n<p>常见的<code>CSS</code>引入方式有以下：</p>\n<ul>\n<li>在组件内直接使用</li>\n<li>组件中引入 .css 文件</li>\n<li>组件中引入 .module.css 文件</li>\n<li>CSS in JS</li>\n</ul>\n<p>组件内直接使用<code>css</code>会导致大量的代码，而文件中直接引入<code>css</code>文件是全局作用域，发生层叠</p>\n<p>引入<code>.module.css</code>文件能够解决局部作用域问题，但是不方便动态修改样式，需要使用内联的方式进行样式的编写</p>\n<p><code>css in js</code>这种方法，可以满足大部分场景的应用，可以类似于预处理器一样样式嵌套、定义、修改状态等</p>\n<h3> redux 工作原理？</h3>\n<p><code>redux</code>要求我们把数据都放在 <code>store</code>公共存储空间</p>\n<p>一个组件改变了 <code>store</code> 里的数据内容，其他组件就能感知到 <code>store</code>的变化，再来取数据，从而间接的实现了这些数据传递的功能</p>\n<p>工作流程图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/27b2e930-e56b-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> redux 中间件有哪些？</h3>\n<p>市面上有很多优秀的<code>redux</code>中间件，如：</p>\n<ul>\n<li>redux-thunk：用于异步操作</li>\n<li>redux-logger：用于日志记录</li>\n</ul>\n<h3> react-router 组件有哪些？</h3>\n<p>常见的组件有：</p>\n<ul>\n<li>BrowserRouter、HashRouter</li>\n<li>Route</li>\n<li>Link、NavLink</li>\n<li>switch</li>\n<li>redirect</li>\n</ul>\n<h3> render 触发时机？</h3>\n<p>在<code>React</code> 中，类组件只要执行了 <code>setState</code> 方法，就一定会触发 <code>render</code> 函数执行</p>\n<p>函数组件<code>useState</code> 会判断当前值有无发生改变确定是否执行<code>render</code>方法，一旦父组件发生渲染，子组件也会渲染</p>\n<h3> 如何减少 render？</h3>\n<p>父组件渲染导致子组件渲染，子组件并没有发生任何改变，这时候就可以从避免无谓的渲染，具体实现的方式有如下：</p>\n<ul>\n<li>shouldComponentUpdate</li>\n<li>PureComponent</li>\n<li>React.memo</li>\n</ul>\n<h3> JSX 转化 DOM 过程？</h3>\n<p><code>jsx</code>首先会转化成<code>React.createElement</code>这种形式，<code>React.createElement</code>作用是生成一个虚拟<code>Dom</code>对象，然后会通过<code>ReactDOM.render</code>进行渲染成真实<code>DOM</code></p>\n<h3> 性能优化手段有哪些</h3>\n<p>除了减少<code>render</code>的渲染之外，还可以通过以下手段进行优化：</p>\n<p>除此之外， 常见性能优化常见的手段有如下：</p>\n<ul>\n<li>避免使用内联函数</li>\n<li>使用 React Fragments 避免额外标记</li>\n<li>使用 Immutable</li>\n<li>懒加载组件</li>\n<li>事件绑定方式</li>\n<li>服务端渲染</li>\n</ul>\n<h3> 如何做服务端渲染？</h3>\n<p><code>node server</code> 接收客户端请求，得到当前的请求<code>url</code> 路径，然后在已有的路由表内查找到对应的组件，拿到需要请求的数据，将数据作为 <code>props</code>、<code>context</code>或者<code>store</code> 形式传入组件</p>\n<p>然后基于 <code>react</code> 内置的服务端渲染方法 <code>renderToString()</code>把组件渲染为 <code>html</code>字符串在把最终的 <code>html</code>进行输出前需要将数据注入到浏览器端</p>\n<p>浏览器开始进行渲染和节点对比，然后执行完成组件内事件绑定和一些交互，浏览器重用了服务端输出的 <code>html</code> 节点，整个流程结束</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a2894970-f3f7-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-05-21T00:00:00.000Z",
      "date_modified": "2023-05-21T05:11:53.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "typeof 与 instanceof 区别",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/typeof_instanceof.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/typeof_instanceof.html",
      "summary": "前端物语|面试物语-typeof 与 instanceof 区别",
      "content_html": "<h1> typeof 与 instanceof 区别</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3fc158f0-7710-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、typeof</h2>\n<p><code>typeof</code> 操作符返回一个字符串，表示未经计算的操作数的类型</p>\n<p>使用方法如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>operand</code>表示对象或原始值的表达式，其类型将被返回</p>\n<p>举个例子</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面例子，前 6 个都是基础数据类型。虽然<code>typeof null</code>为<code>object</code>，但这只是<code>JavaScript</code> 存在的一个悠久 <code>Bug</code>，不代表<code>null</code>就是引用数据类型，并且<code>null</code>本身也不是对象</p>\n<p>所以，<code>null</code>在 <code>typeof</code>之后返回的是有问题的结果，不能作为判断<code>null</code>的方法。如果你需要在 <code>if</code> 语句中判断是否为 <code>null</code>，直接通过<code>===null</code>来判断就好</p>\n<p>同时，可以发现引用类型数据，用<code>typeof</code>来判断的话，除了<code>function</code>会被识别出来之外，其余的都输出<code>object</code></p>\n<p>如果我们想要判断一个变量是否存在，可以使用<code>typeof</code>：(不能使用<code>if(a)</code>， 若<code>a</code>未声明，则报错)</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、instanceof</h2>\n<p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</p>\n<p>使用如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>object</code>为实例对象，<code>constructor</code>为构造函数</p>\n<p>构造函数通过<code>new</code>可以实例对象，<code>instanceof</code>能判断这个对象是否是之前那个构造函数生成的对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于<code>instanceof</code>的实现原理，可以参考下面：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>也就是顺着原型链去找，直到找到相同的原型对象，返回<code>true</code>，否则为<code>false</code></p>\n<h2> 三、区别</h2>\n<p><code>typeof</code>与<code>instanceof</code>都是判断数据类型的方法，区别如下：</p>\n<ul>\n<li>\n<p><code>typeof</code>会返回一个变量的基本类型，<code>instanceof</code>返回的是一个布尔值</p>\n</li>\n<li>\n<p><code>instanceof</code> 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</p>\n</li>\n<li>\n<p>而<code>typeof</code> 也存在弊端，它虽然可以判断基础数据类型（<code>null</code> 除外），但是引用数据类型中，除了<code>function</code> 类型以外，其他的也无法判断</p>\n</li>\n</ul>\n<p>可以看到，上述两种方法都有弊端，并不能满足所有场景的需求</p>\n<p>如果需要通用检测数据类型，可以采用<code>Object.prototype.toString</code>，调用该方法，统一返回格式<code>“[object Xxx]”</code>的字符串</p>\n<p>如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>了解了<code>toString</code>的基本用法，下面就实现一个全局通用的数据类型判断方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-05-21T00:00:00.000Z",
      "date_modified": "2023-05-21T01:05:16.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说你对 Redux 的理解？其工作原理？",
      "url": "https://www.h7ml.cn/posts/interview/React/redux.html",
      "id": "https://www.h7ml.cn/posts/interview/React/redux.html",
      "summary": "前端物语|面试物语-说说你对 Redux 的理解？其工作原理？",
      "content_html": "<h1> 说说你对 Redux 的理解？其工作原理？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/52394be0-e2a5-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>React</code>是用于构建用户界面的，帮助我们解决渲染<code>DOM</code>的过程</p>\n<p>而在整个应用中会存在很多个组件，每个组件的<code>state</code>是由自身进行管理，包括组件定义自身的<code>state</code>、组件之间的通信通过<code>props</code>传递、使用<code>Context</code>实现数据共享</p>\n<p>如果让每个组件都存储自身相关的状态，理论上来讲不会影响应用的运行，但在开发及后续维护阶段，我们将花费大量精力去查询状态的变化过程</p>\n<p>这种情况下，如果将所有的状态进行集中管理，当需要更新状态的时候，仅需要对这个管理集中处理，而不用去关心状态是如何分发到每一个组件内部的</p>\n<p><code>redux</code>就是一个实现上述集中管理的容器，遵循三大基本原则：</p>\n<ul>\n<li>单一数据源</li>\n<li>state 是只读的</li>\n<li>使用纯函数来执行修改</li>\n</ul>\n<p>注意的是，<code>redux</code>并不是只应用在<code>react</code>中，还与其他界面库一起使用，如<code>Vue</code></p>\n<h2> 二、工作原理</h2>\n<p><code>redux</code>要求我们把数据都放在 <code>store</code>公共存储空间</p>\n<p>一个组件改变了 <code>store</code> 里的数据内容，其他组件就能感知到 <code>store</code>的变化，再来取数据，从而间接的实现了这些数据传递的功能</p>\n<p>工作流程图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/27b2e930-e56b-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>根据流程图，可以想象，<code>React Components</code> 是借书的用户， <code>Action Creactor</code> 是借书时说的话(借什么书)， <code>Store</code> 是图书馆管理员，<code>Reducer</code> 是记录本(借什么书，还什么书，在哪儿，需要查一下)， <code>state</code> 是书籍信息</p>\n<p>整个流程就是借书的用户需要先存在，然后需要借书，需要一句话来描述借什么书，图书馆管理员听到后需要查一下记录本，了解图书的位置，最后图书馆管理员会把这本书给到这个借书人</p>\n<p>转换为代码是，<code>React Components</code> 需要获取一些数据, 然后它就告知 <code>Store</code> 需要获取数据，这就是就是 <code>Action Creactor</code> , <code>Store</code> 接收到之后去 <code>Reducer</code> 查一下， <code>Reducer</code> 会告诉 <code>Store</code> 应该给这个组件什么数据</p>\n<h2> 三、如何使用</h2>\n<p>创建一个<code>store</code>的公共数据区域</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>还需要创建一个记录本去辅助管理数据，也就是<code>reduecer</code>，本质就是一个函数，接收两个参数<code>state</code>，<code>action</code>，返回<code>state</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后就可以将记录本传递给<code>store</code>，两者建立连接。如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果想要获取<code>store</code>里面的数据，则通过<code>store.getState()</code>来获取当前<code>state</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>下面再看看如何更改<code>store</code>里面数据，是通过<code>dispatch</code>来派发<code>action</code>，通常<code>action</code>中都会有<code>type</code>属性，也可以携带其他的数据</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面再来看看修改<code>reducer</code>中的处理逻辑：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，<code>reducer</code>是一个纯函数，不需要直接修改<code>state</code></p>\n<p>这样派发<code>action</code>之后，既可以通过<code>store.subscribe</code>监听<code>store</code>的变化，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在<code>React</code>项目中，会搭配<code>react-redux</code>进行使用</p>\n<p>完整代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 小结</h3>\n<ul>\n<li>createStore 可以帮助创建 store</li>\n<li>store.dispatch 帮助派发 action , action 会传递给 store</li>\n<li>store.getState 这个方法可以帮助获取 store 里边所有的数据内容</li>\n<li>store.subscrible 方法订阅 store 的改变，只要 store 发生改变， store.subscrible 这个函数接收的这个回调函数就会被执行</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://cn.redux.js.org/docs/introduction/\" target=\"_blank\" rel=\"noopener noreferrer\">https://cn.redux.js.org/docs/introduction/</a></li>\n<li><a href=\"https://www.redux.org.cn/docs/basics/Actions.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.redux.org.cn/docs/basics/Actions.html</a></li>\n<li><a href=\"https://lulujianglab.com/posts/%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%A7%A3%E6%9E%90\" target=\"_blank\" rel=\"noopener noreferrer\">https://lulujianglab.com/posts/大白话解析</a> Redux 、 redux-thunk 、redux-saga 和 react-redux</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-05-20T00:00:00.000Z",
      "date_modified": "2023-05-20T10:11:46.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "代码展示",
      "url": "https://www.h7ml.cn/intro.html",
      "id": "https://www.h7ml.cn/intro.html",
      "summary": "libie chart 一个基础南丁格尔玫瑰图案例 一个基础南丁格尔玫瑰图案例 mermaid code 一个函数式 React Demo [react] 一个函数式 React Demo Vue Demo [vue] 一个 Vue Demo react-demo 一个类式 React Demo 一个类式 React Demo Vue Composit...",
      "content_html": "",
      "image": "https://v1.jinrishici.com/shuqing/libie.png",
      "date_published": "2020-02-02T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "echarts"
      ]
    },
    {
      "title": "浏览器知识",
      "url": "https://www.h7ml.cn/posts/browser.html",
      "id": "https://www.h7ml.cn/posts/browser.html",
      "summary": "跨域 跨域的原因 —— 浏览器的同源策略 同源策略是浏览器一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介 同源的定义是两个 URL 的 协议、域名(子域名 + 主域名)、端口号 都相同，否则就会出现跨域",
      "content_html": "<h2> 跨域</h2>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">跨域的原因 —— 浏览器的同源策略</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\" target=\"_blank\" rel=\"noopener noreferrer\">同源策略</a>是浏览器一个重要的安全策略，它用于限制一个 <code>origin</code> 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介</p>\n<p>同源的定义是两个 <code>URL</code> 的 <strong>协议</strong>、<strong>域名</strong>(子域名 + 主域名)、<strong>端口号</strong> 都相同，否则就会出现跨域</p>\n</div>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">同源策略的限制范围</p>\n<ol>\n<li>限制跨源网络访问: <code>AJAX</code> 请求不能发送</li>\n<li>限制跨源脚本 <code>API</code> 访问: <code>DOM</code> 无法获得</li>\n<li>限制跨源数据存储访问: <code>Cookie</code> <code>LocalStorage</code> 和 <code>IndexDB</code> 无法读取</li>\n</ol>\n<p>一般常说的跨域指网络跨域</p>\n</div>\n<h3> 常用的跨域解决方案</h3>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">常用的跨域解决方案</p>\n<ol>\n<li><strong>CORS</strong></li>\n<li><strong>JSONP</strong></li>\n<li>Nginx 反向代理</li>\n<li>WebSocket</li>\n<li>postMessage</li>\n<li>document.domain</li>\n</ol>\n</div>\n<h3> CORS 跨源资源共享</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\" target=\"_blank\" rel=\"noopener noreferrer\">CORS (跨源资源共享)</a> 是 <a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP\" target=\"_blank\" rel=\"noopener noreferrer\">HTTP</a> 的一部分，它允许浏览器向跨源服务器发出 <code>XMLHttpRequest</code> 请求，从而解决了 <code>AJAX</code> 只能同源使用的限制。</p>\n<blockquote>\n<p><code>CORS</code> 需要浏览器和服务器同时支持，目前所有浏览器均已支持，只需服务器配置即可使用</p>\n</blockquote>\n<p>浏览器将 <code>CORS</code> 请求分成两类: <strong>简单请求</strong>和<strong>非简单请求</strong></p>\n<h4> 简单请求</h4>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">简单请求必须同时满足以下条件</p>\n<blockquote>\n<p>日常开发只会关注前两点</p>\n</blockquote>\n<ul>\n<li>请求方法是以下三种方法之一\n<ul>\n<li><code>HEAD</code></li>\n<li><code>GET</code></li>\n<li><code>POST</code></li>\n</ul>\n</li>\n<li>只使用了如下的安全首部字段，不得人为设置其他首部字段\n<ul>\n<li><code>Accept</code></li>\n<li><code>Accept-Language</code></li>\n<li><code>Content-Language</code></li>\n<li><code>Content-Type</code> 仅限以下三种\n<ul>\n<li><code>application/x-www-form-urlencoded</code></li>\n<li><code>multipart/form-data</code></li>\n<li><code>text/plain</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>请求中的任意 <code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器(使用 <code>XMLHttpRequest.upload</code> 属性访问<code>XMLHttpRequestUpload</code> 对象)</li>\n<li>请求中没有使用 <code>ReadableStream</code> 对象</li>\n</ul>\n</div>\n<h5> 简单请求基本流程</h5>\n<ol>\n<li>浏览器会直接发出 <code>CORS</code> 请求并在请求头信息之中增加一个 <code>Origin</code> 字段(用来说明本次请求来自哪个源(协议 + 域名 + 端口))</li>\n<li>服务器判断 <code>Origin</code> 字段决定是否同意这次请求</li>\n<li>通过请求会在响应头增加 <code>CORS</code> 相关的字段(以<code>Access-Control-</code>开头)</li>\n<li>拒绝请求时不会增加 <code>CORS</code> 相关的字段，浏览器会抛出异常</li>\n</ol>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">简单请求响应头中的 CORS 字段</p>\n<ul>\n<li><code>Access-Control-Allow-Origin</code>: 只能是 <code>*</code>(接受任意域名的请求)或者是请求时 <code>Origin</code> 字段的值</li>\n<li><code>Access-Control-Allow-Credentials</code>(可选): 是一个布尔值,表示是否允许发送 <code>Cookie</code></li>\n<li><code>Access-Control-Expose-Headers</code>(可选): <code>CORS</code> 请求时 <code>XMLHttpRequest</code> 对象的 <code>getResponseHeader()</code> 方法只能拿到 6 个基本字段：<code>Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma</code>。如果想拿到其他字段就必须在 <code>Access-Control-Expose-Headers</code> 里面指定</li>\n</ul>\n</div>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">CORS 中的 Cookie 设置</p>\n<p><code>CORS</code> 请求默认不发送 <code>Cookie</code>，如果需要发送需要满足如下条件</p>\n<ul>\n<li>服务器必须设置 <code>Access-Control-Allow-Credentials: true</code></li>\n<li><code>Access-Control-Allow-Origin</code> 字段不能为 <code>*</code></li>\n<li><code>AJAX</code> 请求的配置项需设置 <code>withCredentials = true</code></li>\n</ul>\n</div>\n<h4> 非简单请求</h4>\n<p>非简单请求是那种对服务器有特殊要求的请求，如请求方法是 <code>PUT</code> 或 <code>DELETE</code>，或者 <code>Content-Type</code> 字段的类型是 <code>application/json</code>。<br> 非简单请求会在正式通信之前增加一次 <code>HTTP</code> 查询请求，称为<strong>预检请求</strong>，用于获取服务器是否允许该实际请求，同时避免跨域请求对服务器的用户数据产生预期之外的影响</p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">预检请求</p>\n<p>预检请求用的请求方法是 <code>OPTIONS</code> 表示这个请求是用来询问的</p>\n<ul>\n<li>在预检请求请求头信息里会包含如下字段\n<ul>\n<li><code>Origin</code>: 表示本次请求来自哪个源</li>\n<li><code>Access-Control-Request-Method</code>: 用于列出浏览器的 <code>CORS</code> 请求会用到哪些 <code>HTTP</code> 方法</li>\n<li><code>Access-Control-Request-Headers</code>(可选): 指定浏览器 <code>CORS</code> 请求会额外发送的头信息字段</li>\n</ul>\n</li>\n<li>服务器通过后会在预检请求响应头中设置如下字段\n<ul>\n<li><code>Access-Control-Allow-Origin</code></li>\n<li><code>Access-Control-Allow-Credentials</code>(可选)</li>\n<li><code>Access-Control-Allow-Methods</code>: 表示服务器支持的所有跨域请求的方法(为了避免多次预检请求)</li>\n<li><code>Access-Control-Allow-Headers</code>: 表示服务器支持的所有头信息字段，不限于浏览器在预检中请求的字段</li>\n<li><code>Access-Control-Max-Age</code>(可选): 用来指定本次预检请求的有效期单位为秒，在有效期内将不发出另一条预检请求</li>\n</ul>\n</li>\n</ul>\n</div>\n<p>一旦服务器通过了预检请求，以后每次浏览器正常的 <code>CORS</code> 请求，就都跟简单请求一样会有一个 <code>Origin</code> 头信息字段。服务器的回应也都会有一个 <code>Access-Control-Allow-Origin</code> 头信息字段</p>\n<details class=\"hint-container details\"><summary>CORS 请求过程 ![CORS 请求过程](https://static.h7ml.cn/vitepress/assets/images/cors-process.png) :::</summary>\n<p><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener noreferrer\">参考资料 —— 跨域资源共享 CORS 详解</a></p>\n<h3> JSONP</h3>\n<p><code>JSONP</code> 是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，当前源可以得到从其他来源动态产生的 <code>JSON</code> 数据</p>\n<p><strong><code>JSONP</code> 请求过程流程</strong></p>\n<ol>\n<li>前端定义一个解析的回调函数</li>\n<li>创建 <code>script</code> 标签，其 <code>src</code> 指向接口地址并拼接好参数和回调函数名</li>\n<li>后端处理数据并将其拼接到前端传入的回调函数中(拼接好的数据必须是一个合法的 <code>JavaScript</code> 脚本 )</li>\n<li>浏览器执行后端返回的 <code>JavaScript</code> 脚本代码(调用定义好的回调函数)并删除刚创建的 <code>script</code> 标签</li>\n</ol>\n<details class=\"hint-container details\"><summary>JSONP 代码实现</summary>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></details>\n</details>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">JSONP 跨域优缺点</p>\n<ul>\n<li>优点: 实现简单，兼容性好</li>\n<li>缺点\n<ul>\n<li>只支持 <code>GET</code> 请求</li>\n<li>容易遭受 <code>XSS</code> 攻击</li>\n</ul>\n</li>\n</ul>\n</div>\n<p><a href=\"https://juejin.cn/post/6844904126246027278\" target=\"_blank\" rel=\"noopener noreferrer\">了解更多跨域解决方案请点击 —— 10 种跨域解决方案</a></p>\n<h2> 浏览器缓存机制</h2>\n<ul>\n<li>\n<ol>\n<li>浏览器在发送请求前先判断是否命中强缓存</li>\n</ol>\n<ul>\n<li>命中则不发送请求直接使用缓存，否则进行下一步</li>\n</ul>\n</li>\n<li>\n<ol start=\"2\">\n<li>浏览器发送请求后会由服务器判断是否命中协商缓存</li>\n</ol>\n<ul>\n<li>命中则从缓存获取资源，否则进行下一步</li>\n</ul>\n</li>\n<li>\n<ol start=\"3\">\n<li>浏览器直接使用服务器返回的资源并更新缓存</li>\n</ol>\n</li>\n</ul>\n<h3> 强缓存（200 OK）</h3>\n<ul>\n<li><code>Expires</code> 是服务器告诉浏览器的缓存过期时间（值为 <code>GMT</code> 时间，即格林尼治时间）\n<ul>\n<li><code>HTTP1.0</code> 的产物</li>\n<li>受本地时间影响</li>\n<li>设置的值为 <code>max-age=xxx</code>（xxx 是 秒）</li>\n</ul>\n</li>\n<li><code>Cache-Control</code> 用于控制缓存的行为\n<ul>\n<li>是 <code>HTTP1.1</code> 的产物</li>\n<li>取值\n<ul>\n<li><code>public</code>：允许被客户端和代理服务器缓存</li>\n<li><code>private</code>：只允许被客户端缓存（默认值）</li>\n<li><code>no-cache</code>：允许被客户端和代理服务器缓存，但在使用缓存时需要经过协商缓存来验证决定</li>\n<li><code>no-store</code>：所有内容都不会被缓存，即不使用强制缓存也不使用协商缓存每次请求都会下载完整的资源</li>\n<li><code>maxage=xxx</code>：设置客户端和代理服务器的缓存时间，表示缓存内容将在 xxx 秒后失效</li>\n<li><code>s-maxage=xxx</code>：设置代理服务器的缓存时间（优先级比 <code>max-age</code> 高）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">Cache-Control 注意点 `no-cache` 名字存在误导，其并不是不缓存数据，只是在使用缓存时需要经过协商缓存来验证决定<br> `max-age=0` 和 `no-cache` 效果一致 :::</p>\n<h4> 缓存位置</h4>\n<ul>\n<li>内存缓存（memory cache）\n<ul>\n<li>快速读取（内存缓存将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取）</li>\n<li>进程关闭时数据会被清除</li>\n<li>不请求网络资源，资源存在内存中一般 <code>JS</code> 和图片文件会存入内存</li>\n<li>状态码：<code>200（from memory cache）</code></li>\n</ul>\n</li>\n<li>硬盘缓存（disk cache）\n<ul>\n<li>写入硬盘文件进行 <code>I/O</code> 操作</li>\n<li>进程关闭时数据不会被清除</li>\n<li>速度比 <code>memory cache</code> 慢</li>\n<li>不请求网络资源，资源存在磁盘中一般非脚本会存在磁盘中，如 <code>css</code></li>\n<li>状态码：<code>200（from disk cache）</code></li>\n</ul>\n</li>\n<li>代理服务器缓存（server worker）\n<ul>\n<li>可以拦截处理页面的所有网络请求</li>\n<li>仅 <code>HTTPS</code> 下可用、存在兼容问题</li>\n<li>状态码：<code>200（from service worker）</code></li>\n</ul>\n</li>\n</ul>\n<h3> 协商缓存（304 Not Modified）</h3>\n<h4> <code>Last-Modified</code> 和 <code>If-Modified-Since</code></h4>\n<p><code>Last-Modified</code> 表示资源的最后修改时间，值为 <code>GMT</code> 格式时间字符串，精确到秒</p>\n<ul>\n<li>浏览器第一次请求时，服务器会在响应头中返回请求资源的上次更新时间 <code>Last-Modified</code></li>\n<li>当浏览器再次请求时，会在请求头中携带 <code>If-Modified-Since</code> 值为上次请求返回的 <code>Last-Modified</code></li>\n<li>服务器收到请求后，会根据请求头中的 <code>If-Modified-Since</code> 和该资源在服务器的最后被修改时间做对比\n<ul>\n<li>大于 <code>If-Modified-Since</code> 重新返回资源文件，状态码为 200</li>\n<li>小于 <code>If-Modified-Since</code> 资源无更新继续使用缓存文件，状态码为 304</li>\n</ul>\n</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">Last-Modified 存在的问题</p>\n<ul>\n<li>时间精度为秒级会出现误差情况，对文件修改精度有严格要求的场景不能满足</li>\n<li>在集群服务器上各个服务器上的文件时间可能不同</li>\n<li>如果用旧文件覆盖新文件，因为时间更前浏览器不会请求旧文件</li>\n<li>编辑了文件但未修改，会导致缓存失效</li>\n</ul>\n</div>\n</div>\n<h4> ETag 和 If-None-Match</h4>\n<p><code>ETag</code> 是服务器通过算法对资源内容计算出的一个唯一标识（文件 <code>hash</code>）其有强弱之分</p>\n<ul>\n<li>强 <code>Etag</code>\n<ul>\n<li><code>ETag: \"&lt;etag_value&gt;\"</code></li>\n<li>资源发生任何改变都会立刻更新</li>\n<li>难生成，利于比较</li>\n</ul>\n</li>\n<li>弱 <code>Etag</code>（使用 <code>W/</code> 标识）\n<ul>\n<li><code>ETag: W/\"&lt;etag_value&gt;\"</code></li>\n<li>只在资源发生本质变化时更新</li>\n<li>易生成，不利于比较</li>\n</ul>\n</li>\n</ul>\n<h5> 过程</h5>\n<ul>\n<li>浏览器第一次请求时，服务器会在响应头中返回当前资源文件的一个唯一标识 <code>ETag</code></li>\n<li>当浏览器再次请求时，会在请求头中携带 <code>If-None-Match</code> 值为上次请求返回的 <code>ETag</code></li>\n<li>通过接收的 <code>ETag</code> 和服务器重新生成的 <code>ETag</code> 进行对比\n<ul>\n<li>不一致 重新返回资源文件，状态码为 200</li>\n<li>一致 资源无更新继续使用缓存文件，状态码为 304</li>\n</ul>\n</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">Last-Modified 和 Etag 对比</p>\n<ul>\n<li>精确度上：<code>Etag</code> 优于 <code>Last-Modified</code></li>\n<li>性能上：<code>Etag &lt; Last-Modified</code> 每次生成 <code>ETag</code> 都需要进行读写操作，而 <code>Last-Modified</code> 只需要读取操作</li>\n<li>优先级：服务器校验优先考虑 <code>Etag</code></li>\n</ul>\n</div>\n<h3> 应用场景</h3>\n<table>\n<thead>\n<tr>\n<th>强缓存</th>\n<th>协商缓存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>不常变化的文件<br>带 hash 值的 css js 图片</td>\n<td>频繁变动的文件<br>html 文件</td>\n</tr>\n</tbody>\n</table>\n<h3> 用户行为对缓存的影响</h3>\n<ul>\n<li>地址栏输入\n<ul>\n<li>查找 <code>disk cache</code>（磁盘缓存）中是否有匹配，有则使用缓存，没有则发送网络请求</li>\n</ul>\n</li>\n<li>普通刷新（F5）\n<ul>\n<li>因为浏览器 <code>tab</code> 标签并没有关闭，因此 <code>memory cache</code> （内存缓存）是可用的，会被优先使用，其次使用 <code>disk cache</code>（磁盘缓存）</li>\n<li>跳过强缓存规则，直接走协商缓存</li>\n</ul>\n</li>\n<li>强制刷新（Ctrl + F5）\n<ul>\n<li>浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control: no-cache</code> （为了兼容还带了 <code>Pragma: no-cache</code>）服务器直接返回 200 和最新内容。</li>\n<li>跳过所有缓存规则</li>\n</ul>\n</li>\n</ul>\n<h2> 浏览器存储</h2>\n<h3> Cookie</h3>\n<p><code>Cookie</code>（也叫 <code>Web Cookie</code> 或浏览器 <code>Cookie</code>）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。<code>Cookie</code> 使基于无状态的 <code>HTTP</code> 协议记录稳定的状态信息成为了可能，<code>Cookie</code> 在存储时是以键值对的形式存在的</p>\n<p><code>Cookie</code> 主要用于以下三个方面：</p>\n<ul>\n<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>\n<li>个性化设置（如用户自定义设置、主题等）</li>\n<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>\n</ul>\n<p><code>Cookie</code> 的本职工作并非本地存储，而是“维持状态”，因当时并没有其它合适的存储办法而作为唯一的存储手段，所以会用其进行本地存储</p>\n<h4> Cookie 的生成和使用</h4>\n<ul>\n<li>服务器生成，通过 <code>http response header</code> 中的 <code>set-cookie</code></li>\n<li>在 <code>JavaScript</code> 中使用 <code>document.cookie</code> 进行读写</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">Cookie 的缺点</p>\n<ul>\n<li><code>Cookie</code> 最大只能有 <code>4KB</code> 同时大多数浏览器对一个站点的 <code>Cookie</code> 个数也是有限制的</li>\n<li>同一个域名下的所有请求都会携带 <code>Cookie</code> 从而带来不必要的开销和安全问题</li>\n</ul>\n</div>\n<h3> Web Storage</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API\" target=\"_blank\" rel=\"noopener noreferrer\">Web Storage</a>是 <code>HTML5</code> 专门为浏览器存储而提供的数据存储机制，其大小限制为 <code>5MB ~ 10MB</code> (<a href=\"http://dev-test.nemikor.com/web-storage/support-test/\" target=\"_blank\" rel=\"noopener noreferrer\">去查看当前浏览器下 Web Storage 的容量限制</a>)，数据仅保存在客户端不与服务器进行通信</p>\n<p><code>Web Storage</code> 提供了两种机制供我们使用</p>\n<ul>\n<li><code>Local Storage</code>(本地存储)</li>\n<li><code>Session Storage</code>(会话存储)</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">LocalStorage</p>\n<ul>\n<li>保存的数据长期存在</li>\n<li>在同源的所有标签页和窗口之间共享数据</li>\n</ul>\n</div>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">SessionStorage</p>\n<ul>\n<li>数据只存在于当前浏览器的标签页</li>\n<li><strong>在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文</strong>\n<ul>\n<li>在当前标签中打开一个同域下的页面时会复制当前标签页中的 <code>SessionStorage</code> 数据</li>\n<li>复制的 <code>SessionStorage</code> 数据是独立的，不会相互影响(类似深拷贝)</li>\n</ul>\n</li>\n<li>重新加载或恢复页面仍会保持原来的数据</li>\n<li>关闭对应浏览器标签或窗口后数据会被清除</li>\n</ul>\n</div>\n<h4> API 使用</h4>\n<blockquote>\n<p>以 <code>localStorage</code> 为例</p>\n</blockquote>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">sessionStorage localStorage 和 cookie 的区别</p>\n<ul>\n<li>相同点\n<ul>\n<li>都是在客户端保存数据</li>\n<li>存储数据的类型都是字符串</li>\n</ul>\n</li>\n<li>不同点\n<ul>\n<li>生命周期\n<ul>\n<li><code>Cookie</code>: 可以设置失效时间(默认是关闭浏览器后失效)</li>\n<li><code>localStorage</code>: 除非被手动清除否则将会永久保存</li>\n<li><code>sessionStorage</code>: 仅在当前浏览器的标签页下有效，关闭标签或窗口后就会被清除</li>\n</ul>\n</li>\n<li>数据大小\n<ul>\n<li><code>Cookie</code>: 4KB</li>\n<li><code>localStorage</code> 和 <code>sessionStorage</code>: <code>5MB ~ 10MB</code></li>\n</ul>\n</li>\n<li>http 请求\n<ul>\n<li><code>Cookie</code>: 每次都会携带在 <code>HTTP</code> 请求头中</li>\n<li><code>localStorage</code> 和 <code>sessionStorage</code>: 仅在客户储保存不会与服务器通信</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<h3> IndexedDB</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API\" target=\"_blank\" rel=\"noopener noreferrer\">IndexedDB</a> 是一个运行在浏览器上的非关系型数据库，用于<strong>在客户端存储大量结构化数据</strong></p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">IndexedDB 的特点</p>\n<ul>\n<li>存储空间大(一般来说不少于 <code>250MB</code> 甚至没有上限)</li>\n<li>支持存储二进制数据(<code>ArrayBuffer</code> 和 <code>Blob</code>)</li>\n<li>键值对储存</li>\n<li>同源限制</li>\n<li>执行的操作是异步执行，以免阻塞应用程序</li>\n<li>是一个事务型数据库系统</li>\n</ul>\n</div>\n<h4> API 使用</h4>\n<p>打开/创建一个 IndexedDB 数据库，并指定数据库的版本号 (版本号只能为整数)</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建一个对象仓库(类似于数据库中的表)</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>添加数据</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>获取数据</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改数据</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>删除数据</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">在日常开发中可以使用如下类库简化代码量</p>\n<ul>\n<li><a href=\"https://github.com/localForage/localForage\" target=\"_blank\" rel=\"noopener noreferrer\">localForage</a> 一个提供 <code>name:value</code> 的简单语法的客户端数据存储垫片，基于 <code>IndexedDB</code> 实现，并在不持支 <code>IndexedDB</code> 的浏览器中自动回退到 <code>WebSQL</code> 和 <code>localStorage</code></li>\n<li><a href=\"https://github.com/dexie/Dexie.js\" target=\"_blank\" rel=\"noopener noreferrer\">Dexie.js</a> 对 <code>IndexedDB</code> 的封装，通过提供更友好和简单语法进行快速的编码开发</li>\n<li><a href=\"https://github.com/pouchdb/pouchdb\" target=\"_blank\" rel=\"noopener noreferrer\">PouchDB</a> 对 <code>IndexedDB</code> 的封装，通过提供更友好和简单语法进行快速的编码开发</li>\n</ul>\n</div>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/cors-process.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "es6"
      ]
    },
    {
      "title": "es6",
      "url": "https://www.h7ml.cn/posts/es6.html",
      "id": "https://www.h7ml.cn/posts/es6.html",
      "summary": "es6 知识点 ECMAScript 6 (简称 ES6) 是 JavaScript 语言的下一代标准 ECMAScript 的提案流程 Stage 0 - Strawman（展示阶段） Stage 1 - Proposal（征求意见阶段） Stage 2 - Draft（草案阶段） Stage 3 - Candidate（候选人阶段） Stage 4 - Finished（定案阶段）",
      "content_html": "<h2> es6 知识点</h2>\n<p><code>ECMAScript 6</code> (简称 <code>ES6</code>) 是 <code>JavaScript</code> 语言的下一代标准</p>\n<p><code>ECMAScript</code> 的提案流程</p>\n<ul>\n<li><code>Stage 0 - Strawman</code>（展示阶段）</li>\n<li><code>Stage 1 - Proposal</code>（征求意见阶段）</li>\n<li><code>Stage 2 - Draft</code>（草案阶段）</li>\n<li><code>Stage 3 - Candidate</code>（候选人阶段）</li>\n<li><code>Stage 4 - Finished</code>（定案阶段）</li>\n</ul>\n<p>一个提案只要能进入 <code>Stage 2</code> 就差不多肯定会包括在以后的正式标准里面</p>\n<p><a href=\"https://github.com/tc39/ecma262\" target=\"_blank\" rel=\"noopener noreferrer\">ECMAScript 当前的所有提案</a></p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">ES6 和 ES2015 的区别 `ES2015` 是一个年份标记，表示当年发布的 `ECMAScript` 标准的正式版本，其全称为《`ECMAScript 2015` 标准》（简称 `ES2015`）<br> `ES6` 是一个历史名词也是一个泛指，含义是 `5.1` 版以后的 `JavaScript` 的下一代标准，涵盖了 `ES2015、ES2016、ES2017 ES2018` 等等 :::</p>\n<h2> let const</h2>\n<p><code>ES6</code> 新增了 <strong><code>let</code></strong> 和 <strong><code>const</code></strong> 命令，用于声明变量，其声明的变量只在声明所在的块级作用域内有效</p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">let const var 的区别</p>\n<ul>\n<li><code>var</code> 声明的变量会提升到作用域的顶部，<code>let const</code> 不存在变量提升</li>\n<li><code>var</code> 声明的全局变量会被挂载到全局对象 <code>window</code> 上，而 <code>let const</code> 不会</li>\n<li><code>var</code> 可以对一个变量进行重复声明，而 <code>let const</code> 不能重复声明</li>\n<li><code>var</code> 声明的变量作用域范围是函数作用域，<code>let const</code> 声明的变量作用域范围是块级作用域</li>\n<li><code>const</code> 声明的是一个只读的常量，一旦声明常量的值就不能改变(必须对变量进行初始化)\n<ul>\n<li>基本类型保证值不可变</li>\n<li>引用类型保证内存指针不可变</li>\n</ul>\n</li>\n</ul>\n</div>\n</div>\n<h3> 变量提升</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><a href=\"https://www.zhihu.com/question/535442142/answer/2510328090\" target=\"_blank\" rel=\"noopener noreferrer\">为什么 let 和 const 不存在变量提升？ - 知乎</a></p>\n<h3> 挂载到全局对象</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 重复声明</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 作用域范围</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> const 常量定义</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 模板字符串</h2>\n<p>模板字符串 (template string) 是增强版的字符串，用反引号(<strong>`</strong>)标识。它可以当作普通字符串、定义多行字符串或者在字符串中嵌入变量、函数调用以及表达式</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 解构赋值</h2>\n<h3> 解构对象</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 解构数组</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 函数的扩展</h2>\n<h3> 参数默认值</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">函数参数的默认值</p>\n<ul>\n<li>参数变量是默认声明的不能用 <code>let</code>或 <code>const</code> 再次声明，否则会报错</li>\n<li>使用参数默认值时函数不能有同名参数</li>\n<li>参数默认值的位置应该是函数的尾参数</li>\n</ul>\n</div>\n<h3> 剩余参数(rest 参数)</h3>\n<p><code>ES6</code> 引入 <code>rest</code> 参数(形式为 <code>...变量名</code>) 用于获取函数的剩余参数(可以替换 <code>arguments</code> 对象)</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">剩余参数(rest 参数)</p>\n<ul>\n<li><code>rest</code> 参数是一个真正的数组，数组特有的方法都可以使用</li>\n<li><code>rest</code> 参数之后不能再有其他参数，否则会报错</li>\n<li>函数的 <code>length</code> 属性，不包括 <code>rest</code> 参数</li>\n</ul>\n</div>\n<h3> 箭头函数</h3>\n<p><code>ES6</code> 允许使用<strong>箭头</strong>(<code>=&gt;</code>)定义函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">箭头函数与普通函数的区别</p>\n<ul>\n<li><code>this</code>\n<ul>\n<li>普通函数\n<ul>\n<li><code>this</code> 指向是动态的(取决于函数的调用方式)</li>\n<li>可以用 <code>call apply bind</code> 改变 <code>this</code> 指向</li>\n</ul>\n</li>\n<li>箭头函数\n<ul>\n<li><code>this</code> 指向是固定的，指向定义时上层作用域中的 <code>this</code>(它没有自己的 <code>this</code>)</li>\n<li><code>call apply bind</code> 无法改变箭头函数的 <code>this</code> 指向(上下文值始终按词法解析)</li>\n<li>全局作用域下 <code>this</code> 指向全局对象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>箭头函数不可以当作构造函数(不能使用 <code>new</code> 运算符，否则会报错)</li>\n<li>箭头函数的函数体内不可以使用<code>arguments super new.target</code></li>\n<li>箭头函数不可以使用 yield 命令(不能用作 <code>Generator</code> 函数)</li>\n<li>在 <code>class</code> 中使用箭头函数其 <code>this</code> 会和类实例进行绑定</li>\n</ul>\n</div>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意点(以下场合不应该使用箭头函数)</p>\n<ul>\n<li>定义对象方法且该方法内部包括 <code>this</code> 时</li>\n<li>定义原型方法且该方法内部包括 <code>this</code> 时</li>\n<li>需要动态 <code>this</code> 时</li>\n</ul>\n</div>\n<p><a href=\"https://www.babeljs.cn/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&amp;build=&amp;builtIns=false&amp;corejs=3.6&amp;spec=false&amp;loose=false&amp;code_lz=MYewdgzgLgBANiA5jAvDAFASlQPhgbwCgYZRIQ4BTAOgUXQHI6YoALASwgC4GAaFjhEyEAvoUIAzAK5hgUduBgSwWAsRgRKUACrsAtpRBSo6VSjxESJMhAo06jZQM49-bTsJIj-ARgAMfsIiQA&amp;debug=false&amp;forceAllTransforms=true&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=script&amp;lineWrap=true&amp;presets=env%2Creact&amp;prettier=false&amp;targets=&amp;version=7.17.11&amp;externalPlugins=&amp;assumptions=%7B%7D\" target=\"_blank\" rel=\"noopener noreferrer\">利用 <code>babel</code> 编译箭头函数代码查看 <code>this</code> 的指向</a></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 扩展运算符</h2>\n<p>扩展运算符 (<code>spread</code>)是三个点 (<code>...</code>) 它好比 <code>rest</code> 参数的逆运算</p>\n<h3> 函数调用</h3>\n<p>扩展运算符在函数调用时可以将一个数组变为参数序列，从而可以替代函数的 <code>apply()</code> 方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 拷贝数组/对象</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 合并数组/对象</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 使用表达式</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 与解构赋值结合</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">扩展运算符</p>\n<ul>\n<li>使用扩展运算符拷贝数组或对象时其都是<strong>浅拷贝</strong></li>\n<li>对象的扩展运算符等同于使用 <code>Object.assign()</code> 方法</li>\n<li>只有函数调用时扩展运算符才可以放在圆括号中，否则会报错</li>\n<li>扩展运算符用于赋值时只能放在参数的最后一位，否则会报错</li>\n</ul>\n</div>\n<h2> 数组的扩展</h2>\n<h3> Array.from()</h3>\n<p><code>Array.from()</code> 用于将两类对象转为真正的数组</p>\n<ul>\n<li>类似数组的对象 (<code>array-like object</code>)\n<ul>\n<li><code>DOM</code> 操作返回的 <code>NodeList</code></li>\n<li><code>arguments</code> 对象</li>\n</ul>\n</li>\n<li>可遍历 (<code>iterable</code>) 的对象 (包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>)</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">Array.from()</p>\n<p><code>Array.from()</code> 可以接受一个函数作为第二个参数，作用类似于数组的<code>map()</code> 用来对每个元素进行处理，将处理后的值放入返回的数组</p>\n<p>在字符串转为数组时 <code>Array.from()</code> 能正确处理各种 <code>Unicode</code> 字符，可以避免 <code>JavaScript</code> 将大于 <code>\\uFFFF</code> 的 <code>Unicode</code> 字符算作两个字符的 <code>bug</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></div>\n<h3> Array.of()</h3>\n<p><code>Array.of()</code> 用于将一组值转换为数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">Array.of()</p>\n<p><code>Array.of()</code> 方法的主要目的是弥补数组构造函数 <code>Array()</code> 的不足(因为参数个数的不同会导致<code>Array()</code>的行为有差异)</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Array.of()</code> 总是返回参数值组成的数组。如果没有参数就返回一个空数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></div>\n<h3> 实例方法: includes()</h3>\n<p><code>includes()</code> 方法返回一个布尔值，表示某个数组是否包含给定的值(<code>ES2016</code> 引入)</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">includes() 和 indexOf() 的对比</p>\n<p><code>indexOf()</code> 不够语义化，其含义是找到参数值的第一个出现位置，所以要去比较是否不等于 <code>-1</code>，表达起来不够直观<br> <code>indexOf()</code> 内部使用严格相等运算符 (<code>===</code>) 进行判断，这会导致对 <code>NaN</code> 的误判</p>\n</div>\n<h3> 实例方法: find() 和 findIndex()</h3>\n<p><code>find()</code> 方法用于找出第一个符合条件的数组成员，如果<strong>没有符合条件的成员则返回 <code>undefined</code></strong></p>\n<p><code>findIndex()</code> 方法用于找出第一个符合条件的数组成员的位置，如果<strong>没有符合条件的成员则返回 <code>-1</code></strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 实例方法: at()</h3>\n<p><code>at()</code> 方法接受一个整数(支持负数)作为参数返回对应位置的成员，如果<strong>参数位置超出了数组范围则返回 <code>undefined</code></strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 实例方法: flat() 和 flatMap()</h3>\n<p><code>flat()</code> 方法用于将嵌套的数组拍平变成一维的数组，该方法<strong>返回一个新数组不改变原数组</strong></p>\n<p><code>flatMap()</code> 方法会先对原数组的每个成员执行一个函数(相当于执行 <code>Array.prototype.map()</code>) 然后对返回值组成的数组执行 <code>flat()</code> 方法，该方法<strong>返回一个新数组不改变原数组</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">flat() 和 flatMap() 注意点</p>\n<ul>\n<li><code>flat()</code> 方法默认只会拉平一层</li>\n<li><code>flat()</code>方法会跳过原数组中的空位</li>\n<li><code>flatMap()</code> 只能展开一层数组</li>\n</ul>\n</div>\n<h2> 对象的扩展</h2>\n<h3> 属性简写</h3>\n<p><code>ES6</code> 允许在大括号里面直接写入变量和函数作为对象的属性和方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">属性简写</p>\n<p>简写的对象方法不能用作构造函数否则会报错</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></div>\n<h3> 属性名表达式</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">属性名表达式</p>\n<p>属性名表达式与属性简写不能同时使用否则会报错</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>属性名表达式如果是一个对象会自动将其转为字符串 <code>[object Object]</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></div>\n<h3> <a href=\"http://Object.is\" target=\"_blank\" rel=\"noopener noreferrer\">Object.is</a>()</h3>\n<p><code>Object.is()</code> 方法用来比较两个值是否严格相等，严格比较运算符 (<code>===</code>) 的行为基本一致</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">Object.is() 与 === 的不同之处</p>\n<p><code>+0</code>不等于<code>-0</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></div>\n<h3> Object.assign()</h3>\n<p><code>Object.assign()</code> 方法用于对象的合并，将源对象的所有可枚举属性复制到目标对象（第一个参数是目标对象后面的参数都是源对象）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 只有一个参数时会直接返回该参数</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 传入参数不是对象时会先转成对象再返回</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 传入非对象类型的场景</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 传入数组时会把数组当对象处理</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">Object.assign() 总结和应用场景</p>\n<p>总结</p>\n<ul>\n<li><code>Object.assign()</code> 是<strong>浅拷贝</strong>方法</li>\n<li>存在同名属性时，后面的属性会覆盖前面的属性</li>\n<li>只有一个参数时会直接返回该参数</li>\n<li>传入参数不是对象时会先转成对象再返回</li>\n<li>传入 <code>undefined</code> 和 <code>null</code> 时\n<ul>\n<li>如果为第一个参数会报错（无法转成对象）</li>\n<li>如果不为第一个参数时会被忽略</li>\n</ul>\n</li>\n<li>传入数组时会把数组当对象处理</li>\n</ul>\n<p>应用场景</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></div>\n<h3> Object.keys() Object.value() Object.entries()</h3>\n<p><code>Object.keys()</code> 方法返回一个数组，其成员为参数对象自身的（不含继承的）所有可遍历属性的键名(<code>ES5</code> 引入)</p>\n<p><code>Object.value()</code> 方法返回一个数组，其成员为参数对象自身的（不含继承的）所有可遍历属性的键值(<code>ES2017</code> 引入)</p>\n<p><code>Object.entries()</code> 方法返回一个数组（二维数组），其成员为参数对象自身的（不含继承的）所有可遍历属性的键值对数组(<code>ES2017</code> 引入)</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Object.fromEntries()</h3>\n<p><code>Object.fromEntries()</code> 方法是 <code>Object.entries()</code> 的逆操作，用于将键值对的数据结构还原为对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 对象遍历方法对比</h3>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:center\">继承的原型属性</th>\n<th style=\"text-align:center\">不可枚举属性</th>\n<th style=\"text-align:center\">Symbol 属性</th>\n<th style=\"text-align:center\">返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>for...in</td>\n<td style=\"text-align:left\">遍历对象自身和继承的所有可枚举属性(不含 Symbol 属性)</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">key</td>\n</tr>\n<tr>\n<td>Object.keys</td>\n<td style=\"text-align:left\">遍历对象自身所有可枚举属性(不含 Symbol 属性)</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">[key...]</td>\n</tr>\n<tr>\n<td>Object.getOwnPropertyNames</td>\n<td style=\"text-align:left\">遍历对象自身所有属性(不含 Symbol 属性)</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">[key...]</td>\n</tr>\n<tr>\n<td>Object.getOwnPropertySymbols</td>\n<td style=\"text-align:left\">遍历对象自身所有的 Symbol 属性</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">[key...]</td>\n</tr>\n<tr>\n<td>Reflect.ownKeys</td>\n<td style=\"text-align:left\">遍历对象自身所有的属性(包含不可枚举和 Symbol 属性)</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">✅</td>\n<td style=\"text-align:center\">[key...]</td>\n</tr>\n<tr>\n<td>Object.values</td>\n<td style=\"text-align:left\">遍历对象自身所有可枚举属性(不含 Symbol 属性)</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">[value...]</td>\n</tr>\n<tr>\n<td>Object.entries</td>\n<td style=\"text-align:left\">遍历对象自身所有可枚举属性(不含 Symbol 属性)</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">[[key,value]...]</td>\n</tr>\n</tbody>\n</table>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">遍历顺序</p>\n<p><code>ES5</code> 没有规定遍历顺序，其遍历顺序由浏览器厂商定义(可以简单理解为无序的)</p>\n<p><code>ES6</code> 之后规定遍历顺序将按如下规则进行</p>\n<ol>\n<li>首先遍历所有数值键，按照数值升序排列。</li>\n<li>其次遍历所有字符串键，按照加入时间升序排列。</li>\n<li>最后遍历所有 <code>Symbol</code> 键，按照加入时间升序排列。</li>\n</ol>\n<p><code>ES6</code> 内部定义了 <a href=\"https://262.ecma-international.org/11.0/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys\" target=\"_blank\" rel=\"noopener noreferrer\">[[OwnPropertyKeys]]()</a> 方法对属性进行分类和排序</p>\n</div>\n<h2> 运算符的扩展</h2>\n<h3> ?. 可选链操作符</h3>\n<p><a href=\"https://github.com/tc39/proposal-optional-chaining\" target=\"_blank\" rel=\"noopener noreferrer\">ES2020</a> 引入了可选链操作符(又名链判断运算符)，其允许我们在读取对象内部的某个属性时，不需要判断属性的上层对象是否存在</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可选链操作符 <code>?.</code> 的三种写法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">注意点</p>\n<ol>\n<li>可选链操作符相当于一种短路机制，只要不满足条件就不再往下执行</li>\n<li>当有括号时，可选链操作符对圆括号外部没有影响，只对圆括号内部有影响。</li>\n<li>右侧不得为十进制数值。为了保证兼容以前的代码，允许 <code>foo?.3:0</code> 会被解析成 <code>foo ? .3 : 0</code>，因此规定如果 <code>?.</code> 后面紧跟一个十进制数字，那么 <code>?.</code> 不再被看成是一个完整的运算符，而会按照三元运算符进行处理，即小数点会归属于后面的十进制数字形成一个小数。</li>\n<li>禁止使用以下写法</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></div>\n<h3> ?? 空值合并运算符</h3>\n<p><a href=\"https://github.com/tc39/proposal-nullish-coalescing\" target=\"_blank\" rel=\"noopener noreferrer\">ES2020</a>引入了空值合并运算符，只有运算符左侧的值为 <code>null</code> 或 <code>undefined</code> 时才会返回右侧的值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">?? 和 || 的区别</p>\n<ul>\n<li><strong><code>??</code> 运算符</strong>只有左侧是 <code>null</code> 或 <code>undefined</code>才会返回右侧的值</li>\n<li><strong><code>||</code> 运算符</strong>只要左侧是 <a href=\"/interview/base/conversions.html#toboolean\" target=\"blank\">假值</a> 就会返回右侧的值</li>\n</ul>\n</div>\n<h3> 逻辑赋值运算符</h3>\n<p><code>ES2021</code> 引了入三个新的逻辑赋值运算符，用于将逻辑运算符与赋值运算符进行结合</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> ESModule</h2>\n<p><code>ESModule</code> 是 <code>ES6</code> 在语言标准的层面上实现的模块功能，其设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系以及输入和输出的变量</p>\n<ul>\n<li><code>ESModule</code> 是编译时加载，使静态分析成为可能</li>\n<li>模块内部<strong>自动使用严格模式</strong></li>\n<li>模块中的<strong>顶层 <code>this</code> 指向 <code>undefined</code></strong></li>\n</ul>\n<h3> export 命令</h3>\n<p><code>export</code> 命令用于规定模块的对外接口</p>\n<ul>\n<li>一个模块就是一个独立的文件，该文件内部的所有变量外部无法获取，如果希望外部可以获取必须使用 <code>export</code> 关键字输出该变量</li>\n<li>通常情况下 <code>export</code> 输出的变量就是本来的名字，但可以使用 <code>as</code> 关键字重命名</li>\n<li><code>export</code> 命令规定的是对外的接口其必须与模块内部的变量建立一一对应关系</li>\n<li><code>export</code> 命令输出的接口与其对应的值是动态绑定关系(可以取到模块内部实时的值)</li>\n<li><code>export</code> 命令可以出现在模块的任何位置，只要处于<strong>模块顶层</strong>就可以(在块级作用域内使用会报错)</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> import 命令</h3>\n<p><code>import</code> 命令用于输入其他模块提供的功能(变量、函数、class 等)</p>\n<ul>\n<li><code>import</code> 命令<strong>输入的变量都是只读的</strong>(类似于常量，即基本类型不可重新赋值，引用类型可修改属性)</li>\n<li><code>import</code> 命令<strong>具有提升效果</strong>，会提升到整个模块的头部首先执行\n<ul>\n<li><code>import</code> 命令是编译阶段执行的</li>\n<li>不能使用表达式和变量</li>\n</ul>\n</li>\n<li>重复执行同一句 <code>import</code> 命令只会执行一次</li>\n<li><code>import</code> 后面的 <code>from</code> 指定模块文件的位置，其可以是相对路径，也可以是绝对路径</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> export default 命令</h3>\n<p><code>export default</code> 命令可以为模块指定默认输出</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">export default 命令注意点</p>\n<ul>\n<li>一个模块只能有一个默认输出(<code>export default</code> 命令只能使用一次)</li>\n<li><code>export default</code> 命令本质上是输出一个叫做 <code>default</code> 的变量或方法，使用时可以为它取任意名字</li>\n<li><code>export default</code> 命令后面不能跟变量声明语句</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></div>\n<h3> export 与 import 的复合写法</h3>\n<p>如果在一个模块之中，需要先输入后输出同一个模块，<code>import</code> 命令可以与 <code>export</code> 命令写在一起</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">注意点在 `export` 与 `import` 的复合写法时，输入的接口不能在当前模块中使用，只是相当于对外转发了接口 :::</p>\n<h3> import()</h3>\n<p><a href=\"https://github.com/tc39/proposal-dynamic-import\" target=\"_blank\" rel=\"noopener noreferrer\">ES2020</a> 引入 <code>import()</code> 函数支持动态加载模块</p>\n<ul>\n<li><code>import()</code> 函数可以用在任何地方，不仅仅是模块非模块的脚本也可以使用</li>\n<li><code>import()</code> 函数是运行时执行</li>\n<li><code>import()</code> 函数与所加载的模块没有静态连接关系</li>\n<li><code>import()</code> 函数类似于 <code>Node.js</code> 中的 <code>require()</code> 函数，区别主要是前者是异步加载后者是同步加载</li>\n<li><code>import()</code> 函数的返回值是 <code>Promise</code> 对象</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">import() 函数的使用场景</p>\n<ul>\n<li>按需加载</li>\n<li>条件加载</li>\n<li>动态的模块路径</li>\n</ul>\n</div>\n</div>\n<h3> 浏览器对 ESModule 的加载规则</h3>\n<p>浏览器加载 <code>ESModule</code> 同样使用 <code>&lt;script&gt;</code> 标签但是需要设置 <code>type=\"module</code>\" 属性<br> 浏览器对于带有 <code>type=\"module\"</code> 的 <code>&lt;script&gt;</code>都是异步加载，不会堵塞浏览器，即等到整个页面渲染完再执行模块脚本，等同于设置了 <code>&lt;script&gt;</code> 标签的 <code>defer</code> 属性<br> 有多个 <code>&lt;script type=\"module\"&gt;</code> 时会按照在页面出现的顺序依次执行</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当 <code>&lt;script&gt;</code> 同时设置了 <code>type=\"module\"</code> 和 <code>async</code> 属性时，只要加载完成渲染引擎就会中断渲染立即执行，等执行完成后再恢复渲染，即不会按照在页面出现的顺序执行，而是只要该模块加载完成就执行该模块</p>\n<h4> 在 script 中使用 ESModule</h4>\n<p><code>ESModule</code> 内嵌在网页中使用时语法行为与加载外部脚本完全一致，只需注意以下几点</p>\n<ul>\n<li>代码是在模块作用域之中运行而不是在全局作用域运行，模块内部的顶层变量外部不可见</li>\n<li>自动采用严格模式不管有没有声明 <code>use strict</code></li>\n<li>可以使用 <code>import</code> 命令加载其他模块(<code>.js</code> 后缀不可省略，需要提供绝对 <code>URL</code> 或相对 <code>URL</code>) 也可以使用 <code>export</code> 命令输出对外接口</li>\n<li>顶层的 <code>this</code> 关键字返回 <code>undefined</code> 而不是指向 <code>window</code></li>\n<li>同一个模块如果加载多次将只执行一次</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">小技巧利用顶层的 `this` 等于 `undefined` 这个语法点可以判断当前代码是否在 ES6 模块之中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div></div>\n<h2> Promise</h2>\n<p><code>Promise</code> 是异步编程的一种解决方案，比传统的解决方案(回调函数和事件)更合理和更强大</p>\n<p><code>Promise</code> 对象具有以下 <code>3</code> 种状态</p>\n<ul>\n<li><code>pending</code> 等待(初始)</li>\n<li><code>fulfilled</code> 成功</li>\n<li><code>rejected</code> 拒绝</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">Promise 的特点</p>\n<ul>\n<li><code>Promise</code> 对象的状态不受外界影响</li>\n<li>状态一旦改变就不会再变(不可逆)，任何时候都可以得到这个结果</li>\n<li>无法取消 <code>Promise</code>，一旦新建就会立即执行无法中途取消</li>\n<li>当处于 <code>pending</code> 状态时，无法得知目前进展到哪一个阶段(刚刚开始还是即将完成)</li>\n</ul>\n</div>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">实例方法</p>\n<ul>\n<li><code>Promise.prototype.then()</code> 用于实例添加状态改变时的回调函数(第一个参数是 <code>fulfilled</code> 状态的回调函数，第二个参数是 <code>rejected</code> 状态的回调函数)，会返回的是一个新的 <code>Promise</code> 实例</li>\n<li><code>Promise.prototype.catch()</code> 用于指定 <code>rejected</code> 状态的回调函数(是 <code>.then(null, rejection)</code> 或 <code>.then(undefined, rejection)</code> 的别名)</li>\n<li><code>Promise.prototype.finally()</code> (ES2018) 用于指定不管 <code>Promise</code> 对象最后状态如何都会执行的操作 (<code>finally</code> 本质上是 <code>then</code> 方法的特例)</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></div>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">静态方法</p>\n<ul>\n<li><code>Promise.resolve()</code>\n<ul>\n<li>将传入的参数转为 <code>Promise</code> 对象\n<ul>\n<li>参数是一个 <code>Promise</code> 实例则直接返回</li>\n<li>参数是一个 <code>thenable</code> 对象(具有 <code>then</code> 方法的对象) 转为 <code>Promise</code> 对象再立即执行 <code>thenable</code> 对象的 <code>then</code> 方法</li>\n<li>参数不是具有 <code>then</code> 方法的对象或根本就不是对象时返回一个 <code>fulfilled</code> 状态的新 <code>Promise</code> 对象</li>\n<li>没有参数时返回一个 <code>fulfilled</code> 状态的新 <code>Promise</code> 对象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>Promise.reject()</code>\n<ul>\n<li>返回一个 <code>rejected</code> 状态的新 <code>Promise</code> 对象</li>\n</ul>\n</li>\n<li><code>Promise.all()</code>\n<ul>\n<li>将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例，只有所有的 <code>Promise</code> 状态成功才会成功，如果其中一个 <code>Promise</code> 的状态失败就会失败</li>\n</ul>\n</li>\n<li><code>Promise.race()</code>\n<ul>\n<li>将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例，新的 <code>Promise</code> 实例状态会根据最先更改状态的参数实例而更改状态(可以轻松实现超时方法)</li>\n</ul>\n</li>\n<li><code>Promise.allSettled()</code> (ES2020)\n<ul>\n<li>将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例，新的 <code>Promise</code> 实例只有等到所有这些参数实例都返回结果，不管是 <code>fulfilled</code> 还是 <code>rejected</code> ，包装实例才会结束，一旦结束，状态总是 <code>fulfilled</code></li>\n</ul>\n</li>\n<li><code>Promise.any()</code> (ES2021)\n<ul>\n<li>将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例，只要参数实例有一个变成 <code>fulfilled</code> 状态，包装实例就会变成 <code>fulfilled</code> 状态；如果所有参数实例都变成 <code>rejected</code> 状态，包装实例才会变成 <code>rejected</code> 状态</li>\n</ul>\n</li>\n</ul>\n</div>\n",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "es6"
      ]
    },
    {
      "title": "Git",
      "url": "https://www.h7ml.cn/posts/git.html",
      "id": "https://www.h7ml.cn/posts/git.html",
      "summary": "Git 常用命令 初始化 git init 克隆项目 git clone",
      "content_html": "<h2> Git 常用命令</h2>\n<h3> 初始化</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 克隆项目</h2>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 长期保存密码</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 获取分支</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 合并分支</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 获取并且合并分支</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 切换分支</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 新建并切换到分支</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 删除分支</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 查看修改状态</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 查看所有的修改内容</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 查看指定文件修改内容</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 添加指定文件到暂存区</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 添加所有文件到暂存区</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 查看已经在提交区（即已经 add 了的）所有修改内容</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 提交暂存区修改到本地</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 修改刚才提交的描述</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 提交本地版本到远端</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 其他分支有紧急问题，需要马上切过去处理，但当前分支又只改了一半，又不想 commit</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 处理完其他分支的紧急问题以后，回到原先分支继续修改</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 清除所有没有 add 了的修改</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 清除指定没有 add 了的文件的修改</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 清除 untracked 的文件</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 清除 - <code>git ignore了的文件</code></h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> commit 了修改到本地，想放弃这个 commit</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> commit 了修改到本地，想放弃这个 commit，并清空修改</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> commit 了修改到本地，想恢复特定文件成指定的历史版本</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 打标签</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 删除标签</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 列出所有标签</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 推送特定标签到远端</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 推送所有标签到远端</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 删除远端 tag</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 查看当前的 Git 配置</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 设置使用 Git 时的用户名称</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 设置使用 Git 时的邮箱地址</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 新建一个空白分支</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 显示所有远程仓库</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 取回远程仓库的变化，并与本地分支合并</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 强行推送当前分支到远程仓库，忽略冲突</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 只暂存被追踪的文件</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 查看 stash 列表</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 取出最近一次的 stash</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 取出并删除最近一次的 stash</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 清空所有 stash</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 查看提交过的完整日志</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 查看所有分支的所有操作记录（包括被删除的 commit 记录和 reset 操作）</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 撤销 commit 操作</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 撤销 commit 和 add 操作</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 撤销 commit 和 add 操作同时撤销本地已追踪内容的修改</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 删除 Git 中的所有提交历史记录</h2>\n<h3> 1. 创建 orphan 分支</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 2. 添加需要上传文件</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 3. 提交更改</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 4. 删除需要清空提交记录的分支</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 5. 将当前分支重命名为需要清空提交记录的分支名</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 6. 强制更新存储库</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 同步 github fork 项目上游更新</h2>\n<h3> 1. 添加上游仓库</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 2. 拉取上游变动</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 3. 合并(以 master 位置为例)</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 4. 更新远程 fork 仓库分支(以 master 位置为例)</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 将代码提交到 github 的 gh-pages 分支</h2>\n<h3> 1. 安装 gh-pages</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 2. 在 package.json 中添加如下脚本</h2>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 3. 运行 deploy 脚本</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> git log 格式化</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>relative: 相对时间格式</li>\n<li>local: 本地格式</li>\n<li>iso OR iso8601: ISO8601 格式</li>\n<li>rfc: RFC2822 格式</li>\n<li>short: YYYY-MM-DD 格式</li>\n<li>raw: 时间戳格式</li>\n<li>default: 默认格式</li>\n</ul>\n<h2> 自定义输出格式</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>%C(颜色值): 修改输出颜色</li>\n<li>%H: 完整的 commit hash</li>\n<li>%h: 缩写的 commit hash</li>\n<li>%ad: 提交时间(绝对时间 可以使用 -date= 定制格式)</li>\n<li>%ar: 提交时间(相对时间 按多久之前显示)</li>\n<li>%s: commit message</li>\n<li>%d: branch tag 信息</li>\n<li>%an: 作者名称</li>\n<li>%ae: 作者的邮箱地址</li>\n</ul>\n<h2> git 撤销</h2>\n<h3> 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 重置暂存区与工作区，与上一次 commit 保持一致</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 新建一个 commit，用来撤销指定 commit 后者的所有变化都将被前者抵消，并且应用到当前分支</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 暂存操作</h2>\n<h3> 只暂存被追踪的文件</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 暂存所有文件并添加说明</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 查看 stash 列表</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 取出最近一次的 stash</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 取出 stash 列表里对应数字的暂存</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 取出并删除最近一次的 stash</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 清空所有 stash</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "git"
      ]
    },
    {
      "title": "如何编写 JavaScript 引擎？",
      "url": "https://www.h7ml.cn/posts/js-engine.html",
      "id": "https://www.h7ml.cn/posts/js-engine.html",
      "summary": "前端物语|如何编写JavaScript引擎？",
      "content_html": "<h1> 如何编写 JavaScript 引擎？</h1>\n<p>JavaScript 引擎是解释和执行 JavaScript 代码的核心组件。</p>\n<h2> 词法分析器</h2>\n<p>词法分析器是编译器中的一个重要组成部分，其作用是将源程序中的字符流转换为词法单元流，以便后续的语法分析。设计词法分析器的基本步骤如下：</p>\n<ol>\n<li>确定词法单元的类型和模式词法单元是源程序中的最小语法单位，例如标识符、关键字、常量、运算符等。在设计词法分析器时，需要确定每种词法单元的类型和对应的正则表达式模式，以便识别源程序中的词法单元。</li>\n</ol>\n<p>例如，对于一个简单的算术表达式语言，可以定义如下的词法单元类型和模式：</p>\n<ul>\n<li>标识符：以字母或下划线开头，后跟任意个字母、数字或下划线。</li>\n<li>数字常量：一个或多个数字组成的字符串。</li>\n<li>运算符：加号、减号、乘号、除号等。</li>\n<li>左右括号：左括号、右括号。</li>\n</ul>\n<ol start=\"2\">\n<li>编写正则表达式模式确定词法单元类型和模式后，需要编写对应的正则表达式模式，以便识别源程序中的词法单元。正则表达式是一种描述字符串模式的语言，可以用来匹配符合某种模式的字符串。</li>\n</ol>\n<p>例如，对于标识符，可以使用正则表达式[a-zA-Z_][a-zA-Z0-9_]*来匹配以字母或下划线开头、后跟任意个字母、数字或下划线的字符串。</p>\n<ol start=\"3\">\n<li>实现词法分析器在实现词法分析器时，可以使用自动机或递归下降分析等算法，对源程序进行扫描和识别。具体实现方式可以参考以下步骤：</li>\n</ol>\n<ul>\n<li>读入源程序字符流，逐个字符进行扫描。</li>\n<li>对每个字符进行分类，判断其属于哪种词法单元。</li>\n<li>根据词法单元类型和模式，使用正则表达式进行匹配。</li>\n<li>如果匹配成功，则生成对应的词法单元，并将其加入词法单元流中；否则，报告词法错误。</li>\n</ul>\n<ol start=\"4\">\n<li>输出词法单元流在词法分析器完成扫描和识别后，需要将生成的词法单元流输出给后续的语法分析器。词法单元流可以使用链表、数组等数据结构来表示。</li>\n</ol>\n<p>例如，对于一个简单的算术表达式语言，源程序\"1+2*(3-4)\"的词法单元流可以表示为：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数字常量</td>\n<td>1</td>\n</tr>\n<tr>\n<td>运算符</td>\n<td>+</td>\n</tr>\n<tr>\n<td>数字常量</td>\n<td>2</td>\n</tr>\n<tr>\n<td>运算符</td>\n<td>*</td>\n</tr>\n<tr>\n<td>左括号</td>\n<td>(</td>\n</tr>\n<tr>\n<td>数字常量</td>\n<td>3</td>\n</tr>\n<tr>\n<td>运算符</td>\n<td>-</td>\n</tr>\n<tr>\n<td>数字常量</td>\n<td>4</td>\n</tr>\n<tr>\n<td>右括号</td>\n<td>)</td>\n</tr>\n</tbody>\n</table>\n<h2> 设计词法分析器</h2>\n<p>词法分析器是编译器的一个重要组成部分，用于将源代码转换成标记流（Token Stream）。下面是一个简单的词法分析器的设计：</p>\n<ol>\n<li>定义 Token 类，用于表示标记。Token 类应该包含以下属性：</li>\n</ol>\n<ul>\n<li>type：标记类型，例如关键字、标识符、运算符等。</li>\n<li>value：标记的值，例如标识符的名称、数字的值等。</li>\n<li>line：标记所在的行号。</li>\n</ul>\n<ol start=\"2\">\n<li>定义词法分析器类，用于将源代码转换成标记流。词法分析器类应该包含以下方法：</li>\n</ol>\n<ul>\n<li>getNextToken()：从源代码中读取下一个标记，并返回一个 Token 对象。</li>\n<li>tokenize()：将整个源代码转换成标记流。</li>\n</ul>\n<ol start=\"3\">\n<li>在 getNextToken()方法中，可以按照以下步骤进行：</li>\n</ol>\n<ul>\n<li>跳过空格、制表符、换行符等空白字符。</li>\n<li>判断当前字符是否为数字，如果是数字则读取整个数字，并返回一个数字类型的 Token 对象。</li>\n<li>判断当前字符是否为字母，如果是字母则读取整个标识符，并判断是否为关键字，如果是则返回一个关键字类型的 Token 对象，否则返回一个标识符类型的 Token 对象。</li>\n<li>判断当前字符是否为运算符，如果是则返回一个运算符类型的 Token 对象。</li>\n<li>如果当前字符不是数字、字母或运算符，则返回一个未知类型的 Token 对象。</li>\n</ul>\n<ol start=\"4\">\n<li>在 tokenize()方法中，可以按照以下步骤进行：</li>\n</ol>\n<ul>\n<li>读取整个源代码。</li>\n<li>循环调用 getNextToken()方法，直到读取完所有的标记。</li>\n<li>返回一个包含所有 Token 对象的数组。</li>\n</ul>\n<h2> 设计语法分析器</h2>\n<p>语法分析器是编译器的另一个重要组成部分，用于将标记流转换成抽象语法树（Abstract Syntax Tree，AST）。下面是一个简单的语法分析器的设计：</p>\n<ol>\n<li>定义 AST 节点类，用于表示抽象语法树的节点。AST 节点类应该包含以下属性：</li>\n</ol>\n<ul>\n<li>type：节点类型，例如表达式、语句、变量声明等。</li>\n<li>value：节点的值，例如变量名、常量值等。</li>\n<li>children：子节点列表，用于表示节点的子节点。</li>\n</ul>\n<ol start=\"2\">\n<li>定义语法分析器类，用于将标记流转换成抽象语法树。语法分析器类应该包含以下方法：</li>\n</ol>\n<ul>\n<li>parse()：解析标记流，并返回一个 AST 根节点。</li>\n<li>在 parse()方法中，可以按照以下步骤进行：</li>\n</ul>\n<ol start=\"3\">\n<li>读取标记流中的第一个标记，并根据标记的类型创建一个根节点。</li>\n</ol>\n<ul>\n<li>根据语法规则，递归调用子节点的解析方法，创建子节点，并将子节点添加到根节点的子节点列表中。</li>\n<li>如果当前标记不符合语法规则，则抛出语法错误异常。</li>\n<li>重复步骤 2 和 3，直到解析完整个标记流。</li>\n</ul>\n<ol start=\"4\">\n<li>在 AST 节点类中，可以定义一些辅助方法，例如：</li>\n</ol>\n<ul>\n<li>isLeaf()：判断当前节点是否为叶子节点。</li>\n<li>getChildren()：返回当前节点的子节点列表。</li>\n<li>getType()：返回当前节点的类型。</li>\n<li>getValue()：返回当前节点的值。以上是一个简单的语法分析器的设计，实际上还需要考虑很多细节，例如处理优先级、左结合性、右结合性等特殊情况。</li>\n</ul>\n<h2> 实现 JavaScript 运行时</h2>\n<p>实现 JavaScript 运行时需要实现以下几个部分：</p>\n<ol>\n<li>\n<p>词法分析器：读取 JavaScript 代码并将其转换成标记流（Token Stream）。</p>\n</li>\n<li>\n<p>语法分析器：将标记流转换成抽象语法树（Abstract Syntax Tree，AST）。</p>\n</li>\n<li>\n<p>执行引擎：遍历抽象语法树，并执行其中的代码。</p>\n</li>\n<li>\n<p>内置对象和函数：实现 JavaScript 的内置对象和函数，例如 Object、Array、Function 等。</p>\n<p>下面是一个简单的 JavaScript 运行时的实现：</p>\n<ol>\n<li>\n<p>词法分析器：使用正则表达式匹配 JavaScript 代码中的标记，并返回一个标记流（Token Stream）。</p>\n</li>\n<li>\n<p>语法分析器：使用递归下降算法（Recursive Descent Parsing）将标记流转换成抽象语法树（Abstract Syntax Tree，AST）。</p>\n</li>\n<li>\n<p>执行引擎：遍历抽象语法树，并执行其中的代码。</p>\n</li>\n</ol>\n<ul>\n<li>对于变量声明语句，创建一个变量并赋初值，将变量存入当前作用域中。</li>\n<li>对于赋值语句，找到变量，并将其值赋为表达式的值。</li>\n<li>对于表达式语句，计算表达式的值并忽略结果。</li>\n<li>对于条件语句（if 语句），根据条件表达式的值判断执行哪个分支。</li>\n<li>对于循环语句（for、while 语句），根据条件表达式的值判断是否执行循环体。</li>\n<li>对于函数声明语句，创建一个函数对象并将其存入当前作用域中。</li>\n<li>对于函数调用表达式，找到函数，并执行函数体。</li>\n<li>对于对象属性访问表达式，找到对象并获取属性值。</li>\n<li>对于数组元素访问表达式，找到数组并获取元素值。</li>\n</ul>\n<ol start=\"4\">\n<li>内置对象和函数：实现 JavaScript 的内置对象和函数，例如 Object、Array、Function 等。可以使用 JavaScript 语言本身来实现这些内置对象和函数。</li>\n</ol>\n</li>\n</ol>\n<p>以上是一个简单的 JavaScript 运行时的实现，实际上还需要考虑很多细节，例如作用域、闭包、类型转换等特殊情况。</p>\n<h2> 实现 JavaScript 解释器</h2>\n<p>JavaScript 解释器的设计应该包括以下几个部分：</p>\n<h3> 词法分析器：将 JavaScript 代码转换为标记流</h3>\n<p>词法分析（Lexical Analysis）：将代码分解成单个的词法单元（tokens），例如关键字、标识符、运算符等。这可以通过正则表达式或手写解析器实现</p>\n<h3> 语法分析器：将标记流转换为语法树</h3>\n<p>语法分析（Parsing）：将词法单元转换成语法树（Abstract Syntax Tree，AST），并检查语法错误。这可以通过手写递归下降解析器、LL 或 LR 分析器等实现。</p>\n<h3> 语义分析器：对语法树进行语义分析</h3>\n<p>语义分析（Semantic Analysis）：对 AST 进行语义分析，检查类型、作用域、函数调用等。这可以通过遍历 AST 并应用静态或动态分析算法实现。</p>\n<h3> 执行器：执行语法树并输出结果</h3>\n<p>将 AST 转换成可执行的机器代码或字节码。这可以通过直接解释、编译成本地代码或编译成中间代码并交给虚拟机执行等方式实现。</p>\n<details class=\"hint-container details\"><summary>点击查看 JavaScript 解释器的实现</summary>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></details>\n<h2> 实现 JavaScript 编译器</h2>\n<h3> 词法编译器（Lexical Analyzer）</h3>\n<p>词法编译器（Lexical Analyzer）也被称为词法分析器（Lexer），是编译器中的一个组件，用于将源代码转换为令牌（Token）序列。令牌是编程语言中的基本单元，它们由词素（Lexeme）和令牌类型（Token Type）组成。</p>\n<p>词法编译器通常由两个主要部分组成：令牌定义和扫描器。令牌定义是一组正则表达式，用于描述编程语言中的各种令牌类型。扫描器则根据这些正则表达式，对源代码进行扫描，并将其转换为令牌序列。</p>\n<details class=\"hint-container details\"><summary>点击查看词法编译器的实现</summary>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></details>\n<p>定义了一组令牌类型，包括标识符、数字、运算符、标点符号和关键字。然后，我们使用正则表达式和数组常量来定义这些令牌类型的规则。</p>\n<p>tokenize 函数中，遍历源代码中的每个字符，并根据其类型生成相应的令牌。例如，如果字符是数字，则我们将其解析为数字令牌，并将其添加到令牌序列中。</p>\n<h3> 代码生成器：将语法树转换为可执行的机器代码</h3>\n<p>代码生成器（Code Generator）是编译器中的一个组件，用于将抽象语法树（AST）转换为目标代码，例如机器代码、字节码或其他编程语言的代码。</p>\n<p>代码生成器通常由两个主要部分组成：代码生成规则和代码生成器。代码生成规则是一组规则，用于描述如何将 AST 节点转换为目标代码。代码生成器则根据这些规则，对 AST 节点进行遍历，并将其转换为目标代码。</p>\n<details class=\"hint-container details\"><summary>点击查看代码生成器的实现</summary>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></details>\n<h3> 执行器：执行机器代码并输出结果</h3>\n<p>执行器（Executor）是编译器中的一个组件，用于执行目标代码，例如机器代码或字节码，并输出结果。执行器通常由两个主要部分组成：解释器和虚拟机。</p>\n<p>解释器是一种直接执行目标代码的方法，它将目标代码逐条解释并执行。虚拟机是一种模拟计算机硬件的方法，它将目标代码转换为一组指令，并在虚拟计算机上执行这些指令。</p>\n<details class=\"hint-container details\"><summary>点击查看 JavaScript 编译器的实现</summary>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></details>\n<p>在这个例子中，我们定义了一个 execute 函数，它接受一个 JavaScript 源代码字符串作为输入，并将其编译为目标代码，然后使用虚拟机执行目标代码，并输出结果。</p>\n<p>在 createVM 函数中，我们定义了一组虚拟机指令，包括 LOAD（将常量加载到栈中）、ADD（将栈顶两个值相加）、SUB（将栈顶两个值相减）、MUL（将栈顶两个值相乘）、DIV（将栈顶两个值相除）和 PRINT（打印栈顶的值）。然后，我们使用一个简单的栈来模拟虚拟机的堆栈，并在 run 函数中执行指令序列。</p>\n<p>在 execute 函数中，我们首先将源代码编译为目标代码，然后将其解析为指令序列，并使用 createVM 函数创建一个虚拟机。最后，我们调用虚拟机的 run 函数，执行指令序列，并输出结果。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-10-07T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "engine",
        "javascript"
      ]
    },
    {
      "title": "模块化",
      "url": "https://www.h7ml.cn/posts/module.html",
      "id": "https://www.h7ml.cn/posts/module.html",
      "summary": "什么是模块化？ 百度百科中的解释: 模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性。 在编程中 模块化是将一个复杂的应用程序，按照一定的规则拆分成若干个文件(代码块)，并进行组合。文件内部的数据与实现都是私有的，只是对外暴露一些接口(方法、变量)与其他模块进行通信 模块化的好处 避免命名空间的冲突 提高代码的复用性 提高维护性 更好的分离，实现按需加载",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">什么是模块化？</p>\n<p>百度百科中的解释: 模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性。</p>\n<p>在编程中 模块化是将一个复杂的应用程序，按照一定的规则拆分成若干个文件(代码块)，并进行组合。文件内部的数据与实现都是私有的，只是对外暴露一些接口(方法、变量)与其他模块进行通信</p>\n</div>\n<p>模块化的好处</p>\n<ul>\n<li>避免命名空间的冲突</li>\n<li>提高代码的复用性</li>\n<li>提高维护性</li>\n<li>更好的分离，实现按需加载</li>\n</ul>\n<p>目前前端主流的模块规范是</p>\n<ul>\n<li><code>CommonJS</code></li>\n<li><code>ESModule</code></li>\n<li><code>AMD</code></li>\n<li><code>CMD</code></li>\n<li><code>UMD</code></li>\n</ul>\n<h2> CommonJS</h2>\n<p><a href=\"https://www.commonjs.org/\" target=\"_blank\" rel=\"noopener noreferrer\"><code>CommonJS</code></a> 规范是一种同步加载模块的方式，其主要用于服务端，即 <code>Node</code> 中的</p>\n<ul>\n<li><code>module.exports</code> 用于规定当前模块对外输出的接口</li>\n<li><code>exports</code> 是 <code>module.exports</code> 属性的引用</li>\n<li><code>require</code> 用于加载模块文件(读入并执行一个 <code>JavaScript</code> 文件并返回该模块的 <code>exports</code> 对象)</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">exports 和 module.exports</p>\n<ul>\n<li><code>exports</code> 是 <code>module</code> 对象的一个属性</li>\n<li><code>exports</code> 是 <code>module.exports</code> 的一个引用，在默认情况下 <code>module.exports</code> 和 <code>exports</code> 指向<strong>同一个空对象</strong></li>\n<li>模块导出的是 <code>module.exports</code></li>\n</ul>\n</div>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">CommonJS 模块的特点</p>\n<ul>\n<li>所有代码都运行在模块作用域，不会污染全局作用域</li>\n<li>模块可以多次加载，但只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载时就直接读取缓存结果。要想让模块再次运行必须清除缓存</li>\n<li>模块加载的顺序按其在代码中出现的顺序</li>\n</ul>\n</div>\n<h2> ESModule</h2>\n<p><code>ESModule</code> 是 <code>ES6</code> 在语言标准的层面上实现的模块功能，主要由 <code>export</code> 和 <code>import</code> 构成</p>\n<ul>\n<li><code>export</code> 命令用于规定模块的对外接口</li>\n<li><code>import</code> 命令用于输入其他模块提供的功能</li>\n</ul>\n<p><a href=\"/interview/es6/#esmodule\" target=\"blank\">ES6 常用知识 —— ESModule</a></p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">ESModule 与 CommonJS 的差异</p>\n<ul>\n<li><code>CommonJS</code> 是动态语法可以写在判断里；<code>ESModule</code> 静态语法只能写在顶层</li>\n<li><code>CommonJS</code> 模块输出的是一个值的拷贝；<code>ESModule</code> 输出的是值的引用\n<ul>\n<li><code>CommonJS</code> 模块一旦输出一个值模块内部的变化就影响不到这个值</li>\n<li><code>ESModule</code> 模块在 <code>JavaScript</code> 引擎对脚本静态分析时，遇到模块加载命令 <code>import</code>，就会生成一个只读引用，等到脚本真正执行时再根据这个只读引用到被加载的那个模块里面去取值(<code>ESModule</code> 是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块)</li>\n</ul>\n</li>\n<li><code>CommonJS</code> 模块是运行时加载；<code>ESModule</code> 是编译时输出接口。\n<ul>\n<li><code>CommonJS</code> 加载的是一个对象（即 <code>module.exports</code> 属性），该对象只有在脚本运行完才会生成</li>\n<li><code>ESModule</code> 不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</li>\n</ul>\n</li>\n<li><code>CommonJS</code> 模块的 <code>require()</code> 是同步加载模块；<code>ESModule</code> 的 <code>import</code> 命令是异步加载，有一个独立的模块依赖的解析阶段。</li>\n<li>顶层的 <code>this</code> 指向不同\n<ul>\n<li><code>CommonJS</code> 模块中的顶层 <code>this</code> 指向模块本身</li>\n<li><code>ESModule</code> 模块中的顶层 <code>this</code> 指向 <code>undefined</code></li>\n</ul>\n</li>\n<li>模块的循环加载\n<ul>\n<li><code>CommonJS</code> 模块在加载模块后就会执行整个脚本并在内存生成一个对象，当出现某个模块被\"循环加载\"，就只输出已经执行的部分，还未执行的部分不会输出</li>\n<li><code>ESModule</code> 根本不会关心是否发生了\"循环加载\"，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</li>\n</ul>\n</li>\n</ul>\n</div>\n<h2> AMD</h2>\n<p><code>AMD</code> 规范全称是 Asynchronous Module Definition，即异步模块定义，主要用于浏览器。<br> <code>AMD</code> 规范完整描述了模块的定义、依赖关系、引用关系以及加载机制。其代表库是 <a href=\"https://requirejs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">RequireJS</a></p>\n<h3> 相关 api 及使用</h3>\n<ul>\n<li><code>define()</code>: 定义模块</li>\n<li><code>require()</code>: 调用模块</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> CMD</h2>\n<p><code>CMD</code> 规范全称是 Common Module Definition，即通用模块定义，其代表库是 <a href=\"https://seajs.github.io/seajs/docs/\" target=\"_blank\" rel=\"noopener noreferrer\">SeaJS</a></p>\n<blockquote>\n<p><code>CMD</code> 规范是在 <code>AMD</code> 规范的基础上改进的一种规范，其解决了 <code>AMD</code> 规范对依赖模块的执行时机的问题</p>\n</blockquote>\n<h3> 相关 api 及使用</h3>\n<ul>\n<li><code>define()</code>: 定义模块</li>\n<li><code>seajs.use()</code>: 调用模块</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">AMD 和 CMD 的区别</p>\n<ul>\n<li><code>AMD</code>\n<ul>\n<li>依赖前置: 在定义模块的时需要声明其依赖的模块</li>\n<li>在加载模块完成后就会执行该模块，当所有模块都加载执行完后会进入 require 的回调函数执行主逻辑</li>\n</ul>\n</li>\n<li><code>CMD</code>\n<ul>\n<li>就近依赖: 只有当用到某个具体模块时再去加载</li>\n<li>加载完某个依赖模块后并不执行，当所有依赖模块加载完成后进入主逻辑，遇到 require 语句的时候才执行对应的模块</li>\n</ul>\n</li>\n</ul>\n<p>两者最大的区别是对依赖模块的执行时机处理不同</p>\n</div>\n<h2> UMD</h2>\n<p><code>UMD</code> 只是一种通用的写法，是为了解决当时存在多种流行而不统一的规范而产生的一种通用规范<br> <code>UMD</code> 实际是 <strong><code>AMD + CommonJS + 全局变量</code></strong> 这三种规范的结合</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 相关文章</h2>\n<p><a href=\"https://segmentfault.com/a/1190000017878394\" target=\"_blank\" rel=\"noopener noreferrer\">深入 CommonJs 与 ES6 Module</a></p>\n",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "es6"
      ]
    },
    {
      "title": "python",
      "url": "https://www.h7ml.cn/posts/Python/",
      "id": "https://www.h7ml.cn/posts/Python/",
      "summary": "Xpath Scrapy selenium urllib",
      "content_html": "<ul>\n<li>\n<p><a href=\"/posts/Python/Xpath.html\" target=\"blank\">Xpath</a></p>\n</li>\n<li>\n<p><a href=\"/posts/Python/scrapy.html\" target=\"blank\">Scrapy</a></p>\n</li>\n<li>\n<p><a href=\"/posts/Python/selenium.html\" target=\"blank\">selenium</a></p>\n</li>\n<li>\n<p><a href=\"/posts/Python/urllib.html\" target=\"blank\">urllib</a></p>\n</li>\n</ul>\n",
      "date_published": "2022-04-18T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "python"
      ]
    },
    {
      "title": "XPath",
      "url": "https://www.h7ml.cn/posts/Python/Xpath.html",
      "id": "https://www.h7ml.cn/posts/Python/Xpath.html",
      "summary": "XPath 语法 XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。 菜鸟教程 open in new window XML 实例文档 我们将在下面的例子中使用这个 XML 文档。 实例 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;bookstore&gt; &lt;book&gt; &lt;title lang=\"eng\"&gt;Harry Potter&lt;/title&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book&gt; &lt;title lang=\"eng\"&gt;Learning XML&lt;/title&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt; &lt;/bookstore&gt;",
      "content_html": "<h2> XPath 语法</h2>\n<hr>\n<p>XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。</p>\n<hr>\n<p><a href=\"https://www.runoob.com/xpath/xpath-syntax.html\" target=\"_blank\" rel=\"noopener noreferrer\">菜鸟教程 open in new window</a></p>\n<h2> XML 实例文档</h2>\n<p>我们将在下面的例子中使用这个 XML 文档。</p>\n<h2> 实例</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 选取节点</h2>\n<p>XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。 下面列出了最有用的路径表达式：</p>\n<table>\n<thead>\n<tr>\n<th>表达式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>nodename</code></td>\n<td>选取此节点的所有子节点。</td>\n</tr>\n<tr>\n<td><code>/</code></td>\n<td>从根节点选取（取子节点）。</td>\n</tr>\n<tr>\n<td><code>//</code></td>\n<td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置（取子孙节点）。</td>\n</tr>\n<tr>\n<td><code>.</code></td>\n<td>选取当前节点。</td>\n</tr>\n<tr>\n<td><code>..</code></td>\n<td>选取当前节点的父节点。</td>\n</tr>\n<tr>\n<td><code>@</code></td>\n<td>选取属性。</td>\n</tr>\n</tbody>\n</table>\n<p>在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：</p>\n<table>\n<thead>\n<tr>\n<th>路径表达式</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>bookstore</code></td>\n<td>选取 bookstore 元素的所有子节点。</td>\n</tr>\n<tr>\n<td><code>/bookstore</code></td>\n<td>选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</td>\n</tr>\n<tr>\n<td><code>bookstore/book</code></td>\n<td>选取属于 bookstore 的子元素的所有 book 元素。</td>\n</tr>\n<tr>\n<td><code>//book</code></td>\n<td>选取所有 book 子元素，而不管它们在文档中的位置。</td>\n</tr>\n<tr>\n<td><code>bookstore//book</code></td>\n<td>选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td>\n</tr>\n<tr>\n<td><code>//@lang</code></td>\n<td>选取名为 lang 的所有属性。</td>\n</tr>\n</tbody>\n</table>\n<h2> 谓语（Predicates）</h2>\n<p>谓语用来查找某个特定的节点或者包含某个指定的值的节点。</p>\n<p>谓语被嵌在方括号中。</p>\n<p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p>\n<table>\n<thead>\n<tr>\n<th>路径表达式</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>/bookstore/book[1]</code></td>\n<td>选取属于 bookstore 子元素的第一个 book 元素。</td>\n</tr>\n<tr>\n<td><code>/bookstore/book[last()]</code></td>\n<td>选取属于 bookstore 子元素的最后一个 book 元素。</td>\n</tr>\n<tr>\n<td><code>/bookstore/book[last()-1]</code></td>\n<td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td>\n</tr>\n<tr>\n<td><code>/bookstore/book[position()&lt;3]</code></td>\n<td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td>\n</tr>\n<tr>\n<td><code>//title[@lang]</code></td>\n<td>选取所有拥有名为 lang 的属性的 title 元素。</td>\n</tr>\n<tr>\n<td><code>//title[@lang='eng']</code></td>\n<td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td>\n</tr>\n<tr>\n<td><code>/bookstore/book[price&gt;35.00]</code></td>\n<td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td>\n</tr>\n<tr>\n<td><code>/bookstore/book[price&gt;35.00]//title</code></td>\n<td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td>\n</tr>\n</tbody>\n</table>\n<h2> 选取未知节点</h2>\n<p>XPath 通配符可用来选取未知的 XML 元素。</p>\n<table>\n<thead>\n<tr>\n<th>通配符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>*</code></td>\n<td>匹配任何元素节点。</td>\n</tr>\n<tr>\n<td><code>@*</code></td>\n<td>匹配任何属性节点。</td>\n</tr>\n<tr>\n<td><code>node()</code></td>\n<td>匹配任何类型的节点。</td>\n</tr>\n</tbody>\n</table>\n<p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>\n<table>\n<thead>\n<tr>\n<th>路径表达式</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>/bookstore/*</code></td>\n<td>选取 bookstore 元素的所有子元素。</td>\n</tr>\n<tr>\n<td><code>//*</code></td>\n<td>选取文档中的所有元素。</td>\n</tr>\n<tr>\n<td><code>//title[@*]</code></td>\n<td>选取所有带有属性的 title 元素。</td>\n</tr>\n</tbody>\n</table>\n<h2> 选取若干路径</h2>\n<p>通过在路径表达式中使用\"|\"运算符，您可以选取若干个路径。</p>\n<p>在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p>\n<p>| 路径表达式              | 结果           |<br>\n| ----------------------- | -------------- | ----------------------------------------------------------------------------------- |<br>\n| <code>//book/title</code>          | <code>//book/price</code> | 选取 book 元素的所有 title 和 price 元素。                                          |<br>\n| <code>//title</code>               | <code>//price</code>      | 选取文档中的所有 title 和 price 元素。                                              |<br>\n| <code>/bookstore/book/title</code> | <code>//price</code>      | 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。 |</p>\n<h2> XPath 轴（Axes）</h2>\n<p>轴可定义相对于当前节点的节点集。</p>\n<table>\n<thead>\n<tr>\n<th>轴名称</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ancestor</code></td>\n<td>选取当前节点的所有先辈（父、祖父等）。</td>\n</tr>\n<tr>\n<td><code>ancestor-or-self</code></td>\n<td>选取当前节点的所有先辈（父、祖父等）以及当前节点本身。</td>\n</tr>\n<tr>\n<td><code>attribute</code></td>\n<td>选取当前节点的所有属性。</td>\n</tr>\n<tr>\n<td><code>child</code></td>\n<td>选取当前节点的所有子元素。</td>\n</tr>\n<tr>\n<td><code>descendant</code></td>\n<td>选取当前节点的所有后代元素（子、孙等）。</td>\n</tr>\n<tr>\n<td><code>descendant-or-self</code></td>\n<td>选取当前节点的所有后代元素（子、孙等）以及当前节点本身。</td>\n</tr>\n<tr>\n<td><code>following</code></td>\n<td>选取文档中当前节点的结束标签之后的所有节点。</td>\n</tr>\n<tr>\n<td><code>following-sibling</code></td>\n<td>选取当前节点之后的所有兄弟节点</td>\n</tr>\n<tr>\n<td><code>namespace</code></td>\n<td>选取当前节点的所有命名空间节点。</td>\n</tr>\n<tr>\n<td><code>parent</code></td>\n<td>选取当前节点的父节点。</td>\n</tr>\n<tr>\n<td><code>preceding</code></td>\n<td>选取文档中当前节点的开始标签之前的所有节点。</td>\n</tr>\n<tr>\n<td><code>preceding-sibling</code></td>\n<td>选取当前节点之前的所有同级节点。</td>\n</tr>\n<tr>\n<td><code>self</code></td>\n<td>选取当前节点。</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2022-05-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "python"
      ]
    },
    {
      "title": "Scrapy",
      "url": "https://www.h7ml.cn/posts/Python/scrapy.html",
      "id": "https://www.h7ml.cn/posts/Python/scrapy.html",
      "summary": "Scrapy 安装 Windows 安装方式 升级 pip 版本： pip install --upgrade pip",
      "content_html": "<h2> Scrapy</h2>\n<h2> 安装</h2>\n<h3> Windows 安装方式</h3>\n<p>升级 pip 版本：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>通过 pip 安装 Scrapy 框架:</p>\n<h3> Ubuntu 安装方式</h3>\n<p>安装非 Python 的依赖:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>通过 pip 安装 Scrapy 框架：</p>\n<h3> Mac OS 安装方式</h3>\n<p>pip 版本必须转 22+，升级 pip 版本</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>使用清华源下载</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><blockquote>\n<p>注意：在 mac 中使用 scrapy 指令必须在前面加上 python3 -m</p>\n</blockquote>\n<h2> 新建项目</h2>\n<p>在开始爬取之前，必须创建一个新的 Scrapy 项目。进入自定义的项目目录中，运行下列命令：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>其中， mySpider 为项目名称，可以看到将会创建一个 mySpider 文件夹，目录结构大致如下：</p>\n<p>下面来简单介绍一下各个主要文件的作用：</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这些文件分别是:</p>\n<ul>\n<li>scrapy.cfg: 项目的配置文件。</li>\n<li>mySpider/: 项目的 Python 模块，将会从这里引用代码。</li>\n<li>mySpider/items.py: 项目的目标文件。</li>\n<li>mySpider/pipelines.py: 项目的管道文件。</li>\n<li>mySpider/settings.py: 项目的设置文件。</li>\n<li>mySpider/spiders/: 存储爬虫代码目录。</li>\n</ul>\n<h3> 创建爬虫文件</h3>\n<p>1、cd 进入 <code>spiders</code> 文件夹中</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>2、创建爬虫文件</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>3、<code>test.py</code></p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 运行爬虫代码</h3>\n<blockquote>\n<p>注意：有的网站会有 robots 协议，这是一个君子协议，scrapy 默认是启动遵守的，如果想要爬取需要关闭</p>\n</blockquote>\n<p>在<code>settings.py</code>文件中</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 语法</h2>\n<h3> response 对象</h3>\n<p><strong>解析数据返回的对象</strong></p>\n<ul>\n<li>\n<p><code>response.body</code> ：响应返回页面已二进制格式的内容</p>\n</li>\n<li>\n<p><code>response.text</code> ：响应返回页面已字符串格式的内容</p>\n</li>\n<li>\n<p><code>response.url</code> ：响应返回页面 url</p>\n</li>\n<li>\n<p><code>response.status</code> ：响应返回 ajax 请求状态码</p>\n</li>\n<li>\n<p><code>response.xpath()</code>：（常用） 使用 xpath 路径查询特定元素，返回一个<code>selector</code>列表对象</p>\n</li>\n<li>\n<p><code>response.css()</code>：使用<code>css_selector</code>查询元素，返回一个<code>selector</code>列表对象</p>\n<ul>\n<li>获取内容 ：<code>response.css('#su::text').extract_first()</code></li>\n<li>获取属性 ：<code>response.css('#su::attr(“value”)').extract_first()</code></li>\n</ul>\n</li>\n</ul>\n<h3> selector 对象</h3>\n<blockquote>\n<p>通过<code>xpath</code>方法调用返回的是<code>seletor</code>列表</p>\n</blockquote>\n<h4> extract()</h4>\n<ul>\n<li>提取<code>selector</code>对象的值</li>\n<li>如果提取不到值，那么会报错</li>\n<li>使用 xpath 请求到的对象是一个<code>selector</code>对象，需要进一步使用<code>extract()</code>方法拆 包，转换为<code>unicode</code>字符串</li>\n</ul>\n<h4> extract_first()</h4>\n<ul>\n<li>提取<code>seletor</code>列表中的第一个值</li>\n<li>如果提取不到值，会返回一个空值</li>\n<li>返回第一个解析到的值，如果列表为空，此种方法也不会报错，会返回一个空值 <code>xpath() css()</code></li>\n</ul>\n<blockquote>\n<p>注意：每一个<code>selector</code>对象可以再次的去使用<code>xpath</code>或者<code>css</code>方法</p>\n</blockquote>\n<h2> 使用管道封装</h2>\n<p>1、<a href=\"http://items.py\" target=\"_blank\" rel=\"noopener noreferrer\">items.py</a> 在项目目标文件中定义</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2、爬虫住文件</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>3、在<code>settings.py</code>中开启管道</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>4、<a href=\"http://pipelines.py\" target=\"_blank\" rel=\"noopener noreferrer\">pipelines.py</a> 管道文件</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>5、items 目标文件</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> <a href=\"https://geek-docs.com/scrapy/scrapy-tutorials/scrapy-crawlspider.html\" target=\"_blank\" rel=\"noopener noreferrer\">Scrapy CrawlSpideropen in new window</a></h2>\n<h3> 创建爬虫文件</h3>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>Scrapy CrawlSpider</strong>，继承自<code>Spider</code>, 爬取网站常用的爬虫，其定义了一些规则(rule)方便追踪或者是过滤<code>link</code>。 也许该 spider 并不完全适合您的特定网站或项目，但其对很多情况都是适用的。 因此您可以以此为基础，修改其中的方法，当然您也可以实现自己的<code>spider</code>。</p>\n<h3> class scrapy.contrib.spiders.CrawlSpider</h3>\n<p><code>CrawlSpider</code>继承自<code>Spider</code>, 爬取网站常用的爬虫，其定义了一些规则(<code>rule</code>)方便追踪或者是过滤 link。 也许该 spider 并不完全适合您的特定网站或项目，但其对很多情况都是适用的。 因此您可以以此为基础，修改其中的方法，当然您也可以实现自己的<code>spider</code>。</p>\n<p>除了从<code>Spider</code>继承过来的(您必须提供的)属性外，其提供了一个新的属性:</p>\n<ul>\n<li><strong>rules</strong></li>\n</ul>\n<p>一个包含一个(或多个) <code>Rule</code> 对象的集合(list)。 每个 <code>Rule</code> 对爬取网站的动作定义了特定表现。 <code>Rule</code>对象在下边会介绍。 如果多个 rule 匹配了相同的链接，则根据他们在本属性中被定义的顺序，第一个会被使用。</p>\n<p>该 spider 也提供了一个可复写(<code>overrideable</code>)的方法:</p>\n<ul>\n<li><strong>parse_start_url(response)</strong></li>\n</ul>\n<p>当<code>start_url</code>的请求返回时，该方法被调用。 该方法分析最初的返回值并必须返回一个 <code>Item</code> 对象或者 一个 <code>Request</code> 对象或者 一个可迭代的包含二者对象。</p>\n<h3> 爬取规则</h3>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>link_extractor</code> 是一个 <code>Link Extractor</code> 对象。 其定义了如何从爬取到的页面提取链接。</p>\n<p><code>callback</code> 是一个 callable 或 string(该 spider 中同名的函数将会被调用)。 从<code>link_extractor</code>中每获取到链接时将会调用该函数。该回调函数接受一个 response 作为其第一个参数， 并返回一个包含 Item 以及(或) Request 对象(或者这两者的子类)的列表(list)。</p>\n<blockquote>\n<p>当编写爬虫规则时，请避免使用 <code>parse</code> 作为回调函数。 由于 <code>CrawlSpider</code> 使用 parse 方法来实现其逻辑，如果 您覆盖了 parse 方法，crawl spider 将会运行失败。</p>\n</blockquote>\n<ul>\n<li><code>cb_kwargs</code>: 包含传递给回调函数的参数(keyword argument)的字典。</li>\n<li><code>follow</code>: 是一个布尔(boolean)值，指定了根据该规则从 response 提取的链接是否需要跟进。 如果 callback 为 None， follow 默认设置为 True ，否则默认为 False 。</li>\n<li><code>process_links</code>: 是一个 callable 或 string(该 spider 中同名的函数将会被调用)。 从 link_extractor 中获取到链接列表时将会调用该函数。该方法主要用来过滤。</li>\n<li><code>process_request</code>: 是一个 callable 或 string(该 spider 中同名的函数将会被调用)。 该规则提取到每个 request 时都会调用该函数。该函数必须返回一个 request 或者 None。 (用来过滤 request)</li>\n</ul>\n<h3> CrawlSpider 示例</h3>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>CrawlSpider</code>将从<code>yiibai.com</code>的首页开始爬取，获取<code>yiibai.com/cplusplus</code>以及<code>item</code>的链接并，对后者调用 <strong>parse_item</strong> 方法。 当 item 获得返回<code>response</code>时，将使用<code>XPath</code>处理 HTML 并生成一些数据填入 Item 中。</p>\n<h2> 日志信息和日志等级</h2>\n<p><strong>日志级别：</strong></p>\n<ol>\n<li>CRIRICAL：严重错误</li>\n<li>ERROR：一般错误</li>\n<li>WARNING：警告</li>\n<li>INFO：一级信息</li>\n<li>DEBUG：调试信息</li>\n</ol>\n<p>默认日志等级是 DEBUG，只有出现 DEBUG 才会出现。</p>\n<p><strong><a href=\"http://settings.py\" target=\"_blank\" rel=\"noopener noreferrer\">settings.py</a> 文件设置</strong>：</p>\n<ul>\n<li>LOG_FILE：将屏幕显示的信息全部记录到文件中，屏幕不在显示，注意文件名一定是.log</li>\n<li>LOG_LEVEL: 设置日志的等级，就显示哪些，不显示哪些</li>\n</ul>\n<h2> POST 请求</h2>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2022-05-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "python"
      ]
    },
    {
      "title": "selenium",
      "url": "https://www.h7ml.cn/posts/Python/selenium.html",
      "id": "https://www.h7ml.cn/posts/Python/selenium.html",
      "summary": "selenium scrapy + selenium 抓取动态页面 腾讯云博客 open in new window 安装 selenium 下载 selenium 调试工具 Chrome下载地址 open in new window，版本与 Chrome 最近即可",
      "content_html": "<h2> selenium</h2>\n<h2> scrapy + selenium 抓取动态页面</h2>\n<p><a href=\"https://cloud.tencent.com/developer/article/2016732\" target=\"_blank\" rel=\"noopener noreferrer\">腾讯云博客 open in new window</a></p>\n<h3> 安装 selenium</h3>\n<h3> 下载 selenium 调试工具</h3>\n<p>Chrome<a href=\"https://registry.npmmirror.com/binary.html?path=chromedriver/\" target=\"_blank\" rel=\"noopener noreferrer\">下载地址 open in new window</a>，版本与 Chrome 最近即可</p>\n<h3> 使用</h3>\n<p>1、在 <code>middlewares.py</code> 文件中修改返回的 <code>response</code> 对象</p>\n<p>找到 <code>Scrapy[这里是你的项目名字]sDownloaderMiddleware</code> 类，修改<code>process_request</code>方法</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>3、在<code>settings.py</code>文件中打开<code>SPIDER_MIDDLEWARES</code> 、<code>DOWNLOADER_MIDDLEWARES</code> 和<code>DOWNLOAD_DELAY</code>配置</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2022-05-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "python"
      ]
    },
    {
      "title": "urllib",
      "url": "https://www.h7ml.cn/posts/Python/urllib.html",
      "id": "https://www.h7ml.cn/posts/Python/urllib.html",
      "summary": "Urllib urllib 包 包含以下几个模块： urllib.request - 打开和读取 URL。 urllib.error - 包含 urllib.request 抛出的异常。 urllib.parse - 解析 URL。 urllib.robotparser - 解析 robots.txt 文件。",
      "content_html": "<h2> Urllib</h2>\n<p>urllib 包 包含以下几个模块：</p>\n<ul>\n<li><strong>urllib.request</strong> - 打开和读取 URL。</li>\n<li><strong>urllib.error</strong> - 包含 urllib.request 抛出的异常。</li>\n<li><strong>urllib.parse</strong> - 解析 URL。</li>\n<li><strong>urllib.robotparser</strong> - 解析 robots.txt 文件。</li>\n</ul>\n<figure><img src=\"https://picgo-any.oss-cn-shanghai.aliyuncs.com/img/202208142159875.svg\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> urllib.request</h2>\n<p>urllib.request 定义了一些打开 URL 的函数和类，包含授权验证、重定向、浏览器 cookies 等。</p>\n<p>urllib.request 可以模拟浏览器的一个请求发起过程。</p>\n<p>我们可以使用 urllib.request 的 urlopen 方法来打开一个 URL，语法格式如下：</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li><strong>url</strong>：url 地址。</li>\n<li><strong>data</strong>：发送到服务器的其他数据对象，默认为 None。</li>\n<li><strong>timeout</strong>：设置访问超时时间。</li>\n<li><strong>cafile 和 capath</strong>：cafile 为 CA 证书， capath 为 CA 证书的路径，使用 HTTPS 需要用到。</li>\n<li><strong>cadefault</strong>：已经被弃用。</li>\n<li><strong>context</strong>：ssl.SSLContext 类型，用来指定 SSL 设置。</li>\n</ul>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 模拟头部信息</h3>\n<p>我们抓取网页一般需要对 headers（网页头信息）进行模拟，这时候需要使用到 urllib.request.Request 类：</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li><strong>url</strong>：url 地址。</li>\n<li><strong>data</strong>：发送到服务器的其他数据对象，默认为 None。</li>\n<li><strong>headers</strong>：HTTP 请求的头部信息，字典格式。</li>\n<li><strong>origin_req_host</strong>：请求的主机地址，IP 或域名。</li>\n<li><strong>unverifiable</strong>：很少用整个参数，用于设置网页是否需要验证，默认是 False。。</li>\n<li><strong>method</strong>：请求方法， 如 GET、POST、DELETE、PUT 等。</li>\n</ul>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>请求对象的定制</strong></p>\n<p>UA 介绍:User Agent 中文名为<strong>用户代理</strong>，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统</p>\n<p>及版本、CPU 类型、浏览器及版本。浏览器内核、浏览器渲染引擎、浏览器语言、浏览器插件等</p>\n<h2> urllib.parse</h2>\n<p>urllib.parse 用于解析 URL，格式如下：</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>urlstring 为 字符串的 url 地址，scheme 为协议类型，</p>\n<p>allow_fragments 参数为 false，则无法识别片段标识符。相反，它们被解析为路径，参数或查询组件的一部分，并 fragment 在返回值中设置为空字符串。</p>\n<p>以上实例输出结果为：</p>\n<p>完整内容如下：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>索引</th>\n<th>值</th>\n<th>值（如果不存在）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>scheme</code></td>\n<td>0</td>\n<td>URL 协议</td>\n<td><em>scheme</em> 参数</td>\n</tr>\n<tr>\n<td><code>netloc</code></td>\n<td>1</td>\n<td>网络位置部分</td>\n<td>空字符串</td>\n</tr>\n<tr>\n<td><code>path</code></td>\n<td>2</td>\n<td>分层路径</td>\n<td>空字符串</td>\n</tr>\n<tr>\n<td><code>params</code></td>\n<td>3</td>\n<td>最后路径元素的参数</td>\n<td>空字符串</td>\n</tr>\n<tr>\n<td><code>query</code></td>\n<td>4</td>\n<td>查询组件</td>\n<td>空字符串</td>\n</tr>\n<tr>\n<td><code>fragment</code></td>\n<td>5</td>\n<td>片段识别</td>\n<td>空字符串</td>\n</tr>\n<tr>\n<td><code>username</code></td>\n<td></td>\n<td>用户名</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>password</code></td>\n<td></td>\n<td>密码</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>hostname</code></td>\n<td></td>\n<td>主机名（小写）</td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>port</code></td>\n<td></td>\n<td>端口号为整数（如果存在）</td>\n<td><code>None</code></td>\n</tr>\n</tbody>\n</table>\n<h3> .quote()方法</h3>\n<p>将中文字符转换成 Unicode 编码格式</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> .urlencode()方法</h3>\n<p>可以将字典转化成 query 穿惨格式</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> urllib.error</h2>\n<p>urllib.error 模块为 urllib.request 所引发的异常定义了异常类，基础异常类是 URLError。</p>\n<p>urllib.error 包含了两个方法，URLError 和 HTTPError。</p>\n<p>URLError 是 OSError 的一个子类，用于处理程序在遇到问题时会引发此异常（或其派生的异常），包含的属性 reason 为引发异常的原因。</p>\n<p>HTTPError 是 URLError 的一个子类，用于处理特殊 HTTP 错误例如作为认证请求的时候，包含的属性 <strong>code</strong> 为 HTTP 的状态码， <strong>reason</strong> 为引发异常的原因，<strong>headers</strong> 为导致 HTTPError 的特定 HTTP 请求的 HTTP 响应头。</p>\n<p>对不存在的网页抓取并处理异常:</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> encode()方法</h2>\n<p><strong>描述</strong></p>\n<p>encode() 方法以 <em>encoding</em> <strong>指定的编码格式编码字符串</strong>。errors 参数可以指定不同的错误处理方案。</p>\n<p><strong>语法</strong></p>\n<p>encode()方法语法：</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>参数</strong></p>\n<ul>\n<li>encoding -- 要使用的编码，如\"UTF-8\"。</li>\n<li>errors -- 设置不同错误的处理方案。默认为 'strict',意为编码错误引起一个 UnicodeError。 其他可能得值有 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' 以及通过 codecs.register_error() 注册的任何值。</li>\n</ul>\n<p><strong>返回值</strong></p>\n<p>该方法返回编码后的字符串。</p>\n<h2> decode()方法</h2>\n<p><strong>描述</strong></p>\n<p>decode() 方法以 <em>encoding</em> <strong>指定的编码格式解码字符串</strong>。默认编码为字符串编码。</p>\n<p><strong>语法</strong></p>\n<p>decode()方法语法：</p>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>参数</strong></p>\n<ul>\n<li>encoding -- 要使用的编码，如\"UTF-8\"。</li>\n<li>errors -- 设置不同错误的处理方案。默认为 'strict',意为编码错误引起一个 UnicodeError。 其他可能得值有 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' 以及通过 codecs.register_error() 注册的任何值。</li>\n</ul>\n<p><strong>返回值</strong></p>\n<p>该方法返回解码后的字符串。</p>\n<h2> post 请求案例百度翻译</h2>\n<ul>\n<li>Post 请求的参数必须编码，先通过<code>urlencode</code>转换为二进制形式，在通过<code>encode</code>转换为<code>utf-8</code></li>\n<li>响应回来的数据是 json 需要进行反序列（loads）</li>\n</ul>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Cookie 反爬</h2>\n<p>有的加密接口会携带 cookie 或者其他令牌，这个不是固定的每个接口安全方式不一样，所有需要去分析，一般 cookie 是最常见的，在 headers 中添加</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> handler 代理</h2>\n<div class=\"language-python line-numbers-mode\" data-ext=\"py\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://picgo-any.oss-cn-shanghai.aliyuncs.com/img/202208142159875.svg",
      "date_published": "2022-05-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "python"
      ]
    },
    {
      "title": "编程题",
      "url": "https://www.h7ml.cn/posts/coding/coding.html",
      "id": "https://www.h7ml.cn/posts/coding/coding.html",
      "summary": "new 运算符 new 运算符原理 创建一个全新的对象 为新创建的对象添加 __proto__ 属模拟实现 new 运算符性并指向构造函数的原型对象 将新创建的对象作为函数调用的 this 如果构造函数没有返回对象类型，则返回新创建的对象 模拟实现 new 运算符 function myNew() { // 获取构造函数 const Constructor = [].shift.call(arguments); // 创建空对象并设置原型 const obj = Object.create(Constructor.prototype); // 绑定 this 并执行构造函数 const result = Constructor.apply(obj, arguments); // 返回构造函数显示返回的值或新对象 const type = typeof result; return result &amp;&amp; (type === 'object' || type === 'function') ? result : obj; }",
      "content_html": "<h3> new 运算符</h3>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">new 运算符原理</p>\n<ol>\n<li>创建一个全新的对象</li>\n<li>为新创建的对象添加 <strong><code>__proto__</code></strong> 属模拟实现 new 运算符性并指向构造函数的原型对象</li>\n<li>将新创建的对象作为函数调用的 this</li>\n<li>如果构造函数没有返回对象类型，则返回新创建的对象</li>\n</ol>\n</div>\n<details class=\"hint-container details\"><summary>模拟实现 new 运算符</summary>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></details>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new\" target=\"_blank\" rel=\"noopener noreferrer\">new 运算符 —— MDN</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/13\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript 深入之 new 的模拟实现</a></li>\n</ul>\n<h3> instanceof 运算符</h3>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">instanceof 运算符原理 `instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上</p>\n</div>\n<details class=\"hint-container details\"><summary>模拟实现 instanceof 运算符</summary>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></details>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof\" target=\"_blank\" rel=\"noopener noreferrer\">instanceof 运算符 —— MDN</a><br></li>\n<li><a href=\"https://juejin.cn/post/6844903613584654344#heading-1\" target=\"_blank\" rel=\"noopener noreferrer\">instanceof 操作符的实现原理</a></li>\n</ul>\n<h3> Object.create()</h3>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">Object.create() `Object.create()` 方法创建一个新对象，使用现有的对象来提供新创建的对象的 `__proto__` :::</p>\n<details class=\"hint-container details\"><summary>模拟实现 Object.create()</summary>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></details>\n</div>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\" target=\"_blank\" rel=\"noopener noreferrer\">Object.create() —— MDN</a></p>\n<h3> Function.prototype.call()</h3>\n<p><code>call()</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数</p>\n\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" target=\"_blank\" rel=\"noopener noreferrer\">Function.prototype.call() —— MDN</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/11\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript 深入之 call 和 apply 的模拟实现</a></li>\n</ul>\n<h3> Function.prototype.apply()</h3>\n<p><code>apply()</code> 方法调用一个具有给定 <code>this</code> 值的函数，以及以一个数组（或类数组对象）的形式提供的参数</p>\n\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\" target=\"_blank\" rel=\"noopener noreferrer\">Function.prototype.apply() —— MDN</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/11\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript 深入之 call 和 apply 的模拟实现</a></li>\n</ul>\n<h3> Function.prototype.bind()</h3>\n<p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数供调用时使用。</p>\n\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener noreferrer\">Function.prototype.bind() —— MDN</a></li>\n<li>相关学习文章\n<ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/12\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript 深入之 bind 的模拟实现</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25379434\" target=\"_blank\" rel=\"noopener noreferrer\">从一道面试题的进阶，到“我可能看了假源码”</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25483361\" target=\"_blank\" rel=\"noopener noreferrer\">从一道面试题的进阶，到“我可能看了假源码”（2）</a></li>\n</ul>\n</li>\n</ul>\n<h2> 工具方法系列</h2>\n<h3> debounce 函数防抖</h3>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">函数防抖 **作用**: 一个函数在一段时间内多次触发都**只执行最后一次** <br> **原理**: 利用定时器，在函数第一次执行时设定一个定时器，再次调用时如果已经设定过定时器就清空之前的定时器并设定一个新的定时器，当定时器结束后执行传入的回调函数 <br> **应用**: 搜索输入框获取用户输入的联想结果 :::</p>\n<details class=\"hint-container details\"><summary>实现防抖函数</summary>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></details>\n</div>\n<h3> throttle 函数节流</h3>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">函数节流 **作用**: 函数节流指指的是在一段时间内只允许函数执行一次 (例如 `3` 秒执行一次那么在函数第一次调用后的 `3` 秒内后面的函数调用将被忽略) <br> **原理**: 利用时间戳来判断，记录上次执行的时间戳，在每次触发事件时判断当前时间是否大于上次执行的时间 + 设置的间隔 ，如果是则执行回调并更新上次执行的时间戳<br> **应用**: 降低 `scroll resize` 事件的触发频率</p>\n</div>\n<details class=\"hint-container details\"><summary>实现节流函数</summary>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></details>\n",
      "date_published": "2021-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "es6"
      ]
    },
    {
      "title": "前端面试题-手写",
      "url": "https://www.h7ml.cn/posts/coding/handwriting.html",
      "id": "https://www.h7ml.cn/posts/coding/handwriting.html",
      "summary": "1.统计字符串中字符出现的次数 统计字符串中字符出现的次数 /** * @description 统计字符串中字符出现的次数 * @param str * @returns {{}} */ function computeString(str) { const obj = {}; for (let i = 0; i &lt; str.length; i++) { const key = str[i]; if (obj[key]) { obj[key]++; } else { obj[key] = 1; } } return obj; } computeString('12121111');",
      "content_html": "<h3> 1.统计字符串中字符出现的次数</h3>\n<details class=\"hint-container details\"><summary>统计字符串中字符出现的次数</summary>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></details>\n<h3> 2. 函数防抖</h3>\n<details class=\"hint-container details\"><summary>函数防抖</summary>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></details>\n<h3> 3. 函数节流</h3>\n<p>:::<br>\ndetails 函数节流 @<a href=\"./code/throttle.js\">code</a><br>\n:::</p>\n<h3> 4. 手写数组去重</h3>\n<details class=\"hint-container details\"><summary>手写数组去重</summary>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></details>\n<h3> 5. url 参数转换为 object</h3>\n<details class=\"hint-container details\"><summary>url 参数转换为 object</summary>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></details>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "设计模式",
      "url": "https://www.h7ml.cn/posts/designPattern/",
      "id": "https://www.h7ml.cn/posts/designPattern/",
      "summary": "适配器模式 外观模式 基本原则 桥接模式 建造者模式 责任链模式 组合模式 命令模式 装饰器模式 工厂模式 享元模式 中介者模式 解释器模式 迭代器模式 备忘录模式 观察者模式 原型模式 代理模式 发布订阅模式 单例模式 状态模式 策略模式 模版模式 访问者模式",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/adapter\" target=\"_blank\" rel=\"noopener noreferrer\">适配器模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/appearance\" target=\"_blank\" rel=\"noopener noreferrer\">外观模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/basicPrinciple\" target=\"_blank\" rel=\"noopener noreferrer\">基本原则</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/bridge\" target=\"_blank\" rel=\"noopener noreferrer\">桥接模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/build\" target=\"_blank\" rel=\"noopener noreferrer\">建造者模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/chainofresponsibility\" target=\"_blank\" rel=\"noopener noreferrer\">责任链模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/combination\" target=\"_blank\" rel=\"noopener noreferrer\">组合模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/command\" target=\"_blank\" rel=\"noopener noreferrer\">命令模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/decorator\" target=\"_blank\" rel=\"noopener noreferrer\">装饰器模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/factory\" target=\"_blank\" rel=\"noopener noreferrer\">工厂模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/flyweight\" target=\"_blank\" rel=\"noopener noreferrer\">享元模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/intermediary\" target=\"_blank\" rel=\"noopener noreferrer\">中介者模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/interpreter\" target=\"_blank\" rel=\"noopener noreferrer\">解释器模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/iteratorPattern\" target=\"_blank\" rel=\"noopener noreferrer\">迭代器模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/memorandum\" target=\"_blank\" rel=\"noopener noreferrer\">备忘录模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/observer\" target=\"_blank\" rel=\"noopener noreferrer\">观察者模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/prototype\" target=\"_blank\" rel=\"noopener noreferrer\">原型模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/proxy\" target=\"_blank\" rel=\"noopener noreferrer\">代理模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/publishSubscribe\" target=\"_blank\" rel=\"noopener noreferrer\">发布订阅模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/singleton\" target=\"_blank\" rel=\"noopener noreferrer\">单例模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/state\" target=\"_blank\" rel=\"noopener noreferrer\">状态模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/strategy\" target=\"_blank\" rel=\"noopener noreferrer\">策略模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/template\" target=\"_blank\" rel=\"noopener noreferrer\">模版模式</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/designPattern/visitor\" target=\"_blank\" rel=\"noopener noreferrer\">访问者模式</a></li>\n</ul>\n",
      "date_published": "2023-02-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "design"
      ]
    },
    {
      "title": "适配器模式",
      "url": "https://www.h7ml.cn/posts/designPattern/adapter.html",
      "id": "https://www.h7ml.cn/posts/designPattern/adapter.html",
      "summary": "场景 当我们使用第三方库的时候，常常会遇到当前接口和第三方接口不匹配的情况，比如使用一个 Table 的组件，它要求我们返回的表格数据格式如下： { code: 0, // 业务 code msg: '', // 出错时候的提示 data: { total: , // 总数量 list: [], // 表格列表 } };",
      "content_html": "<h1> 场景</h1>\n<p>当我们使用第三方库的时候，常常会遇到当前接口和第三方接口不匹配的情况，比如使用一个 <code>Table</code> 的组件，它要求我们返回的表格数据格式如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但后端返回的数据可能是这样的：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>此时就可以通过适配器模式进行转换。</p>\n<h1> 适配器模式</h1>\n<p>看一下 <a href=\"\">维基百科</a> 给的定义：</p>\n<blockquote>\n<p>In <a href=\"https://en.wikipedia.org/wiki/Software_engineering\" target=\"_blank\" rel=\"noopener noreferrer\">software engineering</a>, the <strong>adapter pattern</strong> is a <a href=\"https://en.wikipedia.org/wiki/Software_design_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">software design pattern</a> that allows the <a href=\"https://en.wikipedia.org/wiki/Interface_(computer_science)\" target=\"_blank\" rel=\"noopener noreferrer\">interface</a> of an existing <a href=\"https://en.wikipedia.org/wiki/Class_(computer_science)\" target=\"_blank\" rel=\"noopener noreferrer\">class</a> to be used as another interface.[<a href=\"https://en.wikipedia.org/wiki/Adapter_pattern#cite_note-HeadFirst-1\" target=\"_blank\" rel=\"noopener noreferrer\">1]</a> It is often used to make existing classes work with others without modifying their <a href=\"https://en.wikipedia.org/wiki/Source_code\" target=\"_blank\" rel=\"noopener noreferrer\">source code</a>.</p>\n</blockquote>\n<p>通过适配器模式可以让当前 <code>class</code> 不改变的情况下正常使用另一个 <code>class</code>。</p>\n<p>在以 <code>class</code> 为基础的语言中有两种实现方式，一种是通过组合的方式，适配器类内部包含原对象的实例。一种是通过类继承，适配器类继承原 <code>class</code> 。可以看下 <code>UML</code> 类图：</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220213124112500.png\" alt=\"image-20220213124112500\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220213124112500</figcaption></figure>\n<p>左边的 <code>Adapter</code> 内部拥有 <code>Adaptee</code> 的实例，右边的 <code>Adapter</code> 类直接继承 <code>Adaptee</code> 类。</p>\n<p>适配器会将 <code>Adaptee</code> 的 <code>specificOperation</code> 方法进行相应的处理包装为 <code>operation</code> 方法供 <code>client</code> 使用。</p>\n<p>看一个简单的例子，现实生活中 <code>iPhone</code> 有两种耳机插口，一种是 <code>Lightning</code>，一种是传统的 <code>3.5</code> 毫米接口。如果是 <code>lightning</code> 插口的耳机想要插到传统的 <code>3.5</code> 毫米接口的电脑上就需要适配器了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过适配器我们成功将 <code>Lightning</code> 耳机插入到了电脑传统耳机孔，让我们再用 <code>js</code> 改写一下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 代码实现</h1>\n<p>回到开头接口不匹配的问题上，<code>Table</code> 组件提供了一个 <code>responseProcessor</code> 的钩子，我们只需要通过这个钩子将接口返回的数据进行包装即可。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 更多场景</h1>\n<p>除了应对数据格式不一致的问题，通过适配器模式我们还可以为上层提供统一接口，来解决兼容性问题。最典型的例子就是 <code>jQuery</code> ，可以看一下其中一段代码:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 易混设计模式</h1>\n<p>适配器模式和<a href=\"https://www.h7ml.cn/designPattern/proxy.html\" target=\"_blank\" rel=\"noopener noreferrer\">代理模式</a>在代码结构上很像，代理模式也是对原对象进行包装处理。区别在于它们的意图不同：</p>\n<ul>\n<li>\n<p>适配器模式是为了解决两个对象之间不匹配的问题，而原对象又不适合直接修改，此时可以使用适配器模式进行一层转换。</p>\n</li>\n<li>\n<p>代理模式是为了增强原对象的功能，提供的接口不会改变。</p>\n</li>\n</ul>\n<h1> 总</h1>\n<p>适配器模式是一种比较简单的设计模式，在 <code>js</code> 中也会很自然的应用，一般通过一个函数进行转换即可。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-02-13T09:15:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "外观模式",
      "url": "https://www.h7ml.cn/posts/designPattern/appearance.html",
      "id": "https://www.h7ml.cn/posts/designPattern/appearance.html",
      "summary": "场景 网络请求中，我们一般使用 axios 库，支持用 Promise 风格调用。 axios .get('/api/user', { params: { ID: '123', }, }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); axios .post( '/api/user', { firstName: 'wind', lastName: 'liang', }, { headers: { 'Content-Type': 'application/json' }, } ) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); });",
      "content_html": "<h1> 场景</h1>\n<p>网络请求中，我们一般使用 <code>axios</code> 库，支持用 <code>Promise</code> 风格调用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到上边的 <code>get</code> 和 <code>post</code> 传参并不统一，使用起来会比较繁琐，<code>post</code> 还需要手动传递 <code>headers</code> 。</p>\n<p>为了解决这些问题，我们可以通过外观（门面）模式来解决。</p>\n<h1> 外观（门面）模式</h1>\n<p>看下 <a href=\"https://en.wikipedia.org/wiki/Facade_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科</a> 的定义。</p>\n<blockquote>\n<p>The <strong>facade pattern</strong> (also spelled <em>façade</em>) is a <a href=\"https://en.wikipedia.org/wiki/Software_design_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">software-design pattern</a> commonly used in <a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\" target=\"_blank\" rel=\"noopener noreferrer\">object-oriented programming</a>. Analogous to a <a href=\"https://en.wikipedia.org/wiki/Facade\" target=\"_blank\" rel=\"noopener noreferrer\">facade</a> in architecture, a facade is an <a href=\"https://en.wikipedia.org/wiki/Object_(computer_science)\" target=\"_blank\" rel=\"noopener noreferrer\">object</a> that serves as a front-facing interface masking more complex underlying or structural code.</p>\n</blockquote>\n<p>外观模式相当于为一个相对复杂的接口或者结构提供一个上层接口供用户使用，看一下 <code>UML</code> 类图。</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220215084348154.png\" alt=\"image-20220215084348154\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220215084348154</figcaption></figure>\n<p>举一个简单例子，比如开电脑是一个复杂的过程，我们可以封装成一个函数来实现：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>改写成 <code>js</code> 。</p>\n<p>算了不改写了，哈哈，直白点其实就是把几个函数封装到了一个函数来调用。</p>\n<p><code>UML</code> 类图中外观模式会和很多 <code>class</code> 交互，但在 <code>js</code> 中可能会很少遇到这种情况，通常是当参数比较复杂或者某个功能使用起来比较麻烦的时候我们就可以通过外观模式进行简化。</p>\n<h1> 代码实现</h1>\n<p>回到开头 <code>axios</code> 的问题，我们可以对 <code>axios</code> 进行一层封装。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后引用 <code>request.js</code> 进行调用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><em>补充一句：上边的封装只是为了演示外观模式的使用，实际项目中封装的会更加全面</em></p>\n<p>通过门面模式除了简化了我们的调用，还有一个好处就是将底层调用封装了起来，未来如果底层需要变化，比如上边的 <code>axios</code> 替换为 <code>fetch</code> ，我们只需要去修改 <code>request.js</code> 即可，业务方无需感知。</p>\n<h1> 更多场景</h1>\n<p>外观模式说的宽泛的话就是将复杂的调用包装一层变的简单些。</p>\n<p>我们平时用到的 <code>Vue</code> 的 <code>template</code> 、<code>React</code> 的 <code>jsx</code> ，也可以认为使用了外观模式，他们都将底层 <code>dom</code> 创建封装起来，使得我们编写页面会变得更加简单。</p>\n<h1> 易混设计模式</h1>\n<p>前边讲到的 <a href=\"https://www.h7ml.cn/designPattern/proxy.html\" target=\"_blank\" rel=\"noopener noreferrer\">代理模式</a>、<a href=\"https://www.h7ml.cn/designPattern/adapter.html\" target=\"_blank\" rel=\"noopener noreferrer\">适配器模式</a>、<a href=\"https://www.h7ml.cn/designPattern/template.html\" target=\"_blank\" rel=\"noopener noreferrer\">模版方法</a> 结构上和外观模式看起来都有些像，区别就在于他们的意图不同：</p>\n<ul>\n<li>适配器模式是为了解决两个对象之间不匹配的问题，而原对象又不适合直接修改，此时可以使用适配器模式进行一层转换。</li>\n<li>代理模式是为了增强原对象的功能，提供的接口不会改变。</li>\n<li>模版模式是将不同功能组合在一起，只提供框架，具体实现还需要调用者传进来。</li>\n<li>外观模式是将比较复杂的调用进行一层封装，提供一个新的接口供用户使用。</li>\n</ul>\n<h1> 总</h1>\n<p>外观模式是一个比较自然的设计模式，某个功能感觉用起来太麻烦还频繁，自然会想到去封装一层再来使用。</p>\n<p>外观模式一个额外好处就是未来能够更好的应对底层的变化。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-02-14T08:15:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "基本原则",
      "url": "https://www.h7ml.cn/posts/designPattern/basicPrinciple.html",
      "id": "https://www.h7ml.cn/posts/designPattern/basicPrinciple.html",
      "summary": "二十三个经典的 设计模式 已经过完了 ，这里再把一些基本原则过一下，以便平时开发中可以更好的体会。 单一职责原则 SRP(Single Responsibility Principle) There should never be more than one reason for a class to change.\" In other words, every class should have only one responsibility.",
      "content_html": "<p>二十三个经典的 <a href=\"https://www.h7ml.cn/designPattern/\" target=\"_blank\" rel=\"noopener noreferrer\">设计模式</a> 已经过完了 ，这里再把一些基本原则过一下，以便平时开发中可以更好的体会。</p>\n<h1> 单一职责原则 SRP(Single Responsibility Principle)</h1>\n<blockquote>\n<p>There should never be more than one reason for a class to change.\" In other words, every class should have only one responsibility.</p>\n</blockquote>\n<p>定义：一个类或者模块应该有且只有一个改变的原因，在 <code>js</code> 中的话更多的会应用在对象、函数中。</p>\n<p>最难的地方就在于结合具体场景对单一职责的判定了，为了应用这个原则把一个模块拆的太细其实也不太好，所以需要我们在方便性和稳定性之间做一个权衡。</p>\n<p>之前讲的 <a href=\"https://www.h7ml.cn/designPattern/\" target=\"_blank\" rel=\"noopener noreferrer\">代理模式</a>、<a href=\"https://www.h7ml.cn/designPattern/decorator.html\" target=\"_blank\" rel=\"noopener noreferrer\">装饰器模式</a> 都有体现。</p>\n<h1> 开闭原则 OCP(open–closed principle)</h1>\n<blockquote>\n<p>Software entities should be open for extension, but closed for modification.</p>\n</blockquote>\n<p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。模块应尽量在不修改原代码的情况下进行扩展。</p>\n<p>平常开发中，要把变的部分和不变的部分分离出来，设计一个结构的时候尽可能的考虑一下未来可能变化的部分。</p>\n<p>可以通过放置 <code>hook</code> 、使用回调函数的方式达到扩展的目的。</p>\n<p>之前讲的 <a href=\"https://www.h7ml.cn/designPattern/publishSubscribe.html\" target=\"_blank\" rel=\"noopener noreferrer\">发布订阅模式</a>、<a href=\"https://www.h7ml.cn/designPattern/template.html\" target=\"_blank\" rel=\"noopener noreferrer\">模版方法模式</a>、<a href=\"https://www.h7ml.cn/designPattern/strategy.html\" target=\"_blank\" rel=\"noopener noreferrer\">策略模式</a>、<a href=\"https://www.h7ml.cn/designPattern/chainofresponsibility.html\" target=\"_blank\" rel=\"noopener noreferrer\">职责链模式</a> 都有体现。</p>\n<h1> 里氏替换原则 LSP(Liskov substitution principle)</h1>\n<blockquote>\n<p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p>\n</blockquote>\n<p>定义：所有引用基类的地方必须能透明地使用其子类的对象，也可以简单理解为任何基类可以出现的地方，子类一定可以出现。</p>\n<p>举个例子就是如果某个地方可以用 <code>A</code> 类， <code>B</code> 类继承于 <code>A</code> 类，那么这个地方一定可以使用 <code>B</code> 类。</p>\n<p>这个原则告诉我们在继承类的时候，如果要实现一个新功能，不要去覆盖父类已经实现的方法，而应该去写一个新方法。</p>\n<p>平常前端开发中很少去写类和继承，这个原则用的比较少。</p>\n<h1> 接口隔离原则 ISP(Interface Segregation Principle)</h1>\n<blockquote>\n<p>Many client-specific interfaces are better than one general-purpose interface.</p>\n</blockquote>\n<p>定义：客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。简单来说就是建立单一的接口，不要建立臃肿庞大的接口。也就是接口尽量细化，同时接口中的方法尽量少。</p>\n<p>举个例子就是 <code>A</code> 接口有 <code>5</code> 个方法，<code>B</code> 类实现 <code>A</code> 接口，但 <code>B</code> 类只用到其中的 <code>3</code> 个方法，此时可以考虑对 <code>A</code> 接口进行拆分。</p>\n<p><code>js</code> 中没有接口，忽略。</p>\n<h1> 依赖倒转原则 DIP(Dependency Inversion Principle)</h1>\n<blockquote>\n<p>Depend upon abstractions, not concretions</p>\n</blockquote>\n<p>定义： 程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p>\n<p>其实就是经常说的面向接口（或者基类）编程。</p>\n<p>但 <code>js</code> 中没有接口和抽象类，这种原则也就用不到了。</p>\n<p>上边五个原则就是经常看到的 <code>SOLID</code> 原则，除了这些还有几个其他的原则。</p>\n<h1> 最小知道原则 LOD(principle of least knowledge)</h1>\n<p>定义：一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p>\n<p>实体的话在前端中更多的对应对象、函数，<a href=\"https://www.h7ml.cn/designPattern/appearance.html\" target=\"_blank\" rel=\"noopener noreferrer\">门面模式</a> 可以看作该原则的应用。</p>\n<p>最小知道原则又叫做迪米特法则 LOD(Law of Demeter)，迪米特其实是宙斯(Zeus) 的姐姐，名字来源的话这里截取下<a href=\"https://en.wikipedia.org/wiki/Law_of_Demeter\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科</a>。</p>\n<blockquote>\n<p><em>The Greek goddess of Agriculture.</em></p>\n<p>The Demeter project was named after Demeter because we were working on a hardware description language Zeus and we were looking for a tool to simplify the implementation of Zeus. We were looking for a tool name related to Zeus and we chose a sister of Zeus: Demeter.</p>\n<p>Later we promoted the idea that Demeter-style software development is about growing software as opposed to building software. We introduced the concept of a growth plan which is basically a sequence of more and more complex UML class diagrams.</p>\n<p>Growth plans are useful for building systems incrementally.</p>\n</blockquote>\n<p>大意就是当时是用一个叫做 <code>Zeus</code> 的硬件语言，然后找到了一个优化 <code>Zens</code> 的工具，为了让它们产生联系，就起了 <code>Demeter</code> 这个名字。</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.com25_29914_743225_ccd123bf574133ea11e60e85e7057014_38a998_301.jpg\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>另外截取一下 「JavaScript 设计开发与实现」书里提到的关于两个名字之间的建议：</p>\n<blockquote>\n<p>许多人更倾向于使用迪米特法则这个名字，也许是因为显得更酷一点。但本书参考 <em>Head First</em></p>\n<p><em>Design Patterns</em> 的建议，称之为最少知识原则。一是因为这个名字更能体现其含义，另一个原因</p>\n<p>是“法则”给人的感觉是必须强制遵守，而原则只是一种指导，没有哪条原则是在实际开发中必</p>\n<p>须遵守的。比如，虽然遵守最小知识原则减少了对象之间的依赖，但也有可能增加一些庞大到难</p>\n<p>以维护的第三者对象。跟单一职责原则一样，在实际开发中，是否选择让代码符合最少知识原则，</p>\n<p>要根据具体的环境来定。</p>\n</blockquote>\n<h1> 合成/聚合复用原则 CARP(Composite/Aggregate Reuse Principle)</h1>\n<p>定义：尽量使用合成/聚合，而不是通过继承达到复用的目的。</p>\n<h1> KISS 原则</h1>\n<p>定义： Keep It Simple, Stupid，在设计中应当注重简约的原则。</p>\n<h1> YAGNI 原则</h1>\n<p>定义：You aren't gonna need it，表示暂时不需要的就不要做。</p>\n<h1> DRY 原则</h1>\n<p>定义：Don't Repeat Yourself，不要写重复的代码。</p>\n<h1> 总</h1>\n<p>所有的原则只是协助于我们写成易维护、易扩展的代码，不能为了去实现而实现、进行过度设计。</p>\n<p>一些代码如果未来完全不用改变，那就用最简单的方式实现即可，当第二次、第三次修改的时候再来重构也不迟。</p>\n<p>设计模式和基本原则的应用一定是结合具体场景的，空谈的话也没有任何意义。</p>\n<p>我们只需要先了解这些原则，然后在日常开发中慢慢进行体会。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-03-08T07:27:19.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "桥接模式",
      "url": "https://www.h7ml.cn/posts/designPattern/bridge.html",
      "id": "https://www.h7ml.cn/posts/designPattern/bridge.html",
      "summary": "组合模式要是用在复杂类的抽离、运行时切换不同方法等，比较难理解，这里 讲的不错。 目前开发中也没有遇到过，此处留坑。",
      "content_html": "<p>组合模式要是用在复杂类的抽离、运行时切换不同方法等，比较难理解，<a href=\"https://refactoringguru.cn/design-patterns/bridge\" target=\"_blank\" rel=\"noopener noreferrer\">这里</a> 讲的不错。</p>\n<p>目前开发中也没有遇到过，此处留坑。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-03-06T16:12:19.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "建造者模式",
      "url": "https://www.h7ml.cn/posts/designPattern/build.html",
      "id": "https://www.h7ml.cn/posts/designPattern/build.html",
      "summary": "场景 如果我们定义了某个函数： function getPhone(size, type, screen, price=100) { ... }",
      "content_html": "<h1> 场景</h1>\n<p>如果我们定义了某个函数：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果这个函数很稳定那没什么问题，但如果经常变动，比如新增参数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>此时我们如果想继续使用 <code>price</code> 的默认值，调用的时候还必须显性的传 <code>undefined</code>，<code>getPhone(4.3, 'iOS', 'OLED', undefined, 0.8)</code>。</p>\n<p>如果再增加一个带默认值的参数，就会看起来越来越怪。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果这个函数在很多地方都调用过，改的时候还需要保证修改后其他地方传参是正常的。</p>\n<p>此时可以借助建造者模式的思想去改造它。</p>\n<h1> 建造者模式</h1>\n<p>看下 <a href=\"https://en.wikipedia.org/wiki/Builder_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科</a> 给的定义：</p>\n<blockquote>\n<p>The <strong>builder pattern</strong> is a <a href=\"https://en.wikipedia.org/wiki/Software_design_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">design pattern</a> designed to provide a flexible solution to various object creation problems in <a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\" target=\"_blank\" rel=\"noopener noreferrer\">object-oriented programming</a>. The intent of the Builder design pattern is to <a href=\"https://en.wikipedia.org/wiki/Separation_of_concerns\" target=\"_blank\" rel=\"noopener noreferrer\">separate</a> the construction of a complex object from its representation. It is one of the <a href=\"https://en.wikipedia.org/wiki/Design_Patterns\" target=\"_blank\" rel=\"noopener noreferrer\">Gang of Four design patterns</a>.</p>\n</blockquote>\n<p>建造者模式属于创建型设计模式，也就是为了生成对象。它将复杂的创建过程从构造函数分离出来，然后就可以在不改变原有构造函数的基础上，创建各种各样的对象。</p>\n<p><code>GoF</code> 书中提供的做法就是新创建一个 <code>Builder</code> 类，对象的创建委托给 <code>Builder</code> 类，原始的类不做操作，只负责调用即可。</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220225075740520.png\" alt=\"image-20220225075740520\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220225075740520</figcaption></figure>\n<p><code>Director</code> 类在构造函数中持有一个 <code>Builder</code> 实例，然后调用 <code>Builder</code> 类的 <code>buildPart</code> 和 <code>getResult</code> 即可创建对象。未来有新的对象需要创建的话，只需要实现新的 <code>Builder</code> 类即可，无需修改 <code>Director</code> 实例。</p>\n<p>原始的建造者模式把对象的创建完全抽离到了 <code>Builder</code> 类中，这可能会导致原始类没啥用了，也许我们可以不全部抽离，<code>Builder</code> 类只负责接收参数即可。</p>\n<p><em>以下示例来自极客时间的 <a href=\"http://gk.link/a/11c3G\" target=\"_blank\" rel=\"noopener noreferrer\">设计模式之美</a></em></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上边的 <code>ResourcePoolConfig</code> 类构造函数需要 <code>4</code> 个参数，如果经常变动，未来可能会越来越多，代码的可读性和易用性都会变差。因此这里可以用到建造者模式，但这里的建造者模式只用来传递参数，其他的逻辑还是维持在 <code>ResourcePoolConfig</code> 类中不变。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样的话我们可以通过 <code>ResourcePoolConfig.Builder()</code> 来设置参数，将生成的参数对象传递给 <code>ResourcePoolConfig</code> 类的构造函数即可。</p>\n<p>这里可以看作是变种的建造者模式，我们不是创建不同的 <code>Builder</code> 类来创建对象，而是给 <code>Builder</code> 类传递不同的参数来创建不同的对象。</p>\n<h1> 代码实现</h1>\n<p><em>这里也只讨论变种的建造者模式。</em></p>\n<p>在 <code>js</code> 中，我们同样可以照猫画虎的引入一个 <code>Builer</code> 类来接受参数，然后将创建参数对象传递给原始类。</p>\n<p>但之所以在 <code>Java</code> 中引入新的 <code>Builder</code> 类是因为 <code>Java</code> 只能通过类来创建对象，但在 <code>js</code> 中我们是可以通过字面量来创建对象的，并且 <code>ES6</code> 还提供了对象的解构语法，会让我们使用起来更加简洁。</p>\n<p>我们只需要将参数列表聚合为一个对象，然后通过解构取参数即可。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们只需要改成：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上边的写法可以很方便的设置默认值，并且参数的顺序也不再重要，未来再扩展的时候也不需要太担心其他地方调用时候传参是否会引起问题。</p>\n<p>注意一下参数列表中 <code>{...} = {}</code> 后边的大括号最好写一下，不然如果用户调用函数的时候什么都没有传，解构就会直接失败了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220225083640409.png\" alt=\"image-20220225083640409\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220225083640409</figcaption></figure>\n<h1> 更多场景</h1>\n<p>通过对象来传递参数除了用在函数中以外，设计组件的时候，如果组件的参数会经常变动，并且越来越多，我们不妨引入一个 <code>Object</code> 类型的参数，然后将相关的参数内聚到 <code>Object</code> 中进行传递。</p>\n<h1> 总</h1>\n<p>原始的建造者模式不清楚有没有实际应用，目前还没遇到，未来有的话再补充吧。</p>\n<p>变种的建造者模式（只传递参数）在 <code>js</code> 中也很简单，直接通过对象传递参数即可。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-02-24T08:42:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "责任链模式",
      "url": "https://www.h7ml.cn/posts/designPattern/chainofresponsibility.html",
      "id": "https://www.h7ml.cn/posts/designPattern/chainofresponsibility.html",
      "summary": "场景 leetcode 65 题 判断是否是合法的数字： image-20220204102426236",
      "content_html": "<h1> 场景</h1>\n<p><a href=\"https://leetcode.wang/leetCode-65-Valid-Number.html\" target=\"_blank\" rel=\"noopener noreferrer\">leetcode 65 题</a> 判断是否是合法的数字：</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220204102426236.png\" alt=\"image-20220204102426236\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220204102426236</figcaption></figure>\n<p>部分有效数字列举如下：<code>[\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"]</code> 部分无效数字列举如下：<code>[\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"]</code></p>\n<p>我们可以依次遍历给定的字符串，然后各种 <code>if</code> 、<code>else</code> 来解决这个问题：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果只是为了刷题 <code>AC</code> 也没啥毛病，但如果在业务中写出这么多 <code>if</code>、<code>else</code> 大概就要被打了。</p>\n<p>为了让代码扩展性和可读性更高，我们可以通过责任链模式进行改写。</p>\n<h1> 责任链模式</h1>\n<p><code>GoF</code> 介绍的责任链模式定义：</p>\n<blockquote>\n<p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p>\n</blockquote>\n<p>避免请求者和接收者之间的耦合，让多个接收者都有机会去处理请求。将接收者组成链条，在链条中传递请求直到有接收者可以处理它。</p>\n<p>原始的定义中，当请求被处理后链条就终止了，但很多地方也会将请求一直传递下去，可以看作是责任链模式的变体。</p>\n<p>看一下 <code>UML</code> 类图和时序图：</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220204151213707.png\" alt=\"image-20220204151213707\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220204151213707</figcaption></figure>\n<p><code>Sender</code> 无需关心哪一个 <code>Receiver</code> 去处理它，只需要通过 <code>Handler</code> 接口在 <code>Receiver</code> 链条中进行处理，每一个 <code>Receiver</code> 处理结束后继续传给下一个 <code>Receiver</code> 。</p>\n<p>看起来比较抽象，看一个具体的例子，不同等级的日志进行不同的处理：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>每个 <code>logger</code> 都继承了 <code>message</code> 方法，并且拥有的 <code>next</code> 也指向一个 <code>logger</code> 对象，通过 <code>next</code> 去调用下一个的 <code>message</code> 方法。</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220204152750255.png\" alt=\"image-20220204152750255\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220204152750255</figcaption></figure>\n<p>让我们用 <code>js</code> 再来改写一下：</p>\n<p>我们先实现一个 <code>Handler</code> 对象，构建链条。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>接下来实现不同的 <code>Logger</code> 。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后进行测试：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出内容和 <code>java</code> 代码是一致的。</p>\n<h1> 代码实现</h1>\n<p>回到开头的场景中，判断是否是有效数字。</p>\n<p>我们可以抽离出不同功能，判断是否是整数、是否是科学记数法、是否是浮点数等等，然后通过职责链模式把它们链接起来，如果某一环节返回了 <code>true</code> 就不再判断，直接返回最终结果。</p>\n<p>可以利用上边写的 <code>Handler</code> 对象，构建链条，此外可以通过返回值提前结束传递。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>数字预处理一下，去掉前后空白和 <code>+</code>、<code>-</code> 便于后续的判断。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>判断是否是整数：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>判断是否是小数：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>判断是否是科学计数法：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>判断是否是十六进制：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后通过 <code>Handler</code> 将上边的功能串联起来即可：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过责任链的设计模式，每一个函数都可以很好的进行复用，并且未来如果要新增一种类型判断，只需要加到责任链中即可，和之前的判断也完全独立。</p>\n<h1> 易混设计模式</h1>\n<p>说到沿着「链」执行，应该会想到 <a href=\"https://www.h7ml.cn/designPattern/decorator.html\" target=\"_blank\" rel=\"noopener noreferrer\">装饰器模式</a> 。</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220204202859919.png\" alt=\"image-20220204202859919\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220204202859919</figcaption></figure>\n<p>它和责任链模式看起来结构上是一致的，我的理解上主要有两点不同：</p>\n<ol>\n<li>装饰器模式是对已有功能的增强，依次包装起来形成链式调用。而责任链模式从一开始就抽象出了很多功能，然后形成责任链。</li>\n<li>装饰器模式会依次调用新增的功能直到最初的功能，责任链模式提供了一种中断的能力，调用到某个操作的时候可以直接终止掉，不是所有的功能都会调用。</li>\n</ol>\n<h1> 总</h1>\n<p>当处理一件事情的时候发现会分很多种情况去讨论，此时可以考虑使用责任链模式进行功能的拆分，提高代码的复用性、扩展性以及可读性。</p>\n<p>像 <code>js</code> 中底层的原型链、作用域链、<code>Dom</code> 元素的冒泡机制都可以看作是责任链模式的应用。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-02-04T10:10:46.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "组合模式",
      "url": "https://www.h7ml.cn/posts/designPattern/combination.html",
      "id": "https://www.h7ml.cn/posts/designPattern/combination.html",
      "summary": "组合模式主要应用在符合树状结构的场景中，父节点和子节点实现统一接口，父节点委托给子节点进行执行。 其中父节点就可以当作组合对象，用户调用的时候无需关系是组合对象还是子对象，面向接口调用即可。 目前开发中还没有遇到过，此处留坑。",
      "content_html": "<p>组合模式主要应用在符合树状结构的场景中，父节点和子节点实现统一接口，父节点委托给子节点进行执行。</p>\n<p>其中父节点就可以当作组合对象，用户调用的时候无需关系是组合对象还是子对象，面向接口调用即可。</p>\n<p>目前开发中还没有遇到过，此处留坑。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-03-03T08:12:19.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "命令模式",
      "url": "https://www.h7ml.cn/posts/designPattern/command.html",
      "id": "https://www.h7ml.cn/posts/designPattern/command.html",
      "summary": "命令模式主要应用在需要延迟执行请求、支持撤回的场景中，可能在文本编辑器中有应用，我目前没有使用过，这里就留坑了。 命令模式本质上就是将数据和操作封装为一个对象，实现操作的撤回、延迟等。 这里贴一下 Youtube 一个博主举的 计算器例子。",
      "content_html": "<p>命令模式主要应用在需要延迟执行请求、支持撤回的场景中，可能在文本编辑器中有应用，我目前没有使用过，这里就留坑了。</p>\n<p>命令模式本质上就是将数据和操作封装为一个对象，实现操作的撤回、延迟等。</p>\n<p>这里贴一下 <code>Youtube</code> 一个博主举的 <a href=\"https://www.youtube.com/watch?v=GQzfF5EMD7o&amp;list=PLZlA0Gpn_vH_CthENcPCM0Dww6a5XYC7f&amp;index=6\" target=\"_blank\" rel=\"noopener noreferrer\">计算器例子</a>。</p>\n<p>首先是一个支持加减乘除的计算器：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果需要给计算器增加撤回的功能，就可以使用命令模式了。</p>\n<p>我们把每一步操作都封装为一个类作为命令对象，类中包含了操作数和操作方法，然后用一个数组记录所有的命令对象。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 总</h1>\n<p>命令模式的思想比较有意思，将数据和操作封装，实现上在 <code>js</code> 中很简单，我们甚至也不需要 <code>class</code> ，直接通过字面量对象传递也可以。</p>\n<p>但实际开发中目前还没用到过，此处留坑。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-03-03T09:27:19.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "装饰器模式",
      "url": "https://www.h7ml.cn/posts/designPattern/decorator.html",
      "id": "https://www.h7ml.cn/posts/designPattern/decorator.html",
      "summary": "场景 微信小程序定义一个页面是通过微信提供的 Page 方法，然后传入一个配置对象进去。 Page({ data: { // 参与页面渲染的数据 logs: [], }, onLoad: function () { // 页面渲染后 执行 }, });",
      "content_html": "<h1> 场景</h1>\n<p>微信小程序定义一个页面是通过微信提供的 <code>Page</code> 方法，然后传入一个配置对象进去。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果我们有个需求是在每个页面加载的时候上报一些自定义数据。</p>\n<p>最直接的当然是去每个页面加就好了，但上报数据的逻辑是一致的，一个一个加有些傻了，这里就可以用到装饰器模式了。</p>\n<h1> 装饰器模式</h1>\n<p>看下维基百科的定义。</p>\n<blockquote>\n<p><strong>装饰器（修饰）模式</strong>，是<a href=\"https://zh.wikipedia.org/w/index.php?title=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BC%8F&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener noreferrer\">面向对象程式</a>领域中，一种动态地往一个类别中添加新的行为的<a href=\"https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener noreferrer\">设计模式</a>。就功能而言，修饰模式相比生成<a href=\"https://zh.wikipedia.org/wiki/%E5%AD%90%E9%A1%9E%E5%88%A5\" target=\"_blank\" rel=\"noopener noreferrer\">子类别</a>更为灵活，这样可以给某个对象而不是整个类别添加一些功能。</p>\n</blockquote>\n<p>看一下 <code>UML</code> 类图和次序图。</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220117093402007.png\" alt=\"image-20220117093402007\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220117093402007</figcaption></figure>\n<p>当访问 <code>Component1</code> 中的 <code>operation</code> 方法时，会先调用预先定义的两个装饰器 <code>Decorator1</code> 和 <code>Decorator2</code> 中的 <code>operation</code> 方法，执行一些额外操作，最后再执行原始的 <code>operation</code> 方法。</p>\n<p>举一个简单的例子：</p>\n<p>买奶茶的话可以额外加珍珠、椰果等，不同小料有不同的价格、也可以自由组合，此时就可以用到装饰器模式，对原始奶茶进行加料、算价。</p>\n<p>原始的奶茶有一个接口和类。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下边引入装饰器，进行加料。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>让我们测试一下，</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>未来如果需要新增一种小料，只需要新写一个装饰器类，并且可以和之前的小料随意搭配。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>让我们用 <code>js</code> 改写一下，达到同样的效果。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>没有再定义类和接口，<code>js</code> 中用函数直接表示。</p>\n<p>原始的 <code>SimpleMilkTea</code> 方法返回一个奶茶对象，然后又定义了三个装饰函数，传入一个奶茶对象，返回一个装饰后的对象。</p>\n<h1> 代码实现</h1>\n<p>回到文章最开头的场景，我们需要为每个页面加载的时候上报一些自定义数据。其实我们只需要引入一个装饰函数，将传入的 <code>option</code> 进行装饰返回即可。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后回到原始页面增加 <code>Base</code> 的调用即可。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同理，利用装饰器模式我们也可以对其它生命周期统一插入我们需要做的事情，而不需要业务方自己再写一遍。</p>\n<p>在大团队的话，每个业务方可能都需要在小程序生命周期做一些事情，此时只需要利用装饰器模式，编写一个装饰函数，然后在业务代码中调用即可。</p>\n<p>最终的业务代码可能会装饰很多层，最终才传给小程序 <code>Page</code> 函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 易混设计模式</h1>\n<p>如果之前看过 <a href=\"https://www.h7ml.cn/designPattern/proxy.html\" target=\"_blank\" rel=\"noopener noreferrer\">代理模式</a>，到这里可能会有一些困惑，因为和代理模式的作用很像，都是对原有对象进行包装，增强原有对象。</p>\n<p>但还是有很大的不同点：</p>\n<p>代理模式中，我们是直接将原对象封装到代理对象之中，对于业务方并不关心原始对象，直接使用代理对象即可。</p>\n<p>装饰器模式中，我们只提供了装饰函数，输入原始对象，输出增强对象。输出的增强对象，还可以接着传入到新的装饰器函数中继续增强。对于业务方，可以随意组合装饰函数，但得有一个最最开始的原始对象。</p>\n<p>再具体点：</p>\n<p>代理模式的话，对象之间的依赖关系已经写死了，原始对象 <code>A</code>，新增代理对象 <code>A1</code>， <code>A1</code> 的基础上再新增代理对象 <code>A2</code>。如果我们不想要 <code>A1</code> 新增的功能了，我们并不能直接使用 <code>A2</code> ，因为 <code>A2</code> 已经包含了 <code>A1</code> 的功能，我们只能在 <code>A</code> 的基础上再新写一个代理对象 <code>A3</code>。</p>\n<p>而装饰器模式，我们只提供装饰函数 <code>A1</code>，装饰函数 <code>A2</code>，然后对原始对象进行装饰 <code>A2(A1(A))</code>。如果不想要 <code>A1</code> 新增的功能，只需要把 <code>A1</code> 这个装饰器去掉，调用 <code>A2(A)</code> 即可。</p>\n<p>所以使用代理模式还是使用装饰器模式，取决于我们是要把所有功能包装后最终产出一个对象给业务方使用，还是提供许多功能，让业务方自由组合。</p>\n<h1> 总</h1>\n<p>装饰器模式同样践行了「单一职责原则」，可以把对象/函数的各个功能独立出来，降低它们之间的耦合性。</p>\n<p>业务开发中，如果某个对象/函数拥有了太多功能，可以考虑使用装饰器模式进行拆分。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-01-17T07:46:19.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "工厂模式",
      "url": "https://www.h7ml.cn/posts/designPattern/factory.html",
      "id": "https://www.h7ml.cn/posts/designPattern/factory.html",
      "summary": "工厂模式是如果业务场景中需要创建多个类似的对象，然后充斥了大量的 if...else... ，此时可以将创建对象的部分抽离出来。 简单工厂模式就是直接抽离，什么都不改，只是将 if..else... 进行了转移。 工厂模式是每一个对象都创建一个工厂类，业务中先得到一个工厂，然后通过工厂得到对象。 抽象工厂模式是每一个工厂类可以生成多种对象。 GoF 中只有工厂模式和抽象工厂模式。 目前开发中还没有遇到过，此处留坑。",
      "content_html": "<p>工厂模式是如果业务场景中需要创建多个类似的对象，然后充斥了大量的 <code>if...else...</code> ，此时可以将创建对象的部分抽离出来。</p>\n<p>简单工厂模式就是直接抽离，什么都不改，只是将 <code>if..else...</code> 进行了转移。</p>\n<p>工厂模式是每一个对象都创建一个工厂类，业务中先得到一个工厂，然后通过工厂得到对象。</p>\n<p>抽象工厂模式是每一个工厂类可以生成多种对象。</p>\n<p><code>GoF</code> 中只有工厂模式和抽象工厂模式。</p>\n<p>目前开发中还没有遇到过，此处留坑。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-03-03T08:12:19.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "享元模式",
      "url": "https://www.h7ml.cn/posts/designPattern/flyweight.html",
      "id": "https://www.h7ml.cn/posts/designPattern/flyweight.html",
      "summary": "享元模式主要用于性能优化，当出现大量的重复对象时，为了防止内存被撑爆，可以抽离一些公共部分进行共享。 目前开发中还没有遇到过，此处留坑。",
      "content_html": "<p>享元模式主要用于性能优化，当出现大量的重复对象时，为了防止内存被撑爆，可以抽离一些公共部分进行共享。</p>\n<p>目前开发中还没有遇到过，此处留坑。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-02-26T18:54:19.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "中介者模式",
      "url": "https://www.h7ml.cn/posts/designPattern/intermediary.html",
      "id": "https://www.h7ml.cn/posts/designPattern/intermediary.html",
      "summary": "中介者模式用于解决多个对象之间交互过于复杂的问题，从多对多的关系转为一对多的关系。 img 和 观察者 模式有些像，区别在于观察模式中的 EventBus 不处理业务逻辑，只是单纯的转发消息。",
      "content_html": "<p>中介者模式用于解决多个对象之间交互过于复杂的问题，从多对多的关系转为一对多的关系。</p>\n<figure><img src=\"https://static001.geekbang.org/resource/image/43/9f/4376d541bf17a029f37aa76009ef3a9f.jpg\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>和 <a href=\"https://www.h7ml.cn/designPattern/observer.html\" target=\"_blank\" rel=\"noopener noreferrer\">观察者</a> 模式有些像，区别在于观察模式中的 <code>EventBus</code> 不处理业务逻辑，只是单纯的转发消息。</p>\n<p>但中介者对象需要知道各个对象的功能，处理相关逻辑。</p>\n<p>目前开发中还没有遇到过，此处留坑。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-03-03T08:12:19.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "解释器模式",
      "url": "https://www.h7ml.cn/posts/designPattern/interpreter.html",
      "id": "https://www.h7ml.cn/posts/designPattern/interpreter.html",
      "summary": "解释器模式应用在对自定义语法的解释上，自己规定一些新语法，然后通过解释器模式，语法的每种表达式进行细分，最终解释整个表达式。 可能会用在编译器、规则引擎上。 目前自己还没有遇到过，此处留坑。",
      "content_html": "<p>解释器模式应用在对自定义语法的解释上，自己规定一些新语法，然后通过解释器模式，语法的每种表达式进行细分，最终解释整个表达式。</p>\n<p>可能会用在编译器、规则引擎上。</p>\n<p>目前自己还没有遇到过，此处留坑。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-03-03T08:12:19.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "迭代器模式",
      "url": "https://www.h7ml.cn/posts/designPattern/iteratorPattern.html",
      "id": "https://www.h7ml.cn/posts/designPattern/iteratorPattern.html",
      "summary": "场景 for...of.... 的原理是？ 迭代器模式 看下 维基百科 给的定义： In object-oriented programming, the iterator pattern is a design pattern in which an iterator is used to traverse a container and access the container's elements. The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled.",
      "content_html": "<h1> 场景</h1>\n<p><code>for...of....</code> 的原理是？</p>\n<h1> 迭代器模式</h1>\n<p>看下 <a href=\"https://en.wikipedia.org/wiki/Iterator_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科</a> 给的定义：</p>\n<blockquote>\n<p>In <a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\" target=\"_blank\" rel=\"noopener noreferrer\">object-oriented programming</a>, the <strong>iterator pattern</strong> is a <a href=\"https://en.wikipedia.org/wiki/Design_pattern_(computer_science)\" target=\"_blank\" rel=\"noopener noreferrer\">design pattern</a> in which an <a href=\"https://en.wikipedia.org/wiki/Iterator\" target=\"_blank\" rel=\"noopener noreferrer\">iterator</a> is used to traverse a <a href=\"https://en.wikipedia.org/wiki/Container_(data_structure)\" target=\"_blank\" rel=\"noopener noreferrer\">container</a> and access the container's elements. The iterator pattern decouples <a href=\"https://en.wikipedia.org/wiki/Algorithm\" target=\"_blank\" rel=\"noopener noreferrer\">algorithms</a> from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled.</p>\n</blockquote>\n<p>说白了就是有个容器类，有一个迭代器类，容器类持有一个迭代器类的对象，然后我们不需要知道容器中元素的具体结构，通过迭代器对象就能够进行遍历。</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220226101825545.png\" alt=\"image-20220226101825545\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220226101825545</figcaption></figure>\n<p>不妨可以看下 <code>java</code> 的具体实现：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>容器类使用 <code>java</code> 自带的 <code>ArrayList</code> 类，然后我们手动实现一个迭代器类 <code>ArrayIterator</code>。</p>\n<h1> js 的迭代器模式</h1>\n<p><code>js</code> 中我们不需要专门定义迭代器的类了，我们可以让容器包含一个 <code>Symbol.iterator</code> 方法，该方法返回一个迭代器对象。</p>\n<p>迭代器对象包含一个 <code>next</code> 方法用来获取元素，同时获取到的元素除了本身的 <code>value</code> 外，还返回一个布尔型变量代表是否有下一个元素。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>事实上，数组已经为我们提前实现了迭代器，我们直接通过 <code>Symbol.iterator</code> 方法拿到，不需要自己再实现了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>还有字符串也为我们内置了迭代器。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同理，<code>Map</code>、<code>Set</code> 都帮我们内置了 <code>Symbol.iterator</code> 方法，可以返回一个迭代器。</p>\n<p>此外，我们也不需要每次都去 <code>while</code> 循环、然后判断是否结束循环了，直接使用 <code>for...of...</code> 即可。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 注意</h1>\n<p>因为数组是通过 <code>index</code> 来获取元素的，如果在遍历过程中删除元素，可能会产生非预期内的事情。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以先思考下会怎么输出，然后看下结果：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们是成功删除了 <code>wind</code> ，但是原数组中 <code>liang</code> 就不会遍历到了，也比较好理解。</p>\n<p>开始的时候，指针 <code>index</code> 指向 <code>wind</code>，进行了输出 <code>console.log(a); // wind</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>此时删除了 <code>wind</code> ，<code>array.splice(0, 1);</code> 数组整体前移。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后指针后移，遍历下个元素。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>就直接走到 <code>亮</code> 了，而没有遍历 <code>liang</code> 。</p>\n<p>原因就是 <code>liang</code> 的位置之前是 <code>wind</code> ，<code>wind</code> 之前已经遍历过了，指针后移就把 <code>liang</code> 跳过了。</p>\n<h1> 总</h1>\n<p>迭代器模式的好处就是可以不知道容器中元素的结构就可以遍历，一般由容器提供一个迭代器供我们使用。为了实现不同的遍历顺序，只需要提供新的迭代器即可。</p>\n<p>一般编程语言中都内置了迭代器，<code>js</code> 也不例外，在 <code>Array</code>、<code>String</code>、<code>Map</code>、<code>Set</code> 中都内置了<code>Symbol.iterator</code> 方法返回一个迭代器对象，同时提供了<code>for...of...</code> 语法统一了各个对象的遍历方式。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-02-26T09:09:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "备忘录模式",
      "url": "https://www.h7ml.cn/posts/designPattern/memorandum.html",
      "id": "https://www.h7ml.cn/posts/designPattern/memorandum.html",
      "summary": "备忘录模式主要是用于来防丢失、撤销、恢复等场景，定义是：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。 需要三个类， Memento 类提供保存对象和得到对象的方法， Originator 类利用 Memento 类提供保存和读取自身状态的方法，Caretaker 类来记录所有的备份。 把 维基百科 的例子贴过来。",
      "content_html": "<p>备忘录模式主要是用于来防丢失、撤销、恢复等场景，定义是：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</p>\n<p>需要三个类， <code>Memento</code> 类提供保存对象和得到对象的方法， <code>Originator</code> 类利用 <code>Memento</code> 类提供保存和读取自身状态的方法，<code>Caretaker</code> 类来记录所有的备份。</p>\n<p>把 <a href=\"https://en.wikipedia.org/wiki/Memento_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科</a> 的例子贴过来。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-03-03T08:12:19.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "观察者模式",
      "url": "https://www.h7ml.cn/posts/designPattern/observer.html",
      "id": "https://www.h7ml.cn/posts/designPattern/observer.html",
      "summary": "场景 假设我们在开发一款外卖网站，进入网站的时候，第一步需要去请求后端接口得到用户的常用外卖地址。然后再去请求其他接口、渲染页面。如果什么都不考虑可能会直接这样写： // getAddress 异步请求 // 页面里有三个模块 A，B，C 需要拿到地址后再进行下一步 // A、B、C 三个模块都是不同人写的，提供了不同的方法供我们调用 getAddress().then((res) =&gt; { const address = res.address; A.update(address); B.next(address); C.change(address); });",
      "content_html": "<h1> 场景</h1>\n<p>假设我们在开发一款外卖网站，进入网站的时候，第一步需要去请求后端接口得到用户的常用外卖地址。然后再去请求其他接口、渲染页面。如果什么都不考虑可能会直接这样写：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>此时页面里多了一个模块 <code>D</code> ，同样需要拿到地址后进行下一步操作，我们只好去翻请求地址的代码把 <code>D</code> 模块的调用补上。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到各个模块和获取地址模块耦合严重，<code>A</code>、<code>B</code>、<code>C</code> 模块有变化或者有新增模块，都需要深入到获取地址的代码去修改，一不小心可能就改出问题了。</p>\n<p>此时就需要观察者模式了。</p>\n<h1> 观察者模式</h1>\n<p>可以看下 <a href=\"https://en.wikipedia.org/wiki/Observer_pattern#cite_note-5\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科</a>的介绍：</p>\n<blockquote>\n<p>The <strong>observer pattern</strong> is a <a href=\"https://en.wikipedia.org/wiki/Software_design_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">software design pattern</a> in which an <a href=\"https://en.wikipedia.org/wiki/Object_(computer_science)#Objects_in_object-oriented_programming\" target=\"_blank\" rel=\"noopener noreferrer\">object</a>, named the <strong>subject</strong>, maintains a list of its dependents, called <strong>observers</strong>, and notifies them automatically of any state changes, usually by calling one of their <a href=\"https://en.wikipedia.org/wiki/Method_(computer_science)\" target=\"_blank\" rel=\"noopener noreferrer\">methods</a>.</p>\n</blockquote>\n<p>很好理解的一个设计模式，有一个 <code>subject</code> 对象，然后有很多 <code>observers</code> 观察者对象，当 <code>subject</code> 对象有变化的时候去通知 <code>observer</code> 对象即可。</p>\n<p>再看一下 <code>UML</code> 图和时序图：</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220127110751274.png\" alt=\"image-20220127110751274\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220127110751274</figcaption></figure>\n<p>每一个观察者都实现了 <code>update</code> 方法，并且调用 <code>Subject</code> 对象的 <code>attach</code> 方法订阅变化。当 <code>Subject</code> 变化时，调用 <code>Observer</code> 的 <code>update</code> 方法去通知观察者。</p>\n<p>先用 <code>java</code> 写一个简单的例子：</p>\n<p>公众号文章可以看作是 <code>Subject</code> ，会不定期更新。然后每一个用户都是一个 <code>Observer</code> ，订阅公众号，当更新的时候就可以第一时间收到消息。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果如下：</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220129125814418.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>上边的实现主要是为了符合最原始的定义，调用 <code>update</code> 的时候没有传参。如果观察者需要的参数是一致的，其实这里也可以直接把更新后的数据传过去，这样观察者就不需要向上边一样再去调用 <code>subject.getPost()</code> 手动拿更新后的数据了。</p>\n<p>这两种不同的方式前者叫做拉 <code>(pull)</code> 模式，就是收到 <code>Subject</code> 的通知后，通过内部的 <code>Subject</code> 对象调用相应的方法去拿到需要的数据。</p>\n<p>后者叫做推 <code>(push)</code> 模式，<code>Subject</code> 更新的时候就将数据推给观察者，观察者直接使用即可。</p>\n<p>下边用 <code>js</code> 改写为推模式：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 <code>js</code> 中，我们可以直接将 <code>update</code> 方法传给 <code>Subject</code> ，同时采取推模式，调用 <code>update</code> 的时候直接将数据传给观察者，看起来会简洁很多。</p>\n<h1> 代码实现</h1>\n<p>回到开头的场景，我们可以利用观察者模式将获取地址后的一系列后续操作解耦出来。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过观察者模式我们将获取地址后的操作解耦了出来，未来有新增模块只需要注册观察者即可。</p>\n<p>当 <code>getAddress</code> 很复杂的时候，通过观察者模式会使得未来的改动变得清晰，不会影响到 <code>getAddress</code> 的逻辑。</p>\n<p>必要的话也可以把 <code>observers</code> 抽离到一个新的文件作为一个新模块，防止让一个文件变得过于臃肿。</p>\n<h1> 总</h1>\n<p>观察者模式比较好理解，通过抽象出一个 <code>Subject</code> 和多个观察者，减轻了它们之间的过度耦合。再说简单点就是利用回调函数，异步完成后调用传入的回调即可。但上边写的观察者模式还是有一些缺点：</p>\n<ul>\n<li><code>Subject</code> 仍需要自己维护一个观察者列表，进行 <code>push</code> 和 <code>update</code>。</li>\n<li>如果有其他的模块也需要使用观察者模式，还需要模块本身再维护一个新的观察者列表，而不能复用之前的代码。</li>\n<li><code>Subject</code> 需要知道观察者提供了什么方法以便未来的时候进行回调。</li>\n</ul>\n<p>下一篇文章会继续改进上边的写法，观察者模式的本质思想不变（某个对象变化，然后通知其他观察者对象进行更新）。</p>\n<p>但写法上会引入一个中间平台，便于代码更好的复用，使得 <code>Subject</code> 和观察者进行更加彻底的解耦，同时给了它一个新的名字「发布订阅模式」。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-01-27T09:22:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "原型模式",
      "url": "https://www.h7ml.cn/posts/designPattern/prototype.html",
      "id": "https://www.h7ml.cn/posts/designPattern/prototype.html",
      "summary": "原型模式在基于类的语言中作用大一些，当构造函数比较复杂，有一些耗时操作，此时通过 new 去创建对象不划算，可以通过 clone 的方法，直接基于已有对象 copy 一个。 js 属于基于原型的面向对象的编程语言，本身就是基于一个对象来生成另一个对象，并没有真正的类。 我们可以直接通过 Object.create 或者 json 序列化反序列化 copy 一个对象。",
      "content_html": "<p>原型模式在基于类的语言中作用大一些，当构造函数比较复杂，有一些耗时操作，此时通过 <code>new</code> 去创建对象不划算，可以通过 <code>clone</code> 的方法，直接基于已有对象 <code>copy</code> 一个。</p>\n<p><code>js</code> 属于基于原型的面向对象的编程语言，本身就是基于一个对象来生成另一个对象，并没有真正的类。</p>\n<p>我们可以直接通过 <code>Object.create</code> 或者 <code>json</code> 序列化反序列化 <code>copy</code> 一个对象。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-02-27T11:53:19.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "代理模式",
      "url": "https://www.h7ml.cn/posts/designPattern/proxy.html",
      "id": "https://www.h7ml.cn/posts/designPattern/proxy.html",
      "summary": "场景 平常业务开发中， 对于网络请求，我们一般会封装成一个模块，并且暴露 get、post 方法供大家使用。 // src/util/request.js import Http from '../http'; export function get(options) { return Http.get(options); } export function post(obj) { return Http.post(options); }",
      "content_html": "<h1> 场景</h1>\n<p>平常业务开发中， 对于网络请求，我们一般会封装成一个模块，并且暴露 <code>get</code>、<code>post</code> 方法供大家使用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Http</code> 模块主要是将 <code>ajax</code> 请求封装，填充一些 <code>headers</code> 等等，然后业务方使用的时候只需要引入上边的 <code>get</code>、<code>post</code> 即可。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>现在有了一个新需求，我们需要将第一次请求中，后端返回请求中的 <code>graytype</code> 字段塞到后续请求中的 <code>headers</code> ，也就是下边这样。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果只是一个请求的话就按上边这样改就可以了，但如果是多个请求一个一个这样去改就有些傻了。</p>\n<p>那直接去改 <code>Http</code> 模块？也是不行的，增加 <code>graytype</code> 字段只是我们负责业务的改变，而 <code>Http</code> 模块是所有业务线所共用的，我们并不能直接去改变它。</p>\n<p>此时就需要代理模式了。</p>\n<h1> 代理模式</h1>\n<p>贴一下 <a href=\"https://en.wikipedia.org/wiki/Proxy_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科</a>的一些解释：</p>\n<blockquote>\n<h3> What problems can the Proxy design pattern solve?</h3>\n<ul>\n<li>The access to an object should be controlled.</li>\n<li>Additional functionality should be provided when accessing an object.</li>\n</ul>\n<h3> What solution does the Proxy design pattern describe?</h3>\n<p>Define a separate <code>Proxy</code> object that</p>\n<ul>\n<li>can be used as substitute for another object (<code>Subject</code>) and</li>\n<li>implements additional functionality to control the access to this subject.</li>\n</ul>\n</blockquote>\n<p>代理模式就是对原有对象进行扩展，从而实现对原对象的控制或者进行额外的操作，不同场景下代理模式又可以细分出很多类别：</p>\n<ol>\n<li>\n<p>远程代理：通过代理模式，实现像操作本地对象一样的操作远程对象。</p>\n</li>\n<li>\n<p>虚拟代理：In place of a complex or heavy object, a skeleton representation may be advantageous in some cases. 常见的比如大图的加载，我们可以通过引入代理对象，先加载一张小图，大图加载完毕后再显示大图。</p>\n</li>\n<li>\n<p>保护代理：将原有对象的属性访问进行权限控制。</p>\n</li>\n<li>\n<p>缓存代理：引入缓存，将之前的结果进行缓存，常见的比如斐波那契数列。</p>\n<p>...</p>\n</li>\n</ol>\n<p>不管起了什么新名字，它们的本质都是一样的，如果用类图表示就是下边的样子：</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220108105835662.png\" alt=\"image-20220108105835662\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220108105835662</figcaption></figure>\n<p>原对象 <code>RealSubject</code> 和 <code>Proxy</code> 对象都继承了 <code>Subject</code> 这个接口，客户端 <code>Client</code> 调用 <code>DoAction()</code> 方法，先经过代理对象 <code>Proxy</code> ，然后由 <code>Proxy</code> 做一些额外的操作，最终再委托给 <code>RealSubject</code> 进行执行。</p>\n<p>看一个 <code>Java</code> 的示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>原有的 <code>RealImage</code> 类在 <code>new</code> 对象的时候就会调用 <code>loadImageFromDisk</code>，如果之后没有调用 <code>displayImage</code> 并且 <code>loadImageFromDisk</code> 比较占资源，那就会是一种浪费。</p>\n<p>通过 <code>ProxyImage</code> ，其内部持有 <code>RealImage</code> 的对象，当调用 <code>displayImage</code> 再去实例化对象，实现了对象的延迟加载。</p>\n<p>当然也带来了坏处，可能会导致第一次调用 <code>displayImage</code> 的时候比较耗时。因此，在这个示例下是否引入代理模式，就看实际场景下的取舍了。</p>\n<p>我们再用 <code>js</code> 来改写一下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>整体思想是一样的，但 <code>js</code> 不用定义接口，也不用定义类，看起来精简了不少。只需要实现和原对象一样的返回即可。</p>\n<h1> 代码实现</h1>\n<p>回到最开始的场景：现在有了一个新需求，我们需要将第一次请求中，后端返回请求中的 <code>graytype</code> 字段塞到后续请求中的 <code>headers</code> 。</p>\n<p>我们可以通过代理模式将 <code>request.js</code> 中的 <code>get</code> 和 <code>post</code> 进行封装，然后同样暴露出 <code>get</code> 和<code>post</code> 即可。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们将原有的 <code>get</code> 和 <code>post</code> 导入，因为还需要导出 <code>get</code> 和 <code>post</code> ，所以将导入的重命名为 <code>Get</code> 和 <code>Post</code> 。</p>\n<p>然后在请求前将 <code>grayType</code> 塞入到 <code>headers</code> ，并且 <code>get</code> 和 <code>post</code> 的时候给 <code>grayType</code> 进行赋值。</p>\n<p>这样在实际业务中，如果需要 <code>grayType</code> ，我们只需要从新写的 <code>src/util/requestNew.js</code> 引入 <code>get</code> 和 <code>post</code> 即可，其他什么都不需要改动。</p>\n<h1> 总</h1>\n<p>代理模式其实说简单了就是对原有对象/函数再包装一层，并且保持和原对象一致的行为。那么为什么不直接改原对象呢？</p>\n<p>第一，可能不方便直接改原对象，所以只能采取代理模式包一层了。</p>\n<p>第二，「单一职责原则」，如果直接修改原对象，会增加原有对象的复杂度，原对象如果负责的职责过多，引起对象改动的原因就会增多。</p>\n<p>第三，未来如果新功能要去掉，修改起来也不方便。如果使用了代理模式，只需要把原来引用的地方还原即可。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-01-07T08:20:25.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "发布订阅模式",
      "url": "https://www.h7ml.cn/posts/designPattern/publishSubscribe.html",
      "id": "https://www.h7ml.cn/posts/designPattern/publishSubscribe.html",
      "summary": "建议先看一下上篇 观察者模式 ，发布订阅模式和观察者模式本质上还是一样的，并且发布订阅模式也没有在经典的设计模式书 GoF 中出现，很多地方也直接把两者看成一种设计模式了。 GoF 的名字也有个有趣的故事，这里 贴过来：",
      "content_html": "<p><strong>建议先看一下上篇</strong> <a href=\"https://www.h7ml.cn/designPattern/observer.html\" target=\"_blank\" rel=\"noopener noreferrer\">观察者模式</a> ，发布订阅模式和观察者模式本质上还是一样的，并且发布订阅模式也没有在经典的设计模式书 <code>GoF</code> 中出现，很多地方也直接把两者看成一种设计模式了。</p>\n<p><code>GoF</code> 的名字也有个有趣的故事，<a href=\"http://wiki.c2.com/?GangOfFour\" target=\"_blank\" rel=\"noopener noreferrer\">这里</a> 贴过来：</p>\n<blockquote>\n<p>The authors of the <a href=\"http://wiki.c2.com/?DesignPatternsBook\" target=\"_blank\" rel=\"noopener noreferrer\">DesignPatternsBook</a> came to be known as the \"Gang of Four.\" The name of the book (\"Design Patterns: Elements of Reusable Object-Oriented Software\") is too long for e-mail, so \"book by the gang of four\" became a shorthand name for it. After all, it isn't the ONLY book on patterns. That got shortened to \"GOF book\", which is pretty cryptic the first time you hear it.</p>\n</blockquote>\n<h1> 场景</h1>\n<p>假设我们在开发一款外卖网站，进入网站的时候，第一步需要去请求后端接口得到用户的常用外卖地址。然后再去请求其他接口、渲染页面。如果使用了观察者模式可能会这样写：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>getAddress</code> 模块和其他 <code>A</code> 、<code>B</code>、<code>C</code> 三个模块已经实现了解耦，但仍需要维护 <code>observers</code> 这个数组来注册观察者，同时还需要知道各个模块提供了什么方法用于回调。</p>\n<p>我们可以使用发布订阅模式，让 <code>getAddress</code> 模块和其他 <code>A</code> 、<code>B</code>、<code>C</code> 三个模块解耦的更加彻底。</p>\n<h1> 发布订阅模式</h1>\n<p>回忆一下观察者模式：</p>\n<blockquote>\n<p>The <strong>observer pattern</strong> is a <a href=\"https://en.wikipedia.org/wiki/Software_design_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">software design pattern</a> in which an <a href=\"https://en.wikipedia.org/wiki/Object_(computer_science)#Objects_in_object-oriented_programming\" target=\"_blank\" rel=\"noopener noreferrer\">object</a>, named the <strong>subject</strong>, maintains a list of its dependents, called <strong>observers</strong>, and notifies them automatically of any state changes, usually by calling one of their <a href=\"https://en.wikipedia.org/wiki/Method_(computer_science)\" target=\"_blank\" rel=\"noopener noreferrer\">methods</a>.</p>\n</blockquote>\n<p>观察者模式中，<code>Subject</code> 自己维护观察者列表进行注册和通知。</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220130170413954.png\" alt=\"image-20220130170413954\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220130170413954</figcaption></figure>\n<p>发布订阅模式的话，引入一个中间平台进行注册和通知，相当于从 <code>Subject</code> 中解耦出来。</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220130171806687.png\" alt=\"image-20220130171806687\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220130171806687</figcaption></figure>\n<p>观察者通过 <code>on</code> 向 <code>EventBus</code> 注册事件，然后 <code>Subject</code> 通过 <code>emit</code> 向 <code>EventBus</code> 发射事件，由 <code>EventBus</code> 来向观察者更新。</p>\n<p>接下来实现一个简单的 <code>EventBus</code> 。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们通过 <code>observersMap</code> 将不同的事件保存为不同的数组，<code>emit</code> 的时候得到对应的数组去调用即可。看下例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 代码实现</h1>\n<p>让我们改造下开头写的观察者模式的代码：</p>\n<p>地址模块：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>A</code> 模块</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>B</code> 模块</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>C</code> 模块</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到 <code>getAddress</code> 模块不再需要关心观察者有谁，它只需要向 <code>EventBus</code> 发射更新事件即可。</p>\n<p>每个模块内部自己如果需要地址信息，只需要订阅相关事件，然后传入回调函数即可。</p>\n<h1> 特殊情况</h1>\n<p>实际工程中可能遇到一些特殊场景，由于 <code>emit</code> 一般在一个异步事件中执行，如果这个异步事件突然执行的变快了，就可能造成某个事件先 <code>emit</code> 了，然后某个模块才进行了 <code>on</code> 。</p>\n<p>此时我们可以对 <code>EventBus</code> 进行一定的改写，使得先订阅事件，后触发事件成为可能。</p>\n<p>为了不改动原有逻辑，我们可以通过 <a href=\"https://www.h7ml.cn/designPattern/proxy.html\" target=\"_blank\" rel=\"noopener noreferrer\">代理模式</a> 进行改写。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 <code>trigger</code> 的时候，如果 <code>offlineStack</code> 不为 <code>null</code>，说明还没有调用过 <code>listen</code>，此时将当前事件保存起来。</p>\n<p><code>listen</code> 的时候遍历之前保存的事件，并且将 <code>offlineStack</code> 置为 <code>null</code>，表示已经调用过 <code>listen</code> 了。</p>\n<p>看一下效果：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>虽然是先进行的 <code>emit</code> 后进行的 <code>on</code> 的，但依旧会正常执行。</p>\n<p>上边的解决方案很粗略，只适用于有一个事件并且只有一个 <code>on</code> 的场景，不然的话比如下边的情况：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>只有 <code>XiaoMing.update</code> 会执行，后边两句就会错过第一次的 <code>emit</code> ，因为执行一次 <code>listen</code> 就把缓存清空了。</p>\n<p>或者在 <code>writePost</code> 之前有了一次 <code>on</code> 了：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同样只有 <code>XiaoMing.update</code> 会执行，后边两句就会错过第一次的 <code>emit</code> 了，因为执行一次 <code>listen</code> 就把缓存清空了。</p>\n<p>对于实际场景，我们还需要根据情况继续进行调整。</p>\n<h1> 总</h1>\n<p>发布订阅模式相对于最原始的观察者模式将 <code>Subject</code> 和 <code>Observers</code> 进行了彻底解耦，<code>Subject</code> 不再需要关心谁订阅了它，<code>Observer</code> 只需要在自己内部订阅它所关心的事件即可。</p>\n<p>通过封装好的 <code>EventBus</code> 也实现了更好的复用，不需要每个模块都去维护自己的观察者列表。</p>\n<p>但同时也带来了坏处，所有的事件订阅分散在各个模块，没有一个全局视角知道某个事件被哪些模块订阅了，可能会导致程序难以理解和调试。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-01-30T11:04:52.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "单例模式",
      "url": "https://www.h7ml.cn/posts/designPattern/singleton.html",
      "id": "https://www.h7ml.cn/posts/designPattern/singleton.html",
      "summary": "场景 如果需要实现一个全局的 loading 遮罩层，正常展示是这样的： image-20220206173318902",
      "content_html": "<h1> 场景</h1>\n<p>如果需要实现一个全局的 <code>loading</code> 遮罩层，正常展示是这样的：</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220206173318902.png\" alt=\"image-20220206173318902\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220206173318902</figcaption></figure>\n<p>但如果用户连续调用 <code>loaing</code> 两次，第二个遮罩层就会覆盖掉第一个：</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220206173534676.png\" alt=\"image-20220206173534676\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220206173534676</figcaption></figure>\n<p>看起来就像出了 <code>bug</code> 一样，因此我们需要采用单例模式，限制用户同一时刻只能调用一个全局 <code>loading</code> 。</p>\n<h1> 单例模式</h1>\n<p>看下 <a href=\"https://en.wikipedia.org/wiki/Singleton_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科</a> 给的定义：</p>\n<blockquote>\n<p>In <a href=\"https://en.wikipedia.org/wiki/Software_engineering\" target=\"_blank\" rel=\"noopener noreferrer\">software engineering</a>, the <strong>singleton pattern</strong> is a <a href=\"https://en.wikipedia.org/wiki/Software_design_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">software design pattern</a> that restricts the <a href=\"https://en.wikipedia.org/wiki/Instantiation_(computer_science)\" target=\"_blank\" rel=\"noopener noreferrer\">instantiation</a> of a <a href=\"https://en.wikipedia.org/wiki/Class_(computer_programming)\" target=\"_blank\" rel=\"noopener noreferrer\">class</a> to one \"single\" instance. This is useful when exactly one object is needed to coordinate actions across the system.</p>\n</blockquote>\n<p>可以说是最简单的设计模式了，就是保证类的实例只有一个即可。</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220206181649135.png\" alt=\"image-20220206181649135\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220206181649135</figcaption></figure>\n<p>看一下 <code>java</code> 的示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上边在初始化类的时候就进行了创建对象，并且将构造函数设置为 <code>private</code> 不允许外界调用，提供 <code>getInstance</code> 方法获取对象。</p>\n<p>还有一种 <code>Lazy initialization</code> 的模式，也就是延迟到调用 <code>getInstance</code> 的时候才去创建对象。但如果多个线程中同时调用 <code>getInstance</code> 可能会导致创建多个对象，所以还需要进行加锁。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但单例模式存在很多争议，比如可测试性不强、对抽象、继承、多态都支持得不友好等等，但我感觉主要是基于 <code>class</code> 这类语言引起的问题，这里就不讨论了。</p>\n<p>回到 <code>js</code> ，模拟上边实现一下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但上边就真的是邯郸学步一样的模仿了 <code>java</code> 的实现，事实上，<code>js</code> 创建对象并不一定需要通过 <code>new</code> 的方式，下边我们详细讨论下。</p>\n<h1> js 的单例模式</h1>\n<p>首先单例模式产生的对象一般都是工具对象等，比如 <code>jQuery</code> 。它不需要我们通过构造函数去传参数，所以就不需要去 <code>new</code> 一个构造函数去生成对象。</p>\n<p>我们只需要通过字面量对象， <code>var a = {}</code> ，<code>a</code> 就可以看成一个单例对象了。</p>\n<p>通常的单例对象可能会是下边的样子，暴露几个方法供外界使用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但如果<code>Singleton</code> 有私有属性，可以写成下边的样子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但此时外界就可以通过 <code>Singleton</code> 随意修改 <code>privateVar</code> 的值。</p>\n<p>为了解决这个问题，我们可以借助闭包，通过 <code>IIFE (Immediately Invoked Function Expression)</code> 将一些属性和方法私有化。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但随着 <code>ES6</code> 、<code>Webpack</code> 的出现，我们很少像上边那样去定义一个模块了，而是通过单文件，一个文件就是一个模块，同时也可以看成一个<strong>单例对象</strong>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后使用的时候 <code>import</code> 即可。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>即使有另一个文件也 <code>import</code> 了同一个文件。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但这两个不同文件的 <code>Singleton</code> 仍旧是同一个对象，这是 <code>ES Moudule</code> 的特性。</p>\n<p>那如果通过 <code>Webpack</code> 将 <code>ES6</code> 转成 <code>ES5</code> 以后呢，这种方式还会是单例对象吗？</p>\n<p>答案当然是肯定的，可以看一下 <code>Webpack</code> 打包的产物，其实就是使用了 <code>IIFE</code> ，同时将第一次 <code>import</code> 的模块进行了缓存，第二次 <code>import</code> 的时候会使用之前的缓存。可以看下 <code>__webpack_require__</code> 的实现，和单例模式的逻辑是一样的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 代码实现</h1>\n<p>回头开头我们说的全局 <code>loading</code> 的问题，解决起来也很简单，同样的，如果已经有了 <code>loading</code> 的实例，我们只需要直接返回即可。</p>\n<p>这里直接看一下 <code>ElementUI</code> 对于全局 <code>loading</code> 的处理。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样在使用 <code>Element</code> 的 <code>loading</code> 的时候，如果同时调用两次，其实只会有一个 <code>loading</code> 的遮罩层，第二个并不会显示。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 更多场景</h1>\n<p>如果使用了 <code>ES6</code> 的模块，其实就不用考虑单不单例的问题了，但如果我们使用的第三方库，它没有 <code>export</code> 一个实例对象，而是 <code>export</code> 一个 <code>function/class</code> 呢？</p>\n<p>比如之前介绍的 <a href=\"https://www.h7ml.cn/designPattern/publishSubscribe.html\" target=\"_blank\" rel=\"noopener noreferrer\">发布-订阅模式</a> 的 <code>Event</code> 对象，这个肯定需要是全局单例的，如果我们使用 <code>eventemitter3</code> 这个 <code>node</code> 包，看一下它的导出：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到它直接将 <code>EventEmitter</code> 这个函数导出了，如果每个页面都各自 <code>import</code> 它，然后通过 <code>new EventEmitter()</code> 来生成对象，那发布订阅就乱套了，因为它们不是同一个对象了。</p>\n<p>此时，我们可以新建一个模块，然后 <code>export</code> 一个实例化对象，其他页面去使用这个对象就实现单例模式了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 总</h1>\n<p>单例模式比较简单，主要是保证全局对象唯一，但相对于通过 <code>class</code> 生成对象的单例模式，<code>js</code> 就很特殊了。</p>\n<p>因为在 <code>js</code> 中我们可以直接生成对象，并且这个对象就是全局唯一，所以在 <code>js</code> 中，单例模式是浑然天成的，我们平常并不会感知到。</p>\n<p>尤其是现在开发使用 <code>ES6</code> 模块，每个模块也同样是一个单例对象，平常业务开发中也很少去应用单例模式，为了举出上边的例子真的是脑细胞耗尽了，哈哈。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-02-06T17:31:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "状态模式",
      "url": "https://www.h7ml.cn/posts/designPattern/state.html",
      "id": "https://www.h7ml.cn/posts/designPattern/state.html",
      "summary": "状态模式主要应用在游戏、工作流引擎中，其实就是有限状态机的实现，目前开发中还没有遇到过，此处留坑。 但状态模式也比较有意思，它可以将过多的 if...else... 或者 switch...case... 抽离出来，使得代码的扩展性更好一些。 举个例子，详细解释可以查看极客时间的 设计模式之美 讲的。 一个超级马里奥的例子，吃了蘑菇、吃了花都会有不同的状态进行转移。",
      "content_html": "<p>状态模式主要应用在游戏、工作流引擎中，其实就是有限状态机的实现，目前开发中还没有遇到过，此处留坑。</p>\n<p>但状态模式也比较有意思，它可以将过多的 <code>if...else...</code> 或者 <code>switch...case...</code> 抽离出来，使得代码的扩展性更好一些。</p>\n<p>举个例子，详细解释可以查看极客时间的 <a href=\"http://gk.link/a/11c3G\" target=\"_blank\" rel=\"noopener noreferrer\">设计模式之美</a> 讲的。</p>\n<p>一个超级马里奥的例子，吃了蘑菇、吃了花都会有不同的状态进行转移。</p>\n<figure><img src=\"https://static001.geekbang.org/resource/image/5a/6c/5aa0310b9b3ea08794cfc2f376c8f96c.jpg\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上边的实现没什么问题，通过 <code>if</code> 来进行状态的转移，并进行相关操作，但可维护性和扩展性都很差。</p>\n<p>我们可以通过状态模式进行改写，将每一种状态抽离出来，将状态的变更委托给状态类实现，原来的类不再处理。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 总</h1>\n<p>状态模式很巧妙，虽然实际开发中还没应用到，但还是很有意思的。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-03-04T08:42:19.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "策略模式",
      "url": "https://www.h7ml.cn/posts/designPattern/strategy.html",
      "id": "https://www.h7ml.cn/posts/designPattern/strategy.html",
      "summary": "场景 进入一个营销活动页面，会根据后端下发的不同 type ，前端页面展示不同的弹窗。 async getMainData() { try { const res = await activityQuery(); // 请求后端数据 this.styleType = res.styleType; if (this.styleType === STYLE_TYPE.Reward) { this.openMoneyPop(); }else if (this.styleType === STYLE_TYPE.Waitreward) { this.openShareMoneyPop(); } else if (this.styleType === STYLE_TYPE.Poster) { this.openPosterPop(); } else if (this.styleType === STYLE_TYPE.Activity) { this.openActivityPop(); } else if (this.styleType === STYLE_TYPE.Balance) { this.openBalancePop(); } else if (this?.styleType === STYLE_TYPE.Cash) { this.openCashBalancePop(); } } catch (error) { log.error(MODULENAME, '主接口异常', JSON.stringify(error)); } }",
      "content_html": "<h1> 场景</h1>\n<p>进入一个营销活动页面，会根据后端下发的不同 <code>type</code> ，前端页面展示不同的弹窗。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个代码的话看了就想打人，未来新增一种弹窗类型的话，我们需要到 <code>getMainData</code> 内部去补一个 <code>else if</code>，一不小心可能就会影响到原有的逻辑，并且随着迭代函数会越来越大。但其实每种弹窗是相互独立的，我们并不关心其他弹窗的逻辑。</p>\n<p>此时，就需要策略模式了。</p>\n<h1> 策略模式</h1>\n<p>看下 <a href=\"https://zh.wikipedia.org/wiki/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科</a> 的定义。</p>\n<blockquote>\n<p>策略模式作为一种<a href=\"https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener noreferrer\">软件设计模式</a>，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在中国交个人所得税”和“在美国交个人所得税”就有不同的算税方法。</p>\n<p>策略模式：</p>\n<ul>\n<li>定义了一族算法（业务规则）；</li>\n<li>封装了每个算法；</li>\n<li>这族的算法可互换代替（interchangeable）。</li>\n</ul>\n</blockquote>\n<p>看一下如果是 <code>Java</code> 语言会怎么实现：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>主要是利用到类的多态，根据传入 <code>Context</code> 中不同的 <code>strategy</code>，来执行不同的 <code>execute()</code>。如果未来有新增算法的话，只需要新增一个类即可。</p>\n<p>那如果是 <code>js</code> 呢？众所周知，<code>ES6</code> 之前 <code>js</code> 是没有 <code>class</code> 关键字的，即使现在有了，也依然只是基于原型的语法糖，底层和 <code>java</code> 的类是完全不同的。</p>\n<p>此外，<code>js</code> 中函数是一等公民，可以当作参数传入和返回，因此实现策略模式我们完全不需要去定一个类，然后通过生成的对象调用方法。在 <code>js</code> 中我们只需要将函数传入即可。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上边主要演示了思想，实际开发中，我们完全可以把每种策略分文件单独写然后再 <code>import</code>。</p>\n<p>相对于 <code>java</code>，写法简单了很多，我们不需要定义各个类，只需要用一个对象来存储所有策略，再提供一个调用策略的函数，甚至这个函数也可以直接省略。</p>\n<h1> 优化代码</h1>\n<p>将所有弹窗方法从业务代码 <code>getMainData</code> 中抽离出来，只暴露一个打开弹窗的函数供业务调用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后就是 <code>popTypes.js</code> 文件。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 更多场景</h1>\n<p>表单验证也是一个典型场景，常用的，我们需要验证用户输入字段是否是数字、是否必填、是否是数组，还有自定义的一些验证，同样可以通过策略模式实现，从而使得代码更易维护和扩展。</p>\n<p>如果使用过 <code>Element UI</code>，对下边表单的 <code>rule</code> 一定很熟悉。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Element</code> 会帮助我们校验 <code>name</code> 是否是 <code>string</code>、<code>age</code> 是否是 <code>number</code>。而 <code>Element</code> 其实是用的一个开源的 <strong><a href=\"https://github.com/yiminghe/async-validator\" target=\"_blank\" rel=\"noopener noreferrer\">async-validator</a></strong> 校验库。</p>\n<p><strong><a href=\"https://github.com/yiminghe/async-validator\" target=\"_blank\" rel=\"noopener noreferrer\">async-validator</a></strong> 内部会内置很多 <code>type</code> 的 <code>validator</code>，然后会根据 <code>rule</code> 中的 <code>type</code> 来帮我们填充相应的 <code>validator</code>。让我们看一下相应的源码。</p>\n<p>首先是 <code>validator</code> 文件夹，会定义很多校验规则，<code>date</code> 类型、<code>number</code> 类型等等，相当于很多策略。</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220106090411041.png\" alt=\"image-20220106090411041\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220106090411041</figcaption></figure>\n<p>然后是上边截图中的 <code>validator/index.ts</code> 文件，将这些策略导出。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>校验前会执行下边的代码，通过 <code>type</code> 填充相应的 <code>validator</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>策略模式的体现就是 <code>getValidationMethod</code> 方法了，让我们看一下实现。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>填充相应的 <code>validator</code> 之后接下来只需要遍历相应的 <code>rule</code> 然后校验就可以了。</p>\n<h1> 总</h1>\n<p>当出现很多 <code>if else</code> 或者 <code>switch</code> 的时候，我们就可以考虑是否能使用策略模式了。</p>\n<p>通过策略模式，我们可以把策略从业务代码中抽离出来，未来扩展的话无需深入到业务代码修改，只需要新增需要的策略，不会使得业务代码变得越来越臃肿。</p>\n<p>甚至策略模式也可以更好的进行复用，如果其他业务场景需要类似的策略，直接引入即可，和原有的业务相互独立。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-01-03T16:09:36.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "模版模式",
      "url": "https://www.h7ml.cn/posts/designPattern/template.html",
      "id": "https://www.h7ml.cn/posts/designPattern/template.html",
      "summary": "场景 示例代码来源于极客时间课程，React Hooks 核心原理与实战，顺便推荐一下，很不错的课程 平常开发中一定遇到过这样的场景：发起异步请求，loading 状态显示，获取数据并显示在界面上，如果遇到错误还会显示错误状态的相关展示。 为了方便运行，先写一个 mock 数据的方法： const list = { page: 1, per_page: 6, total: 12, total_pages: 2, data: [ { id: 1, email: 'george.bluth@reqres.in', first_name: 'windliang', last_name: 'windliang', avatar: 'https://reqres.in/img/faces/1-image.jpg', }, { id: 2, email: 'janet.weaver@reqres.in', first_name: 'Janet', last_name: 'Weaver', avatar: 'https://reqres.in/img/faces/2-image.jpg', }, { id: 3, email: 'emma.wong@reqres.in', first_name: 'Emma', last_name: 'Wong', avatar: 'https://reqres.in/img/faces/3-image.jpg', }, ], }; export const getDataMock = () =&gt; new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(list); }, 2000); });",
      "content_html": "<h1> 场景</h1>\n<p><em>示例代码来源于极客时间课程，<a href=\"http://gk.link/a/118JP\" target=\"_blank\" rel=\"noopener noreferrer\">React Hooks 核心原理与实战</a>，顺便推荐一下，很不错的课程</em></p>\n<p>平常开发中一定遇到过这样的场景：发起异步请求，<code>loading</code> 状态显示，获取数据并显示在界面上，如果遇到错误还会显示错误状态的相关展示。</p>\n<p>为了方便运行，先写一个 <code>mock</code> 数据的方法：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后是列表组件：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>效果就是下边的样子：</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/loadingtemplate2.gif\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>事实上，可能会有很多组件都需要这个过程，<code>loading</code> -&gt; 展示数据 -&gt; <code>loading</code> 消失、错误展示，每一个组件单独维护这一套逻辑就太麻烦了，此时就可以用到模版模式了。</p>\n<h1> 模版模式</h1>\n<p>看下 <a href=\"https://en.wikipedia.org/wiki/Template_method_pattern\" target=\"_blank\" rel=\"noopener noreferrer\">维基百科</a> 给到的定义：</p>\n<blockquote>\n<p>The template method is a method in a superclass, usually an abstract superclass, and defines the skeleton of an operation in terms of a number of high-level steps. These steps are themselves implemented by additional <em>helper methods</em> in the same class as the <em>template method</em>.</p>\n<p>The <em>helper methods</em> may be either <em><a href=\"https://en.wikipedia.org/wiki/Abstract_method\" target=\"_blank\" rel=\"noopener noreferrer\">abstract methods</a></em>, in which case subclasses are required to provide concrete implementations, or <em><a href=\"https://en.wikipedia.org/w/index.php?title=Hook_methods&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener noreferrer\">hook methods</a>,</em> which have empty bodies in the superclass. <a href=\"https://en.wikipedia.org/wiki/Subclass_(computer_science)\" target=\"_blank\" rel=\"noopener noreferrer\">Subclasses</a> can (but are not required to) customize the operation by <a href=\"https://en.wikipedia.org/wiki/Method_overriding\" target=\"_blank\" rel=\"noopener noreferrer\">overriding</a> the hook methods. The intent of the template method is to define the overall structure of the operation, while allowing subclasses to refine, or redefine, certain steps.[<a href=\"https://en.wikipedia.org/wiki/Template_method_pattern#cite_note-:2-2\" target=\"_blank\" rel=\"noopener noreferrer\">2]</a></p>\n</blockquote>\n<p>简单来说，模版模式就是抽象父类提供一个骨架方法，里边会调用一些抽象方法或者空方法，抽象方法/空方法由子类自行去实现，可以看一下 <code>UML</code> 类图。</p>\n<figure><img src=\"http://static.h7ml.cn/vitepress/assets/images/designPattern/windliangblog.oss-cn-beijing.aliyuncs.comimage-20220210212704745.png\" alt=\"image-20220210212704745\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220210212704745</figcaption></figure>\n<p>举一个做饭的简单例子，看一下代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Cook</code> 类提供骨架方法 <code>startCook</code> ，编写了做饭的主要流程，其他抽象方法 <code>prepareIngredients</code> 、 <code>cooking</code> 下放给子类去实现自己独有的逻辑。</p>\n<p>让我们用 <code>js</code> 来改写一下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上边是 <code>js</code> 照猫画虎的去按照 <code>java</code> 的形式去实现模版方法，作为函数是一等公民的 <code>js</code> ，也许我们可以换一种方式。</p>\n<h1> js 的模版模式</h1>\n<p>模板模式是一个方法中定义一个算法骨架，可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>\n<p>原始定义中通过抽象类继承实现，但由于 <code>js</code> 并没有抽象类，实现起来也有些繁琐，也许我们可以通过组合的方式，将需要的方法以参数的形式传给算法骨架。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过组合的方式，代码会变得更加清爽简单，不需要再定义 <code>TomatoEgg</code> 类和 <code>Potato</code> 类，只需要简单的传参。</p>\n<p>但 <code>js</code> 实现的只能是带引号的模版方法了，一方面我们并没有通过继承去实现，另一方面 <code>js</code> 并没有抽象类、抽象方法的功能，如果某些方法没有实现，并不能在代码编写阶段发现，到了运行阶段才会收到 <code>Error</code>。</p>\n<h1> 代码实现</h1>\n<p>回到开头异步请求的例子，我们可以定义一个请求 <code>Hook</code> ，将 <code>loaing</code> 处理、数据返回处理这些步骤封装起来，外界只需要传递请求的方法即可。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>业务调用的地方使用上边的 <code>Hook</code> 即可。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>完整代码放到 <a href=\"https://codesandbox.io/s/great-flower-o83v0?file=/src/list.js:0-786\" target=\"_blank\" rel=\"noopener noreferrer\">Sandxox</a> 上了，感兴趣的同学也可以去运行下。</p>\n<h1> 更多场景</h1>\n<p>「模版方法」在框架中会更常见，比如我们平常写的 <code>vue</code> ，它的内部定义了各个生命周期的执行顺序，然后对我们开放了生命周期的钩子，可以执行我们自己的操作。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>「模版方法」如果再说的宽泛一点，<code>ElementUI</code> 的 <code>dialog</code> 也可以当作模版方法。</p>\n<div class=\"language-vue line-numbers-mode\" data-ext=\"vue\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>el-dialog</code> 实现了 <code>Dialog</code> 的基本样式和行为，并且通过 <code>slot</code> 以供扩展，让我们实现自己个性的东西。</p>\n<h1> 总</h1>\n<p>虽然在 <code>js</code> 中我们并不能真正实现模版模式，但模版模式的作用我们还是实现了，践行了「开放关闭原则」:</p>\n<ul>\n<li>\n<p>对扩展开放: 可以通过传入不同的参数，实现不同的应用需求。</p>\n</li>\n<li>\n<p>对修改关闭: 模版方法通过闭包的形式，内部的属性、方法外界并不能修改。</p>\n</li>\n</ul>\n<p>模版方法同样提升了复用能力，我们可以把公共的部分提取到模版方法中，业务方就不需要自己再实现一次了。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-02-10T09:15:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "访问者模式",
      "url": "https://www.h7ml.cn/posts/designPattern/visitor.html",
      "id": "https://www.h7ml.cn/posts/designPattern/visitor.html",
      "summary": "访问者模式主要作用是实现数据和操作的分离，可以在不改变数据类的同时，增加新的操作类型。 其主要通过「双分派」的思想实现。给原数据类传入一个 Visitor 方法，原数据类调用 Visitor 提供的方法，并将自己通过 this 传给 Visitor ，Vistior 实现相关操作。 目前开发中还没有遇到过，此处留坑。",
      "content_html": "<p>访问者模式主要作用是实现数据和操作的分离，可以在不改变数据类的同时，增加新的操作类型。</p>\n<p>其主要通过「双分派」的思想实现。给原数据类传入一个 <code>Visitor</code> 方法，原数据类调用 <code>Visitor</code> 提供的方法，并将自己通过 <code>this</code> 传给 <code>Visitor</code> ，<code>Vistior</code> 实现相关操作。</p>\n<p>目前开发中还没有遇到过，此处留坑。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2022-03-03T08:12:19.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "设计模式",
        "frontend"
      ]
    },
    {
      "title": "docker",
      "url": "https://www.h7ml.cn/posts/docker/",
      "id": "https://www.h7ml.cn/posts/docker/",
      "summary": "docker dockerfile",
      "content_html": "<ul>\n<li>\n<p><a href=\"/posts/docker/docker.html\" target=\"blank\">docker</a></p>\n</li>\n<li>\n<p><a href=\"/posts/docker/dockerfile.html\" target=\"blank\">dockerfile</a></p>\n</li>\n</ul>\n",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "docker",
      "url": "https://www.h7ml.cn/posts/docker/docker.html",
      "id": "https://www.h7ml.cn/posts/docker/docker.html",
      "summary": "docker 概念 Docker 的核心四大组成对象 镜像 ( Image )、容器 ( Container )、网络 ( Network )、数据卷 ( Volume ) 镜像 所谓镜像，可以理解为一个只读的文件包，其中包含了虚拟环境运行最原始文件系统的内容。 每次对镜像内容的修改，Docker 都会将这些修改铸造成一个镜像层，而一个镜像其实就是由其下层所有的镜像层所组成的。当然，每一个镜像层单独拿出来，与它之下的镜像层都可以组成一个镜像。",
      "content_html": "<h1> docker</h1>\n<h2> 概念</h2>\n<h3> Docker 的核心四大组成对象</h3>\n<blockquote>\n<p>镜像 ( Image )、容器 ( Container )、网络 ( Network )、数据卷 ( Volume )</p>\n</blockquote>\n<h4> 镜像</h4>\n<p>所谓镜像，可以理解为一个只读的文件包，其中包含了<strong>虚拟环境运行最原始文件系统的内容</strong>。</p>\n<p>每次对镜像内容的修改，Docker 都会将这些修改铸造成一个镜像层，而一个镜像其实就是由其下层所有的镜像层所组成的。当然，每一个镜像层单独拿出来，与它之下的镜像层都可以组成一个镜像。</p>\n<p>另外，由于这种结构，Docker 的镜像实质上是无法被修改的，因为所有对镜像的修改只会产生新的镜像，而不是更新原有的镜像。</p>\n<p>类似<code>git</code>，增量记录文件变更。</p>\n<h5> 镜像命名</h5>\n<p>准确的来说，镜像的命名我们可以分成三个部分：username、repository 和 tag。</p>\n<p>username： 主要用于识别上传镜像的不同用户，与 GitHub 中的用户空间类似。对于 username 来说，在上面我们展示的 docker images 结果中，有的镜像有 username 这个部分，而有的镜像是没有的。没有 username 这个部分的镜像，表示镜像是由 Docker 官方所维护和提供的，所以就不单独标记用户了。 <strong>repository</strong>：主要用于识别进行的内容，形成对镜像的表意描述。Docker 中镜像的 repository 部分通常采用的是软件名，可以任意取名，用软件名，只是为了更易示意。 tag：主要用户表示镜像的版本，方便区分进行内容的不同细节。</p>\n<h4> 容器</h4>\n<p>容器就是用来隔离虚拟环境的基础设施，而在 Docker 里，它也被引申为<strong>隔离出来的虚拟环境</strong>。通过 PID 进程隔离，容器中的主进程就是容器本身，杀掉容器中的主进程，相当于杀掉了容器。</p>\n<p>如果把镜像理解为编程中的类，那么容器就可以理解为类的实例。镜像内存放的是不可变化的东西，当以它们为基础的容器启动后，容器内也就成为了一个“活”的空间。</p>\n<p>用更官方的定义，Docker 的容器应该有三项内容组成：</p>\n<ul>\n<li>一个 Docker 镜像</li>\n<li>一个程序运行环境</li>\n<li>一个指令集合</li>\n</ul>\n<h5> 容器生命周期</h5>\n<p>Created、Running、Paused、Stopped、Deleted</p>\n<ul>\n<li>Created：容器已经被创建，容器所需的相关资源已经准备就绪，但容器中的程序还未处于运行状态。</li>\n<li>Running：容器正在运行，也就是容器中的应用正在运行。</li>\n<li>Paused：容器已暂停，表示容器中的所有程序都处于暂停 ( 不是停止 ) 状态。</li>\n<li>Stopped：容器处于停止状态，占用的资源和沙盒环境都依然存在，只是容器中的应用程序均已停止。</li>\n<li>Deleted：容器已删除，相关占用的资源及存储在 Docker 中的管理信息也都已释放和移除。</li>\n</ul>\n<h5> 写时复制机制</h5>\n<p>Docker 的写时复制与编程中的相类似，也就是在通过镜像运行容器时，并不是马上就把镜像里的所有内容拷贝到容器所运行的沙盒文件系统中，而是利用 UnionFS 将镜像以只读的方式挂载到沙盒文件系统中。只有在容器中发生对文件的修改时，修改才会体现到沙盒环境上。</p>\n<p>也就是说，容器在创建和启动的过程中，不需要进行任何的文件系统复制操作，也不需要为容器单独开辟大量的硬盘空间，与其他虚拟化方式对这个过程的操作进行对比，Docker 启动的速度可见一斑。</p>\n<h5> 容器互联</h5>\n<p>由于 Docker 提倡容器与应用共生的轻量级容器理念，所以容器中通常只包含一种应用程序，但我们知道，如今纷繁的系统服务，没有几个是可以通过单一的应用程序支撑的。拿最简单的 Web 应用为例，也至少需要业务应用、数据库应用、缓存应用等组成。也就是说，在 Docker 里我们需要通过多个容器来组成这样的系统。</p>\n<h5> 镜像 vs 容器</h5>\n<p>镜像像是记录容器运行环境的模板，是只读的，docker 依照这个模板启动一个容器，容器启动运行时是按需从镜像模板里拿取依赖（写时复制）肯定是先有模板才能依照模板启动容器！没有镜像，容器就是无源之水。镜像像类，容器像类的实例。或者说，镜像是程序是死的，容器是运行的进程，是活的。</p>\n<h4> 网络</h4>\n<p>网络通讯是目前最常用的一种程序间的数据交换方式，所有的应用都可以通过网络在不同的硬件平台或操作系统平台上进行数据交互。</p>\n<p>docker 容器间建立虚拟网络，将数个容器包裹其中，同时与其他网络环境隔离。</p>\n<p>在 Docker 网络中，有三个比较核心的概念，也就是：沙盒 ( Sandbox )、网络 ( Network )、端点 ( Endpoint )。</p>\n<ul>\n<li>沙盒提供了容器的虚拟网络栈，也就是之前所提到的端口套接字、IP 路由表、防火墙等的内容。其实现隔离了容器网络与宿主机网络，形成了完全独立的容器网络环境。</li>\n<li>网络可以理解为 Docker 内部的虚拟子网，网络内的参与者相互可见并能够进行通讯。Docker 的这种虚拟网络也是于宿主机网络存在隔离关系的，其目的主要是形成容器间的安全通讯环境。</li>\n<li>端点是位于容器或网络隔离墙之上的洞，其主要目的是形成一个可以控制的突破封闭的网络环境的出入口。当容器的端点与网络的端点形成配对后，就如同在这两者之间搭建了桥梁，便能够进行数据传输了。</li>\n</ul>\n<h4> 数据卷</h4>\n<p>在 Docker 中，通过这几种方式进行数据共享或持久化的文件或目录，我们都称为数据卷 ( Volume )。</p>\n<p>在以往的虚拟机中，我们通常直接采用虚拟机的文件系统作为应用数据等文件的存储位置。然而这种方式其实并非完全安全的，当虚拟机或者容器出现问题导致文件系统无法使用时，虽然我们可以很快的通过镜像重置文件系统使得应用快速恢复运行，但是之前存放的数据也就消失了。</p>\n<p>为了保证数据的独立性，我们通常会单独挂载一个文件系统来存放数据。这种操作在虚拟机中是繁琐的，因为我们不但要搞定挂载在不同宿主机中实现的方法，还要考虑挂载文件系统兼容性，虚拟操作系统配置等问题。值得庆幸的是，这些在 Docker 里都已经为我们轻松的实现了，我们只需要简单的一两个命令或参数，就能完成文件系统目录的挂载。</p>\n<p>基于底层存储实现，Docker 提供了三种适用于不同场景的文件系统挂载方式：Bind Mount、Volume 和 Tmpfs Mount。</p>\n<ul>\n<li>\n<p>Bind Mount 能够直接将宿主操作系统中的目录和文件挂载到容器内的文件系统中，通过指定容器外的路径和容器内的路径，就可以形成挂载映射关系，在容器内外对文件的读写，都是相互可见的。</p>\n</li>\n<li>\n<p>Volume 也是从宿主操作系统中挂载目录到容器内，只不过这个挂载的目录由 Docker 进行管理，我们只需要指定容器内的目录，不需要关心具体挂载到了宿主操作系统中的哪里。</p>\n</li>\n<li>\n<p>Tmpfs Mount 支持挂载系统内存中的一部分到容器的文件系统里，不过由于内存和容器的特征，它的存储并不是持久的，其中的内容会随着容器的停止而消失。</p>\n</li>\n</ul>\n<h4> 其他</h4>\n<p>Docker 是依赖于 Linux 而存在的，其实 Docker Desktop 的实现逻辑很简单：既然 Windows 和 macOS 中没有 Docker 能够利用的 Linux 环境，那么我们生造一个 Linux 环境就行啦！Docker for Windows 和 Docker for Mac 正是这么实现的。</p>\n<h2> 常用命令</h2>\n<ul>\n<li><code>docker version</code></li>\n</ul>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p><code>docker info</code></p>\n<p>在 docker info 这条命令的结果中，我们可以看到正在运行的 Docker Engine 实例中运行的容器数量，存储的引擎等等信息。</p>\n</li>\n<li>\n<p><code>docker images</code></p>\n<p>在 docker images 命令的结果中，我们可以看到镜像的 ID ( IMAGE ID)、构建时间 ( CREATED )、占用空间 ( SIZE ) 等数据。</p>\n</li>\n</ul>\n<h3> 镜像相关</h3>\n<ul>\n<li>\n<p><code>docker pull</code>：拉取镜像</p>\n</li>\n<li>\n<p><code>docker search</code>：搜索镜像</p>\n</li>\n<li>\n<p><code>docker images</code>：列出本地镜像</p>\n</li>\n<li>\n<p><code>docker inspect</code>：查看关于某个镜像相当完备的信息</p>\n</li>\n<li>\n<p><code>docker rmi</code>：删除镜像</p>\n</li>\n<li>\n<p><code>docker commit &lt;container&gt;</code>：提交容器的更改，例如<code>docker commit -m \"Configured\" webapp</code>，打包生成新镜像。Docker 执行将容器内沙盒文件系统记录成镜像层的时候，会先暂停容器的运行，以保证容器内的文件系统处于一个相对稳定的状态，确保数据的一致性</p>\n</li>\n</ul>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><code>docker tag</code>：重命名镜像名</li>\n</ul>\n<h4> 镜像迁移</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 容器相关</h3>\n<ul>\n<li><code>docker create &lt;image&gt;</code>：根据所给出的镜像创建容器，例如：<code>docker create --name nginx nginx:1.12</code></li>\n<li><code>docker start &lt;容器名&gt;</code>：启动容器</li>\n<li><code>docker run</code>：创建(create)并且启动(start)容器，例如：<code>docker run --name nginx -d nginx:1.12</code>，<code>-d</code>表示在启动后将程序与控制台分离，使其进入“后台”运行。创建时通过<code>--link</code>可让一个容器连接到另外一个容器。可以通过<code>--expose</code>来暴露容器端口。</li>\n</ul>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><code>docker ps</code>：列出的容器是处于运行中的容器，<code>-a</code>参数，列出所有容器。结果中还可以看到容器暴露给其他容器访问的端口</li>\n<li><code>docker stop &lt;name&gt;</code>：停止容器</li>\n<li><code>docker rm &lt;name&gt;</code>：删除容器，容器中应用程序所产生的一些文件数据，是非常重要的，如果这些数据随着容器的删除而丢失，其损失是非常巨大的。对于这类由应用程序所产生的数据，并且需要保证它们不会随着容器的删除而消失的，我们可以使用 Docker 中的数据卷来单独存放。由于数据卷是独立于容器存在的，所以其能保证数据不会随着容器的删除而丢失</li>\n<li><code>docker exec &lt;name&gt; &lt;CMD&gt;</code>：让容器运行我们所给出的命令，例如：<code>docker exec nginx more /etc/hostname</code></li>\n<li><code>docker exec -it nginx bash</code>，用 bash 来进入 nginx 容器，其中 -i ( --interactive ) 表示保持我们的输入流，只有使用它才能保证控制台程序能够正确识别我们的命令。而 -t ( --tty ) 表示启用一个伪终端，形成我们与 bash 的交互，如果没有它，我们无法看到 bash 内部的执行结果</li>\n</ul>\n<h3> 网络相关</h3>\n<ul>\n<li><code>docker network create</code>：自己定义虚拟子网，例如：<code>docker network create -d bridge individual</code>，通过 -d 选项我们可以为新的网络指定驱动的类型，其值可以是刚才我们所提及的 bridge、host、overlay、maclan、none，也可以是其他网络驱动插件所定义的类型。这里我们使用的是 Bridge Driver ( 当我们不指定网络驱动时，Docker 也会默认采用 Bridge Driver 作为网络驱动 )- <code>docker network ls</code>：查看 Docker 中已经存在的网络</li>\n<li><code>docker run --network</code>：在我们创建容器时，可以通过 --network 来指定容器所加入的网络</li>\n<li><code>docker run --publish</code>：映射端口，把容器的端口映射到宿主操作系统的端口上，从外部访问宿主操作系统的端口时，数据请求就会自动发送给与之关联的容器端口，例如：<code>docker run -d --name nginx -p 80:80 -p 443:443 nginx:1.12</code>。<code>-p &lt;ip&gt;:&lt;host-port&gt;:&lt;container-port&gt;</code> 其中 ip 是宿主操作系统的监听 ip，可以用来控制监听的网卡，默认为 0.0.0.0，也就是监听所有网卡。host-port 和 container-port 分别表示映射到宿主操作系统的端口和容器的端口，这两者是可以不一样的，我们可以将容器的 80 端口映射到宿主操作系统的 8080 端口，传入 -p 8080:80 即可</li>\n</ul>\n<h3> 存储相关</h3>\n<ul>\n<li>\n<p><code>docker run --volume</code>：将宿主操作系统中的目录挂载到容器，例如：<code>docker run -d --name nginx -v /webapp/html:/usr/share/nginx/html nginx:1.12</code> (参数传递不同，即可实现使用数据卷挂载，参考下一条命令)</p>\n<ol>\n<li>\n<p>使用 <code>-v</code> 或 <code>--volume</code> 来挂载宿主操作系统目录的形式是 <code>-v &lt;host-path&gt;:&lt;container-path&gt; 或 --volume &lt;host-path&gt;:&lt;container-path&gt;</code>，其中 <code>host-path</code> 和 <code>container-path</code> 分别代表宿主操作系统中的目录和容器中的目录。这里需要注意的是，为了避免混淆，Docker 这里强制定义目录时必须使用绝对路径，不能使用相对路径。</p>\n</li>\n<li>\n<p>我们能够指定目录进行挂载，也能够指定具体的文件来挂载，具体选择何种形式来挂载，大家可以根据具体的情况来选择。可以添加<code>:ro</code>实现只读挂载。</p>\n</li>\n<li>\n<p>当我们需要从宿主操作系统共享配置的时候 和 当我们需要借助 Docker 进行开发的时候(每次对代码的修改都可以直接在容器外部进行)，该挂载方式有实际应用场景。</p>\n</li>\n</ol>\n</li>\n<li>\n<p><code>docker run --volume</code>：例如：<code>docker run -d --name webapp -v /webapp/storage webapp:latest</code>，</p>\n<ul>\n<li>数据卷的本质其实依然是宿主操作系统上的一个目录，只不过这个目录存放在 Docker 内部，接受 Docker 的管理。在使用数据卷进行挂载时，我们不需要知道数据具体存储在了宿主操作系统的何处，只需要给定容器中的哪个目录会被挂载即可。</li>\n</ul>\n</li>\n<li>\n<p><code>-v &lt;name&gt;:&lt;container-path&gt;</code>：数据卷命名，例如：<code>docker run -d --name webapp -v appdata:/webapp/storage webapp:latest</code>，命名为<code>appdata</code></p>\n<ul>\n<li>数据卷的命名在 Docker 中是唯一的</li>\n</ul>\n</li>\n<li>\n<p><code>docker volume create &lt;name&gt;</code>：创建数据卷</p>\n</li>\n<li>\n<p><code>docker volume ls</code>：列出数据卷</p>\n</li>\n<li>\n<p><code>docker volume rm &lt;name&gt;</code>：删除数据卷，在删除容器时，可以使用<code>docker rm -v &lt;container-name&gt;</code>来删除容器的同时删除关联的数据卷</p>\n</li>\n</ul>\n<p>如果我们没有随容器删除这些数据卷，Docker 在创建新的容器时也不会启用它们，即使它们与新创建容器所定义的数据卷有完全一致的特征。也就是说，此时它们已经变成了孤魂野鬼，纯粹的占用着硬盘空间而又不受管理。</p>\n<ul>\n<li><code>docker volume prune</code>：删除那些没有被容器引用的数据卷</li>\n</ul>\n<h4> 数据卷容器</h4>\n<p>创建数据卷容器的方式很简单，由于不需要容器本身运行，因而我们找个简单的系统镜像都可以完成创建：<code>docker create --name appdata -v /webapp/storage ubuntu</code>，使用<code>ubuntu</code>镜像来创建名为<code>appdata</code>的数据卷容器</p>\n<p>数据卷容器就可以算是容器间的文件系统桥梁，可以像加入网络一样引用数据卷容器，只需要在创建新容器时使用专门的 --volumes-from 选项即可，<code>sudo docker run -d --name webapp --volumes-from appdata webapp:latest</code></p>\n<h4> 数据卷备份和迁移</h4>\n<p>由于数据卷本身就是宿主操作系统中的一个目录，我们只需要在 Docker 资源目录里找到它就可以很轻松的打包、迁移、恢复了。虽然这么做相对其他虚拟化方案来说已经很简单了，但在 Docker 里还不是最优雅的解决方式。</p>\n<p>利用数据卷容器，我们还能够更方便的对数据卷中的数据进行迁移。</p>\n<p>数据备份、迁移、恢复的过程可以理解为对数据进行打包，移动到其他位置，在需要的地方解压的过程。在数据打包之前，我们先建立一个用来存放打包文件的目录，这里我们使用 /backup 作为例子。</p>\n<p>要备份数据，我们先建立一个临时的容器，将用于备份的目录和要备份的数据卷都挂载到这个容器上。</p>\n<p>在备份命令中，除了挂载的配置外，我们再注意几个选项。通过 --rm 选项，我们可以让容器在停止后自动删除，而不需要我们再使用容器删除命令来删除它，这对于我们使用一些临时容器很有帮助。在容器所基于的镜像之后，我们还看到了一串命令，也就是 tar cvf /backup/backup.tar /webapp/storage，其实如果我们在镜像定义之后接上命令，可以直接替换掉镜像所定义的主程序启动命令，而去执行这一条命令。在很多场合下，我们还能通过这个方法干很多不同的事情。</p>\n<p>在备份后，我们就可以在 /backup 下找到数据卷的备份文件，也就是 backup.tar 了。</p>\n<p>如果要恢复数据卷中的数据，我们也可以借助临时容器完成。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 笔记</h2>\n<h3> 修改国内镜像源</h3>\n<p>在<code>Docker Desktop</code>的 docker engine 中配置增加<code>registry-mirrors</code></p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 通过 Dockerfile 创建镜像</h2>\n<p>Dockerfile 是 Docker 中用于定义镜像自动化构建流程的配置文件，在 Dockerfile 中，包含了构建镜像过程中需要执行的命令和其他操作。通过 Dockerfile 我们可以更加清晰、明确的给定 Docker 镜像的制作过程，而由于其仅是简单、小体积的文件，在网络等其他介质中传递的速度极快，能够更快的帮助我们实现容器迁移和集群部署。</p>\n<h3> 编写</h3>\n<p>相对于之前我们介绍的提交容器修改，再进行镜像迁移的方式相比，使用 Dockerfile 进行这项工作有很多优势，我总结了几项尤为突出的。</p>\n<ul>\n<li>Dockerfile 的体积远小于镜像包，更容易进行快速迁移和部署。</li>\n<li>环境构建流程记录了 Dockerfile 中，能够直观的看到镜像构建的顺序和逻辑。</li>\n<li>使用 Dockerfile 来构建镜像能够更轻松的实现自动部署等自动化流程。</li>\n<li>在修改环境搭建细节时，修改 Dockerfile 文件要比从新提交镜像来的轻松、简单。</li>\n</ul>\n<h4> Dockerfile 的结构</h4>\n<p>总体上来说，我们可以将 Dockerfile 理解为一个由上往下执行指令的脚本文件。当我们调用构建命令让 Docker 通过我们给出的 Dockerfile 构建镜像时，Docker 会逐一按顺序解析 Dockerfile 中的指令，并根据它们不同的含义执行不同的操作。</p>\n<p>如果进行细分，我们可以将 Dockerfile 的指令简单分为五大类。</p>\n<ul>\n<li>基础指令：用于定义新镜像的基础和性质。</li>\n<li>控制指令：是指导镜像构建的核心部分，用于描述镜像在构建过程中需要执行的命令。</li>\n<li>引入指令：用于将外部文件直接引入到构建镜像内部。</li>\n<li>执行指令：能够为基于镜像所创建的容器，指定在启动时需要执行的脚本或命令。</li>\n<li>配置指令：对镜像以及基于镜像所创建的容器，可以通过配置指令对其网络、用户等内容进行配置。</li>\n</ul>\n<p>这五类命令并非都会出现在一个 Dockerfile 里，但却对基于这个 Dockerfile 所构建镜像形成不同的影响。</p>\n<h4> 常见 Dockerfile 指令</h4>\n<ul>\n<li>FROM</li>\n</ul>\n<p>通常来说，我们不会从零开始搭建一个镜像，而是会选择一个已经存在的镜像作为我们新镜像的基础，这种方式能够大幅减少我们的时间。</p>\n<p>在 Dockerfile 里，我们可以通过 FROM 指令指定一个基础镜像，接下来所有的指令都是基于这个镜像所展开的。在镜像构建的过程中，Docker 也会先获取到这个给出的基础镜像，再从这个镜像上进行构建操作。</p>\n<p>FROM 指令支持三种形式，不管是哪种形式，其核心逻辑就是指出能够被 Docker 识别的那个镜像，好让 Docker 从那个镜像之上开始构建工作。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>既然选择一个基础镜像是构建新镜像的根本，那么 Dockerfile 中的第一条指令必须是 FROM 指令，因为没有了基础镜像，一切构建过程都无法开展。</p>\n<p>当然，一个 Dockerfile 要以 FROM 指令作为开始并不意味着 FROM 只能是 Dockerfile 中的第一条指令。在 Dockerfile 中可以多次出现 FROM 指令，当 FROM 第二次或者之后出现时，表示在此刻构建时，要将当前指出镜像的内容合并到此刻构建镜像的内容里。这对于我们直接合并两个镜像的功能很有帮助。</p>\n<ul>\n<li>RUN</li>\n</ul>\n<p>镜像的构建虽然是按照指令执行的，但指令只是引导，最终大部分内容还是控制台中对程序发出的命令，而 RUN 指令就是用于向控制台发送命令的指令。</p>\n<p>在 RUN 指令之后，我们直接拼接上需要执行的命令，在构建时，Docker 就会执行这些命令，并将它们对文件系统的修改记录下来，形成镜像的变化。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>ENTRYPOINT 和 CMD</li>\n</ul>\n<p>基于镜像启动的容器，在容器启动时会根据镜像所定义的一条命令来启动容器中进程号为 1 的进程。而这个命令的定义，就是通过 Dockerfile 中的 ENTRYPOINT 和 CMD 实现的。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>ENTRYPOINT 指令和 CMD 指令的用法近似，都是给出需要执行的命令，并且它们都可以为空，或者说是不在 Dockerfile 里指出。</p>\n<p>当 ENTRYPOINT 与 CMD 同时给出时，CMD 中的内容会作为 ENTRYPOINT 定义命令的参数，最终执行容器启动的还是 ENTRYPOINT 中给出的命令。</p>\n<ul>\n<li>EXPOSE</li>\n</ul>\n<p>由于我们构建镜像时更了解镜像中应用程序的逻辑，也更加清楚它需要接收和处理来自哪些端口的请求，所以在镜像中定义端口暴露显然是更合理的做法。</p>\n<p>通过 EXPOSE 指令就可以为镜像指定要暴露的端口。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>当我们通过 EXPOSE 指令配置了镜像的端口暴露定义，那么基于这个镜像所创建的容器，在被其他容器通过 --link 选项连接时，就能够直接允许来自其他容器对这些端口的访问了。</p>\n<ul>\n<li>VOLUME</li>\n</ul>\n<p>在一些程序里，我们需要持久化一些数据，比如数据库中存储数据的文件夹就需要单独处理。在之前的小节里，我们提到可以通过数据卷来处理这些问题。</p>\n<p>但使用数据卷需要我们在创建容器时通过 -v 选项来定义，而有时候由于镜像的使用者对镜像了解程度不高，会漏掉数据卷的创建，从而引起不必要的麻烦。</p>\n<p>还是那句话，制作镜像的人是最清楚镜像中程序工作的各项流程的，所以它来定义数据卷也是最合适的。所以在 Dockerfile 里，提供了 VOLUME 指令来定义基于此镜像的容器所自动建立的数据卷。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在 VOLUME 指令中定义的目录，在基于新镜像创建容器时，会自动建立为数据卷，不需要我们再单独使用 -v 选项来配置了。</p>\n<ul>\n<li>COPY 和 ADD</li>\n</ul>\n<p>在制作新的镜像的时候，我们可能需要将一些软件配置、程序代码、执行脚本等直接导入到镜像内的文件系统里，使用 COPY 或 ADD 指令能够帮助我们直接从宿主机的文件系统里拷贝内容到镜像里的文件系统中。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>COPY 与 ADD 指令的定义方式完全一样，需要注意的仅是当我们的目录中存在空格时，可以使用后两种格式避免空格产生歧义。</p>\n<p>对比 COPY 与 ADD，两者的区别主要在于 ADD 能够支持使用网络端的 URL 地址作为 src 源，并且在源文件被识别为压缩包时，自动进行解压，而 COPY 没有这两个能力。</p>\n<p>虽然看上去 COPY 能力稍弱，但对于那些不希望源文件被解压或没有网络请求的场景，COPY 指令是个不错的选择。</p>\n<h3> 构建镜像</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><code>-t</code> 选项，用它来指定新生成镜像的名称</li>\n</ul>\n<h3> 常见技巧</h3>\n<h4> 构建中使用变量</h4>\n<p>在 Dockerfile 里，我们可以用 ARG 指令来建立一个参数变量，我们可以在构建时通过构建指令传入这个参数变量，并且在 Dockerfile 里使用它。</p>\n<p>例如，我们希望通过参数变量控制 Dockerfile 中某个程序的版本，在构建时安装我们指定版本的软件，我们可以通过 ARG 定义的参数作为占位符，替换版本定义的部分。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在这个例子里，我们将 Tomcat 的版本号通过 ARG 指令定义为参数变量，在调用下载 Tomcat 包时，使用变量替换掉下载地址中的版本号。通过这样的定义，就可以让我们在不对 Dockerfile 进行大幅修改的前提下，轻松实现对 Tomcat 版本的切换并重新构建镜像了。</p>\n<p>如果我们需要通过这个 Dockerfile 文件构建 Tomcat 镜像，我们可以在构建时通过 docker build 的 --build-arg 选项来设置参数变量。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 环境变量</h4>\n<p>环境变量也是用来定义参数的东西，与 ARG 指令相类似，环境变量的定义是通过 ENV 这个指令来完成的。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>环境变量的使用方法与参数变量一样，也都是能够直接替换指令参数中的内容。</p>\n<p>与参数变量只能影响构建过程不同，环境变量不仅能够影响构建，还能够影响基于此镜像创建的容器。环境变量设置的实质，其实就是定义操作系统环境变量，所以在运行的容器里，一样拥有这些变量，而容器中运行的程序也能够得到这些变量的值。</p>\n<p>另一个不同点是，环境变量的值不是在构建指令中传入的，而是在 Dockerfile 中编写的，所以如果我们要修改环境变量的值，我们需要到 Dockerfile 修改。不过即使这样，只要我们将 ENV 定义放在 Dockerfile 前部容易查找的地方，其依然可以很快的帮助我们切换镜像环境中的一些内容。</p>\n<p>由于环境变量在容器运行时依然有效，所以运行容器时我们还可以对其进行覆盖，在创建容器时使用 -e 或是 --env 选项，可以对环境变量的值进行修改或定义新的环境变量。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>事实上，这种用法在我们开发中是非常常见的。也正是因为这种允许运行时配置的方法存在，环境变量和定义它的 ENV 指令，是我们更常使用的指令，我们会优先选择它们来实现对变量的操作。</p>\n<p>另外需要说明一点，通过 ENV 指令和 ARG 指令所定义的参数，在使用时都是采用 $ + NAME 这种形式来占位的，所以它们之间的定义就存在冲突的可能性。对于这种场景，大家只需要记住，ENV 指令所定义的变量，永远会覆盖 ARG 所定义的变量，即使它们定时的顺序是相反的。</p>\n<h4> 合并命令</h4>\n<p>在上一节我们展示的完整的官方 Redis 镜像的 Dockerfile 中，我们会发现 RUN 等指令里会聚合下大量的代码。</p>\n<p>事实上，下面两种写法对于搭建的环境来说是没有太大区别的。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 构建缓存</h4>\n<p>Docker 在镜像构建的过程中，还支持一种缓存策略来提高镜像的构建速度。</p>\n<p>由于镜像是多个指令所创建的镜像层组合而得，那么如果我们判断新编译的镜像层与已经存在的镜像层未发生变化，那么我们完全可以直接利用之前构建的结果，而不需要再执行这条构建指令，这就是镜像构建缓存的原理。</p>\n<p>那么 Docker 是如何判断镜像层与之前的镜像间不存在变化的呢？这主要参考两个维度，第一是所基于的镜像层是否一样，第二是用于生成镜像层的指令的内容是否一样。</p>\n<p>基于这个原则，我们在条件允许的前提下，更建议将不容易发生变化的搭建过程放到 Dockerfile 的前部，充分利用构建缓存提高镜像构建的速度。另外，指令的合并也不宜过度，而是将易变和不易变的过程拆分，分别放到不同的指令里。</p>\n<p>在另外一些时候，我们可能不希望 Docker 在构建镜像时使用构建缓存，这时我们可以通过 --no-cache 选项来禁用它。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 搭配 ENTRYPOINT 和 CMD</h4>\n<p>上一节我们谈到了 ENTRYPOINT 和 CMD 这两个命令，也解释了这两个命令的目的，即都是用来指定基于此镜像所创建容器里主进程的启动命令的。</p>\n<p>两个指令的区别在于，ENTRYPOINT 指令的优先级高于 CMD 指令。当 ENTRYPOINT 和 CMD 同时在镜像中被指定时，CMD 里的内容会作为 ENTRYPOINT 的参数，两者拼接之后，才是最终执行的命令。</p>\n<p>有的读者会存在疑问，既然两者都是用来定义容器启动命令的，为什么还要分成两个，合并为一个指令岂不是更方便吗？</p>\n<p>这其实在于 ENTRYPOINT 和 CMD 设计的目的是不同的。<strong>ENTRYPOINT 指令主要用于对容器进行一些初始化，而 CMD 指令则用于真正定义容器中主程序的启动命令</strong>。</p>\n<p>另外，我们之前谈到创建容器时可以改写容器主程序的启动命令，而这个覆盖只会覆盖 CMD 中定义的内容，而不会影响 ENTRYPOINT 中的内容。</p>\n<p>我们依然以之前的 Redis 镜像为例，这是 Redis 镜像中对 ENTRYPOINT 和 CMD 的定义。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以很清晰的看到，CMD 指令定义的正是启动 Redis 的服务程序，而 ENTRYPOINT 使用的是一个外部引入的脚本文件。</p>\n<p>事实上，使用脚本文件来作为 ENTRYPOINT 的内容是常见的做法，因为对容器运行初始化的命令相对较多，全部直接放置在 ENTRYPOINT 后会特别复杂。</p>\n<p>我们来看看 Redis 中的 ENTRYPOINT 脚本，可以看到其中会根据脚本参数进行一些处理，而脚本的参数，其实就是 CMD 中定义的内容。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里我们要关注脚本最后的一条命令，也就是 exec \"$@\"。在很多镜像的 ENTRYPOINT 脚本里，我们都会看到这条命令，其作用其实很简单，就是运行一个程序，而运行命令就是 ENTRYPOINT 脚本的参数。反过来，由于 ENTRYPOINT 脚本的参数就是 CMD 指令中的内容，所以实际执行的就是 CMD 里的命令。</p>\n<p>所以说，虽然 Docker 对容器启动命令的结合机制为 CMD 作为 ENTRYPOINT 的参数，合并后执行 ENTRYPOINT 中的定义，但实际在我们使用中，我们还会在 ENTRYPOINT 的脚本里代理到 CMD 命令上。</p>\n<h4> 使用 Alpine 镜像</h4>\n<p>如果大家多接触几个镜像，就会发现带有 Alpine 的版本是许多镜像中都常见的标签。带有 Alpine 标签的镜像到底是什么样的存在呢？它与相同软件不同标签的镜像又有什么样的区别呢？</p>\n<p>镜像标签中的 Alpine 其实指的是这个镜像内的文件系统内容，是基于 Alpine Linux 这个操作系统的。Alpine Linux 是一个相当精简的操作系统，而基于它的 Docker 镜像可以仅有数 MB 的尺寸。如果软件基于这样的系统镜像之上构建而得，可以想象新的镜像也是十分小巧的。</p>\n<h2> Docker Compose 容器编排</h2>\n<p>由于 Docker 采用轻量级容器的设计，每个容器一般只运行一个软件，而目前绝大多数应用系统都绝不是一个软件所能组成的。虽然我们之前提到了容器间互相连接、交换数据的各种方法，通过这些方法足以搭建起完整的用于应用系统运行的容器群，但是这显然还不够，这个容器群的搭建需要执行太多命令，更重要的是需要考虑太多应用和容器间的依赖关系处理，是一波令人头大的操作。在这一节中，我们就来介绍如何解决这些问题。</p>\n<h3> 容器管理问题</h3>\n<p>拿任何一个相对完整的应用系统来说，都不可能是由一个程序独立支撑的，而对于使用 Docker 来部署的分布式计算服务更是这样。随着时代的发展和技术演进，我们越来越推崇将大型服务拆分成较小的微服务，分别部署到独立的机器或容器中。也就是说，我们的应用系统往往由数十个甚至上百个应用程序或微服务组成。即使是一个小的微服务模块，通常都需要多个应用协作完成工作。</p>\n<p>我们编写一个小型的微服务模块，虽然我们编写代码主要针对的是其中的应用部分，但如果我们要完整的进行开发、测试，与应用相关的周边软件必然是必不可少的。</p>\n<p>虽然 Docker Engine 帮助我们完成了对应用运行环境的封装，我们可以不需要记录复杂的应用环境搭建过程，通过简单的配置便可以将应用运行起来了，但这只是针对单个容器或单个应用程序来说的。如果延伸到由多个应用组成的应用系统，那情况就稍显复杂了。</p>\n<p>就拿最简单的例子来说吧，如果我们要为我们的应用容器准备一个 MySQL 容器和一个 Redis 容器，那么在每次启动时，我们先要将 MySQL 容器和 Redis 容器启动起来，再将应用容器运行起来。这其中还不要忘了在创建应用容器时将容器网络连接到 MySQL 容器和 Redis 容器上，以便应用连接上它们并进行数据交换。</p>\n<p>这还不够，如果我们还对容器进行了各种配置，我们最好还得将容器创建和配置的命令保存下来，以便下次可以直接使用。</p>\n<p>如果我们要想让这套体系像 docker run 和 docker rm 那样自如的进行无痕切换，那就更加麻烦了，我们可能需要编写一些脚本才能不至于被绕到命令的毛线球里。</p>\n<p>说了这么多，其实核心还是缺少一个对容器组合进行管理的东西。</p>\n<p>针对这种情况，我们就不得不引出在我们开发中最常使用的多容器定义和运行软件，也就是 Docker Compose 了。</p>\n<p>如果说 Dockerfile 是将容器内运行环境的搭建固化下来，那么 Docker Compose 我们就可以理解为将多个容器运行的方式和配置固化下来。</p>\n<p>在 Docker Compose 里，我们通过一个配置文件，将所有与应用系统相关的软件及它们对应的容器进行配置，之后使用 Docker Compose 提供的命令进行启动，就能让 Docker Compose 将刚才我们所提到的那些复杂问题解决掉。</p>\n<h3> 编写 Docker Compose 配置</h3>\n<p>配置文件是 Docker Compose 的核心部分，我们正是通过它去定义组成应用服务容器群的各项配置，而编写配置文件，则是使用 Docker Compose 过程中最核心的一个步骤。</p>\n<p>Docker Compose 的配置文件是一个基于 YAML 格式的文件。关于 YAML 的语法大家可以在网上找到，这里不再细说，总的来说，YAML 是一种清晰、简单的标记语言，你甚至都可以在看过几个例子后摸索出它的语法。</p>\n<p>与 Dockerfile 采用 Dockerfile 这个名字作为镜像构建定义的默认文件名一样，Docker Compose 的配置文件也有一个缺省的文件名，也就是 docker-compose.yml，如非必要，我建议大家直接使用这个文件名来做 Docker Compose 项目的定义。</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Docker Compose 配置文件里可以包含许多内容，从每个容器的各个细节控制，到网络、数据卷等的定义。</p>\n<p>这里我们看几个主要的细节。首先是 version 这个配置，这代表我们定义的 docker-compose.yml 文件内容所采用的版本，目前 Docker Compose 的配置文件已经迭代至了第三版，其所支持的功能也越来越丰富，所以我们建议使用最新的版本来定义。</p>\n<p>接下来我们来看 services 这块，这是整个 docker-compose.yml 的核心部分，其定义了容器的各项细节。</p>\n<p>在 Docker Compose 里不直接体现容器这个概念，这是把 service 作为配置的最小单元。虽然我们看上去每个 service 里的配置内容就像是在配置容器，但其实 service 代表的是一个应用集群的配置。每个 service 定义的内容，可以通过特定的配置进行水平扩充，将同样的容器复制数份形成一个容器集群。而 Docker Compose 能够对这个集群做到黑盒效果，让其他的应用和容器无法感知它们的具体结构。</p>\n<h3> 启动和停止</h3>\n<ul>\n<li>启动：<code>docker-compose up -d</code>，-d 代表后台执行</li>\n</ul>\n<p>需要注意的是，docker-compose 命令默认会识别当前控制台所在目录内的 docker-compose.yml 文件，而会以这个目录的名字作为组装的应用项目的名称。如果我们需要改变它们，可以通过选项 -f 来修改识别的 Docker Compose 配置文件，通过 -p 选项来定义项目名(一堆容器构成一个项目，即一个服务)。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>停止所有的容器，并将它们删除，同时消除网络等配置内容，也就是几乎将这个 Docker Compose 项目的所有影响从 Docker 中清除。</li>\n</ul>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果条件允许，我更建议大家像容器使用一样对待 Docker Compose 项目，做到随用随启，随停随删。也就是使用的时候通过 docker-compose up 进行，而短时间内不再需要时，通过 docker-compose down 清理它。</p>\n<p>借助 Docker 容器的秒级启动和停止特性，我们在使用 docker-compose up 和 docker-compose down 时可以非常快的完成操作。这就意味着，我们可以在不到半分钟的时间内停止一套环境，切换到另外一套环境，这对于经常进行多个项目开发的朋友来说，绝对是福音。</p>\n<p>通过 Docker 让我们能够在开发过程中搭建一套不受干扰的独立环境，让开发过程能够基于稳定的环境下进行。而 Docker Compose 则让我们更近一步，同时让我们处理好多套开发环境，并进行快速切换。</p>\n<h3> 容器命令</h3>\n<p>除了启动和停止命令外，Docker Compose 还为我们提供了很多直接操作服务的命令。之前我们说了，服务可以看成是一组相同容器的集合，所以操作服务就有点像操作容器一样。</p>\n<p>这些命令看上去都和 Docker Engine 中对单个容器进行操作的命令类似，我们来看几个常见的。</p>\n<p>在 Docker Engine 中，如果我们想要查看容器中主进程的输出内容，可以使用 docker logs 命令。而由于在 Docker Compose 下运行的服务，其命名都是由 Docker Compose 自动完成的，如果我们直接使用 docker logs 就需要先找到容器的名字，这显然有些麻烦了。我们可以直接使用 docker-compose logs 命令来完成这项工作。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在 docker-compose logs 衔接的是 Docker Compose 中所定义的服务的名称。</p>\n<p>同理，在 Docker Compose 还有几个类似的命令可以单独控制某个或某些服务。</p>\n<p>通过 docker-compose create，docker-compose start 和 docker-compose stop 我们可以实现与 docker create，docker start 和 docker stop 相似的效果，只不过操作的对象由 Docker Engine 中的容器变为了 Docker Compose 中的服务。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 常用的 Docker Compose 配置项</h3>\n<h4> 配置示例</h4>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 指定镜像</h4>\n<p>容器最基础的就是镜像了，所以每个服务必须指定镜像。在 Docker Compose 里，我们可以通过两种方式为服务指定所采用的镜像。一种是通过 <code>image</code> 这个配置，这个相对简单，给出能在镜像仓库中找到镜像的名称即可。</p>\n<p>另外一种指定镜像的方式就是直接采用 <code>Dockerfile</code> 来构建镜像，通过 build 这个配置我们能够定义构建的环境目录，这与 docker build 中的环境目录是同一个含义。如果我们通过这种方式指定镜像，那么 Docker Compose 先会帮助我们执行镜像的构建，之后再通过这个镜像启动容器。</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在配置文件里，我们还能用 Map 的形式来定义 build，在这种格式下，我们能够指定更多的镜像构建参数，例如 Dockerfile 的文件名，构建参数等等。</p>\n<p>当然，对于一些可以不通过重新构建镜像的方式便能修改的内容，我们还是不建议重新构建镜像，而是使用原有的镜像做简单的修改。</p>\n<p>例如上面的配置里，我们希望修改 Redis 的启动命令，加入配置文件以便对 Redis 服务进行配置，那么我们可以直接通过 command 配置来修改。而在 MySQL 的定义，我们通过 environment 配置为 MySQL 设置了初始密码。</p>\n<p>这些对镜像的使用方法我们在之前都已经谈到过了，只不过我们之前用的是 Docker Engine 的命令以及其选项来控制的，而在 Docker Compose 里，我们直接通过配置文件来定义它们。</p>\n<p>由于 Docker Compose 的配置已经固化下来，所以我们不需要担心忘记之前执行了哪些命令来启动容器，当每次需要开启或关闭环境时，只需要 docker-compose up -d 和 docker-compose down 命令，就能轻松完成操作。</p>\n<h4> 依赖声明 (depends_on)</h4>\n<blockquote>\n<p>容器启动顺序</p>\n</blockquote>\n<p>虽然我们在 Docker Compose 的配置文件里定义服务，在书写上有由上至下的先后关系，但实际在容器启动中，由于各种因素的存在，其顺序还是无法保障的。</p>\n<p>所以，如果我们的服务间有非常强的依赖关系，我们就必须告知 Docker Compose 容器的先后启动顺序。只有当被依赖的容器完全启动后，Docker Compose 才会创建和启动这个容器。</p>\n<p>定义依赖的方式很简单，在上面的例子里我们已经看到了，也就是 depends_on 这个配置项，我们只需要通过它列出这个服务所有依赖的其他服务即可。在 Docker Compose 为我们启动项目的时候，会检查所有依赖，形成正确的启动顺序并按这个顺序来依次启动容器。</p>\n<h4> 文件挂载</h4>\n<p>在 Docker Compose 里定义文件挂载的方式与 Docker Engine 里也并没有太多的区别，使用 volumes 配置可以像 docker CLI 里的 -v 选项一样来指定外部挂载和数据卷挂载。</p>\n<p>在上面的例子里，我们看到了定义几种常用挂载的方式。我们能够直接挂载宿主机文件系统中的目录，也可以通过数据卷的形式挂载内容。</p>\n<p>在使用外部文件挂载的时候，我们可以直接指定相对目录进行挂载，这里的相对目录是指相对于 docker-compose.yml 文件的目录。</p>\n<p>由于有相对目录这样的机制，我们可以将 docker-compose.yml 和所有相关的挂载文件放置到同一个文件夹下，形成一个完整的项目文件夹。这样既可以很好的整理项目文件，也利于完整的进行项目迁移。</p>\n<p>虽然 Docker 提倡将代码或编译好的程序通过构建镜像的方式打包到镜像里，随整个 CI 流部署到服务器中，但对于开发者来说，每次修改程序进行简单测试都要重新构建镜像简直是浪费生命的操作。<strong>所以在开发时，我们推荐直接将代码挂载到容器里，而不是通过镜像构建的方式打包成镜像。</strong></p>\n<p>同时，<strong>在开发过程中，对于程序的配置等内容，我们也建议直接使用文件挂载的形式挂载到容器里</strong>，避免经常修改所带来的麻烦。</p>\n<h5> 使用数据卷</h5>\n<p>如果我们要在项目中使用数据卷来存放特殊的数据，我们也可以让 Docker Compose 自动完成对数据卷的创建，而不需要我们单独进行操作。</p>\n<p>在上面的例子里，独立于 services 的 volumes 配置就是用来声明数据卷的。定义数据卷最简单的方式仅需要提供数据卷的名称，对于我们在 Docker Engine 中创建数据卷时能够使用的其他定义，也能够放入 Docker Compose 的数据卷定义中。</p>\n<p>如果我们想把属于 Docker Compose 项目以外的数据卷引入进来直接使用，我们可以将数据卷定义为外部引入，通过 external 这个配置就能完成这个定义。</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在加入 external 定义后，Docker Compose 在创建项目时不会直接创建数据卷，而是优先从 Docker Engine 中已有的数据卷里寻找并直接采用。</p>\n<h4> 配置网络</h4>\n<p>网络也是容器间互相访问的桥梁，所以网络的配置对于多个容器组成的应用系统来说也是非常重要的。在 Docker Compose 里，我们可以为整个应用系统设置一个或多个网络。</p>\n<p>要使用网络，我们必须先声明网络。声明网络的配置同样独立于 services 存在，是位于根配置下的 networks 配置。在上面的例子里，我们已经看到了声明 frontend 和 backend 这两个网络最简单的方式。</p>\n<p>除了简单的声明网络名称，让 Docker Compose 自动按默认形式完成网络配置外，我们还可以显式的指定网络的参数。</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在这里，我们为网络定义了网络驱动的类型，并指定了子网的网段。</p>\n<h5> 使用网络别名</h5>\n<p>直接使用容器名或服务名来作为连接其他服务的网络地址，因为缺乏灵活性，常常还不能满足我们的需要。这时候我们可以为服务单独设置网络别名，在其他容器里，我们将这个别名作为网络地址进行访问。</p>\n<p>网络别名的定义方式很简单，这里需要将之前简单的网络 List 定义结构修改成 Map 结构，以便在网络中加入更多的定义。</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在我们进行这样的配置后，我们便可以使用这里我们所设置的网络别名对其他容器进行访问了。</p>\n<h5> 端口映射</h5>\n<p>在 Docker Compose 的每个服务配置里，我们还看到了 ports 这个配置项，它是用来定义端口映射的。</p>\n<p>我们可以利用它进行宿主机与容器端口的映射，这个配置与 docker CLI 中 -p 选项的使用方法是近似的。</p>\n<p>需要注意的是，由于 YAML 格式对 xx:yy 这种格式的解析有特殊性，在设置小于 60 的值时，会被当成时间而不是字符串来处理，所以我们最好使用引号将端口映射的定义包裹起来，避免歧义。</p>\n<h2> 编写 Docker Compose 项目 (实践一)</h2>\n<h3> 编写 Docker Compose 项目</h3>\n<p>在这一小节里，我们以一个由 MySQL、Redis、PHP-FPM 和 Nginx 组成的小型 PHP 网站为例，介绍通过 Docker 搭建运行这套程序运行环境的方法。</p>\n<p>既然我们说到这个小型网站是由 MySQL、Redis、PHP-FPM 和 Nginx 四款软件所组成的，那么自然在 Docker 里，我们要准备四个容器分别来运行它们。而为了更好地管理这四个容器所组成的环境，我们这里还会使用到 Docker Compose。</p>\n<p>与搭建一个软件开发项目类似，我们提倡将 Docker Compose 项目的组成内容聚集到一个文件目录中，这样更利于我们进行管理和迁移。</p>\n<p>简单说明一下这个结构中主要目录和文件的功能和作用。在这个结构里，我们可以将根目录下的几个目录分为四类：</p>\n<ul>\n<li>第一类是 Docker 定义目录，也就是 compose 这个目录。在这个目录里，包含了 docker-compose.yml 这个用于定义 Docker Compose 项目的配置文件。此外，还包含了我们用于构建自定义镜像的内容。</li>\n<li>第二类是程序文件目录，在这个项目里是 mysql、nginx、phpfpm、redis 这四个目录。这些目录分别对应着 Docker Compose 中定义的服务，在其中主要存放对应程序的配置，产生的数据或日志等内容。</li>\n<li>第三类是代码目录，在这个项目中就是存放 Web 程序的 website 目录。我们将代码统一放在这个目录中，方便在容器中挂载。</li>\n<li>第四类是工具命令目录，这里指 bin 这个目录。我们在这里存放一些自己编写的命令脚本，我们通过这些脚本可以更简洁地操作整个项目。</li>\n</ul>\n<h3> docker-compose.yml</h3>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用合适的镜像是提高工作效率的途径之一，这里讲解一下我们在这个项目中选择镜像的原由。</p>\n<p>在这个项目里，我们直接采用了 MySQL、Redis 和 Nginx 三个官方镜像，而对于 PHP-FPM 的镜像，我们需要增加一些功能，所以我们通过 Dockerfile 构建的方式来生成。</p>\n<p>对于 MySQL 来说，我们需要为它们设置密码，所以原则上我们是需要对它们进行改造并生成新的镜像来使用的。而由于 MySQL 镜像可以通过我们之前在镜像使用方法一节所提到的环境变量配置的方式，来直接指定 MySQL 的密码及其他一些关键性内容，所以我们就无须单独构建镜像，可以直接采用官方镜像并配合使用环境变量来达到目的。</p>\n<p>对于 Redis 来说，出于安全考虑，我们一样需要设置密码。Redis 设置密码的方法是通过配置文件来完成的，所以我们需要修改 Redis 的配置文件并挂载到 Redis 容器中。这个过程也相对简单，不过需要注意的是，在官方提供的 Redis 镜像里，默认的启动命令是 redis-server，其并没有指定加载配置文件。所以在我们定义 Redis 容器时，要使用 command 配置修改容器的启动命令，使其读取我们挂载到容器的配置文件。</p>\n<h3> 自定义镜像 (Dockerfile)</h3>\n<p>相比较于 MySQL、Redis 这样可以通过简单配置即可直接使用的镜像不同，PHP 的镜像中缺乏了一些我们程序中必要的元素，而这些部分我们推荐使用自定义镜像的方式将它们加入其中。</p>\n<p>在这个例子里，因为需要让 PHP 连接到 MySQL 数据库中，所以我们要为镜像中的 PHP 程序安装和开启 pdo_mysql 这个扩展。</p>\n<p>了解如何安装扩展，这就要考验我们之前在 Docker Hub 镜像使用一节中学到的知识了。我们通过阅读 PHP 镜像的介绍页面，可以找到 PHP 镜像中已经为我们准备好了扩展的安装和启用命令，这让我们可以很轻松地在镜像中加入扩展。</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>由于 Docker 官方所提供的镜像比较精简，所以在这个 Dockerfile 里，我们还执行了 cron 的安装命令，来确保我们可以使用定时任务。</p>\n<p>大家注意到，这里除了我们进行功能安装外，还将一个脚本拷入了镜像中，并将其作为 ENTRYPOINT 启动入口。这个文件的作用主要是为了启动 cron 服务，以便我们在容器中可以正常使用它。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>在 docker-entrypoint.sh 里，除了启动 cron 服务的命令外，我们在脚本的最后看到的是 exec \"$@\" 这行命令。$@ 是 shell 脚本获取参数的符号，这里获得的是所有传入脚本的参数，而 exec 是执行命令，直接执行这些参数。</code></p>\n<p>如果直接看这条命令大家会有些疑惑，参数怎么拿来执行，这不是有问题么？</p>\n<p>请大家回顾一下，我们之前提到的，如果在镜像里同时定义了 ENTRYPOINT 和 CMD 两个指令，CMD 指令的内容会以参数的形式传递给 ENTRYPOINT 指令。所以，这里脚本最终执行的，是 CMD 中所定义的命令。</p>\n<h3> 目录挂载</h3>\n<p>在这个例子里，我们会把项目中的一些目录或文件挂载到容器里，这样的挂载主要有三种目的：</p>\n<ul>\n<li>\n<p>将程序的配置通过挂载的方式覆盖容器中对应的文件，这让我们可以直接在容器外修改程序的配置，并通过直接重启容器就能应用这些配置；</p>\n</li>\n<li>\n<p>把目录挂载到容器中应用数据的输出目录，就可以让容器中的程序直接将数据输出到容器外，对于 MySQL、Redis 中的数据，程序的日志等内容，我们可以使用这种方法来持久保存它们；</p>\n</li>\n<li>\n<p>把代码或者编译后的程序挂载到容器中，让它们在容器中可以直接运行，这就避免了我们在开发中反复构建镜像带来的麻烦，节省出大量宝贵的开发时间。</p>\n</li>\n</ul>\n<p>上述的几种方法，对于线上部署来说都是不适用的，但在我们的开发过程中，却可以为我们免去大量不必要的工作，因此建议在开发中使用这些挂载结构。</p>\n<h3> 编写辅助脚本</h3>\n<p>我们知道，虽然 Docker Compose 简化了许多操作流程，但我们还是需要使用 docker-compose 命令来管理项目。对于这个例子来说，我们要启动它就必须使用这样的 docker-compose 命令来管理项目。对于这个例子来说，我们要启动它就必须使用这样的：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>而执行的目录必须是 docker-compose.yml 文件所在的目录，这样才能正确地读取 Docker Compose 项目的配置内容。</p>\n<p>我编写了一个 compose 脚本，用来简化 docker-compose 的操作命令。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在这个脚本里，我把一些共性的东西包含进去，这样我们就不必每次传入这些参数或选项了。同时，这个脚本还能自适应调用的目录，准确找到 docker-compose.yml 文件，更方便我们直接调用。</p>\n<p>通过这个脚本来操作项目，我们的命令就可以简化为：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> docker 常用命令</h2>\n<h3> 一、docker 启动</h3>\n<h4> Ubuntu</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> CentOS</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 二、关闭 docker</h3>\n<h4> Ubuntu</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> CentOS</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 三、重启 docker</h3>\n<h4> Ubuntu</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> CentOS</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 四、卸载 docker</h3>\n<h4> Ubuntu</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> CentOS</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 五、镜像加速</h3>\n<p>Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p>\n<blockquote>\n<p>科大镜像：<a href=\"https://docker.mirrors.ustc.edu.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">https://docker.mirrors.ustc.edu.cn/</a></p>\n<p>网易：<a href=\"https://hub-mirror.c.163.com/\" target=\"_blank\" rel=\"noopener noreferrer\">https://hub-mirror.c.163.com/</a></p>\n<p>阿里云：&lt;https://&lt;你的&gt; ID&gt;.mirror.aliyuncs.com</p>\n<p>七牛云加速器：<a href=\"https://reg-mirror.qiniu.com\" target=\"_blank\" rel=\"noopener noreferrer\">https://reg-mirror.qiniu.com</a></p>\n<p>Ubuntu14.04、Debian7Wheezy</p>\n</blockquote>\n<p>对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中配置加速器地址：</p>\n<blockquote>\n<p>DOCKER_OPTS=\"--registry-mirror=<a href=\"https://registry.docker-cn.com\" target=\"_blank\" rel=\"noopener noreferrer\">https://registry.docker-cn.com</a>\"</p>\n</blockquote>\n<p>重新启动服务:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> Ubuntu16.04+、Debian8+、CentOS7</h4>\n<p>对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）：</p>\n<p><code>{\"registry-mirrors\":[\"https://reg-mirror.qiniu.com/\"]}</code></p>\n<p>之后重新启动服务：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 六、镜像使用</h3>\n<h4> 列出镜像列表</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 获取一个新的镜像</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 查找镜像</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 删除镜像`</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 七、容器使用</h3>\n<h4> 1、获取镜像</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 2、启动容器</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><blockquote>\n<p><code>-i</code>: 交互式操作。</p>\n<p><code>-t</code>: 终端。</p>\n<p><code>-d</code>: 后台运行</p>\n<p><code>--name nginx-test</code>：容器名称。</p>\n<p><code>nginx</code>: nginx 镜像</p>\n<p><code>/bin/bash</code>：放在镜像名后的是命令，这里我们希望有个交互式 <code>Shell</code>，因此用的是 <code>/bin/bash</code>。(要退出终端，直接输入 <code>exit</code>)</p>\n</blockquote>\n<h4> 3、提交容器副本为镜像</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><blockquote>\n<p>-m: 提交的描述信息</p>\n<p>-a: 指定镜像作者</p>\n<p>h7ml：容器 ID</p>\n<p>lqs/nginx-test:v1: 指定要创建的目标镜像名</p>\n</blockquote>\n<h4> 4、查看所有的容器</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 5、停止一个容器</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 6、启动已停止运行的容器</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 7、进入容器</h4>\n<p><code>docker attach</code> # 退出容器会停止</p>\n<p><code>docker exec</code> # 推荐大家使用 <code>docker exec</code> 命令，因为此退出容器终端，不会导致容器的停止。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>8、导出容器</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 9、导入容器快照</h4>\n<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，以下实例将快照文件 <code>nginx.tar</code> 导入到镜像 <code>test/nginx:v1</code>:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 10、删除容器</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 八、容器的端口映射</h3>\n<h4> 1、查看容器端口的映射情况</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 2、容器启动时可以指定通信协议，比如 tcp、udp</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 3、容器启动绑定多 IP 和端口（跟多个-p）</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 4、通过宿主机的 iptables 进行 nat 转发，将宿主机的端口映射到容器的内部端口上</h4>\n<p>这种方式适用于容器启动时没有指定端口映射的情况！</p>\n<p>首先获得容器的 ip 地址</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>将容器的 80 端口映射到 docker 主机的 8080 端口</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 5、提交一个运行中的容器为镜像，运行镜像并添加端口</h4>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "docker"
      ]
    },
    {
      "title": "dockerFile",
      "url": "https://www.h7ml.cn/posts/docker/dockerfile.html",
      "id": "https://www.h7ml.cn/posts/docker/dockerfile.html",
      "summary": "DockerFile 官网 open in new window，Dockerfile 是用来构建 Docker 镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。 image-20221025173147579",
      "content_html": "<h2> DockerFile</h2>\n<p><a href=\"https://docs.docker.com/engine/reference/builder\" target=\"_blank\" rel=\"noopener noreferrer\">官网 open in new window</a>，Dockerfile 是用来构建 Docker 镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221025173147579.png\" alt=\"image-20221025173147579\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221025173147579</figcaption></figure>\n<p>构建三步骤</p>\n<ul>\n<li>编写 Dockerfile 文件</li>\n<li>docker build 命令构建镜像</li>\n<li>docker run 依镜像运行容器实例</li>\n</ul>\n<h2> DockerFile 构建过程解析</h2>\n<h3> Dockerfile 内容基础知识</h3>\n<ol>\n<li>每条保留字指令都<strong>必须为大写字母</strong>且后面要跟随至少一个参数</li>\n<li>指令按照从上到下，顺序执行</li>\n<li>#表示注释</li>\n<li>每条指令都会创建一个新的镜像层并对镜像进行提交</li>\n</ol>\n<h3> Docker 执行 Dockerfile 的大致流程</h3>\n<ul>\n<li>（1）<code>docker</code>从基础镜像运行一个容器</li>\n<li>（2）执行一条指令并对容器作出修改</li>\n<li>（3）执行类似<code>docker commit</code>的操作提交一个新的镜像层</li>\n<li>（4）<code>docker</code>再基于刚提交的镜像运行一个新容器</li>\n<li>（5）执行<code>dockerfile</code>中的下一条指令直到所有指令都执行完成</li>\n</ul>\n<h3> 小总结</h3>\n<p>从应用软件的角度来看，<code>Dockerfile</code>、<code>Docker</code>镜像与<code>Docker</code>容器分别代表软件的三个不同阶段，</p>\n<ul>\n<li><code>Dockerfile</code>是软件的原材料</li>\n<li><code>Docker</code>镜像是软件的交付品</li>\n<li><code>Docker</code>容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例</li>\n</ul>\n<p><code>Dockerfile</code>面向开发，<code>Docker</code>镜像成为交付标准，<code>Docker</code>容器则涉及部署与运维，三者缺一不可，合力充当 Docker 体系的基石。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221025174124972.png\" alt=\"image-20221025174124972\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221025174124972</figcaption></figure>\n<p>1、<code>Dockerfile</code>，需要定义一个<code>Dockerfile</code>，<code>Dockerfile</code>定义了进程需要的一切东西。<code>Dockerfile</code>涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计<code>namespace</code>的权限控制)等等;</p>\n<p>2、<code>Docker</code>镜像，在用<code>Dockerfile</code>定义一个文件之后，<code>docker build</code>时会产生一个 Docker 镜像，当运行 <code>Docker</code>镜像时会真正开始提供服务;</p>\n<p>3、<code>Docker</code>容器，容器是直接提供服务的。</p>\n<h2> DockerFile 常用保留字指令</h2>\n<h3> FROM</h3>\n<p>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是 from</p>\n<h3> MAINTAINER</h3>\n<p>镜像维护者的姓名和邮箱地址</p>\n<h3> RUM</h3>\n<p>容器构建时需要运行的命令</p>\n<ul>\n<li>shell 格式</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221025175142566.png\" alt=\"image-20221025175142566\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221025175142566</figcaption></figure>\n<ul>\n<li>exec 格式</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221025175157422.png\" alt=\"image-20221025175157422\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221025175157422</figcaption></figure>\n<h3> EXPOSE</h3>\n<p>当前容器对外暴露出的端口</p>\n<h3> WORKDIR</h3>\n<p>指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p>\n<h3> USER</h3>\n<p>指定该镜像以什么样的用户去执行，如果都不指定，默认是 root</p>\n<h3> ENV</h3>\n<p>用来在构建镜像过程中设置环境变量</p>\n<h3> ADD</h3>\n<p>将宿主机目录下的文件拷贝进镜像且会自动处理 URL 和解压 tar 压缩包</p>\n<h3> COPY</h3>\n<p>类似 ADD，拷贝文件和目录到镜像中。 将从构建上下文目录中 <strong>&lt;源路径&gt;</strong> 的文件/目录复制到新的一层的镜像内的 <strong>&lt;目标路径&gt;</strong> 位置</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> VOLUME</h3>\n<p>容器数据卷，用于数据保存和持久化工作</p>\n<h3> CMD</h3>\n<p>指定容器启动后的要干的事情</p>\n<p><code>CMD</code>指令的格式和<code>RUN</code>相以，也是两种格式：</p>\n<ul>\n<li>shell 格式：<code>CND&lt;命令&gt;</code></li>\n<li>exec 格式：<code>CND[\"可执行文件\"，\"参数1\"，\"参数2\"..]</code></li>\n<li>参数列表格式：<code>CMD[\"参数1\"，\"参数2\"..]</code>。在指定了<code>ENTRYPOINT</code>指令后，用 CND 指定具体的参数。</li>\n</ul>\n<p>WARNING</p>\n<p><code>Dockerfile</code> 中可以有多个 <code>CMD</code> 指令，<strong>但只有最后一个生效，<code>CMD</code> 会被 <code>docker run</code> 之后的参数替换</strong></p>\n<p>参考官网<code>Tomcat</code>的<code>dockerfile</code>演示讲解</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026091950694.png\" alt=\"image-20221026091950694\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221026091950694</figcaption></figure>\n<p><strong>我们演示自己的覆盖操作</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026092007321.png\" alt=\"image-20221026092007321\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221026092007321</figcaption></figure>\n<p><strong>它和前面 RUN 命令的区别</strong></p>\n<ul>\n<li>CMD 是在 <code>docker run</code> 时运行</li>\n<li>RUN 是在 <code>docker build</code> 时运行</li>\n</ul>\n<h3> ENTRYPOINT</h3>\n<p>也是用来指定一个容器启动时要运行的命令</p>\n<p>类似于 <code>CMD</code> 指令，<strong>但是<code>ENTRYPOINT</code>不会被<code>docker run</code>后面的命令覆盖</strong>， 而且这些命令行参数<strong>会被当作参数送给 ENTRYPOINT 指令指定的程序</strong></p>\n<p><strong>命令格式和案例说明：</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026092602383.png\" alt=\"image-20221026092602383\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221026092602383</figcaption></figure>\n<p><code>ENTRYPOINT</code>可以和 CMD 一起用，一般是变参才会使用 <code>CMD</code> ，这里的 <code>CMD</code> 等于是在给 <code>ENTRYPOINT</code> 传参。</p>\n<p>当指定了<code>ENTRYPOINT</code>后，CMD 的含义就发生了变化，不再是直接运行其命令而是将 CMD 的内容作为参数传递给<code>ENTRYPOINT</code>指令，他两个组合会变成</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026092623867.png\" alt=\"image-20221026092623867\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221026092623867</figcaption></figure>\n<p>**案例如下：**假设已通过 <code>Dockerfile</code> 构建了 <strong><code>nginx:test</code></strong> 镜像：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026092655607.png\" alt=\"image-20221026092655607\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221026092655607</figcaption></figure>\n<table>\n<thead>\n<tr>\n<th>是否传参</th>\n<th>按照 dockerfile 编写执行</th>\n<th>传参运行</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Docker 命令</td>\n<td>docker run nginx:test</td>\n<td>docker run nginx:test -c /etc/nginx/new.conf</td>\n</tr>\n<tr>\n<td>衍生出的实际命令</td>\n<td>nginx -c /etc/nginx/nginx.conf</td>\n<td>nginx -c /etc/nginx/new.conf</td>\n</tr>\n</tbody>\n</table>\n<p>TIP</p>\n<p>优点：在执行<code>docker run</code>的时候可以指定 <code>ENTRYPOINT</code> 运行所需的参数。</p>\n<p>注意：如果 <code>Dockerfile</code> 中如果存在多个 <code>ENTRYPOINT</code> 指令，仅最后一个生效。</p>\n<h3> 小总结</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026093032611.png\" alt=\"image-20221026093032611\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221026093032611</figcaption></figure>\n<h2> 案例</h2>\n<p>自定义镜像 mycentosjava8</p>\n<ul>\n<li>\n<p>Centos7 镜像具备 vim+ifconfig+jdk8</p>\n</li>\n<li>\n<p>JDK 的下载镜像地址</p>\n</li>\n</ul>\n<p><a href=\"https://www.oracle.com/java/technologies/downloads/#java8\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.oracle.com/java/technologies/downloads/#java8</a></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026102031246.png\" alt=\"image-20221026102031246\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221026102031246</figcaption></figure>\n<p><a href=\"https://mirrors.yangxingzhen.com/jdk/\" target=\"_blank\" rel=\"noopener noreferrer\">https://mirrors.yangxingzhen.com/jdk/</a></p>\n<p>准备编写 Dockerfile 文件</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026102052196.png\" alt=\"image-20221026102052196\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221026102052196</figcaption></figure>\n<div class=\"language-docker line-numbers-mode\" data-ext=\"docker\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>大写字母 D、构建</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>注意，上面 TAG 后面有个空格，有个点，代表当前目录</p>\n</blockquote>\n<p>运行</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026102424772.png\" alt=\"image-20221026102424772\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221026102424772</figcaption></figure>\n<h2> 虚悬镜像</h2>\n<p>是什么：仓库名、标签都是<code>&lt;none&gt;</code>的镜像，俗称 dangling image，Dockerfile 写一个。</p>\n<div class=\"language-docker line-numbers-mode\" data-ext=\"docker\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026103459708.png\" alt=\"image-20221026103459708\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221026103459708</figcaption></figure>\n<p>查看</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026103518732.png\" alt=\"image-20221026103518732\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221026103518732</figcaption></figure>\n<p>删除</p>\n<p>虚悬镜像已经失去存在价值，可以删除</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026103545644.png\" alt=\"image-20221026103545644\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221026103545644</figcaption></figure>\n<h2> 总结</h2>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/docker/image-20221026103626226.png\" alt=\"image-20221026103626226\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221026103626226</figcaption></figure>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/docker/image-20221025173147579.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "docker"
      ]
    },
    {
      "title": "JavaScript ES6 Array 数组新增方法",
      "url": "https://www.h7ml.cn/posts/ecmascript/Array.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/Array.html",
      "summary": "JavaScript ES6 Array 数组新增方法 Array.of() 将参数中所有值作为元素形成数组。 没有参数则返回空数组 Array.of(1, '2', true); // [1, '2', true]",
      "content_html": "<h1> JavaScript ES6 Array 数组新增方法</h1>\n<h2> Array.of()</h2>\n<p>将参数中所有值作为元素形成数组。</p>\n<p>没有参数则返回空数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> Array.from()</h2>\n<p>将类数组对象或可迭代对象转化为数组。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 转换类数组</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 转换 map</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 转换 set</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 转换字符串</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 方法</h2>\n<h3> find()查找</h3>\n<p>则返回符合条件的第一个元素。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> findIndex() 查找索引</h3>\n<p>则返回符合条件的第一个元素的索引。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> fill()填充</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> copyWithin() 覆盖</h3>\n<ol>\n<li>开始覆盖的位置索引</li>\n<li>复制起始位置</li>\n<li>（可选）复制结束位置，默认为结尾</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> entries() 遍历</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不使用 for... of 循环</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> keys()遍历键名</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> values()遍历键值</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> includes()查找</h3>\n<p>数组是否包含指定值</p>\n<p>Set 的 has 方法用于查找值，Map 的 has 方法用于查找键名。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> flat()嵌套数组转一维数</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> flatMap()</h3>\n<p>先遍历元素，再对数组执行 flat() 方法。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ES6 Function 箭头函数",
      "url": "https://www.h7ml.cn/posts/ecmascript/Function.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/Function.html",
      "summary": "JavaScript ES6 Function 箭头函数 传参 // 默认参数 // 使用默认参数时，不能有同名形参 function fn(name, age = 17) { console.log(name + ',' + age); } function f(...values) { // [1, 2] console.log(values.length); // 2 } f(1, 2); // 2",
      "content_html": "<h1> JavaScript ES6 Function 箭头函数</h1>\n<h2> 传参</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 箭头函数</h2>\n<ul>\n<li>与一般函数区别\n<ul>\n<li>先声明后使用</li>\n<li>不能使用 arguments ,使用 ...rest 剩余运算符解决</li>\n<li>不能 new 当做构造函数</li>\n</ul>\n</li>\n<li>简写\n<ul>\n<li>只有一个形参时可以省略圆括号</li>\n<li>只有一条语句，且把这条语句当做返回值时可以省略大括号</li>\n</ul>\n</li>\n<li>this 指向\n<ul>\n<li>this 指向上一层函数的 this</li>\n<li>箭头函数的当前调用者不能使用 call，apply、bind 改变 this 指向</li>\n</ul>\n</li>\n<li>不适用场景\n<ul>\n<li>对象中的方法不适用箭头函数</li>\n<li>DOM 绑定事件不适用箭头函数</li>\n</ul>\n</li>\n</ul>\n<h2> 箭头函数不适用的场景</h2>\n<ol>\n<li>对象中的方法不能用箭头函数；</li>\n<li>给 DOM 绑定事件时不能用箭头函数；</li>\n</ol>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ES6 Generator 函数",
      "url": "https://www.h7ml.cn/posts/ecmascript/Generator.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/Generator.html",
      "summary": "JavaScript ES6 Generator 函数 执行机制 function 后加 *，函数执行后返回 Iterator 对象 返回的对象调用 next 方法开始执行，遇到 yield 关键字会停止。 再次调用 next 方法会从上一次的结束的地方继续执行，直到 yield yield 后面的值会在 next 执行停止时返回 next 传的参数会在函数内传给 yield function* fnc() { console.log('开始'); let a = yield '返回给next'; // next 没有传参 a 默认 undefined console.log(a, '结束'); // next传入 '结束' return '2'; } let f = fnc(); f.next('next传入'); // {value: \"返回给 next\", done: false} f.next(); // {value: undefined, done: true}",
      "content_html": "<h1> JavaScript ES6 Generator 函数</h1>\n<ul>\n<li>执行机制</li>\n</ul>\n<ol>\n<li>function 后加 *，函数执行后返回 Iterator 对象</li>\n<li>返回的对象调用 next 方法开始执行，遇到 yield 关键字会停止。</li>\n<li>再次调用 next 方法会从上一次的结束的地方继续执行，直到 yield</li>\n<li>yield 后面的值会在 next 执行停止时返回</li>\n<li>next 传的参数会在函数内传给 yield</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ES6 Iterator 迭代器",
      "url": "https://www.h7ml.cn/posts/ecmascript/Iterator.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/Iterator.html",
      "summary": "JavaScript ES6 Iterator 迭代器 核心概念： 迭代器是一个统一的接口，作用是使各种数据结构可被便捷的访问 是 Symbol.iterator 下的方法实现。提供这种接口的有 Array、String、arguments、Map、Set、Dom 元素（正在进行中）。可以被 for...of 遍历 Array 下有 Symbol 属性，所以arr[Symbol.iterator]()调用，返回 Iterator 对象 iterator 对象下 next 方法单次调用方法{value: '本次遍历的值', done: 是否遍历结束，返回 true/false }",
      "content_html": "<h1> JavaScript ES6 Iterator 迭代器</h1>\n<p>核心概念：</p>\n<ol>\n<li>迭代器是一个统一的接口，作用是使各种数据结构可被便捷的访问</li>\n<li>是 Symbol.iterator 下的方法实现。提供这种接口的有 Array、String、arguments、Map、Set、Dom 元素（正在进行中）。可以被 for...of 遍历</li>\n<li>Array 下有 Symbol 属性，所以<code>arr[Symbol.iterator]()</code>调用，返回 Iterator 对象</li>\n<li>iterator 对象下 next 方法单次调用方法<code>{value: '本次遍历的值', done: 是否遍历结束，返回 true/false }</code></li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ES6 Map 对象",
      "url": "https://www.h7ml.cn/posts/ecmascript/Map.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/Map.html",
      "summary": "JavaScript ES6 Map 对象 方法 set()、get()、delete()、has()、clear()、size set，get 键值对 key 是字符串 var myMap = new Map(); myMap.set('键', '和键关联的值'); // 设置 键值对 myMap.get('键'); // \"和键关联的值\" 获取值",
      "content_html": "<h1> JavaScript ES6 Map 对象</h1>\n<ul>\n<li>方法</li>\n</ul>\n<p>set()、get()、delete()、has()、clear()、size</p>\n<h2> set，get 键值对</h2>\n<p>key 是字符串</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>key 是对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>key 是函数时也与 key 是对象同理。</p>\n<p>key 是 NaN ，NaN 作为 Map 的键没有区别。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Map 的迭代 遍历</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> for...of</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> forEach</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 对象操作</h2>\n<h3> 转换</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 克隆</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 合并</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ES6 Object 对象",
      "url": "https://www.h7ml.cn/posts/ecmascript/Object.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/Object.html",
      "summary": "JavaScript ES6 Object 对象 简写 对象简写 const age = 12; const name = 'Amy'; const person = { age, name }; // {age: 12, name: \"Amy\"} // 等同于 person = {age: age, name: name}",
      "content_html": "<h1> JavaScript ES6 Object 对象</h1>\n<h2> 简写</h2>\n<h3> 对象简写</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 方法简写</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">Generator 函数，要在前面加星号</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></div>\n<h3> 属性名表达式</h3>\n<ul>\n<li>[变量]</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 合并对象</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">注意如果两个对象有同名的属性会被覆盖（数组也是同理） :::</p>\n<h3> Object.assign()</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>将后面所有可枚举的属性赋值到 target 对象中。重复的值会覆盖</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>只有一个参数不是对象，也会转换为对象返回</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>第一个参数时 null 或 undefined 会报错</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>null 和 undefined 放第二个之后会跳过</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同名属性会被替换</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>数组的处理</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 链判断运算符</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 三种用法</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></div>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ES6 Promise",
      "url": "https://www.h7ml.cn/posts/ecmascript/Promise.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/Promise.html",
      "summary": "JavaScript ES6 Promise Promise 状态 Promise 状态 pending（进行中） ----&gt; fulfilled/resolved（成功） pending（进行中） ----&gt; rejected（失败） 只要处于 fulfilled/resolved [成功] 和 rejected [失败]，状态就不会再变。 创建 Promise 参数内的函数会立即执行，并返回 Promise 对象 两个参数代表状态，resolve 成功调用，reject 失败调用",
      "content_html": "<h1> JavaScript ES6 Promise</h1>\n<h2> Promise 状态</h2>\n<p>Promise 状态</p>\n<ul>\n<li>pending（进行中） ----&gt; fulfilled/resolved（成功）</li>\n<li>pending（进行中） ----&gt; rejected（失败）</li>\n</ul>\n<p>只要处于 fulfilled/resolved [成功] 和 rejected [失败]，状态就不会再变。</p>\n<ol>\n<li>创建 Promise 参数内的函数会立即执行，并返回 Promise 对象</li>\n<li>两个参数代表状态，resolve 成功调用，reject 失败调用</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"3\">\n<li>返回 Pormise 对象调用 then 方法，第一个参数对象 resolve 成功后的回调，第二个参数对应 reject 失败时回调。then 方法也会返回 Promise 对象</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"4\">\n<li>then 方法执行成功的回调时，如果发生错误，不会被第二个参数对应 reject 失败时回调捕捉到。</li>\n<li>then 方法执行成功的回调发生错误是，链式调用 catch 方法可以捕捉前面 then 方法发生的错误</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Promise.all()与 Promise.race()</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol>\n<li>传入数组中包含多个 Promise 实例，也可以是别的值，all 包装成一个新的 Promise</li>\n<li>全部都成功后，返回每个 Promise 成功的值 [\"resolve 成功值 1\", \"resolve 成功值 1\"]</li>\n<li>任何一个失败，返回第一个失败的 Promise 结果</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>不管成功还是失败、哪个结果获得的快，就返回那个结果。</p>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ES6 Proxy",
      "url": "https://www.h7ml.cn/posts/ecmascript/Proxy.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/Proxy.html",
      "summary": "JavaScript ES6 Proxy target：即目标对象 handler：是一个对象，代理 target 的指定行为 let proxy = new Proxy(target, handler); let target = { name: 'Tom', age: 24, }; let handler = { get: function (target, key) { // 获取target的值会触发次函数 console.log('getting ' + key); return target[key]; // 不是target.key }, set: function (target, key, value) { // 设置target的值会触发次函数 console.log('setting ' + key); target[key] = value; }, };",
      "content_html": "<h1> JavaScript ES6 Proxy</h1>\n<ul>\n<li>target：即目标对象</li>\n<li>handler：是一个对象，代理 target 的指定行为</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ES6 Set 对象",
      "url": "https://www.h7ml.cn/posts/ecmascript/Set.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/Set.html",
      "summary": "JavaScript ES6 Set 对象 原型方法 add()、delete()、has()、clear()、 size Set 对象允许存储任何类型的唯一值，原始值或引用值都可。 特殊值 +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复。 undefined 与 undefined 是恒等的，所以不重复。 NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。",
      "content_html": "<h1> JavaScript ES6 Set 对象</h1>\n<ul>\n<li>原型方法\n<ul>\n<li>add()、delete()、has()、clear()、 size</li>\n</ul>\n</li>\n<li>Set 对象允许存储任何类型的唯一值，原始值或引用值都可。</li>\n<li>特殊值\n<ul>\n<li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复。</li>\n<li>undefined 与 undefined 是恒等的，所以不重复。</li>\n<li>NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。</li>\n</ul>\n</li>\n</ul>\n<h2> 创建</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 转换</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 数组去重</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 并集</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 交集</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Set.has(x) 是 set 中的一个方法。</p>\n<p>判断当前 set 对象 中是否含有 x，返回 true/false。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>[...a] 解构成数组。filter 过滤</p>\n<p>传入 x，返回 set 对象 b 中是否存在 x</p>\n<p>存在返回 true，不存在返回 false 被过滤掉</p>\n<h2> 差集</h2>\n<p>与交集同理</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ES6 String 字符串新增方法",
      "url": "https://www.h7ml.cn/posts/ecmascript/String.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/String.html",
      "summary": "JavaScript ES6 String 字符串新增方法 模板字面量 console.log(`Hello, ${`World`}!`); // Hello, World!",
      "content_html": "<h1> JavaScript ES6 String 字符串新增方法</h1>\n<h2> 模板字面量</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>所有插入的值都会使用 toString()强制转型为字符串：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>也可以插入自己之前的值：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 标签函数</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>标签函数的表达式参数的个数始终是 n，传给标签函数的第一个参数所包含的字符串个数则始终是 n+1。返回正常的字符串结果：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 字符串原始值</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过标签函数的第一个参数取得原始值：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 识别查找</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> repeat()</h2>\n<p>repeat()：返回新字符串，将字符串重复指定次数返回。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>0 至 -1 之间的小数，取整得到 -0 ，等同于 repeat 零次</p>\n<p>NaN，等同于 repeat 零次</p>\n<p>负数或者 Infinity ，会报错:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>传入字符串会隐式转换数字</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 字符串补全</h2>\n<p>padStart：返回新的字符串，从头部（左侧）补全。</p>\n<p>padEnd：返回新的字符串，从尾部（右侧）补全。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 去除空格</h2>\n<p>trimStart()：消除字符串头部的空格 trimEnd()：消除尾部的空格</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示浏览器还部署了额外的两个方法，trimLeft() 是 trimStart() 的别名，trimRight() 是 trimEnd() 的别名。 :::</p>\n<h2> 替换</h2>\n<p>matchAll()：方法返回一个正则表达式在当前字符串的所有匹配</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></div>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ES6 Symbol 对象",
      "url": "https://www.h7ml.cn/posts/ecmascript/Symbol.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/Symbol.html",
      "summary": "JavaScript ES6 Symbol 对象 符号本身是原始类型，所以 typeof 操作符对符号返回 symbol。 let sym = Symbol(); console.log(typeof sym); // symbol",
      "content_html": "<h1> JavaScript ES6 Symbol 对象</h1>\n<p>符号本身是原始类型，所以 typeof 操作符对符号返回 symbol。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 声明</h2>\n<ol>\n<li>原始数据类型，不能使用 new</li>\n<li>括号内是备注的意思，独一无二的值，两个 Symbol 不相等</li>\n<li>typeof 检测为 Symbol</li>\n<li>作为对象的键名独一无二、使用 [] 设置/获取，不能用.运算符获取设置</li>\n<li>作为对象属性名是，是共有属性，不是私有属性，可以在类的外部访问</li>\n<li>不能被枚举 for in、for of、Object.keys()、Object.getOwnPropertyNames() 返回</li>\n<li>可以被 Object.getOwnPropertySymbols() 和 Reflect.ownKeys() 取到</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>作为属性名</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为了避免创建符号包装对象，Symbol()函数不能与 new 关键字一起作为构造函数使用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果要包装对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>全局符号注册表第一次调用会检查全局的注册表，不存在则生成新的符号添加到注册表，存在则会直接返回对于的。</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>与 Symbol()定义的符号也并不等同</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Symbol.for()的任何值都会被转换为字符串</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Symbol.keyFor()来查询全局注册表</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>计算属性语法中使用符号作为属性：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果没有保存 Symbol 的引用，需要遍历才能找到：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"highlight-lines\"><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><br><br><br><br><br><br><br></div><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Symbol.for()</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol>\n<li>全局搜索是否存在该名称</li>\n<li>有：返回本身，没有：新建一个返回</li>\n<li>使两个 Symbol 类型的变量相等，生成同一个 Hash 值</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Symbol.keyFor(sym)</h2>\n<ol>\n<li>查找键值的某个 Symbol</li>\n<li>找到返回该 Symbol 的 key 值，字符串类型。否则 undefined</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.asyncIterator</h3>\n<p>该方法返回对象默认的 AsyncIterator 由 for-await-of 语句使用。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>技术上来说，由 Symbol.asyncIterator 函数生成的对象应该通过 next()方法陆续返回 Promise 实例。</p>\n<p>也可以隐式通过异步生成器函数返回：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.hasInstance</h3>\n<p>ECMAScript 规范，这个符号作为一个属性表示“一个方法，传入对象返回该对象是否是它的实例。</p>\n<p>instanceof 操作符可以用来确定一个对象实例的原型链上是否有原型。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>ES6 中，instanceof 操作符会使用 Symbol.hasInstance 函数来确定关系</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Baz 继承了 Bar 并覆写了 Symbol.hasInstance，instanceof 操作符也会在原型链上寻找这个属性，所以说就就跟在原型链上寻找其他属性一样，这里重新定义了这个函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"highlight-lines\"><br><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><br><br><br><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div></div><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.isConcatSpreadable</h3>\n<ul>\n<li>ECMAScript 规范，这个符号作为一个属性表示“一个布尔值”</li>\n<li>默认情况下则对象应该用 Array.prototype.concat()展开数组元素</li>\n<li>如果是 true，则被忽略</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.iterator</h3>\n<ul>\n<li>ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器，由 for-of 语句使用”</li>\n<li>for-of 循环时，会调用以 Symbol.iterator 为键的函数，并默认这个函数会返回一个实现迭代器 API 的对象。</li>\n<li>很多时候，返回的对象是实现该 API 的 Generator：</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Symbol.iterator 返回的对象可以通过 next()方法陆续返回值。也可以隐式地通过生成器函数返回：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"highlight-lines\"><br><br><br><br><br><div class=\"highlight-line\">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.match</h3>\n<ul>\n<li>ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串。由 String.prototype.match()方法使用”</li>\n<li>String.prototype.match() 会调用以 Symbol.match 为键的函数来正则求值</li>\n<li>正则表达式的原型上就有 Symbol.match 这个函数</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>match 方法传入非正则表达式会被转为 RegExp 对象，如果要改变默认行为，需要重新定义 Symbol.match 函数。</p>\n<p>Symbol.match 接收一个参数，就是调用 match() 方法之前的字符串实例。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"highlight-lines\"><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><br><br><br><br><br><br><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><br><br><br></div><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.replace</h3>\n<ul>\n<li>这个符号作为一个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 String.prototype.replace()方法使用”</li>\n<li>String.prototype.replace() 会调用 Symbol.replace 为键的方法来正则求值</li>\n<li>正则表达式原型上也有 Symbol.replace</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象，可以重新定义 Symbol.replace 函数取代默认对正则表达式求值的行为。</p>\n<p>Symbol.replace 函数接收两个参数，即调用 replace()方法的字符串实例和替换字符串</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"highlight-lines\"><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><br><br><br><br><br><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><br><br></div><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.search</h3>\n<ul>\n<li>ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由 String.prototype.search()方法使用”</li>\n<li>String.prototype.search() 会调用 Symbol.search 为键的方法来正则求值</li>\n<li>正则表达式原型上也有 Symbol.search</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>search 方法传入非正则表达式值会被转换为 RegExp 对象，重新定义 Symbol.search 函数以取代默认对正则表达式求值的行为</p>\n<p>Symbol.search 函数接收一个参数，就是调用 search()方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"highlight-lines\"><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><br><br><br><br><br><br><br><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><br><br><br><br></div><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.species</h3>\n<ul>\n<li>ECMAScript 规范，这个符号作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"highlight-lines\"><br><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><div class=\"highlight-line\">&nbsp;</div></div><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>刚看到这有点懵，看下面例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol>\n<li>MyArr 继承 Array，a 是 MyArr 构造的实例，b 又是 a 实例衍生的对象。</li>\n<li>按道理说 b 应该是 Array 构造出来的实例，但实际上 MyArr 构造的实例（instanceof 返回 true 说明 b 原型链上存在 MyArr）</li>\n<li>而 Symbol.species 属性就是为了解决这个问题而提供的：</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样，衍生出来的 b 则不是 MyArray 构造出来的了，而是 return 返回 Array 的实例</p>\n<h3> Symbol.split</h3>\n<ul>\n<li>ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，方法匹配正则的索引位置拆分字符串。由 String.prototype.split()方法使用”。</li>\n<li>String.prototype.split()方法会使用以 Symbol.split 为键的函数来对正则表达式求值</li>\n<li>正则表达式原型上也有 Symbol.split</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Symbol.split 第一个参数就是调用 match()方法的字符串实例。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"highlight-lines\"><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><br><br><br><br><br><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><br><br></div><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.toPrimitive</h3>\n<ul>\n<li>ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法将对象转换为相应的原始值。由 ToPrimitive 抽象操作使用”</li>\n<li>很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型</li>\n<li>重写 Symbol.toPrimitive 属性上的方法可以改变默认行为：</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"highlight-lines\"><br><br><br><br><br><br><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><br><br><br><br><br><br></div><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.toStringTag</h3>\n<ul>\n<li>ECMAScript 规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法 Object.prototype.toString()使用”。</li>\n<li>toString()获取对象标识时，会查找 Symbol.toStringTag 指定的实例标识符，默认为\"Object\"。</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>内置类型已经定义了 Symbol.toStringTag 属性，但自定义类需要自己定义：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"highlight-lines\"><br><br><br><br><br><br><br><div class=\"highlight-line\">&nbsp;</div><br><br><br><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div></div><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol.unscopables</h3>\n<ul>\n<li>ECMAScript 规范，这个符号作为一个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联对象的 with 环境绑定中排除”</li>\n<li>让对应的属性值的键为 true，就可以阻止改属性出现在 with 中</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"highlight-lines\"><br><br><br><br><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><div class=\"highlight-line\">&nbsp;</div><br><br><br></div><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ES6 let、cont、解构",
      "url": "https://www.h7ml.cn/posts/ecmascript/VariableDeclarationDestructuring.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/VariableDeclarationDestructuring.html",
      "summary": "JavaScript ES6 let、cont、解构 let 和 const 遇到 {} 就形成作用域 同一作用域不能重复声明变量或函数 [如：let 声明过不能用 const 和 var 声明相同名字] 没有变量提升 const 必须初始化赋值，不能被修改，而 let 声明的变量不用 const 定义的对象或者数组，其实是可变的。 可以修改添加属性 const car = { color: 'white' }; car.color = 'red'; // 修改属性: car.owner = 'Johnson'; // 添加属性",
      "content_html": "<h1> JavaScript ES6 let、cont、解构</h1>\n<h2> let 和 const</h2>\n<ol>\n<li>遇到 {} 就形成作用域</li>\n<li>同一作用域不能重复声明变量或函数 [如：let 声明过不能用 const 和 var 声明相同名字]</li>\n<li>没有变量提升</li>\n<li>const 必须初始化赋值，不能被修改，而 let 声明的变量不用</li>\n<li>const 定义的对象或者数组，其实是可变的。</li>\n</ol>\n<ul>\n<li>可以修改添加属性</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>不能赋值</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>数组同理</p>\n<ol start=\"6\">\n<li>全局作用域 var 属于 window 对象。let 不属于 window 对象。</li>\n<li>let 有暂时性死区、要先声明再使用。</li>\n</ol>\n<h2> 解构</h2>\n<p>[模式] = [数组];</p>\n<p>{模式} = {对象};</p>\n<ul>\n<li>完全解构</li>\n<li>不完全解构 [,可以被忽略 为赋值成功为 undefined ]</li>\n<li>嵌套</li>\n<li>默认值 , undefined 不会被赋值,null 可以被赋值</li>\n</ul>\n<p>数组解构</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol>\n<li>, 会忽略</li>\n<li>[] 可以嵌套</li>\n<li>undefined 不会赋值上去， m = 88 默认值，null 会被赋值</li>\n<li>...z 剩余运算符 收集对象/数组/值 或 展开数组/对象/值</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>字符串</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>对象</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>解构默认值</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>对象 = 数组</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 运用</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>设置默认值，可以改变传入参数的顺序</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ES6 async 函数",
      "url": "https://www.h7ml.cn/posts/ecmascript/async.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/async.html",
      "summary": "JavaScript ES6 async 函数 async 函数返回 Promise 对象，用同步流程来表达异步操作 虽然返回的是 Promise 对象，但不能在 async 函数中调用 resolve，reject 函数 async 可以单独使用，await 只能在 async 函数中使用 调用 async 函数会立即执行，遇到 await 关键字会暂停执行，await 后的指向完成后，async 函数接着执行。 如果 await 后的异步需要时间，await 下一行会接着执行，导致 await 的结果比下一行代码后得到 解决异步需要时间的问题，await 等待的是 Promise 的结果。所以 await 后面配合 Promise 执行异步函数，但 await 不能处理 Promise 失败后的结果 解决失败结果方法一：await prm().catch(e =&gt; {}); 阅读不方便 解决方法二 ： 在 prm() 结果中不管成功还是失败,都调用 resolve 方法,成功传[null,数据]，失败传 [err]; await 执行后 [e,d]=await prm(); 结构判断 e 是否出错",
      "content_html": "<h1> JavaScript ES6 async 函数</h1>\n<ol>\n<li>async 函数返回 Promise 对象，用同步流程来表达异步操作</li>\n<li>虽然返回的是 Promise 对象，但不能在 async 函数中调用 resolve，reject 函数</li>\n<li>async 可以单独使用，await 只能在 async 函数中使用</li>\n<li>调用 async 函数会立即执行，遇到 await 关键字会暂停执行，await 后的指向完成后，async 函数接着执行。</li>\n<li>如果 await 后的异步需要时间，await 下一行会接着执行，导致 await 的结果比下一行代码后得到</li>\n<li>解决异步需要时间的问题，await 等待的是 Promise 的结果。所以 await 后面配合 Promise 执行异步函数，但 await 不能处理 Promise 失败后的结果</li>\n<li>解决失败结果方法一：await prm().catch(e =&gt; {}); 阅读不方便</li>\n<li>解决方法二 ： 在 prm() 结果中不管成功还是失败,都调用 resolve 方法,成功传[null,数据]，失败传 [err]; await 执行后 [e,d]=await prm(); 结构判断 e 是否出错</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ES6 class 类",
      "url": "https://www.h7ml.cn/posts/ecmascript/class.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/class.html",
      "summary": "JavaScript ES6 class 类 constructor内外都可以定义属性，前面加static为静态属性 类里面，方法(){}为成员方法，加static为静态方法constructor内this.方法()为实例方法 继承父类方法使用extends，子类没有constructor时会默认调用父类的constructor 子类constructor内使用this之前必须调用super()方法把父类的this继承下来 成员属性、方法、静态属性、方法也会继承下来。子类使用父类方法可以super.方法名，也可以this.方法 子类用super.父类属性，也可以使用this来获取 静态方法不能访问成员属性，成员方法不能访问静态属性",
      "content_html": "<h1> JavaScript ES6 class 类</h1>\n<ol>\n<li><code>constructor</code>内外都可以定义属性，前面加<code>static</code>为静态属性</li>\n<li>类里面，<code>方法(){}</code>为成员方法，加<code>static</code>为静态方法<code>constructor</code>内<code>this.方法()</code>为实例方法</li>\n<li>继承父类方法使用<code>extends</code>，子类没有<code>constructor</code>时会默认调用父类的<code>constructor</code></li>\n<li>子类<code>constructor</code>内使用<code>this</code>之前必须调用<code>super()</code>方法把父类的<code>this</code>继承下来</li>\n<li>成员属性、方法、静态属性、方法也会继承下来。子类使用父类方法可以<code>super.方法名</code>，也可以<code>this.方法</code></li>\n<li>子类用<code>super.父类属性</code>，也可以使用<code>this</code>来获取</li>\n<li>静态方法不能访问成员属性，成员方法不能访问静态属性</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ES6 模块化",
      "url": "https://www.h7ml.cn/posts/ecmascript/modular.html",
      "id": "https://www.h7ml.cn/posts/ecmascript/modular.html",
      "summary": "JavaScript ES6 模块化 es6 模块语法无法在浏览器，vscode 直接运行。 需要安装 npm 包：babel 将 es6 语法转换成 es5。browserify 后台代码编译成前端 npm 包 单个暴露 export let/var 属性名=属性值 export function 方法名(){ }",
      "content_html": "<h1> JavaScript ES6 模块化</h1>\n<ol>\n<li>es6 模块语法无法在浏览器，vscode 直接运行。</li>\n<li>需要安装 npm 包：babel 将 es6 语法转换成 es5。browserify 后台代码编译成前端 <a href=\"../%E6%9C%8D%E5%8A%A1%E7%AB%AF/Node.js/npm\">npm 包</a></li>\n</ol>\n<p>单个暴露</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>批量暴露</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>暴露所有</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>使用模块：导入单个对应 export</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>引入所有：对应 export default</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "工程化",
      "url": "https://www.h7ml.cn/posts/engineering/",
      "id": "https://www.h7ml.cn/posts/engineering/",
      "summary": "editorconfig gitattributes gitignore prettierrc",
      "content_html": "<h3> <a href=\"/posts/engineering/editorconfig.html\" target=\"blank\">editorconfig</a></h3>\n<h3> <a href=\"/posts/engineering/gitattributes.html\" target=\"blank\">gitattributes</a></h3>\n<h3> <a href=\"/posts/engineering/gitignore.html\" target=\"blank\">gitignore</a></h3>\n<h3> <a href=\"/posts/engineering/prettierrc.html\" target=\"blank\">prettierrc</a></h3>\n<h3> <a href=\"/posts/engineering/license.html\" target=\"blank\">license</a></h3>\n<h3> <a href=\"/posts/engineering/package-json.html\" target=\"blank\">package.json</a></h3>\n<h3> <a href=\"/posts/engineering/tsconfig_json.html\" target=\"blank\">tsconfig_json</a></h3>\n<h3> <a href=\"/posts/engineering/eslintrc.html\" target=\"blank\">eslintrc</a></h3>\n<h2> 使用 <code>husky</code>、<code>lint-staged</code>、<code>commitlint</code> 构建前端工作流</h2>\n<h3> 作用</h3>\n<p>可以帮助我们在 <code>commit</code> 前，对代码和 <code>commit messages</code> 进行 <code>lint</code></p>\n<h3> 介绍</h3>\n<p><a href=\"https://github.com/typicode/husky\" target=\"_blank\" rel=\"noopener noreferrer\">husky</a> 是一个 <code>Git Hooks</code> 工具，让你操作 <code>Git Hooks</code> 变得更容易</p>\n<p><a href=\"https://github.com/okonet/lint-staged\" target=\"_blank\" rel=\"noopener noreferrer\">lint-staged</a> 可以只对 <code>git</code> 暂存文件运行 <code>lint</code> 从而提高速度</p>\n<p><a href=\"https://github.com/conventional-changelog/commitlint\" target=\"_blank\" rel=\"noopener noreferrer\">commitlint</a> 检查 <code>git commit messages</code> 是否符合规范</p>\n<p><a href=\"https://github.com/commitizen/cz-cli\" target=\"_blank\" rel=\"noopener noreferrer\">commitizen</a> 获得有关提交消息格式的即时反馈，并提示您输入必填字段。</p>\n<h3> 安装</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 使用 commitlint</h3>\n<p>修改<code>package.json</code></p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>根目录创建 <code>commitlint.config.js</code></li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> <code>@commitlint/config-conventional</code> type 说明</h3>\n<p>type 含义 feat 新功能 fix 修复 bug docs 修改文档 style 代码格式修改 refactor 重构（即不是新增功能，也不是修复 bug） perf 更改代码以提高性能 test 增加测试 build 构建过程或辅助工具的变动 ci 修改项目持续集成流程 chore 其他类型的提交 revert 恢复上一次提交</p>\n<h2> 在项目中使用 ESLint 和 Prettier</h2>\n<h3> 全局安装依赖</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>它会问你一些问题，你可以按照你的喜好进行配置，我选的是 popular 下面的 standard，生成的文件是 js 格式，那么就会创建出 eslintrc.js 文件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 配置文件 <code>.eslintrc.js</code> 介绍</h3>\n<p>根目录新建 <code>.eslintrc.js</code> 文件 <a href=\"https://gitee.com/dgiiot/dgiot-dashboard/blob/master/.eslintrc.js\" target=\"_blank\" rel=\"noopener noreferrer\">dgiot-dashboard .eslintrc.js</a></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><a href=\"https://cn.eslint.org/docs/user-guide/configuring\" target=\"_blank\" rel=\"noopener noreferrer\">.eslintrc.js 配置项说明</a></p>\n<h3> 添加脚本命令</h3>\n<p>在 <code>package.json</code> 的 <code>scripts</code> 配置项中写入</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 使用 Prettier</h2>\n<p>Prettier 是一个代码格式化工具，它通过解析代码并使用自己的规则（考虑最大行长）重新格式化代码，从而实现一致的编码风格</p>\n<h3> 安装</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li><a href=\"https://github.com/prettier/prettier\" target=\"_blank\" rel=\"noopener noreferrer\"><code>prettier</code></a>代码格式化程序</li>\n<li><a href=\"https://github.com/prettier/eslint-config-prettier\" target=\"_blank\" rel=\"noopener noreferrer\"><code>eslint-config-prettier</code></a>: 关闭 <code>ESLint</code> 中不必要的或可能与 <code>Prettier</code> 冲突的规则。</li>\n<li><a href=\"https://github.com/prettier/eslint-plugin-prettier\" target=\"_blank\" rel=\"noopener noreferrer\"><code>eslint-plugin-prettier</code></a>: 将 <code>Prettier</code> 作为 <code>ESLint</code> 规则运行，并将差异报告为单个 <code>ESLint</code> 问题。</li>\n</ul>\n<h3> 修改 <code>.eslintrc.js</code></h3>\n<h4> <code>eslint-config-prettier</code> 8.0.0 之后版本</h4>\n<p>在 <code>extends</code> 配置项中增加 <code>prettier</code> 和 <code>plugin:prettier/recommended</code></p>\n<h4> <code>eslint-config-prettier</code> 8.0.0 之前版本</h4>\n<p>在 <code>extends</code> 配置项中增加 <code>prettier/@typescript-eslint</code> 和 <code>plugin:prettier/recommended</code></p>\n<p><a href=\"https://github.com/prettier/eslint-config-prettier/blob/main/CHANGELOG.md#version-800-2021-02-21\" target=\"_blank\" rel=\"noopener noreferrer\">相关 CHANGELOG</a></p>\n<h3> 自定义 <code>Prettier</code> 风格规则</h3>\n<p>在根目录创建 <code>prettier.config.js</code> 文件和 <code>.prettierignore</code></p>\n<p><code>.prettierrc</code> <a href=\"https://gitee.com/dgiiot/dgiot-dashboard/blob/master/prettier.config.js\" target=\"_blank\" rel=\"noopener noreferrer\">dgiot-dashboard prettier</a></p>\n<p>自定义 <code>Prettier</code> 风格规则</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 添加脚本命令</h3>\n<p>在 <code>package.json</code> 的 <code>scripts</code> 配置项中写入 <code>\"prettier\": \"prettier --write ./src\"</code></p>\n<p><a href=\"https://cn.eslint.org/docs/rules/\" target=\"_blank\" rel=\"noopener noreferrer\">ESLint Rules</a> <a href=\"https://prettier.io/docs/en/options.html\" target=\"_blank\" rel=\"noopener noreferrer\">Prettier Options</a></p>\n<h2> 语义化版本控制</h2>\n<h3> 语义化版本说明</h3>\n<ul>\n<li>\n<p>标准版本号表示: X.Y.Z</p>\n\n<ul>\n<li>Y: 表示次版本号，在有向下兼容的新功能出现时递增</li>\n<li>Z: 表示修订版本号，在只做了向下兼容的修正时才递增</li>\n</ul>\n</li>\n<li>\n<p>先行版本号，在修订版本号使用连接号加上一连串以句点分隔的标识符来修饰。</p>\n\n<ul>\n<li>例子: 1.0.0-alpha 1.0.0-beta</li>\n</ul>\n</li>\n<li>\n<p>版本号优先级</p>\n\n<ul>\n<li>当主版本号、次版本号及修订版本号都相同时</li>\n</ul>\n</li>\n</ul>\n<h4> 版本号优先级排序</h4>\n<ol>\n<li>要将版本号拆分为主版本号、次版本号、修订版本号及先行版本号</li>\n<li>由左到右依序比较每个标识符(主版本号、次版本号及修订版本号直接以数值比较)</li>\n<li>当主版本号、次版本号及修订版本号都相同时，以先行版本号来判断</li>\n<li>先行版本号判断通过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较</li>\n</ol>\n<blockquote>\n<p>🌰 1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0</p>\n</blockquote>\n<h2> 使用 standard-version</h2>\n<p><a href=\"https://github.com/conventional-changelog/standard-version\" target=\"_blank\" rel=\"noopener noreferrer\">standard-version</a> 可以进行语义化版本发布和 CHANGELOG 生成</p>\n<h3> 安装</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 使用</h3>\n<p>在 <code>package.json</code> 的 <code>scripts</code> 配置 <code>\"release\": \"standard-version\"</code></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><a href=\"https://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"noopener noreferrer\">语义化版本 2.0.0</a></li>\n<li><a href=\"https://github.com/npm/node-semver\" target=\"_blank\" rel=\"noopener noreferrer\">语义版本控制程序 semver</a></li>\n</ul>\n",
      "date_published": "2021-05-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": []
    },
    {
      "title": "editorconfig",
      "url": "https://www.h7ml.cn/posts/engineering/editorconfig.html",
      "id": "https://www.h7ml.cn/posts/engineering/editorconfig.html",
      "summary": "跨编辑器/IDE 规范编码风格，使用 yaml 风格，配置文件为 .editorconfig 官网 注意在 VSCode 中需要下载一个插件，用于支持 editorconfigCore 一个规范的 .editorconfig 通常是这样的： root = true [*] charset = utf-8 indent_size = 2 indent_style = space end_of_line = lf insert_final_newline = true trim_trailing_whitespace = true [*.md] insert_final_newline = false trim_trailing_whitespace = false",
      "content_html": "<p>跨编辑器/IDE 规范编码风格，使用 yaml 风格，配置文件为 <code>.editorconfig</code></p>\n<p><a href=\"https://editorconfig.org/\" target=\"_blank\" rel=\"noopener noreferrer\">官网</a></p>\n<p>注意在 VSCode 中需要下载一个插件，用于支持 <code>editorconfigCore</code></p>\n<p>一个规范的 <code>.editorconfig</code> 通常是这样的：</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2021-05-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "engineering"
      ]
    },
    {
      "title": "eslintrc",
      "url": "https://www.h7ml.cn/posts/engineering/eslintrc.html",
      "id": "https://www.h7ml.cn/posts/engineering/eslintrc.html",
      "summary": "用于配置 ESLint 规则的配置文件 通常的表现形式有： package.json 中配置 eslintConfig 字段 使用 json、javascript、yaml 编写的 .eslintrc.* 文件 有很多信息可以配置： Environments - 指定脚本的运行环境。每种环境都有一组特定的预定义全局变量。 Globals - 脚本在执行期间访问的额外的全局变量。 Rules - 启用的规则及其各自的错误级别。",
      "content_html": "<p>用于配置 ESLint 规则的配置文件</p>\n<p>通常的表现形式有：</p>\n<ul>\n<li><code>package.json</code> 中配置 <code>eslintConfig</code> 字段</li>\n<li>使用 <code>json</code>、<code>javascript</code>、<code>yaml</code> 编写的 <code>.eslintrc.*</code> 文件</li>\n</ul>\n<p>有很多信息可以配置：</p>\n<ul>\n<li>Environments - 指定脚本的运行环境。每种环境都有一组特定的预定义全局变量。</li>\n<li>Globals - 脚本在执行期间访问的额外的全局变量。</li>\n<li>Rules - 启用的规则及其各自的错误级别。</li>\n</ul>\n<h2> 例子</h2>\n<p>一个 <code>.eslintrc</code> 文件示例(使用 json 编写)</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> eslint 与 prettierrc 使用</h1>\n<h2> 安装</h2>\n<ol>\n<li><code>vscode</code>搜索插件<code>eslint</code>安装</li>\n<li>控制台运行<code>npx i eslint --init</code>安装并执行<code>eslint</code>初始化</li>\n</ol>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 配置</h2>\n<ul>\n<li>依赖：<code>npm i @vue/eslint-config-typescript -D</code>.vue 文件的 ts 校验</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 配置不要做格式校验的文件</h2>\n<p>根目录<code>.eslintignore</code></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 代码格式化</h2>\n<ul>\n<li>\n<p><code>vscode</code>安装插件<code>Prettier - Code formatter</code></p>\n</li>\n<li>\n<p>配置格式化规则</p>\n</li>\n</ul>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>配置不需要格式化的文件</li>\n</ul>\n<p>根目录<code>.prettierignore</code></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 配置<code>prettier</code>格式化与<code>eslint</code>一致</h2>\n<ol>\n<li>vscode 快捷键 <code>ctrl + ,</code> 打开设置</li>\n<li>搜索<code>formatter</code></li>\n<li><code>Editor:Default Formatter</code>设置为<code>Prettier - Code formatter</code></li>\n<li>搜索<code>formatter on save</code>打钩，在报存是自动格式化</li>\n</ol>\n",
      "date_published": "2021-05-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "engineering"
      ]
    },
    {
      "title": "gitattributes",
      "url": "https://www.h7ml.cn/posts/engineering/gitattributes.html",
      "id": "https://www.h7ml.cn/posts/engineering/gitattributes.html",
      "summary": "当执行 git 动作时，.gitattributes 文件允许你指定由 git 使用的文件和路径的属性，例如：git commit 等。 比较常用的有 eol(end of line) 属性，主要原因在于 Windows 和 Unix like 的文件结尾行不同 windows 是 CRLF(Carriage Return Line Feed) 回车换行 但在 unix like 系统中，使用 LF(Line Feed) 换行 由于换行符不同，不同操作平台之间的开发者很容易导致 Git 提交的文件不一致(可能会从 LF 改为 CRLF 或者反之)，所以 gitattributes 就可以排上用场了：",
      "content_html": "<p>当执行 git 动作时，.gitattributes 文件允许你指定由 git 使用的文件和路径的属性，例如：git commit 等。</p>\n<p>比较常用的有 <code>eol</code>(end of line) 属性，主要原因在于 Windows 和 Unix like 的文件结尾行不同</p>\n<ul>\n<li>windows 是 <code>CRLF</code>(Carriage Return Line Feed) 回车换行</li>\n<li>但在 unix like 系统中，使用 <code>LF</code>(Line Feed) 换行</li>\n</ul>\n<p>由于换行符不同，不同操作平台之间的开发者很容易导致 Git 提交的文件不一致(可能会从 LF 改为 CRLF 或者反之)，所以 gitattributes 就可以排上用场了：</p>\n<p>一个规范的 <code>.gitattributes</code> 的文件可能是这样的：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果希望工作区的所有文本都是规范化的，可以采用</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在上面的配置文件中规范：</p>\n<ul>\n<li>所有文件是 <code>auto</code></li>\n<li><code>.js</code> 是 <code>lf</code></li>\n<li><code>.ts</code> 是 <code>crlf</code></li>\n<li><code>.sh</code> 不进行格式化</li>\n</ul>\n<h2> 引用</h2>\n<ul>\n<li><a href=\"https://www.cnblogs.com/kidsitcn/p/4769344.html\" target=\"_blank\" rel=\"noopener noreferrer\">详解</a></li>\n</ul>\n",
      "date_published": "2021-05-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "engineering"
      ]
    },
    {
      "title": "gitignore",
      "url": "https://www.h7ml.cn/posts/engineering/gitignore.html",
      "id": "https://www.h7ml.cn/posts/engineering/gitignore.html",
      "summary": "配置此文件可以让 git 对某些特定文件不追踪变化 gitignore 语法规则 空行不匹配任何文件，可以作为分隔符来提高可读性 # 为开头的行作为注释，若真的需要 #，则需要使用 \\# / 作为目录分割 ! 用于排除已忽略目录中的某个子文件/目录（即再次追踪） 如果在某个模式的开头或者中间（或者两者都有）存在 /，那么就是 gitignore 文件所在的根目录 如果末尾存在 /，那么只匹配目录，不再匹配文件 * 匹配除了 / 之外的任何，? 匹配除 / 之外的一个字符，范围符号例如 [a-zA-Z] 匹配范围中的一个字符 ** 的意义就比较多了 例如 **/foo 匹配所有地方的 foo 文件或文件夹，与 foo 的模式相同 **/foo/bar 匹配任何地方的 foo 目录下的 bar 文件或文件夹 后面的 /** 则匹配所有的子目录或者子文件，例如 a/** 匹配 a 下的所有目录和文件 中间的 ** 则表示无限深度的子目录，例如 a/**/b 匹配 a 下的所有子目录下的 b 文件或文件夹",
      "content_html": "<p>配置此文件可以让 git 对某些特定文件不追踪变化</p>\n<h2> gitignore 语法规则</h2>\n<ul>\n<li>空行不匹配任何文件，可以作为分隔符来提高可读性</li>\n<li><code>#</code> 为开头的行作为注释，若真的需要 <code>#</code>，则需要使用 <code>\\#</code></li>\n<li><code>/</code> 作为目录分割</li>\n<li><code>!</code> 用于排除已忽略目录中的某个子文件/目录（即再次追踪）</li>\n<li>如果在某个模式的开头或者中间（或者两者都有）存在 <code>/</code>，那么就是 <code>gitignore</code> 文件所在的根目录</li>\n<li>如果末尾存在 <code>/</code>，那么只匹配目录，不再匹配文件</li>\n<li><code>*</code> 匹配除了 <code>/</code> 之外的任何，<code>?</code> 匹配除 <code>/</code> 之外的<strong>一个字符</strong>，范围符号例如 [a-zA-Z] 匹配范围中的一个字符</li>\n<li><code>**</code> 的意义就比较多了\n<ul>\n<li>例如 <code>**/foo</code> 匹配所有地方的 <code>foo</code> 文件或文件夹，与 <code>foo</code> 的模式相同</li>\n<li><code>**/foo/bar</code> 匹配任何地方的 <code>foo</code> 目录下的 <code>bar</code> 文件或文件夹</li>\n<li>后面的 <code>/**</code> 则匹配所有的子目录或者子文件，例如 <code>a/**</code> 匹配 a 下的所有目录和文件</li>\n<li>中间的 <code>**</code> 则表示无限深度的子目录，例如 <code>a/**/b</code> 匹配 a 下的所有子目录下的 b 文件或文件夹</li>\n</ul>\n</li>\n</ul>\n<h2> 例子</h2>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2021-05-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "engineering"
      ]
    },
    {
      "title": "license",
      "url": "https://www.h7ml.cn/posts/engineering/license.html",
      "id": "https://www.h7ml.cn/posts/engineering/license.html",
      "summary": "开源协议文件 开源许可证详解 目前使用较多的开源协议为 MIT，同时该协议的最为自由",
      "content_html": "<p>开源协议文件</p>\n<ul>\n<li><a href=\"https://www.runoob.com/w3cnote/open-source-license.html\" target=\"_blank\" rel=\"noopener noreferrer\">开源许可证详解</a></li>\n</ul>\n<p>目前使用较多的开源协议为 <code>MIT</code>，同时该协议的最为自由</p>\n",
      "date_published": "2021-05-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "engineering"
      ]
    },
    {
      "title": "package-lock.json",
      "url": "https://www.h7ml.cn/posts/engineering/package-json.html",
      "id": "https://www.h7ml.cn/posts/engineering/package-json.html",
      "summary": "# npm package.json 属性详解 本文转自https://www.cnblogs.com/tzyy/p/5193811.html (opens new window) ，作者：TZYY",
      "content_html": "<h2> <a href=\"#npm-package-json%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3\">#</a> npm package.json 属性详解</h2>\n<blockquote>\n<p>本文转自<a href=\"https://www.cnblogs.com/tzyy/p/5193811.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/tzyy/p/5193811.html (opens new window)</a> ，作者：TZYY</p>\n</blockquote>\n<h2> <a href=\"#%E6%A6%82%E8%BF%B0\">#</a> 概述</h2>\n<p><code>package.json</code>必须是一个严格的 json 文件，而不仅仅是 js 里边的一个对象。其中很多属性可以通过<code>npm-config</code>来生成</p>\n<h2> <a href=\"#name\">#</a> name</h2>\n<p><code>package.json</code>中最重要的属性是<code>name</code>和<code>version</code> 两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个 npm 模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。 <code>name</code> 属性就是你的模块名称，下面是一些命名规则:</p>\n<ul>\n<li>\n<p><code>name</code>必须小于等于 214 个字节，包括前缀名称在内（如 xxx/xxxmodule）。</p>\n</li>\n<li>\n<p><code>name</code>不能以\"_\"或\".\"开头</p>\n</li>\n<li>\n<p>不能含有大写字母</p>\n</li>\n<li>\n<p><code>name</code>会成为 url 的一部分，不能含有 url 非法字符</p>\n<p>下面是官网文档的一些建议：</p>\n</li>\n<li>\n<p>不要使用和 node 核心模块一样的名称</p>\n</li>\n<li>\n<p><code>name</code>中不要含有\"js\"和\"node\"。 It's assumed that it's js, since you're writing a package.json file, and you can specify the engine using the \"engines\" field. (See below.)</p>\n</li>\n<li>\n<p><code>name</code>属性会成为模块 url、命令行中的一个参数或者一个文件夹名称，任何非 url 安全的字符在 name 中都不能使用，也不能以\"_\"或\".\"开头</p>\n</li>\n<li>\n<p><code>name</code>属性也许会被写在<code>require()</code>的参数中，所以最好取个简短而语义化的值。</p>\n</li>\n<li>\n<p>创建一个模块前可以先到后边的网址查查<code>name</code> 是否已经被占用. <a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.npmjs.com/ (opens new window)</a></p>\n<ul>\n<li>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><code>name</code>属性可以有一些前缀如 e.g. @myorg/mypackage.在 npm-scope(7)的文档中可以看到详细说明</p>\n<h2> <a href=\"#version\">#</a> version</h2>\n<p><code>version</code>必须可以被 npm 依赖的一个<code>node-semver</code>模块解析。具体规则见下面的<code>dependencies</code>模块</p>\n<h2> <a href=\"#description\">#</a> description</h2>\n<p>一个描述，方便别人了解你的模块作用，搜索的时候也有用。</p>\n<h2> <a href=\"#keywords\">#</a> keywords</h2>\n<p>一个字符串数组，方便别人搜索到本模块</p>\n<h2> <a href=\"#homepage\">#</a> homepage</h2>\n<p>项目主页 url <strong>注意:</strong> 这个项目主页 url 和 url 属性不同，如果你填写了 url 属性，npm 注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从 npm 官方仓库获取，而是会重定向到 url 属性配置的地址。（原文档中用了 spit(吐)这个单词，作者表示他不是在开玩笑:）</p>\n<h2> <a href=\"#bugs\">#</a> bugs</h2>\n<p>填写一个 bug 提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽，例如：</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4</p>\n<p>url 和 email 可以任意填或不填，如果只填一个，可以直接写成一个字符串而不是对象。如果填写了 url，npm bugs 命令会使用这个 url。</p>\n<h2> <a href=\"#license\">#</a> license</h2>\n<p>你应该为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。最简单的，例如你用 BSD-3-Clause 或 MIT 之类的协议，如下：</p>\n<p>你可以在<a href=\"https://spdx.org/licenses/\" target=\"_blank\" rel=\"noopener noreferrer\">https://spdx.org/licenses/ (opens new window)</a>这个地址查阅协议列表 。</p>\n<h2> <a href=\"#%E5%92%8C%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7-author-contributors\">#</a> 和用户相关的属性: author, contributors</h2>\n<p><code>author</code>是一个码农， <code>contributors</code>是一个码农数组。 <code>person</code>是一个有一些描述属性的对象，如下 like this:</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5</p>\n<p>也可以按如下格式缩写，npm 会帮着转换:</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>1</p>\n<p><code>email</code>和<code>url</code>属性实际上都是可以省略的。描述用户信息的还有一个<code>maintainers</code>（维护者）属性。</p>\n<h2> <a href=\"#files\">#</a> files</h2>\n<p><code>files</code>属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）你也可以在模块根目录下创建一个<code>.npmignore</code>文件（windows 下无法直接创建以\".\"开头的文件，使用 linux 命令行工具创建如 git bash），写在这个文件里边的文件即便被写在 files 属性里边也会被排除在外，这个文件的写法\".gitignore\"类似。</p>\n<h2> <a href=\"#main\">#</a> main</h2>\n<p><code>main</code>属性指定了程序的主入口文件。意思是，如果你的模块被命名为 foo，用户安装了这个模块并通过 require(\"foo\") 来使用这个模块，那么 require 返回的内容就是 main 属性指定的文件中 module.exports 指向的对象。它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。</p>\n<h2> <a href=\"#bin\">#</a> bin</h2>\n<p>很多模块有一个或多个需要配置到 PATH 路径下的可执行模块，npm 让这个工作变得十分简单（实际上 npm 本身也是通过 bin 属性安装为一个可执行命令的）如果要用 npm 的这个功能，在 package.json 里边配置一个 bin 属性。bin 属性是一个已命令名称为 key，本地文件名称为 value 的 map 如下：</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3</p>\n<p>模块安装的时候，若是全局安装，则 npm 会为 bin 中配置的文件在 bin 目录下创建一个软连接（对于 windows 系统，默认会在 C: \\Users\\username\\AppData\\Roaming\\npm 目录下），若是局部安装，则会在项目内的./node_modules/.bin/目录下创建一个软链接。因此，按上面的例子，当你安装 myapp 的时候，npm 就会为 cli.js 在/usr/local/bin/myapp 路径创建一个软链接。如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5</p>\n<p>作用和如下写法相同:</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5<br>\n6<br>\n7</p>\n<h2> <a href=\"#man\">#</a> man</h2>\n<p>制定一个或通过数组制定一些文件来让 linux 下的 man 命令查找文档地址。如果只有一个文件被指定的话，安装后直接使用 man+模块名称，而不管 man 指定的文件的实际名称。例如:</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5<br>\n6<br>\n7</p>\n<p>通过 man foo 命令会得到 ./man/doc.1 文件的内容。 如果 man 文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5<br>\n6<br>\n7</p>\n<p>会创建一些文件来作为 man foo 和 man foo-bar 命令的结果。 man 文件必须以数字结尾，或者如果被压缩了，以.gz 结尾。数字表示文件将被安装到 man 的哪个部分。</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5<br>\n6<br>\n7</p>\n<p>会创建 man foo 和 man 2 foo 两条命令。</p>\n<h2> <a href=\"#directories\">#</a> directories</h2>\n<p>CommonJs 通过 directories 来制定一些方法来描述模块的结构，看看 npm 的 package.json 文件<a href=\"https://registry.npmjs.org/npm/latest\" target=\"_blank\" rel=\"noopener noreferrer\">https://registry.npmjs.org/npm/latest</a> ，可以发现里边有这个字段的内容。 <img src=\"http://zoucz.com/blogimgs/2016-02-16/1455624810992.png\" alt=\"img\" loading=\"lazy\"> 目前这个配置没有任何作用，将来可能会整出一些花样来。</p>\n<h3> <a href=\"#directories-lib\">#</a> directories.lib</h3>\n<p>告诉用户模块中 lib 目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。</p>\n<h3> <a href=\"#directories-bin\">#</a> directories.bin</h3>\n<p>如果你在这里指定了 bin 目录，这个配置下面的文件会被加入到 bin 路径下，如果你已经在 package.json 中配置了 bin 目录，那么这里的配置将不起任何作用。</p>\n<h3> <a href=\"#directories-man\">#</a> directories.man</h3>\n<p>指定一个目录，目录里边都是 man 文件，这是一种配置 man 文件的语法糖。</p>\n<h3> <a href=\"#directories-doc\">#</a> directories.doc</h3>\n<p>在这个目录里边放一些 markdown 文件，可能最终有一天它们会被友好的展现出来（应该是在 npm 的网站上）</p>\n<h3> <a href=\"#directories-example\">#</a> directories.example</h3>\n<p>放一些示例脚本，或许某一天会有用 - -！</p>\n<h2> <a href=\"#repository\">#</a> repository</h2>\n<p>指定一个代码存放地址，对想要为你的项目贡献代码的人有帮助。像这样：</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5<br>\n6<br>\n7<br>\n8<br>\n9<br>\n10<br>\n11</p>\n<p>若你的模块放在 GitHub, GitHub gist, Bitbucket, or GitLab 的仓库里，npm install 的时候可以使用缩写标记来完成：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5<br>\n6<br>\n7</p>\n<h2> <a href=\"#scripts\">#</a> scripts</h2>\n<p>scripts 属性是一个对象，里边指定了项目的生命周期个各个环节需要执行的命令。key 是生命周期中的事件，value 是要执行的命令。 具体的内容有 install start stop 等，详见 <a href=\"https://docs.npmjs.com/misc/scripts\" target=\"_blank\" rel=\"noopener noreferrer\">https://docs.npmjs.com/misc/scripts (opens new window)</a></p>\n<h2> <a href=\"#config\">#</a> config</h2>\n<p>用来设置一些项目不怎么变化的项目配置，例如 port 等。 用户用的时候可以使用如下用法：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>1</p>\n<p>可以通过 npm config set foo:port 80 来修改 config。详见<a href=\"https://docs.npmjs.com/misc/config\" target=\"_blank\" rel=\"noopener noreferrer\">https://docs.npmjs.com/misc/config (opens new window)</a></p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4</p>\n<h2> <a href=\"#dependencies\">#</a> dependencies</h2>\n<p>dependencies 属性是一个对象，配置模块依赖的模块列表，key 是模块名称，value 是版本范围，版本范围是一个字符，可以被一个或多个空格分割。 dependencies 也可以被指定为一个 git 地址或者一个压缩包地址。 不要把测试工具或 transpilers 写到 dependencies 中。下面是一些写法，详见<a href=\"https://docs.npmjs.com/misc/semver\" target=\"_blank\" rel=\"noopener noreferrer\">https://docs.npmjs.com/misc/semver (opens new window)</a></p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5<br>\n6<br>\n7<br>\n8<br>\n9<br>\n10<br>\n11<br>\n12<br>\n13<br>\n14<br>\n15</p>\n<h2> <a href=\"#urls-as-dependencies\">#</a> URLs as Dependencies</h2>\n<p>在版本范围的地方可以写一个 url 指向一个压缩包，模块安装的时候会把这个压缩包下载下来安装到模块本地。</p>\n<h2> <a href=\"#git-urls-as-dependencies\">#</a> Git URLs as Dependencies</h2>\n<p>Git url 可以像下面一样:</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5</p>\n<p>commit-ish 可以是任意标签，哈希值，或者可以检出的分支，默认是 master 分支。</p>\n<h2> <a href=\"#github-urls\">#</a> GitHub URLs</h2>\n<p>支持 github 的 username/modulename 的写法，#后边可以加后缀写明分支 hash 或标签：</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5<br>\n6<br>\n7<br>\n8</p>\n<h2> <a href=\"#local-paths\">#</a> Local Paths</h2>\n<p>npm2.0.0 版本以上可以提供一个本地路径来安装一个本地的模块，通过 npm install xxx --save 来安装，格式如下：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4</p>\n<p>package.json 生成的相对路径如下:</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5<br>\n6</p>\n<p>这种属性在离线开发或者测试需要用 npm install 的情况，又不想自己搞一个 npm server 的时候有用，但是发布模块到公共仓库时不应该使用这种属性。</p>\n<h2> <a href=\"#devdependencies\">#</a> devDependencies</h2>\n<p>如果有人想要下载并使用你的模块，也许他们并不希望或需要下载一些你在开发过程中使用的额外的测试或者文档框架。在这种情况下，最好的方法是把这些依赖添加到 devDependencies 属性的对象中。 这些模块会在 npm link 或者 npm install 的时候被安装，也可以像其他 npm 配置一样被管理，详见 npm 的 config 文档。对于一些跨平台的构建任务，例如把 CoffeeScript 编译成 JavaScript，就可以通过在 package.json 的 script 属性里边配置 prepublish 脚本来完成这个任务，然后需要依赖的 coffee-script 模块就写在 devDependencies 属性种。例如:</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5<br>\n6<br>\n7<br>\n8<br>\n9<br>\n10<br>\n11</p>\n<p>prepublish 脚本会在发布之前运行，因此用户在使用之前就不用再自己去完成编译的过程了。在开发模式下，运行 npm install 也会执行这个脚本（见 npm script 文档），因此可以很方便的调试。</p>\n<h2> <a href=\"#peerdependencies\">#</a> peerDependencies</h2>\n<p>有时候做一些插件开发，比如 grunt 等工具的插件，它们往往是在 grunt 的某个版本的基础上开发的，而在他们的代码中并不会出现 require(\" grunt\")这样的依赖，dependencies 配置里边也不会写上 grunt 的依赖，为了说明此模块只能作为插件跑在宿主的某个版本范围下，可以配置 peerDependencies：</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5<br>\n6<br>\n7</p>\n<p>上面这个配置确保再 npm install 的时候 tea-latte 会和 2.x 版本的 tea 一起安装，而且它们两个的依赖关系是同级的： ├── tea-latte@1.3.5 └── tea@2.2.0 这个配置的目的是让 npm 知道，如果要使用此插件模块，请确保安装了兼容版本的宿主模块。</p>\n<h2> <a href=\"#bundleddependencies\">#</a> bundledDependencies</h2>\n<p>上面的单词少个 d，写成 bundleDependencies 也可以。 指定发布的时候会被一起打包的模块。</p>\n<h2> <a href=\"#optionaldependencies\">#</a> optionalDependencies</h2>\n<p>如果一个依赖模块可以被使用，同时你也希望在该模块找不到或无法获取时 npm 继续运行，你可以把这个模块依赖放到 optionalDependencies 配置中。这个配置的写法和 dependencies 的写法一样，不同的是这里边写的模块安装失败不会导致 npm install 失败。 当然，这种模块就需要你自己在代码中处理模块确实的情况了，例如：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>1<br>\n2<br>\n3<br>\n4<br>\n5<br>\n6<br>\n7<br>\n8<br>\n9<br>\n10<br>\n11<br>\n12<br>\n13<br>\n14<br>\n15</p>\n<p>optionalDependencies 中的配置会覆盖 dependencies 中的配置，最好只在一个地方写。</p>\n<h2> <a href=\"#engines\">#</a> engines</h2>\n<p>你可以指定项目运行的 node 版本范围，如下： { \"engines\" : { \"node\" : \"&gt;=0.10.3 &lt;0.12\" } } 和 dependencies 一样，如果你不指定版本范围或者指定为*，任何版本的 node 都可以。也可以指定一些 npm 版本可以正确的安装你的模块，例如： { \"engines\" : { \"npm\" : \"~1.0.20\" } } 要注意的是，除非你设置了 engine-strict 属性，engines 属性是仅供参考的。</p>\n<h2> <a href=\"#enginestrict\">#</a> engineStrict</h2>\n<p>注意：这个属性已经弃用，将在 npm 3.0.0 版本干掉。</p>\n<h2> <a href=\"#os\">#</a> os</h2>\n<p>可以指定你的模块只能在哪个操作系统上跑： \"os\" : [ \"darwin\", \"linux\" ] 也可以指定黑名单而不是白名单： \"os\" : [ \"! win32\" ] 服务的操作系统是由 process.platform 来判断的，这个属性允许黑白名单同时存在，虽然没啥必要这样搞...</p>\n<h2> <a href=\"#cpu\">#</a> cpu</h2>\n<p>限制模块只能在某某 cpu 架构下运行 \"cpu\" : [ \"x64\", \"ia32\" ] 同样可以设置黑名单: \"cpu\" : [ \"!arm\", \"!mips\" ] cpu 架构通过 process.arch 判断</p>\n<h2> <a href=\"#preferglobal\">#</a> preferGlobal</h2>\n<p>如果您的软件包主要用于安装到全局的命令行应用程序，那么该值设置为 true ，如果它被安装在本地，则提供一个警告。实际上该配置并没有阻止用户把模块安装到本地，只是防止该模块被错误的使用引起一些问题。</p>\n<h2> <a href=\"#private\">#</a> private</h2>\n<p>如果这个属性被设置为 true，npm 将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。如果你只想让模块被发布到一个特定的 npm 仓库，如一个内部的仓库，可与在下面的 publishConfig 中配置仓库参数。</p>\n<h2> <a href=\"#publishconfig\">#</a> publishConfig</h2>\n<p>这个配置是会在模块发布时用到的一些值的集合。如果你不想模块被默认被标记为最新的，或者默认发布到公共仓库，可以在这里配置 tag 或仓库地址。</p>\n<h2> <a href=\"#default-values\">#</a> DEFAULT VALUES</h2>\n<p>npm 设置了一些默认参数，如： \"scripts\": {\"start\": \"node server.js\"} 如果模块根目录下有一个 server.js 文件，那么 npm start 会默认运行这个文件。 \"scripts\":{\"preinstall\": \"node-gyp rebuild\"} 如果模块根目录下有 binding.gyp, npm 将默认用 node-gyp 来编译 preinstall 的脚本 \"contributors\": [...] 若模块根目录下有 AUTHORS 文件，则 npm 会按 Name (url) 格式解析每一行的数据添加到 contributors 中，可以用#添加行注释</p>\n<h2> <a href=\"#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3%E5%88%97%E8%A1%A8-https-docs-npmjs-com\">#</a> 参考文档列表(<a href=\"https://docs.npmjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">https://docs.npmjs.com/</a>)</h2>\n",
      "image": "http://zoucz.com/blogimgs/2016-02-16/1455624810992.png",
      "date_published": "2021-05-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "engineering"
      ]
    },
    {
      "title": "prettierrc",
      "url": "https://www.h7ml.cn/posts/engineering/prettierrc.html",
      "id": "https://www.h7ml.cn/posts/engineering/prettierrc.html",
      "summary": "prettier 的配置文件 通常的表现形式有： package.json 中配置 prettier 字段 用 JSON 或者 yaml 写 .prettierrc 文件 一个 .prettierrc.json、.prettierrc.yaml、.prettierrc.yml、.prettierrc.json5 文件 一个 .prettierrc.js、.prettierrc.cjs、prettier.config.js、prettier.config.cjs 文件用 module.exports 导出 一个 .prettierrc.toml 文件",
      "content_html": "<p>prettier 的配置文件</p>\n<p>通常的表现形式有：</p>\n<ul>\n<li><code>package.json</code> 中配置 <code>prettier</code> 字段</li>\n<li>用 JSON 或者 yaml 写 <code>.prettierrc</code> 文件</li>\n<li>一个 <code>.prettierrc.json</code>、<code>.prettierrc.yaml</code>、<code>.prettierrc.yml</code>、<code>.prettierrc.json5</code> 文件</li>\n<li>一个 <code>.prettierrc.js</code>、<code>.prettierrc.cjs</code>、<code>prettier.config.js</code>、<code>prettier.config.cjs</code> 文件用 <code>module.exports</code> 导出</li>\n<li>一个 <code>.prettierrc.toml</code> 文件</li>\n</ul>\n<h2> 例子</h2>\n<p>一个 <code>.prettierrc</code> 文件示例(使用 json 编写)</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2021-05-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "engineering"
      ]
    },
    {
      "title": "tsconfig.json",
      "url": "https://www.h7ml.cn/posts/engineering/tsconfig_json.html",
      "id": "https://www.h7ml.cn/posts/engineering/tsconfig_json.html",
      "summary": "Typescript 配置文件 通过该配置文件可以指定 ts 编译的版本，编译的配置选项开关等 文档",
      "content_html": "<p>Typescript 配置文件</p>\n<p>通过该配置文件可以指定 ts 编译的版本，编译的配置选项开关等</p>\n<p><a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\" target=\"_blank\" rel=\"noopener noreferrer\">文档</a></p>\n",
      "date_published": "2021-05-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "engineering"
      ]
    },
    {
      "title": "使用 Node.js 连接多种类型数据库",
      "url": "https://www.h7ml.cn/posts/fullStackTale/Database.html",
      "id": "https://www.h7ml.cn/posts/fullStackTale/Database.html",
      "summary": "本文介绍了如何使用 Node.js 连接多种不同类型的数据库，包括 MySQL、MongoDB、PostgreSQL、Oracle、Microsoft SQL Server、Redis、SQLite、Couchbase、Cassandra、Neo4j、ArangoDB、RethinkDB、CouchDB、Firebase 和 MariaDB，并提供了相应的示例代码和依赖包安装步骤。",
      "content_html": "<h1> 使用 Node.js 连接多种类型数据库</h1>\n<h2> 关系对比</h2>\n<table>\n<thead>\n<tr>\n<th>数据库</th>\n<th>驱动/模块</th>\n<th>连接方式</th>\n<th>优缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MariaDB</td>\n<td>mariadb</td>\n<td>使用 <code>mariadb.createConnection()</code> 创建连接，或者使用 <code>mariadb.createPool()</code> 创建连接池</td>\n<td>MariaDB 是 MySQL 的一个分支，与 MySQL 兼容。驱动程序相对较新，但已受到广泛认可和广泛使用。</td>\n</tr>\n<tr>\n<td>MongoDB</td>\n<td>mongodb</td>\n<td>使用 <code>mongodb.MongoClient.connect()</code> 创建连接</td>\n<td>MongoDB 是一个面向文档的 NoSQL 数据库，具有可伸缩性、灵活性和高速读写等特点。MongoDB Node.js 驱动程序是官方支持的，并且易于使用。</td>\n</tr>\n<tr>\n<td>PostgreSQL</td>\n<td>pg</td>\n<td>使用 <code>new pg.Client()</code> 创建连接</td>\n<td>PostgreSQL 是一个功能强大的关系型数据库，具有高度的稳定性和可靠性。pg 驱动程序是 Node.js 中最流行的 PostgreSQL 驱动程序之一。</td>\n</tr>\n<tr>\n<td>Oracle</td>\n<td>oracledb</td>\n<td>使用 <code>oracledb.getConnection()</code> 创建连接</td>\n<td>Oracle 是一个功能强大的关系型数据库，主要用于企业级应用程序。oracledb 驱动程序是官方支持的，并且具有很好的性能和可靠性。</td>\n</tr>\n<tr>\n<td>Microsoft SQL Server</td>\n<td>mssql</td>\n<td>使用 <code>new mssql.ConnectionPool()</code> 创建连接池</td>\n<td>Microsoft SQL Server 是一个功能强大的关系型数据库，主要用于企业级应用程序。mssql 驱动程序是 Node.js 中最流行的 Microsoft SQL Server 驱动程序之一。</td>\n</tr>\n<tr>\n<td>Redis</td>\n<td>ioredis</td>\n<td>使用 <code>new Redis()</code> 创建连接</td>\n<td>Redis 是一个内存数据结构存储系统，适用于需要快速读写和高并发的应用程序。ioredis 是一个支持 Redis 集群和复制功能的 Redis 驱动程序。</td>\n</tr>\n<tr>\n<td>SQLite</td>\n<td>better-sqlite3</td>\n<td>使用 <code>better-sqlite3()</code> 创建连接</td>\n<td>SQLite 是一个非常轻量级的嵌入式数据库，适用于小型项目。better-sqlite3 是官方 SQLite3 驱动程序的代替品，速度更快且易于使用。</td>\n</tr>\n<tr>\n<td>Couchbase</td>\n<td>couchbase</td>\n<td>使用 <code>new couchbase.Cluster()</code> 创建连接</td>\n<td>Couchbase 是一个面向文档的 NoSQL 数据库，适用于需要快速读写和高并发的应用程序。couchbase 驱动程序是官方支持的，并且具有很好的性能和可靠性。</td>\n</tr>\n<tr>\n<td>Cassandra</td>\n<td>cassandra-driver</td>\n<td>使用 <code>new cassandra.Client()</code> 创建连接</td>\n<td>Cassandra 是一个分布式的 NoSQL 数据库，适用于大规模数据存储和处理。cassandra-driver 是官方支持的驱动程序，并具有很好的性能和可靠性。</td>\n</tr>\n<tr>\n<td>Neo4j</td>\n<td>neo4j-driver</td>\n<td>使用 <code>neo4j.driver()</code> 创建连接</td>\n<td>Neo4j 是一个图形数据库，适用于需要处理高度连接数据的应用程序。neo4j-driver 是官方支持的 Node.js 驱动程序，并且易于使用。</td>\n</tr>\n<tr>\n<td>ArangoDB</td>\n<td>arangojs</td>\n<td>使用 <code>new arangojs.Database()</code> 创建连接</td>\n<td>ArangoDB 是一个多模型数据库（支持文档、图形和键值数据），适用于需要存储多种类型数据的应用程序。ArangoJS 是一个用于 Node.js 的 ArangoDB 驱动程序。</td>\n</tr>\n<tr>\n<td>RethinkDB</td>\n<td>rethinkdbdash</td>\n<td>使用 <code>rethinkdbdash()</code> 创建连接</td>\n<td>RethinkDB 是一个面向文档的 NoSQL 数据库，具有实时更新和可伸缩性等功能。它可以使用 RethinkDB 驱动程序或 rethinkdbdash。</td>\n</tr>\n</tbody>\n</table>\n<h2> typeorm</h2>\n<p>TypeORM 是一个基于 TypeScript 的 ORM（对象关系映射）框架，它支持多种不同类型的数据库，包括 MySQL、PostgreSQL、SQLite、Microsoft SQL Server、Oracle 和 MongoDB 等。TypeORM 提供了一套简单易用的 API，让开发者可以使用面向对象的方式来管理数据库表格和数据。</p>\n<h3> TypeORM 具有以下特点：</h3>\n<ul>\n<li>支持 TypeScript：TypeORM 是使用 TypeScript 编写的，因此可以充分利用 TypeScript 的强类型特性来避免很多潜在的错误。</li>\n<li>支持多种数据库：除了传统的 SQL 数据库外，TypeORM 还支持 NoSQL 数据库 MongoDB。</li>\n<li>易于使用：TypeORM 提供了一套简洁而易于理解的 API，使得开发者可以自然而然地使用面向对象的方式来操作数据库。</li>\n<li>丰富的功能：TypeORM 不仅支持常见的 CRUD 操作，还提供了事务处理、迁移、查询构建器等丰富的功能。</li>\n<li>可扩展性：TypeORM 支持插件机制，开发者可以编写自己的插件来扩展 TypeORM 的功能。</li>\n</ul>\n<p>在使用 TypeORM 时，开发者需要定义实体类来映射数据库表格。实体类需要继承 <code>BaseEntity</code> 类，并使用装饰器来标记属性与表格字段的映射关系。例如：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上代码定义了一个名为 <code>User</code> 的实体类，用于映射数据库中的 <code>user</code> 表格。<code>@Entity()</code> 装饰器表示该类是一个实体类，<code>@PrimaryGeneratedColumn()</code> 装饰器表示 <code>id</code> 属性是主键，并使用自动增长方式生成值。<code>@Column()</code> 装饰器则表示该属性对应表格的一个字段。</p>\n<p>在定义完实体类后，就可以使用 TypeORM 提供的 API 来进行数据库操作了。例如，要查询所有用户的信息，可以使用以下代码：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>TypeORM 还提供了很多其他的 API，包括添加、更新和删除数据等操作。总之，TypeORM 是一个功能强大、易于使用的 ORM 框架，适合用来开发各种类型的应用程序。</p>\n<p>除了基本的 CRUD 操作外，TypeORM 还提供了一些高级功能，例如事务处理、查询构建器、关系映射等。</p>\n<h4> 事务处理</h4>\n<p>在数据库操作中，有时需要执行多个操作，而这些操作必须要么全部成功，要么全部失败。这时就需要使用事务处理机制来实现。TypeORM 提供了 <code>EntityManager</code> 类来支持事务处理。</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上代码演示了一个简单的事务处理例子。在一个事务中，我们创建了一个新用户和一篇新文章，并将作者与文章关联起来。如果任何一个操作失败，整个事务都会被回滚。可以注意到，在 <code>transaction</code> 方法中传入的是一个回调函数，这个函数接收一个 <code>EntityManager</code> 对象，可以使用这个对象来执行数据库操作。</p>\n<h4> 查询构建器</h4>\n<p>TypeORM 的查询构建器提供了一种更加灵活的方式来构建查询语句，以便满足特定的查询需求。使用查询构建器，开发者可以将查询条件动态地构建成链式调用的方式。</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上代码演示了一个使用查询构建器来查询用户信息的例子。该例子中，我们首先创建了一个基于 <code>User</code> 实体的查询构建器，并使用 <code>where</code> 方法指定了查询条件，然后使用 <code>leftJoinAndSelect</code> 方法关联了用户和文章实体，并使用 <code>orderBy</code> 方法按照文章发布时间排序。最后，我们调用 <code>getMany()</code> 方法执行查询操作。</p>\n<h4> 关系映射</h4>\n<p>在数据库中，有时需要处理多个实体之间的关系。比如，在上面的例子中，一个用户可以拥有多篇文章。TypeORM 提供了多种不同的关系映射方式来满足这种需求，包括一对一、一对多、多对一和多对多关系。</p>\n<p>以下是一个简单的例子，演示了如何使用 TypeORM 来定义一对多关系：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上代码中，我们使用 <code>@OneToMany</code> 和 <code>@ManyToOne</code> 装饰器来定义用户和文章之间的一对多关系。<code>@OneToMany</code> 装饰器表示一个用户可以拥有多篇文章，而 <code>@ManyToOne</code> 装饰器则表示每篇文章都有一个作者。</p>\n<p>总之，TypeORM 是一个强大而灵活的 ORM 框架，支持多种不同类型的数据库，并提供了丰富的功能和易于使用的 API。无论是开发小型应用还是大型企业级应用，TypeORM 都是一个值得考虑的选择。</p>\n<h2> 安装 TypeORM</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>以上命令会在当前项目中安装 TypeORM 依赖包，并将其添加到 <code>package.json</code> 文件的 <code>dependencies</code> 列表中。</p>\n<p>另外，TypeORM 还需要相应数据库的驱动程序。例如，如果要使用 MySQL 数据库，需要安装 <code>mysql2</code> 包；如果要使用 PostgreSQL 数据库，需要安装 <code>pg</code> 包。以下是一些常用数据库的驱动程序依赖包：</p>\n<ul>\n<li>MySQL: <code>npm install mysql2 --save</code></li>\n<li>PostgreSQL: <code>npm install pg --save</code></li>\n<li>SQLite: <code>npm install sqlite3 --save</code></li>\n<li>Microsoft SQL Server: <code>npm install mssql --save</code></li>\n<li>Oracle: <code>npm install oracledb --save</code></li>\n<li>MongoDB: <code>npm install mongodb --save</code></li>\n</ul>\n<p>安装完成后，就可以在代码中使用 TypeORM 了。为了方便配置 TypeORM，建议在项目根目录下创建一个 <code>ormconfig.json</code> 文件，用于存放数据库连接信息和其他相关配置。例如，以下是一个连接 MySQL 数据库的示例：</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上配置文件中，我们指定了连接的数据库类型、主机地址、端口号、用户名、密码和数据库名称等信息。<code>synchronize</code> 属性表示 TypeORM 是否自动创建数据库表格以及更新表格结构，<code>logging</code> 属性表示是否输出日志信息，<code>entities</code>、<code>migrations</code> 和 <code>subscribers</code> 分别指定实体类、迁移文件和订阅者文件存放的位置。最后，<code>cli</code> 属性用于在命令行中使用 TypeORM CLI 工具时指定相关选项。</p>\n<p>总之，安装 TypeORM 很简单，只需要执行一条命令即可。不过，要使用 TypeORM 还需要根据具体情况安装相应数据库的驱动程序，并在项目根目录下创建一个 <code>ormconfig.json</code> 文件来配置数据库连接信息和其他相关设置。</p>\n<h2> 使用 typeorm 封装通用连接方法</h2>\n<p>以下是通用的 TypeScript 连接方法：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这是一个通用的 TypeORM 连接方法，适用于大多数关系型数据库。你只需要在环境变量中设置一些必要的连接参数，即可使用此方法连接到不同的数据库。</p>\n<h2> 对应不同数据库的连接方法</h2>\n<p>以下是连接不同类型数据库的示例代码方法和对应的依赖包安装步骤，使用 TypeScript 的格式返回，配置文件从 <code>.env</code> 文件读取。</p>\n<h3> MySQL</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> MongoDB</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> PostgreSQL</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Oracle</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Microsoft SQL Server</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Redis</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> SQLite</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Couchbase</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Cassandra</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Neo4j</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> ArangoDB</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> RethinkDB</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> CouchDB</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Firebase</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> MariaDB</h3>\n<p><strong>依赖包：</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>示例代码：</strong></p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，在使用以上代码前，需要先在 <code>.env</code> 文件中设置对应的环境变量。例如：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个示例中连接 MySQL 数据库时，使用的是 <code>mysql2</code> 包，因此需要安装该包。<code>.env</code> 文件中设置的参数包括主机地址、用户名、密码和数据库名称。在连接数据库时，这些参数将从 <code>.env</code> 文件中读取。</p>\n<p>以上提供了连接不同类型数据库的示例代码方法和对应的依赖包安装步骤，都使用 TypeScript 的格式返回，并从 <code>.env</code> 文件读取配置文件。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2024-04-10T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "Node.js",
        "MySQL",
        "MongoDB",
        "PostgreSQL"
      ]
    },
    {
      "title": "github",
      "url": "https://www.h7ml.cn/posts/github/",
      "id": "https://www.h7ml.cn/posts/github/",
      "summary": "action",
      "content_html": "<ul>\n<li><a href=\"/posts/github/action.html\" target=\"blank\">action</a></li>\n</ul>\n",
      "date_published": "2023-01-18T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "github"
      ]
    },
    {
      "title": "github action",
      "url": "https://www.h7ml.cn/posts/github/action.html",
      "id": "https://www.h7ml.cn/posts/github/action.html",
      "summary": "GitHub Actions GitHub Actions 是一个持续集成和持续交付 (CI/CD) 平台，可用于自动执行构建、测试和部署管道。您可以创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉取请求部署到生产环境。将 GitHub Actions 命令保存为 main.yml，放于 .github\\workflows 目录下，repo 发生指定调节的改变时，Actions 会自动运行。[1] GitHub Actions 官方市场 open in new window Awesome Actionsopen in new window",
      "content_html": "<h2> GitHub Actions</h2>\n<p>GitHub Actions 是一个持续集成和持续交付 (CI/CD) 平台，可用于自动执行构建、测试和部署管道。您可以创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉取请求部署到生产环境。将 GitHub Actions 命令保存为 <code>main.yml</code>，放于 <code>.github\\workflows</code> 目录下，repo 发生指定调节的改变时，Actions 会自动运行。<a href=\"#footnote1\">[1]</a></p>\n<ul>\n<li><a href=\"https://github.com/marketplace?type=actions\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub Actions 官方市场 open in new window</a></li>\n<li><a href=\"https://github.com/sdras/awesome-actions\" target=\"_blank\" rel=\"noopener noreferrer\">Awesome Actionsopen in new window</a></li>\n</ul>\n<p>如果 GitHub Actions 命令中有涉及密码等私密信息，则进入项目仓库的「setting」&gt;「Secrets」&gt;「Action」，添加密钥进行加密处理。比如新建密钥 PERSONAL_TOKEN，Actions 命令中使用 <code>${{ secrets.PERSONAL_TOKEN }}</code> 来指代该密钥。</p>\n<h3> 不同仓库间复制</h3>\n<p>复制文件到目的地，文档没变化则不会执行。案例为将当前仓库 main 分支下 docs 的 <a href=\"http://readme.md/\" target=\"_blank\" rel=\"noopener noreferrer\">README.mdopen in new window</a> 文件复制到另一个仓库 rockbenben/LearnData/ 路径下，如果目标路径存在相同文件，则将覆盖。如果让 <code>clean: true</code> 生效，Actions 会将目标路径情况，然后执行复制。</p>\n<p>此动作需按 <a href=\"https://docs.github.com/cn/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token#creating-a-token\" target=\"_blank\" rel=\"noopener noreferrer\">Creating a personal access tokenopen in new window</a> 建立 <a href=\"https://github.com/settings/tokens\" target=\"_blank\" rel=\"noopener noreferrer\">个人访问令牌 open in new window</a>，勾选权限「repo Full control of private repositories」，然后将该 token 值其保存在项目仓库的 Action 密钥。</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Actions 失败重试</h3>\n<p>在 job 和 step 中使用 if 语句，只有满足条件时才执行具体的 job 或 step。<a href=\"#footnote2\">[2]</a></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>first_step 会总是执行，second_step 需要上一步 first_step 执行成功才会执行，third_step 只有上一步 second_step 执行失败才执行。当 third_step 与 second_step 命令相同时，就可以达到失败重试的效果了。</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> uses 版本号</h3>\n<p><code>uses: SamKirkland/FTP-Deploy-Action@4.3.1</code>：uses 会指定此步骤运行 SamKirkland/FTP-Deploy-Action 存储库中的 4.3.1 版本。</p>\n<p>但有时 Actions 的版本不会这么快更新，又必须使用最新版，可以将版本号改为 branch name，比如 <code>uses: SamKirkland/FTP-Deploy-Action@master</code>。</p>\n<h2> 常见问题</h2>\n<h3> GitHub 忽略指定文件</h3>\n<p>项目路径新建一个命名为 .gitignore 的文件，将想要忽略的文件夹和文件写入 .gitignore 文件，换行分隔。</p>\n<p>比如要忽略 node_modules 文件夹，就直接在文件中输入 node_modules。</p>\n<hr>\n<ol>\n<li>\n<p><a href=\"https://docs.github.com/cn/actions/learn-github-actions/understanding-github-actions\" target=\"_blank\" rel=\"noopener noreferrer\">了解 GitHub Actionsopen in new window</a> <a href=\"#footnote-ref1\">↩︎</a></p>\n</li>\n<li>\n<p><a href=\"https://blog.csdn.net/Ber_Bai/article/details/120310024\" target=\"_blank\" rel=\"noopener noreferrer\">最全总结，GitHub Action 自动化部署 open in new window</a> <a href=\"#footnote-ref2\">↩︎</a></p>\n</li>\n</ol>\n",
      "date_published": "2023-01-18T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "github"
      ]
    },
    {
      "title": "图形学",
      "url": "https://www.h7ml.cn/posts/graphics/",
      "id": "https://www.h7ml.cn/posts/graphics/",
      "summary": "svg canvas webgl baiduMap erharts openlayers three fabric konva",
      "content_html": "<ul>\n<li>\n<p><a href=\"/posts/graphics/svg.html\" target=\"blank\">svg</a></p>\n</li>\n<li>\n<p><a href=\"/posts/graphics/canvas.html\" target=\"blank\">canvas</a></p>\n</li>\n<li>\n<p><a href=\"/posts/graphics/webgl.html\" target=\"blank\">webgl</a></p>\n</li>\n<li>\n<p><a href=\"/posts/graphics/baiduMap.html\" target=\"blank\">baiduMap</a></p>\n</li>\n<li>\n<p><a href=\"/posts/graphics/erharts.html\" target=\"blank\">erharts</a></p>\n</li>\n<li>\n<p><a href=\"/posts/graphics/openlayers.html\" target=\"blank\">openlayers</a></p>\n</li>\n<li>\n<p><a href=\"/posts/graphics/three.html\" target=\"blank\">three</a></p>\n</li>\n<li>\n<p><a href=\"/posts/graphics/fabric.html\" target=\"blank\">fabric</a></p>\n</li>\n<li>\n<p><a href=\"/posts/graphics/konva.html\" target=\"blank\">konva</a></p>\n</li>\n</ul>\n",
      "date_published": "2021-01-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "graphics"
      ]
    },
    {
      "title": "baiduMap",
      "url": "https://www.h7ml.cn/posts/graphics/baiduMap.html",
      "id": "https://www.h7ml.cn/posts/graphics/baiduMap.html",
      "summary": "baiduMap",
      "content_html": "<h1> baiduMap</h1>\n",
      "date_published": "2021-01-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "graphics"
      ]
    },
    {
      "title": "canvas",
      "url": "https://www.h7ml.cn/posts/graphics/canvas.html",
      "id": "https://www.h7ml.cn/posts/graphics/canvas.html",
      "summary": "canvas",
      "content_html": "<h1> canvas</h1>\n",
      "date_published": "2021-01-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "graphics"
      ]
    },
    {
      "title": "erharts",
      "url": "https://www.h7ml.cn/posts/graphics/erharts.html",
      "id": "https://www.h7ml.cn/posts/graphics/erharts.html",
      "summary": "erharts",
      "content_html": "<h1> erharts</h1>\n",
      "date_published": "2021-01-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "graphics"
      ]
    },
    {
      "title": "fabric",
      "url": "https://www.h7ml.cn/posts/graphics/fabric.html",
      "id": "https://www.h7ml.cn/posts/graphics/fabric.html",
      "summary": "fabric",
      "content_html": "<h1> fabric</h1>\n",
      "date_published": "2021-01-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "graphics"
      ]
    },
    {
      "title": "konva",
      "url": "https://www.h7ml.cn/posts/graphics/konva.html",
      "id": "https://www.h7ml.cn/posts/graphics/konva.html",
      "summary": "konva 前言 用过 Canvas 的都知道它的 API 比较多，使用起来也很麻烦，比如我想绘制一个圆形就要调一堆 API，对开发算不上友好。 const canvas = document.querySelector('canvas'); const context = canvas.getContext('2d'); // 设置字体样式 context.font = '24px SimSun, Songti SC'; context.fillText('24px的宋体呈现', 20, 50); // 绘制完整圆 context.fillStyle = 'RGB(255, 0, 0)'; context.beginPath(); context.arc(150, 75, 50, 0, Math.PI * 2); context.stroke();",
      "content_html": "<h1> konva</h1>\n<h2> 前言</h2>\n<p>用过 Canvas 的都知道它的 API 比较多，使用起来也很麻烦，比如我想绘制一个圆形就要调一堆 API，对开发算不上友好。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为了解决这个痛点，诞生了例如 PIXI、ZRender、Fabric 等 Canvas 库。今天要讲的 Konva 也是一个很优秀的 Canvas 框架，API 封装简洁易懂，基于 TypeScript 实现，有 React 和 Vue 版本。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 架构设计</h2>\n<h3> Konva Tree</h3>\n<p>从前言里面给的那段代码可以看出来，Konva 有一定的嵌套结构，有些类似 DOM 结构。通过 add 和 remove 就能实现子节点的添加和删除。 <img src=\"https://camo.githubusercontent.com/f9afa6e7475eb6ffdf610aeae294ab6678a51e1a45ef71b05e2f583c1f0144f1/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f343537372f36373130386631382d303239312d346138312d613336312d3735653565626462366539642e706e67\" alt=\"\" loading=\"lazy\"> Konva Tree 主要包括这么几部分：</p>\n<ol>\n<li>Stage 根节点：这是应用的根节点，会创建一个 div 节点，作为事件的接收层，根据事件触发时的坐标来分发出去。一个 Stage 节点可以包含多个 Layer 图层。</li>\n<li>Layer 图层：Layer 里面会创建一个 Canvas 节点，主要作用就是绘制 Canvas 里面的元素。一个 Layer 可以包含多个 Group 和 Shape。</li>\n<li>Group 组：Group 包含多个 Shape，如果对其进行变换和滤镜，里面所有的 Shape 都会生效。</li>\n<li>Shape：指 Text、Rect、Circle 等图形，这些是 Konva 封装好的类。 <img src=\"https://camo.githubusercontent.com/29a78d23111ca442579c11ed9c56d8d8f50288dcf9e99bc6128e0a8de0470f71/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f343537372f34333435323935312d386131372d343665642d613136302d6563343065393234396132322e706e67\" alt=\"\" loading=\"lazy\"></li>\n</ol>\n<h3> build dom</h3>\n<p>Stage 创建的时候会去创建两个 Canvas 节点以及 content 容器节点，这两个 Canvas 节点是用于 perfectDrawEnabled 的，后面会讲到。这里需要注意的就是这个 content 节点，作为整个 Konva 画布的容器，之后的 Layer 都会被 append 进去。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在调用 Stage.add 的时候，不仅会调用 Layer 的绘制方法，还会把 Layer 的 Canvas 节点 append 进去。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 渲染</h2>\n<h3> 批量渲染</h3>\n<p>从前面的代码中可以看到，没有手动调用绘制方法，但依然会进行绘制，说明会在一定的时机进行渲染。 这个时机就在 add 方法里面，不管 Group、Layer、Stage 哪个先 add，最终都会触发渲染。他们三个都继承了 Container 类，在 Container 类里面有一个 add 方法，我们来一探究竟。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>除了一些常规的处理之外，渲染的关键就在 <code>_requestDraw</code> 方法里面。这里调用了 Layer 上面的 <code>batchDraw</code> 进行批量重绘。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个批量重绘的原理是利用 requestAnimationFrame 方法将要绘制的内容放到下一帧来绘制。这样同时修改多个图形多个属性就不需要反复绘制了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Shape 绘制</h3>\n<p>所有涉及到图形绘制的地方都是调用 Shape 实现类上的 <code>_sceneFunc</code> 方法，以 Circle 为例：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 Shape 和 Node 两个基类上面只负责调用，具体的实现放到具体的 Shape 实现上面。这样带来两个好处，一个是可以实现自定义图形，另一个是以后要是支持 SVG、WebGL 会很方便。</p>\n<h3> 离屏渲染</h3>\n<p>什么是离屏渲染？就是在屏幕之外预渲染一个 Canvas，之后通过 drawImage 的形式将其绘制到屏幕要显示的 Canvas 上面，对形状相似或者重复的对象绘制性能提升非常高。假设我们有个列表页，每次滚动的时候全部重新绘制开销会比较大。但如果我们实现一个 Canvas 池，把已经绘制过的列表项存起来。下次滚动到这里的时候，就可以直接从 Canvas 池里面取出来 drawImage 到页面上了。在 Node 类上面有个 cache 方法，这个方法可以实现细粒度的离屏渲染。 cache 方法内部会创建三个 canvas，分别是：</p>\n<ol>\n<li>cachedSceneCanvas：用于绘制图形的 canvas 的离屏渲染。</li>\n<li>cachedFilterCanvas：用于处理滤镜效果。</li>\n<li>cachedHitCanvas：用于处理 hitCanvas 的离屏渲染。</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> perfectDrawEnabled</h3>\n<p>Canvas 在绘制 stroke 和 fill 的时候，如果遇到透明度的时候，stroke 会和 fill 的一部分重合到一起，就不符合我们的预期了。比如下面这段代码：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>它的实际展示效果是这样的，中间的 stroke 和 fill 有一部分重叠。 <img src=\"https://camo.githubusercontent.com/4828d368c32e74643cbb46d198154e8d11830dc3610a082b9eca3f624f09449f/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f343537372f30343531323865362d303637332d343535662d383739302d6335336437346365353662622e706e67\" alt=\"\" loading=\"lazy\"> 在这种情况下，KonvaJS 实现了一个 perfectDrawEnabled 功能，它会这样做：</p>\n<ol>\n<li>在 bufferCanvas 上绘制 Shape</li>\n<li>绘制 fill 和 stroke</li>\n<li>在 layer 上应用透明度</li>\n<li>将 bufferCanvas 绘制到 sceneCanvas 上面可以看到开启 perfectDrawEnabled 和关闭 perfectDrawEnabled 的区别很明显： <img src=\"https://camo.githubusercontent.com/5aa09e0b1727de6052f80f44d0dd13736059acfe0e84bb681cb09cc4f4d01ec5/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f343537372f63613061646131612d613263322d343363322d626262362d3534353264323365343534362e706e67\" alt=\"\" loading=\"lazy\"> 它会在 Stage 里面创建一个 bufferCanvas 和 bufferHitCanvas，前者就是针对 sceneCanvas 的，后者是针对 hitCanvas 的。在 Shape 的 drawScene 方法里面，会判断是否使用 bufferCanvas：</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 事件</h2>\n<p>Konva 里面的事件是在 Canvas 外层创建了一个 div 节点，在这个节点上面接收了 DOM 事件，再根据坐标点来判断当前点击的是哪个 Shape，然后进行事件分发。所以关键就在如何判断当前点击的 Shape 是哪个？相比 ZRender 里面比较复杂的计算，Konva 使用了一个相当巧妙的方式。</p>\n<h3> 事件分发</h3>\n<p>Konva 目前支持下面这么多事件，EVENTS 是 <code>事件名-事件处理方法</code> 的映射。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们以 mousedown 这个具体的事件作为例子来分析，它的处理方法在 <code>_pointerdown</code> 里面。 <code>_pointerdown</code> 先执行了 <code>setPointersPositions</code>，计算当前鼠标点击的坐标，减去 content 相对页面的坐标，得到了当前点击相对于 content 的坐标。同时将其存入了 <code>_changedPointerPositions</code> 里面。 <img src=\"https://camo.githubusercontent.com/b9b5d26a9416879dc1be928551640eba483b5af33a0af809def5f2b2fc6a5fea/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f343537372f32393861326332322d363837332d343464352d393234662d3331306461343239313931302e706e67\" alt=\"\" loading=\"lazy\"> 然后遍历 <code>_changedPointerPositions</code>，通过 <code>getIntersection</code> 获取到了点击的 Shape 图形。这个 <code>getIntersection</code> 遍历调用了每个 Layer 的 <code>getIntersection</code> 方法，通过 Layer 获取到了对应的 Shape。因为可以存在多个 Layer，每个 Layer 也可以在同一个位置绘制多个 Shape，所以理论上可以获取到多个 Shape，Konva 这里只取了第一个 Shape，按照 Layer -Shape 的顺序来的。 <img src=\"https://camo.githubusercontent.com/a462a32aa3f2bf7f01f52a225069d66a35b7ffbb9de0320ec7bfabb81a21b2e0/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f343537372f34663139613934392d303035372d346434632d393032342d3561633637373838663239382e706e67\" alt=\"\" loading=\"lazy\"> 然后 Stage 会调用 Shape 上面的 <code>_fireAndBubble</code> 方法，这个方法调用 <code>_fire</code> 发送 Konva 自己的事件，此时通过 on 绑定的事件回调就会触发，有点儿像 jQuery 那样。然后 Konva 会继续往上找到父节点，继续调用父节点的 <code>_fireAndBubble</code> 方法，直到再也找不到父节点为止，这样就实现了事件冒泡。对于不想被点击到的 Shape 来说，可以设置 <code>isListening</code> 属性为 false，这样事件就不会触发了。</p>\n<h3> 匹配 Shape</h3>\n<p>那么 Layer 是怎么根据点击坐标获取到对应的 Shape 呢？如果是规则的图形（矩形、圆形）还比较容易计算，要是下面这种不规则图形呢？ <img src=\"https://camo.githubusercontent.com/56f41e90923fd22589829ba27314071b45fccabf3584bd84fef6096769120833/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f343537372f33353666323635322d663831332d343434362d393265612d3563383735363035303631342e706e67\" alt=\"\" loading=\"lazy\"> 众所周知，在 Canvas 里面有个 <code>getImageData</code> 方法，它会根据传入的坐标来返回一个 ImageData 信息，里面有当前坐标对应的色值。那么我们能不能根据这个色值来获取到对应的 Shape 呢？ <img src=\"https://camo.githubusercontent.com/e975ab71150c628666949ce3803e1e6d50e6045bd370850de3e2ae65f495aa20/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f343537372f36396264363065342d306335302d346465662d613564372d3665303531393761323663392e706e67\" alt=\"\" loading=\"lazy\"> 因此，Konva 在创建 Layer 的时候会创建两个 Canvas，一个用于 sceneCanvas 用于绘制 Shape，另一个 hitCanvas 在内存里面，用于判断是否被打击。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><img src=\"https://camo.githubusercontent.com/352ea8233908db8e9464a7b814deb15ebf770b61c171ca4067da513109f29deb/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f343537372f35333735653761642d393835332d343236302d613265312d6631633263643738366662642e706e67\" alt=\"\" loading=\"lazy\"> 当 Shape 初始化的时候，会生成一个随机的颜色，以这个颜色作为 key 存入到 shapes 数组里面。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>每次在 sceneCanvas 上面绘制的时候，同样会在内存中的 hitCanvas 里面绘制一遍，并且将上面随机生成的色值作为 fill 和 stroke 的颜色填充。当点击 sceneCanvas 的时候，获取到点击的坐标点，通过调用 hitCanvas 的 <code>getImageData</code> 就可以获取到 colorKey，然后再通过 colorKey 就能找到对应的 Shape 了，真是相当巧妙的实现。 <img src=\"https://camo.githubusercontent.com/821609f511a6cd1760042d9fea1d66ce53deabed1e2628df0683b73e898cba16/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f343537372f62376437653336382d643833622d343765342d613234382d3734613732306133656665632e706e67\" alt=\"\" loading=\"lazy\"> 但这种方式也有缺陷，因为生成的随机 hex 颜色是有上限的，最多会会有 256<em>256</em> 256 = 16777216 种，如果超过了这么多就会导致匹配不准确。不过考虑一下如果有 16777216 个 DOM 节点，浏览器就会卡爆了，换成这么多 Canvas 图形一样会导致性能爆炸。</p>\n<h3> 自定义 hitFunc</h3>\n<p>如果你想自定义事件响应区域，Konva 也提供了 hitFunc 方法给你实现。在绘制 hitCanvas 的时候，原本的绘制 sceneFunc 就失效了，取而代之的是绘制 hitFunc。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 拖拽事件</h3>\n<p>Konva 的拖拽事件没有使用原生的方法，而是基于 mousemove 和 touchmove 来计算移动的距离，进而手动设置 Shape 的位置，实现逻辑比较简单，这里不细说。</p>\n<h2> 滤镜</h2>\n<p>Konva 支持多种滤镜，在使用滤镜之前需要先将 Shape cache 起来，然后使用 <code>filter()</code> 方法添加滤镜。 在 cache 里面除了创建用于离屏渲染的 Canvas，还会创建滤镜 Canvas。滤镜处理在 <code>_getCachedSceneCanvas</code> 里面。 <img src=\"https://camo.githubusercontent.com/5736b6469b94b56d537b2a76c8999e3b307278d42527a4bb7f4d87f2b68357cd/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f343537372f39346434613735622d626262362d343861312d623036302d6165376530386164626130382e706e67\" alt=\"\" loading=\"lazy\"> 首先将 sceneCanvas 通过 drawImage 绘制到 filterCanvas 上面，接着 filterCanvas 获取所有的 ImageData，遍历所有设置的滤镜方法，将 ImageData 传给滤镜方法来处理。处理完 ImageData 之后，再将其通过 putImageData 绘制到 filterCanvas 上面。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>那滤镜效果怎么画上去的呢？在 konva 里面进行了特殊处理，如果存在 filterCanvas，那就不会使用 cacheCanvas 了，也就是我们原本用于缓存的离屏 Canvas 会被 filterCanvas 进行替代。最终 filterCanvas 会通过 drawImage 的方式绘制到 sceneCanvas 上面。</p>\n<h2> 选择器</h2>\n<p>Konva 实现了选择器，方便我们快速查找到某个 Shape。目前主要有三种选择器，分别是 id 选择器、name 选择器、type 选择器。前两者需要在实例化的时候传入一个 id 或者 name 属性，后者则是根据类名（Rect、Line 等）来查找的。选择器查找的时候需要调用 find 方法，这个 find 方法挂载在 Container 类上面。它调用了 _descendants 进行子节点的遍历，将遍历的 node 节点调用 isMatch 方法来判断是否匹配上。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 isMatch 里面可以看到后根据是什么类型的选择器来分别进行匹配。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 序列化</h2>\n<p>Konva 还支持对 Stage 的序列化和反序列化，简单来说就是把 Stage 的数据导出成一份 JSON 数据以及把 JSON 数据导入，方便我们在 NodeJS 端进行服务端渲染。序列化主要在 toObject 方法里面，它会对函数和 DOM 节点进行过滤，只保留一份描述信息，比如 Layer 的信息、Shape 的信息等等，有点儿类似 React 里面的 Virtual DOM。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>而反序列化则是对传入的 JSON 信息进行解析，根据 className 来创建不同的对象，对深层结构进行递归，然后 add 到父节点里面。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> React</h2>\n<p>Konva 和 React 绑定没有使用重新封装一遍组件的方式，而是采用了和 react-dom、react-native 一样的形式，基于 react-reconciler 来实现一套 hostConfig，从而定制自己的 Host Component（宿主组件）。</p>\n<h3> react-reconciler</h3>\n<p>React Fiber 架构诞生之后，他们就将原来的 React 核心代码做了抽离。主要包括 react、react-reconciler 和 platform 实现（react-dom、react-native 等）三部分。在 react-reconciler 里面实现了大名鼎鼎的 Diff 算法、时间切片、调度等等，它还暴露给了我们一个 hostConfig 文件，允许我们在各种钩子函数中实现自己的渲染。在 React 里面，有两种组件类型，一种是 Host Component（宿主组件），另一种是 Composition Component（复合组件）。在 DOM 里面，前者就是 h1、div、span 等元素，在 react-native 里面，前者就是 View、Text、ScrollView 等元素。后者则是我们基于 Host Component 自定义的组件，比如 App、Header 等等。在 react-reconciler 里面，它允许我们去自定义 Host Component 的渲染（增删查改），这也意味着跨平台的能力。我们只需要编写一份 hostConfig 文件，就能够实现自己的渲染。 <img src=\"https://camo.githubusercontent.com/695f54a7f71577ec66604e45270bc623eabb928e823bcce2b564d636de17997a/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f343537372f64333463333963632d386464312d346239382d613933332d6533633338303164643739332e706e67\" alt=\"\" loading=\"lazy\"> 参考上面的架构图，会发现不管是渲染到 native、canvas，甚至是小程序都可以。业界已经有方案是基于这个来实现了，可以参考蚂蚁金服的 remax：<a href=\"https://zhuanlan.zhihu.com/p/79788488\" target=\"_blank\" rel=\"noopener noreferrer\">Remax - 使用真正的 React 构建小程序</a></p>\n<h3> react-konva</h3>\n<p>react-konva 的主要实现就在 ReactKonvaHostConfig.js 里面，它利用 Konva 原本的 API 实现了对 Virtual DOM 的映射，响应了 Virtual DOM 的增删查改。这里从中抽取了部分源码：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> vue-konva</h2>\n<p>在 Vue 上面，Konva 通过 Vue.use 注册了一个插件，这个插件里面分别注册了每个组件。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再来看看 KonvaNode 的实现，在 KonvaNode 里面，对于节点的增删查改都在 Vue 的生命周期里面实现的。 在 Vue 的 created 生命周期里面调用 initKonva 去 new 一个 NodeClass，和上面 React 的方式几乎一样。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>而在 Updated 的时候去进行 Props 的更新，在 destroyed 里面对节点进行 destroy，实现上更加简洁一些。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 缺陷</h2>\n<h3> 脏矩形</h3>\n<p>在性能方面，Konva 对比 PIXI、ZRender 这些库还是不太够看。如果我们 Layer 上有非常多的 Shape，如果想更新某个 Shape，按照 Konva 的实现方式依然会全量绘制。虽然 Konva 支持单个 Shape 重绘，但实现上是无脑覆盖原来的位置，这也意味着如果你的图形在其他节点图形下面，就会出现问题。所以这里缺少非常重要的局部更新能力，也就是我们常说的脏矩形。脏矩形就是指当我们更新一个 Shape 的时候，利用碰撞检测计算出和他相交的所有 Shape，将其进行合并，计算出一块儿脏区域。然后我们通过 clip 限制 Canvas 只在这块儿脏区进行绘制，这样就实现了局部更新。 <img src=\"https://camo.githubusercontent.com/0c8f0933195af9f1afa41f3f2a373158a101454f3c36c8a585eee32337a9f33c/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f343537372f63616536613739652d623937312d343238392d393432652d6536303539366537303432362e706e67\" alt=\"\" loading=\"lazy\"> 可惜 Konva 的包围盒实现的非常简单，不适合做碰撞检测，它也没有提供脏矩形的能力。</p>\n",
      "image": "https://camo.githubusercontent.com/f9afa6e7475eb6ffdf610aeae294ab6678a51e1a45ef71b05e2f583c1f0144f1/68747470733a2f2f66696c65732e6d646e6963652e636f6d2f757365722f343537372f36373130386631382d303239312d346138312d613336312d3735653565626462366539642e706e67",
      "date_published": "2021-01-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "graphics"
      ]
    },
    {
      "title": "openlayers",
      "url": "https://www.h7ml.cn/posts/graphics/openlayers.html",
      "id": "https://www.h7ml.cn/posts/graphics/openlayers.html",
      "summary": "openlayers",
      "content_html": "<h1> openlayers</h1>\n",
      "date_published": "2021-01-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "graphics"
      ]
    },
    {
      "title": "svg",
      "url": "https://www.h7ml.cn/posts/graphics/svg.html",
      "id": "https://www.h7ml.cn/posts/graphics/svg.html",
      "summary": "svg 可缩放矢量图形（Scalable Vector Graphics，SVG），是一种用于描述二维的矢量图形。 网格 计算机绘图都差不多使用网格系统。这种系统以页面的左上角为(0,0)坐标点，坐标以像素为单位，x 轴正方向是向右，y 轴正方向是向下. &lt;!-- 定义一个矩形，即从左上角开始，向右延展50px，向下延展50px，形成一个50*50大的矩形。 --&gt; &lt;svg width=\"50\" height=\"50\"&gt; &lt;rect width=\"50\" height=\"50\" fill=\"#42b883\" /&gt; &lt;/svg&gt;",
      "content_html": "<h1> svg</h1>\n<p>可缩放矢量图形（Scalable Vector Graphics，SVG），是一种用于描述二维的矢量图形。</p>\n<h2> 网格</h2>\n<p>计算机绘图都差不多使用网格系统。这种系统以页面的左上角为(0,0)坐标点，坐标以像素为单位，x 轴正方向是向右，y 轴正方向是向下.</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"50\" height=\"50\">\n  <rect width=\"50\" height=\"50\" fill=\"#42b883\"></rect>\n</svg>\n<h3> 像素</h3>\n<p>基本上，在 SVG 文档中的 1 个像素对应输出设备（比如显示屏）上的 1 个像素。SVG 也可以定义绝对大小，来实现 svg 中可缩放的特性。只需给出数字，不标明单位，输出时就会采用用户的单位。</p>\n<ul>\n<li>定义了一个 50*50px 的 SVG 画布，这里 1 用户单位等同于 1 屏幕单位。</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"50\" height=\"50\">\n<rect width=\"100%\" height=\"100%\" fill=\"#42b883\"></rect></svg>\n<ul>\n<li>这里定义的画布尺寸是 <code>100*100px</code>。但是，<code>viewBox</code> 属性定义了画布上可以显示的区域：从(0,0)点开始，<code>50宽*50</code> 高的区域。这个<code>50*50</code>的区域，会放到<code>100*100</code>的画布上显示。于是就形成了放大两倍的效果。</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"100\" height=\"100\" viewBox=\"0 0 50 50\">\n<rect width=\"100%\" height=\"100%\" fill=\"#42b883\"></rect></svg>\n<h2> 基本形状</h2>\n<p>svg 有不同的形状，并且使用不同的属性来定义图形的大小和位置</p>\n<h3> 矩形</h3>\n<p><code>rect</code> 元素会在屏幕上绘制一个矩形 。其 6 个基本属性就可以控制它在屏幕上的位置和形状。</p>\n<ul>\n<li>x: 矩形左上角的 x 位置</li>\n<li>y: 矩形左上角的 y 位置</li>\n<li>width: 矩形的宽度</li>\n<li>height: 矩形的高度</li>\n<li>rx: 圆角的 x 方位的半径</li>\n<li>ry: 圆角的 y 方位的半径</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"100\" height=\"100\">\n<rect x=\"10\" y=\"10\" width=\"30\" height=\"30\" fill=\"#42b883\"></rect><rect x=\"60\" y=\"10\" rx=\"10\" ry=\"10\" width=\"30\" height=\"30\" fill=\"#42b883\"></rect></svg>\n<h3> 圆形</h3>\n<p><code>circle</code> 只有 3 个属性用来设置圆形。</p>\n<ul>\n<li>r: 圆的半径</li>\n<li>cx: 圆心的 x 位置</li>\n<li>cy: 圆心的 y 位置</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"50\" height=\"50\">\n<circle cx=\"25\" cy=\"25\" r=\"25\" fill=\"#42b883\"></circle></svg>\n<h3> 椭圆</h3>\n<p><code>Ellipse</code> 是 <code>circle</code> 元素更通用的形式,以分别缩放圆的 x 半径和 y 半径（通常称之为长轴半径和短轴半径）。</p>\n<ul>\n<li>rx: 椭圆的 x 半径</li>\n<li>ry: 椭圆的 y 半径</li>\n<li>cx: 椭圆中心的 x 位置</li>\n<li>cy: 椭圆中心的 y 位置</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"50\" height=\"50\">\n<ellipse cx=\"25\" cy=\"25\" rx=\"25\" ry=\"20\" fill=\"#42b883\"></ellipse></svg>\n<h3> 线条</h3>\n<p><code>Line</code> 绘制直线。它取两个点的位置作为属性，指定这条线的起点和终点位置。</p>\n<ul>\n<li>x1: 起点的 x 位置</li>\n<li>y1: 起点的 y 位置</li>\n<li>x2: 终点的 x 位置</li>\n<li>y2: 终点的 y 位置</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"50\" height=\"50\">\n<line x1=\"10\" x2=\"50\" y1=\"10\" y2=\"50\" stroke=\"#42b883\" stroke-width=\"5\"></line></svg>\n<h3> 折线</h3>\n<p><code>Polyline</code> 是一组连接在一起的直线。因为它可以有很多的点，折线的的所有点位置都放在一个 <code>points</code> 属性中：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"50\" height=\"50\">\n<polyline points=\"10 10, 10 20, 20 30, 30 20, 50 50\" stroke=\"#42b883\" stroke-width=\"2\" fill=\"transparent\"></polyline></svg>\n<h3> 多边形</h3>\n<p>polygon 和折线很像，它们都是由连接一组点集的直线构成。不同的是，polygon 的路径在最后一个点处自动回到第一个点。需要注意的是，矩形也是一种多边形，如果需要更多灵活性的话，你也可以用多边形创建一个矩形。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"50\" height=\"50\">\n<polyline points=\"0 0, 0 50, 50 50, 50 0, 0 0\" stroke=\"#42b883\" stroke-width=\"5\" fill=\"transparent\"></polyline></svg>\n<h2> 路径</h2>\n<p><code>path</code> 可能是 <code>SVG</code> 中最强大的基本形状。你可以用 <code>path</code> 元素绘制任何形状。另外，path 只需要设定很少的点，就可以创建平滑流畅的线条（比如曲线）。<code>path</code> 元素的形状是通过属性 <code>d</code> 定义的，属性 d 的值是一个“命令+参数”的序列。</p>\n<h3> 直线命令</h3>\n<p>元素里有 5 个画直线的命令：</p>\n<h4> M</h4>\n<p>画笔当前位于一个点，在使用 M 命令移动画笔后，只会移动画笔，但不会在两点之间画线</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> L &amp; H &amp; V</h4>\n<p>L 命令将会在当前位置和新位置（L 前面画笔所在的点）之间画一条线段。L 需要两个参数，分别是一个点的 x 轴和 y 轴坐标，L 命令将会在当前位置和新位置（L 前面画笔所在的点）之间画一条线段。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>另外还有两个简写命令，用来绘制水平线和垂直线。H，绘制水平线。V，绘制垂直线。这两个命令都只带一个参数，标明在 x 轴或 y 轴移动到的位置，因为它们都只在坐标轴的一个方向上移动。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"60\" height=\"60\">\n<path d=\"M10 10 H 50 V 50 H 10 Z\" fill=\"transparent\" stroke=\"#42b883\"></path></svg>\n<h3> 曲线命令</h3>\n<p>绘制平滑曲线的命令有三个，其中两个用来绘制贝塞尔曲线，另外一个用来绘制弧形或者说是圆的一部分。</p>\n<p>三次贝塞尔曲线需要定义一个点和两个控制点，所以用 C 命令创建三次贝塞尔曲线，需要设置三组坐标参数：</p>\n<h4> C 命令</h4>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这里的最后一个坐标(x,y)表示的是曲线的终点，另外两个坐标是控制点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点。如果你熟悉代数或者微积分的话，会更容易理解控制点，控制点描述的是曲线起始点的斜率，曲线上各个点的斜率，是从起点斜率到终点斜率的渐变过程.</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"190px\" height=\"160px\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M10 10 C 20 20, 40 20, 50 10\" stroke=\"black\" fill=\"transparent\"></path><path d=\"M70 10 C 70 20, 120 20, 120 10\" stroke=\"black\" fill=\"transparent\"></path><path d=\"M130 10 C 120 20, 180 20, 170 10\" stroke=\"black\" fill=\"transparent\"></path><path d=\"M10 60 C 20 80, 40 80, 50 60\" stroke=\"black\" fill=\"transparent\"></path><path d=\"M70 60 C 70 80, 110 80, 110 60\" stroke=\"black\" fill=\"transparent\"></path><path d=\"M130 60 C 120 80, 180 80, 170 60\" stroke=\"black\" fill=\"transparent\"></path><path d=\"M10 110 C 20 140, 40 140, 50 110\" stroke=\"black\" fill=\"transparent\"></path><path d=\"M70 110 C 70 140, 110 140, 110 110\" stroke=\"black\" fill=\"transparent\"></path><path d=\"M130 110 C 120 140, 180 140, 170 110\" stroke=\"black\" fill=\"transparent\"></path></svg>\n<h4> S</h4>\n<p>S 命令可以用来创建与前面一样的贝塞尔曲线，但是，如果 S 命令跟在一个 C 或 S 命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。果 S 命令单独使用，前面没有 C 或 S 命令，那当前点将作为第一个控制点。相当于 C 的快捷命令。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"190px\" height=\"160px\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80\" stroke=\"black\" fill=\"transparent\"></path>\n</svg>\n<h3> Q</h3>\n<p>二次贝塞尔曲线 Q，它比三次贝塞尔曲线简单，只需要一个控制点，用来确定起点和终点的曲线斜率。因此它需要两组参数，控制点和终点坐标。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"190px\" height=\"160px\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M10 80 Q 95 10 180 80\" stroke=\"black\" fill=\"transparent\"></path>\n</svg>\n<h3> T</h3>\n<p>快捷命令 T 会通过前一个控制点，推断出一个新的控制点。在你的第一个控制点后面，可以只定义终点，就创建出一个相当复杂的曲线。需要注意的是，T 命令前面必须是一个 Q 命令，或者是另一个 T 命令，才能达到这种效果。如果 T 单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"190px\" height=\"160px\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n  <path d=\"M10 80 Q 52.5 10, 95 80 T 180 80\" stroke=\"black\" fill=\"transparent\"></path>\n</svg>\n<h2> Fill 和 Stroke 属性</h2>\n<p>大多数基本的涂色可以通过在元素上设置两个属性来搞定：<code>fill</code> 属性和 <code>stroke</code> 属性。</p>\n<ul>\n<li><code>fill</code> 属性设置对象内部的颜色</li>\n<li><code>stroke</code> 属性设置绘制对象的线条的颜色</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"190px\" height=\"160px\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n  <rect x=\"10\" y=\"10\" width=\"100\" height=\"100\" stroke=\"black\" fill=\"red\" fill-opacity=\"0.5\" stroke-width=\"1\" stroke-opacity=\"0.9\"></rect>\n</svg>\n<h3> Fill</h3>\n<p><code>fill-opacity</code> 控制填充色的不透明度，属性 <code>stroke-opacity</code> 控制描边的不透明度。</p>\n<h3> Stroke</h3>\n<ul>\n<li><code>stroke-width</code> 属性定义了描边的宽度.</li>\n</ul>\n<h4> stroke-linecap</h4>\n<p>属性控制边框终点的形状,有三个值：</p>\n<ul>\n<li><code>butt</code> 用直边结束线段，它是常规做法，线段边界 90 度垂直于描边的方向、贯穿它的终点。</li>\n<li><code>square</code> 的效果差不多，但是会稍微超出实际路径的范围，超出的大小由 stroke-width 控制。</li>\n<li><code>round</code> 表示边框的终点是圆角，圆角的半径也是由 stroke-width 控制的。</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"160\" height=\"140\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n  <line x1=\"40\" x2=\"120\" y1=\"20\" y2=\"20\" stroke=\"black\" stroke-width=\"10\" stroke-linecap=\"butt\"></line>\n  <line x1=\"40\" x2=\"120\" y1=\"60\" y2=\"60\" stroke=\"black\" stroke-width=\"10\" stroke-linecap=\"square\"></line>\n  <line x1=\"40\" x2=\"120\" y1=\"100\" y2=\"100\" stroke=\"black\" stroke-width=\"10\" stroke-linecap=\"round\"></line>\n</svg>\n<h4> stroke-linejoin</h4>\n<p>用来控制两条描边线段之间，用什么方式连接。每条折线都是由两个线段连接起来的，连接处的样式由 <code>stroke-linejoin</code> 属性控制，它有三个可用的值:</p>\n<ul>\n<li>miter 是默认值，表示用方形画笔在连接处形成尖角</li>\n<li>round 表示用圆角连接，实现平滑效果。</li>\n<li>bevel，连接处会形成一个斜接。</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"160\" height=\"280\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n  <polyline points=\"40 60 80 20 120 60\" stroke=\"black\" stroke-width=\"20\" stroke-linecap=\"butt\" fill=\"none\" stroke-linejoin=\"miter\"></polyline>\n<polyline points=\"40 140 80 100 120 140\" stroke=\"black\" stroke-width=\"20\" stroke-linecap=\"round\" fill=\"none\" stroke-linejoin=\"round\"></polyline><polyline points=\"40 220 80 180 120 220\" stroke=\"black\" stroke-width=\"20\" stroke-linecap=\"square\" fill=\"none\" stroke-linejoin=\"bevel\"></polyline></svg>\n<h5> stroke-dasharray</h5>\n<p>通过指定 <code>stroke-dasharray</code> 属性，将虚线类型应用在描边上。<code>stroke-dasharray</code> 是一组用逗号分割的数字组成的数列, 和 path 不一样，这里的数字必须用逗号分割（空格会被忽略）。每一组数字，第一个用来表示填色区域的长度，第二个用来表示非填色区域的长度。第二个路径会先做 5 个像素单位的填色，紧接着是 5 个空白单位，然后又是 5 个单位的填色。如果你想要更复杂的虚线模式，你可以定义更多的数字。第一个例子指定了 3 个数字，这种情况下，数字会循环两次，形成一个偶数的虚线模式（奇数个循环两次变偶数个）。所以该路径首先渲染 5 个填色单位，10 个空白单位，5 个填色单位，然后回头以这 3 个数字做一次循环，但是这次是创建 5 个空白单位，10 个填色单位，5 个空白单位。通过这两次循环得到偶数模式，并将这个偶数模式不断重复。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"200\" height=\"150\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n  <path d=\"M 10 75 Q 50 10 100 75 T 190 75\" stroke=\"black\" stroke-linecap=\"round\" stroke-dasharray=\"5,10,5\" fill=\"none\"></path>\n  <path d=\"M 10 75 L 190 75\" stroke=\"red\" stroke-linecap=\"round\" stroke-width=\"1\" stroke-dasharray=\"5,5\" fill=\"none\"></path>\n</svg>\n<h2> 渐变</h2>\n<h3> 线性渐变</h3>\n<p>线性渐变沿着直线改变颜色，要插入一个线性渐变，你需要在 <code>SVG</code> 文件的 <code>defs</code> 元素内部，创建一个 <code>&lt;linearGradient&gt;</code> 节点。</p>\n<h4> 基础示例</h4>\n<p>下面是一个应用了线性渐变的 <code>&lt;rect&gt;</code> 元素的示例。线性渐变内部有几个 <code>&lt;stop&gt;</code> 结点，这些结点通过指定位置的 <code>offset</code>（偏移）属性和 <code>stop-color</code>（颜色中值）属性来说明在渐变的特定位置上应该是什么颜色；可以直接指定这两个属性值，该示例中指明了渐变开始颜色为红色，到中间位置时变成半透明的黑色，最后变成蓝色。渐变的方向可以通过两个点来控制，它们分别是属性 <code>x1、x2、y1、y2</code>，这些属性定义了渐变路线走向。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"120\" height=\"120\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n  <defs>\n    <linearGradient id=\"Gradient1\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"1\">\n      <stop offset=\"0%\" stop-color=\"red\"></stop>\n      <stop offset=\"50%\" stop-color=\"yellow\" stop-opacity=\"0.5\"></stop>\n      <stop offset=\"100%\" stop-color=\"blue\"></stop>\n    </linearGradient>\n  </defs>\n<rect id=\"rect1\" x=\"10\" y=\"10\" rx=\"15\" ry=\"15\" width=\"100\" height=\"100\" fill=\"url(#Gradient1)\"></rect></svg>\n<h3> 径向渐变</h3>\n<p>径向渐变与线性渐变相似，只是它是从一个点开始发散绘制渐变。创建径向渐变需要在文档的 <code>defs</code> 中添加一个 <code>&lt;radialGradient&gt;</code> 元素, 中值（stops）的使用方法与之前一致，但是现在这个对象的颜色是中间是红色的，且向着边缘的方向渐渐的变成蓝色。跟线性渐变一样，<code>&lt;radialGradient&gt;</code> 节点可以有多个属性来描述其位置和方向，但是它更加复杂。径向渐变也是通过两个点来定义其边缘位置，两点中的第一个点定义了渐变结束所围绕的圆环，它需要一个中心点，由 <code>cx</code> 和 <code>cy</code> 属性及半径 <code>r</code> 来定义，通过设置这些点我们可以移动渐变范围并改变它的大小。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"120\" height=\"240\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n  <defs>\n    <radialGradient id=\"RadialGradient1\">\n      <stop offset=\"0%\" stop-color=\"red\"></stop>\n      <stop offset=\"100%\" stop-color=\"blue\"></stop>\n    </radialGradient>\n    <radialGradient id=\"RadialGradient2\" cx=\"0.25\" cy=\"0.25\" r=\"0.25\">\n      <stop offset=\"0%\" stop-color=\"red\"></stop>\n      <stop offset=\"100%\" stop-color=\"blue\"></stop>\n    </radialGradient>\n  </defs>\n<rect x=\"10\" y=\"10\" rx=\"15\" ry=\"15\" width=\"100\" height=\"100\" fill=\"url(#RadialGradient1)\"></rect><rect x=\"10\" y=\"120\" rx=\"15\" ry=\"15\" width=\"100\" height=\"100\" fill=\"url(#RadialGradient2)\"></rect></svg>\n<h3> 中心和焦点</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"120\" height=\"120\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n  <defs>\n      <radialGradient id=\"Gradient\" cx=\"0.5\" cy=\"0.5\" r=\"0.5\" fx=\"0.25\" fy=\"0.25\">\n        <stop offset=\"0%\" stop-color=\"red\"></stop>\n        <stop offset=\"100%\" stop-color=\"blue\"></stop>\n      </radialGradient>\n  </defs>\n<rect x=\"10\" y=\"10\" rx=\"15\" ry=\"15\" width=\"100\" height=\"100\" fill=\"url(#Gradient)\" stroke=\"black\" stroke-width=\"2\"></rect><circle cx=\"60\" cy=\"60\" r=\"50\" fill=\"transparent\" stroke=\"white\" stroke-width=\"2\"></circle><circle cx=\"35\" cy=\"35\" r=\"2\" fill=\"white\" stroke=\"white\"></circle><circle cx=\"60\" cy=\"60\" r=\"2\" fill=\"white\" stroke=\"white\"></circle><text x=\"38\" y=\"40\" fill=\"white\" font-family=\"sans-serif\" font-size=\"10pt\">(fx,fy)</text><text x=\"63\" y=\"63\" fill=\"white\" font-family=\"sans-serif\" font-size=\"10pt\">(cx,cy)</text></svg>\n<!-- ## Patterns 图案\n\n## Texts 文字 -->\n<h3> xml</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><svg width=\"100%\" height=\"100%\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n  <title>雷猴</title>\n  <circle cx=\"50\" cy=\"50\" r=\"50\" fill=\"hotpink\"></circle>\n</svg>\n<p>xml 是浏览器能读取的格式，但如果希望 svg 能在浏览器中渲染出来，需要使用 xmlns 声明渲染规则。</p>\n<p>所以必须使用 xmlns=\"<a href=\"http://www.w3.org/2000/svg\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.w3.org/2000/svg</a>\"。</p>\n",
      "date_published": "2021-01-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "graphics"
      ]
    },
    {
      "title": "three",
      "url": "https://www.h7ml.cn/posts/graphics/three.html",
      "id": "https://www.h7ml.cn/posts/graphics/three.html",
      "summary": "three",
      "content_html": "<h1> three</h1>\n",
      "date_published": "2021-01-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "graphics"
      ]
    },
    {
      "title": "webgl",
      "url": "https://www.h7ml.cn/posts/graphics/webgl.html",
      "id": "https://www.h7ml.cn/posts/graphics/webgl.html",
      "summary": "webgl",
      "content_html": "<h1> webgl</h1>\n",
      "date_published": "2021-01-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "graphics"
      ]
    },
    {
      "title": "JavaScript 原生 touch",
      "url": "https://www.h7ml.cn/posts/html/%E5%8E%9F%E7%94%9Ftouch.html",
      "id": "https://www.h7ml.cn/posts/html/%E5%8E%9F%E7%94%9Ftouch.html",
      "summary": "JavaScript 原生 touch 事件 touchstart：手指按下 touchmove：手指移动 touchend：手指抬起 PC 端事件，比移动端事件略慢，大概慢 300ms 点透问题： 在 300ms 之内，如果上层元素消失或隐藏，目标就会漂移到下层元素身上，就会触发点击行为。 解决办法： 下层元素不要使用有点击特性的元素",
      "content_html": "<h1> JavaScript 原生 touch</h1>\n<h2> 事件</h2>\n<ul>\n<li>touchstart：手指按下</li>\n<li>touchmove：手指移动</li>\n<li>touchend：手指抬起</li>\n</ul>\n<p>PC 端事件，比移动端事件略慢，大概慢 300ms</p>\n<ul>\n<li>\n<p>点透问题：</p>\n<ul>\n<li>在 300ms 之内，如果上层元素消失或隐藏，目标就会漂移到下层元素身上，就会触发点击行为。</li>\n</ul>\n</li>\n<li>\n<p>解决办法：</p>\n<ul>\n<li>下层元素不要使用有点击特性的元素</li>\n</ul>\n</li>\n</ul>\n<h2> 事件对象</h2>\n<p>ev 不需要兼容</p>\n<p>ev 主要使用的 3 个属性：</p>\n<ul>\n<li>touches: 所有在屏幕上的手指的一个列表</li>\n<li>targetTouches: 当前在目标元素上的手指的列表</li>\n<li>changedTouches: 当前在目标元素上发生变化（触发当前事件）的手指的列表 最常用\n<ul>\n<li>clientX: 事件触发到可视区左边的距离</li>\n<li>clientY:事件触发到可视区上边的距离</li>\n<li>identifier: 标识符 第几个手指 0-n</li>\n<li>pageX: 事件触发到页面的左边的距离</li>\n<li>pageY: 事件触发到页面的上边的距离</li>\n<li>radiusX: x 轴的旋转半径</li>\n<li>radiusY: y 轴的旋转半径</li>\n<li>rotationAngle: 旋转角度 deg</li>\n<li>screenX: 事件触发到屏幕的左边距离</li>\n<li>screenY: 事件触发到屏幕的上边距离</li>\n</ul>\n</li>\n</ul>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "面试物语",
      "url": "https://www.h7ml.cn/posts/interview/",
      "id": "https://www.h7ml.cn/posts/interview/",
      "summary": "JavaScript [ == 和 =区别，分别在什么情况使用](https://www.h7ml.cn/posts/interview/JavaScript/== _=) 说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？ DOM 常见的操作有哪些？ ajax 原理是什么？如何实现？ 数组的常用方法有哪些？ bind、call、apply 区别？如何实现一个 bind? Javascript 本地存储的方式有哪些？区别及应用场景？ 说说你对闭包的理解？闭包使用场景 JavaScript 中执行上下文和执行栈是什么？ 大文件上传如何做断点续传？ 深拷贝浅拷贝的区别？如何实现一个深拷贝？ 说说 JavaScript 中的数据类型？存储上的差别？ 什么是防抖和节流？有什么区别？如何实现？ 说说 JavaScript 中的事件模型 解释下什么是事件代理？应用场景？ 说说你对事件循环的理解 Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？ 说说你对函数式编程的理解？优缺点？ Javascript 如何实现继承？ 说说你了解的 js 数据结构？ 说说 Javascript 数字精度丢失的问题，如何解决？ 说说 JavaScript 中内存泄漏的几种情况？ 说说 new 操作符具体干了什么？ JavaScript 原型，原型链 ? 有什么特点？ 如何实现上拉加载，下拉刷新？ 说说你对正则表达式的理解？应用场景？ 说说你对作用域链的理解 web 常见的攻击方式有哪些？如何防御？ 什么是单点登录？如何实现？ JavaScript 字符串的常用方法有哪些？ 举例说明你对尾递归的理解，有哪些应用场景 谈谈 this 对象的理解 谈谈 JavaScript 中的类型转换机制 typeof 与 instanceof 区别 如何判断一个元素是否在可视区域中？ NodeJS 说说对 Node 中的 Buffer 的理解？应用场景？ 说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter? 说说对 Node 中的 Stream 的理解？应用场景？ 说说对 Nodejs 中的事件循环机制理解? 如何实现文件上传？说说你的思路 说说对 Node 中的 fs 模块的理解? 有哪些常用方法 说说 Node. js 有哪些全局对象？ 如何实现 jwt 鉴权机制？说说你的思路 说说对中间件概念的理解，如何封装 node 中间件？ 说说你对 Node.js 的理解？优缺点？应用场景？ 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互? Node 性能如何进行监控以及优化？ 说说对 Node 中的 process 的理解？有哪些常用方法？ 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略? README.md React React 事件绑定的方式有哪些？区别？ React 构建组件的方式有哪些？区别？ 说说对 Fiber 架构的理解？解决了什么问题？ 说说对高阶组件的理解？应用场景? 说说 React 性能优化的手段有哪些？ 说说 React Jsx 转换成真实 DOM 过程？ 说说对 React 的理解？有哪些特性？ 说说对 React Hooks 的理解？解决了什么问题？ 说说你对 React Router 的理解？常用的 Router 组件有哪些？ 说说 React Router 有几种模式？实现原理？ 说说对 React refs 的理解？应用场景？ [ 说说 Real DOM 和 Virtual DOM 的区别？优缺点？](https://www.h7ml.cn/posts/interview/React/Real_DOM_Virtual DOM) 说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？ 说说 React 的事件机制？ 在 react 中组件间过渡动画如何实现？ 说说你在 React 项目是如何捕获错误的？ 说说对 React 中类组件和函数组件的理解？有什么区别？ React 中组件之间如何通信？ 说说对受控组件和非受控组件的理解？应用场景？ 说说 React diff 的原理是什么？ 你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？ 说说你对 immutable 的理解？如何应用在 react 项目中？ 说说 react 中引入 css 的方式有哪几种？区别？ 说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？ React 中的 key 有什么作用？ 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？ 说说你对 Redux 的理解？其工作原理？ 说说 React render 方法的原理？在什么时候会被触发？ 说说 React 服务端渲染怎么做？原理是什么？ 说说 React 中的 setState 执行机制 state 和 props 有什么区别？ 说说你在使用 React 过程中遇到的常见问题？如何解决? super() 和 super(props) 有什么区别？ algorithm 说说你对算法的理解？应用场景？ 说说你对二分查找的理解？如何实现？应用场景？ 说说你对堆的理解？如何实现？应用场景？ 说说你对链表的理解？常见的操作有哪些？ 说说你对冒泡排序的理解？如何实现？应用场景？ 说说你对分而治之、动态规划的理解？区别？ 说说你对贪心算法、回溯算法的理解？应用场景？ 说说你对图的理解？相关操作有哪些？ 说说你对插入排序的理解？如何实现？应用场景？ 说说你对归并排序的理解？如何实现？应用场景？ 说说你对快速排序的理解？如何实现？应用场景？ 说说你对选择排序的理解？如何实现？应用场景？ 说说你对集合的理解？常见的操作有哪些？ 说说常见的排序算法有哪些？区别？ 说说你对栈、队列的理解？应用场景？ 说说你对数据结构的理解？有哪些？区别？ 说说你对算法中时间复杂度，空间复杂度的理解？如何计算？ 说说你对树的理解？相关的操作有哪些？ applet 说说微信小程序的实现原理？ 说说你对微信小程序的理解？优缺点？ 说说微信小程序的生命周期函数有哪些？ 说说微信小程序的登录流程？ 说说微信小程序中路由跳转的方式有哪些？区别？ 说说提高微信小程序的应用速度的手段有哪些？ 说说微信小程序的发布流程？ 说说微信小程序的支付流程？ css 谈谈你对 BFC 的理解？ css3 动画有哪些？ 说说你对盒子模型的理解? 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？ 如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？ CSS3 新增了哪些新特性？ 如果要做优化，CSS 提高性能的方法有哪些？ 说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？ 说说 em/px/rem/vh/vw 区别? 说说 flexbox（弹性盒布局模型）,以及适用场景？ 介绍一下 grid 网格布局 css 中，有哪些方式可以隐藏页面元素？区别? 怎么理解回流跟重绘？什么场景下会触发？ 让 Chrome 支持小于 12px 的文字方式有哪些？区别？ 什么是响应式设计？响应式设计的基本原理是什么？如何做？ 说说对 Css 预编语言的理解？有哪些区别? 如何实现单行／多行文本溢出的省略样式？ CSS 如何画一个三角形？原理是什么？ 如何使用 css 完成视差滚动效果? design 说说你对工厂模式的理解？应用场景？ 说说你对发布订阅、观察者模式的理解？区别？ 说说你对代理模式的理解？应用场景？ 说说你对单例模式的理解？如何实现？ 说说你对策略模式的理解？应用场景？ 说说对设计模式的理解？常见的设计模式有哪些？ es6 ES6 中数组新增了哪些扩展？ 你是怎么理解 ES6 中 Decorator 的？使用场景？ 对象新增了哪些扩展？ 你是怎么理解 ES6 中 Generator 的？使用场景？ 你是怎么理解 ES6 中 Module 的？使用场景？ 对象新增了哪些扩展？ 你是怎么理解 ES6 中 Promise 的？使用场景？ 你是怎么理解 ES6 中 Proxy 的？使用场景? 你是怎么理解 ES6 新增 Set、Map 两种数据结构的？ 说说 var、let、const 之间的区别 git 说说你对 Git 的理解？ 说说 Git 中 HEAD、工作树和索引之间的区别？ 说说你对版本管理的理解？常用的版本管理工具有哪些？ 说说 Git 常用的命令有哪些？ ,- 说说 Git 中 fork, clone,branch 这三个概念，有什么区别? [ 说说你对 git rebase 和 git merge 的理解？区别？](https://www.h7ml.cn/posts/interview/git/gitRebase_ gitMerge) [ 说说对 git pull 和 git fetch 的理解？有什么区别？](https://www.h7ml.cn/posts/interview/git/git_pull _git_fetch) [ 说说你对 git reset 和 git revert 的理解？区别？](https://www.h7ml.cn/posts/interview/git/git_reset_ git_revert) 说说你对 git stash 的理解？应用场景？ http 说说 HTTP1.0/1.1/2.0 的区别? 如何理解 CDN？说说实现原理？ DNS 协议 是什么？说说 DNS 完整的查询过程? 说一下 GET 和 POST 的区别？ 为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？ 什么是 HTTP? HTTP 和 HTTPS 的区别? 如何理解 OSI 七层模型? 如何理解 TCP/IP 协议? 如何理解 UDP 和 TCP? 区别? 应用场景? 说说对 WebSocket 的理解？应用场景？ 说说地址栏输入 URL 敲下回车后发生了什么? 说说 TCP 为什么需要三次握手和四次挥手？ 说说 HTTP 常见的请求头有哪些? 作用？ 说说 HTTP 常见的状态码有哪些，适用场景？ linux 说说 linux 系统下 文件操作常用的命令有哪些？ [ typescript 说说你对 TypeScript 中类的理解？应用场景？ 说说 typescript 的数据类型有哪些？ 说说你对 TypeScript 装饰器的理解？应用场景？ 说说你对 TypeScript 中枚举类型的理解？应用场景？ 说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？ 说说你对 TypeScript 中泛型的理解？应用场景？ 说说你对 TypeScript 中高级类型的理解？有哪些？ 说说你对 TypeScript 中接口的理解？应用场景？ 说说对 TypeScript 中命名空间与模块的理解？区别？ 说说如何在 React 项目中应用 TypeScript？ 说说你对 TypeScript 的理解？与 JavaScript 的区别？ 说说如何在 Vue 项目中应用 TypeScript？ vue vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？ Vue 项目中有封装过 axios 吗？主要是封装哪方面的？ 你了解 axios 的原理吗？有看过它的源码吗？ 双向数据绑定是什么 Vue 组件之间的通信方式都有哪些？ Vue 中组件和插件有什么区别？ Vue 项目中你是如何解决跨域的呢？ 为什么 data 属性是一个函数而不是一个对象？ 动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？ 你了解 vue 的 diff 算法吗？说说看 ,- 你是怎么处理 vue 项目中的错误的？ Vue 中的过滤器了解吗？过滤器的应用场景有哪些？ SPA 首屏加载速度慢的怎么解决？ v-if 和 v-for 的优先级是什么？ 说说你对 keep-alive 的理解是什么？ 你知道 vue 中 key 的原理吗？说说你对它的理解 请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？ 说说你对 vue 的 mixin 的理解，有什么应用场景？ Vue 常用的修饰符有哪些有什么应用场景 Vue 实例挂载的过程 Vue 中的$nextTick 有什么作用？ Vue.observable 你有了解过吗？说说看 vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？ v-show 和 v-if 有什么区别？使用场景分别是什么？ 你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢 SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？ 说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？ 什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路 vue3 有了解过吗？能说说跟 vue2 的区别吗？ vue3 Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？ Vue3.0 的设计目标是什么？做了哪些优化 用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？ Vue3.0 性能提升主要是通过哪几方面体现的？ Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？ css 选择器有哪些？优先级？哪些属性可以继承？ 说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？ webpack 说说 webpack 的热更新是如何做到的？原理是什么？ 说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？ 说说 webpack 中常见的 Plugin？解决了什么问题？ 与 webpack 类似的工具还有哪些？区别？ 说说 webpack 的构建流程? 如何提高 webpack 的构建速度？ 说说如何借助 webpack 来优化前端性能？ 说说 webpack proxy 工作原理？为什么能解决跨域? 说说你对 webpack 的理解？解决了什么问题？",
      "content_html": "<ul>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript</a></p>\n</li>\n<li>\n<p>[ == 和 =<mark>区别，分别在什么情况使用](<a href=\"https://www.h7ml.cn/posts/interview/JavaScript/==\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/posts/interview/JavaScript/==</a> _</mark>=)</p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/BOM\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/Dom\" target=\"_blank\" rel=\"noopener noreferrer\"> DOM 常见的操作有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/ajax\" target=\"_blank\" rel=\"noopener noreferrer\"> ajax 原理是什么？如何实现？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/array_api\" target=\"_blank\" rel=\"noopener noreferrer\"> 数组的常用方法有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/bind_call_apply\" target=\"_blank\" rel=\"noopener noreferrer\"> bind、call、apply 区别？如何实现一个 bind?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/cache\" target=\"_blank\" rel=\"noopener noreferrer\"> Javascript 本地存储的方式有哪些？区别及应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/closure\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对闭包的理解？闭包使用场景</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/context_stack\" target=\"_blank\" rel=\"noopener noreferrer\"> JavaScript 中执行上下文和执行栈是什么？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/continue_to_upload\" target=\"_blank\" rel=\"noopener noreferrer\"> 大文件上传如何做断点续传？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/copy\" target=\"_blank\" rel=\"noopener noreferrer\"> 深拷贝浅拷贝的区别？如何实现一个深拷贝？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/data_type\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 JavaScript 中的数据类型？存储上的差别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/debounce_throttle\" target=\"_blank\" rel=\"noopener noreferrer\"> 什么是防抖和节流？有什么区别？如何实现？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/event_Model\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 JavaScript 中的事件模型</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/event_agent\" target=\"_blank\" rel=\"noopener noreferrer\"> 解释下什么是事件代理？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/event_loop\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对事件循环的理解</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/function_cache\" target=\"_blank\" rel=\"noopener noreferrer\"> Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/functional_programming\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对函数式编程的理解？优缺点？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/inherit\" target=\"_blank\" rel=\"noopener noreferrer\"> Javascript 如何实现继承？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/js_data_structure\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你了解的 js 数据结构？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/loss_accuracy\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 Javascript 数字精度丢失的问题，如何解决？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/memory_leak\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 JavaScript 中内存泄漏的几种情况？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/new\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 new 操作符具体干了什么？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/prototype\" target=\"_blank\" rel=\"noopener noreferrer\"> JavaScript 原型，原型链 ? 有什么特点？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/pull_up_loading_pull_down_refresh\" target=\"_blank\" rel=\"noopener noreferrer\"> 如何实现上拉加载，下拉刷新？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/regexp\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对正则表达式的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/scope\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对作用域链的理解</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/security\" target=\"_blank\" rel=\"noopener noreferrer\"> web 常见的攻击方式有哪些？如何防御？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/single_sign\" target=\"_blank\" rel=\"noopener noreferrer\"> 什么是单点登录？如何实现？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/string_api\" target=\"_blank\" rel=\"noopener noreferrer\"> JavaScript 字符串的常用方法有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/tail_recursion\" target=\"_blank\" rel=\"noopener noreferrer\"> 举例说明你对尾递归的理解，有哪些应用场景</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/this\" target=\"_blank\" rel=\"noopener noreferrer\"> 谈谈 this 对象的理解</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/type_conversion\" target=\"_blank\" rel=\"noopener noreferrer\"> 谈谈 JavaScript 中的类型转换机制</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/typeof_instanceof\" target=\"_blank\" rel=\"noopener noreferrer\"> typeof 与 instanceof 区别</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/visible\" target=\"_blank\" rel=\"noopener noreferrer\"> 如何判断一个元素是否在可视区域中？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS\" target=\"_blank\" rel=\"noopener noreferrer\">NodeJS</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/Buffer\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 Node 中的 Buffer 的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/EventEmitter\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/Stream\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 Node 中的 Stream 的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/event_loop\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 Nodejs 中的事件循环机制理解?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/file_upload\" target=\"_blank\" rel=\"noopener noreferrer\"> 如何实现文件上传？说说你的思路</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/fs\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 Node 中的 fs 模块的理解? 有哪些常用方法</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/global\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 Node. js 有哪些全局对象？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/jwt\" target=\"_blank\" rel=\"noopener noreferrer\"> 如何实现 jwt 鉴权机制？说说你的思路</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/middleware\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对中间件概念的理解，如何封装 node 中间件？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/nodejs\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对 Node.js 的理解？优缺点？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/paging\" target=\"_blank\" rel=\"noopener noreferrer\"> 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/performance\" target=\"_blank\" rel=\"noopener noreferrer\"> Node 性能如何进行监控以及优化？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/process\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 Node 中的 process 的理解？有哪些常用方法？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/require_order\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/README.md\" target=\"_blank\" rel=\"noopener noreferrer\">README.md</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React\" target=\"_blank\" rel=\"noopener noreferrer\">React</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/Binding_events\" target=\"_blank\" rel=\"noopener noreferrer\"> React 事件绑定的方式有哪些？区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/Building_components\" target=\"_blank\" rel=\"noopener noreferrer\"> React 构建组件的方式有哪些？区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/Fiber\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 Fiber 架构的理解？解决了什么问题？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/High_order_components\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对高阶组件的理解？应用场景?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/Improve_performance\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React 性能优化的手段有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/JSX_to_DOM\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React Jsx 转换成真实 DOM 过程？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/React\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 React 的理解？有哪些特性？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/React_Hooks\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 React Hooks 的理解？解决了什么问题？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/React_Router\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对 React Router 的理解？常用的 Router 组件有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/React_Router_model\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React Router 有几种模式？实现原理？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/React_refs\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 React refs 的理解？应用场景？</a></p>\n</li>\n<li>\n<p>[ 说说 Real DOM 和 Virtual DOM 的区别？优缺点？](<a href=\"https://www.h7ml.cn/posts/interview/React/Real_DOM_Virtual\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/posts/interview/React/Real_DOM_Virtual</a> DOM)</p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/Redux_Middleware\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/SyntheticEvent\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React 的事件机制？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/animation\" target=\"_blank\" rel=\"noopener noreferrer\"> 在 react 中组件间过渡动画如何实现？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/capture_error\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你在 React 项目是如何捕获错误的？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/class_function_component\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 React 中类组件和函数组件的理解？有什么区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/communication\" target=\"_blank\" rel=\"noopener noreferrer\"> React 中组件之间如何通信？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/controlled_Uncontrolled\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对受控组件和非受控组件的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/diff\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React diff 的原理是什么？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/how_to_use_redux\" target=\"_blank\" rel=\"noopener noreferrer\"> 你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/immutable\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对 immutable 的理解？如何应用在 react 项目中？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/import_css\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 react 中引入 css 的方式有哪几种？区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/improve_render\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/key\" target=\"_blank\" rel=\"noopener noreferrer\"> React 中的 key 有什么作用？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/life_cycle\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/redux\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对 Redux 的理解？其工作原理？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/render\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React render 方法的原理？在什么时候会被触发？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/server_side_rendering\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React 服务端渲染怎么做？原理是什么？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/setState\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React 中的 setState 执行机制</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/state_props\" target=\"_blank\" rel=\"noopener noreferrer\"> state 和 props 有什么区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/summary\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你在使用 React 过程中遇到的常见问题？如何解决?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/React/super()_super(props)\" target=\"_blank\" rel=\"noopener noreferrer\"> super() 和 super(props) 有什么区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm\" target=\"_blank\" rel=\"noopener noreferrer\">algorithm</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/Algorithm\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对算法的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/BinarySearch\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对二分查找的理解？如何实现？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/Heap\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对堆的理解？如何实现？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/LinkedList\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对链表的理解？常见的操作有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/bubbleSort\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对冒泡排序的理解？如何实现？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/design1\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对分而治之、动态规划的理解？区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/design2\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对贪心算法、回溯算法的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/graph\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对图的理解？相关操作有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/insertionSort\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对插入排序的理解？如何实现？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/mergeSort\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对归并排序的理解？如何实现？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/quickSort\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对快速排序的理解？如何实现？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/selectionSort\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对选择排序的理解？如何实现？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/set\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对集合的理解？常见的操作有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/sort\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说常见的排序算法有哪些？区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/stack_queue\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对栈、队列的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/structure\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对数据结构的理解？有哪些？区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/time_space\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对算法中时间复杂度，空间复杂度的理解？如何计算？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/algorithm/tree\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对树的理解？相关的操作有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/applet\" target=\"_blank\" rel=\"noopener noreferrer\">applet</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/applet/WebView_jscore\" target=\"_blank\" rel=\"noopener noreferrer\">说说微信小程序的实现原理？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/applet/applet\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对微信小程序的理解？优缺点？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/applet/lifecycle\" target=\"_blank\" rel=\"noopener noreferrer\">说说微信小程序的生命周期函数有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/applet/login\" target=\"_blank\" rel=\"noopener noreferrer\">说说微信小程序的登录流程？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/applet/navigate\" target=\"_blank\" rel=\"noopener noreferrer\">说说微信小程序中路由跳转的方式有哪些？区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/applet/optimization\" target=\"_blank\" rel=\"noopener noreferrer\">说说提高微信小程序的应用速度的手段有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/applet/publish\" target=\"_blank\" rel=\"noopener noreferrer\">说说微信小程序的发布流程？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/applet/requestPayment\" target=\"_blank\" rel=\"noopener noreferrer\">说说微信小程序的支付流程？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css\" target=\"_blank\" rel=\"noopener noreferrer\">css</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/BFC\" target=\"_blank\" rel=\"noopener noreferrer\">谈谈你对 BFC 的理解？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/animation\" target=\"_blank\" rel=\"noopener noreferrer\">css3 动画有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/box\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对盒子模型的理解?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/center\" target=\"_blank\" rel=\"noopener noreferrer\">元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/column_layout\" target=\"_blank\" rel=\"noopener noreferrer\">如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/css3_features\" target=\"_blank\" rel=\"noopener noreferrer\">CSS3 新增了哪些新特性？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/css_performance\" target=\"_blank\" rel=\"noopener noreferrer\">如果要做优化，CSS 提高性能的方法有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/dp_px_dpr_ppi\" target=\"_blank\" rel=\"noopener noreferrer\">说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/em_px_rem_vh_vw\" target=\"_blank\" rel=\"noopener noreferrer\">说说 em/px/rem/vh/vw 区别?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/flexbox\" target=\"_blank\" rel=\"noopener noreferrer\">说说 flexbox（弹性盒布局模型）,以及适用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/grid\" target=\"_blank\" rel=\"noopener noreferrer\">介绍一下 grid 网格布局</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/hide_attributes\" target=\"_blank\" rel=\"noopener noreferrer\">css 中，有哪些方式可以隐藏页面元素？区别?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/layout_painting\" target=\"_blank\" rel=\"noopener noreferrer\">怎么理解回流跟重绘？什么场景下会触发？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/less_12px\" target=\"_blank\" rel=\"noopener noreferrer\">让 Chrome 支持小于 12px 的文字方式有哪些？区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/responsive_layout\" target=\"_blank\" rel=\"noopener noreferrer\">什么是响应式设计？响应式设计的基本原理是什么？如何做？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/sass_less_stylus\" target=\"_blank\" rel=\"noopener noreferrer\">说说对 Css 预编语言的理解？有哪些区别?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/single_multi_line\" target=\"_blank\" rel=\"noopener noreferrer\">如何实现单行／多行文本溢出的省略样式？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/triangle\" target=\"_blank\" rel=\"noopener noreferrer\">CSS 如何画一个三角形？原理是什么？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/css/visual_scrolling\" target=\"_blank\" rel=\"noopener noreferrer\">如何使用 css 完成视差滚动效果?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/design\" target=\"_blank\" rel=\"noopener noreferrer\">design</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/design/Factory_Pattern\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对工厂模式的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/design/Observer_Pattern\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对发布订阅、观察者模式的理解？区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/design/Proxy_Pattern\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对代理模式的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/design/Singleton_Pattern\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对单例模式的理解？如何实现？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/design/Strategy_Pattern\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对策略模式的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/design/design\" target=\"_blank\" rel=\"noopener noreferrer\">说说对设计模式的理解？常见的设计模式有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/es6\" target=\"_blank\" rel=\"noopener noreferrer\">es6</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/es6/array\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 中数组新增了哪些扩展？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/es6/decorator\" target=\"_blank\" rel=\"noopener noreferrer\">你是怎么理解 ES6 中 Decorator 的？使用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/es6/function\" target=\"_blank\" rel=\"noopener noreferrer\">对象新增了哪些扩展？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/es6/generator\" target=\"_blank\" rel=\"noopener noreferrer\">你是怎么理解 ES6 中 Generator 的？使用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/es6/module\" target=\"_blank\" rel=\"noopener noreferrer\">你是怎么理解 ES6 中 Module 的？使用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/es6/object\" target=\"_blank\" rel=\"noopener noreferrer\">对象新增了哪些扩展？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/es6/promise\" target=\"_blank\" rel=\"noopener noreferrer\">你是怎么理解 ES6 中 Promise 的？使用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/es6/proxy\" target=\"_blank\" rel=\"noopener noreferrer\">你是怎么理解 ES6 中 Proxy 的？使用场景?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/es6/set_map\" target=\"_blank\" rel=\"noopener noreferrer\">你是怎么理解 ES6 新增 Set、Map 两种数据结构的？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/es6/var_let_const\" target=\"_blank\" rel=\"noopener noreferrer\">说说 var、let、const 之间的区别</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/git\" target=\"_blank\" rel=\"noopener noreferrer\">git</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/git/Git\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 Git 的理解？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/git/HEAD_tree_index\" target=\"_blank\" rel=\"noopener noreferrer\">说说 Git 中 HEAD、工作树和索引之间的区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/git/Version_control\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对版本管理的理解？常用的版本管理工具有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/git/command\" target=\"_blank\" rel=\"noopener noreferrer\">说说 Git 常用的命令有哪些？</a> ,- <a href=\"https://www.h7ml.cn/posts/interview/git/fork_clone_branch\" target=\"_blank\" rel=\"noopener noreferrer\">说说 Git 中 fork, clone,branch 这三个概念，有什么区别?</a></p>\n</li>\n<li>\n<p>[ 说说你对 git rebase 和 git merge 的理解？区别？](<a href=\"https://www.h7ml.cn/posts/interview/git/gitRebase_\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/posts/interview/git/gitRebase_</a> gitMerge)</p>\n</li>\n<li>\n<p>[ 说说对 git pull 和 git fetch 的理解？有什么区别？](<a href=\"https://www.h7ml.cn/posts/interview/git/git_pull\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/posts/interview/git/git_pull</a> _git_fetch)</p>\n</li>\n<li>\n<p>[ 说说你对 git reset 和 git revert 的理解？区别？](<a href=\"https://www.h7ml.cn/posts/interview/git/git_reset_\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/posts/interview/git/git_reset_</a> git_revert)</p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/git/git_stash\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 git stash 的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http\" target=\"_blank\" rel=\"noopener noreferrer\">http</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http/1.0_1.1_2.0\" target=\"_blank\" rel=\"noopener noreferrer\">说说 HTTP1.0/1.1/2.0 的区别?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http/CDN\" target=\"_blank\" rel=\"noopener noreferrer\">如何理解 CDN？说说实现原理？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http/DNS\" target=\"_blank\" rel=\"noopener noreferrer\">DNS 协议 是什么？说说 DNS 完整的查询过程?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http/GET_POST\" target=\"_blank\" rel=\"noopener noreferrer\">说一下 GET 和 POST 的区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http/HTTPS\" target=\"_blank\" rel=\"noopener noreferrer\">为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http/HTTP_HTTPS\" target=\"_blank\" rel=\"noopener noreferrer\">什么是 HTTP? HTTP 和 HTTPS 的区别?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http/OSI\" target=\"_blank\" rel=\"noopener noreferrer\">如何理解 OSI 七层模型?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http/TCP_IP\" target=\"_blank\" rel=\"noopener noreferrer\">如何理解 TCP/IP 协议?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http/UDP_TCP\" target=\"_blank\" rel=\"noopener noreferrer\">如何理解 UDP 和 TCP? 区别? 应用场景?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http/WebSocket\" target=\"_blank\" rel=\"noopener noreferrer\">说说对 WebSocket 的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http/after_url\" target=\"_blank\" rel=\"noopener noreferrer\">说说地址栏输入 URL 敲下回车后发生了什么?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http/handshakes_waves\" target=\"_blank\" rel=\"noopener noreferrer\">说说 TCP 为什么需要三次握手和四次挥手？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http/headers\" target=\"_blank\" rel=\"noopener noreferrer\">说说 HTTP 常见的请求头有哪些? 作用？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/http/status\" target=\"_blank\" rel=\"noopener noreferrer\">说说 HTTP 常见的状态码有哪些，适用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/linux\" target=\"_blank\" rel=\"noopener noreferrer\">linux</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/linux/file\" target=\"_blank\" rel=\"noopener noreferrer\">说说 linux 系统下 文件操作常用的命令有哪些？</a></p>\n</li>\n<li>\n<p>[</p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/typescript\" target=\"_blank\" rel=\"noopener noreferrer\">typescript</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/typescript/class\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 中类的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/typescript/data_type\" target=\"_blank\" rel=\"noopener noreferrer\">说说 typescript 的数据类型有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/typescript/decorator\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 装饰器的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/typescript/enum\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 中枚举类型的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/typescript/function\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/typescript/generic\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 中泛型的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/typescript/high_type\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 中高级类型的理解？有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/typescript/interface\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 中接口的理解？应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/typescript/namespace_module\" target=\"_blank\" rel=\"noopener noreferrer\">说说对 TypeScript 中命名空间与模块的理解？区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/typescript/react\" target=\"_blank\" rel=\"noopener noreferrer\">说说如何在 React 项目中应用 TypeScript？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/typescript/typescript_javascript\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 的理解？与 JavaScript 的区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/typescript/vue\" target=\"_blank\" rel=\"noopener noreferrer\">说说如何在 Vue 项目中应用 TypeScript？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue\" target=\"_blank\" rel=\"noopener noreferrer\">vue</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/404\" target=\"_blank\" rel=\"noopener noreferrer\"> vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/axios\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 项目中有封装过 axios 吗？主要是封装哪方面的？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/axiosCode\" target=\"_blank\" rel=\"noopener noreferrer\"> 你了解 axios 的原理吗？有看过它的源码吗？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/bind\" target=\"_blank\" rel=\"noopener noreferrer\"> 双向数据绑定是什么</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/communication\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 组件之间的通信方式都有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/components_plugin\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 中组件和插件有什么区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/cors\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 项目中你是如何解决跨域的呢？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/data\" target=\"_blank\" rel=\"noopener noreferrer\"> 为什么 data 属性是一个函数而不是一个对象？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/data_object_add_attrs\" target=\"_blank\" rel=\"noopener noreferrer\"> 动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/diff\" target=\"_blank\" rel=\"noopener noreferrer\"> 你了解 vue 的 diff 算法吗？说说看</a> ,- <a href=\"https://www.h7ml.cn/posts/interview/vue/error\" target=\"_blank\" rel=\"noopener noreferrer\"> 你是怎么处理 vue 项目中的错误的？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/filter\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 中的过滤器了解吗？过滤器的应用场景有哪些？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/first_page_time\" target=\"_blank\" rel=\"noopener noreferrer\"> SPA 首屏加载速度慢的怎么解决？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/if_for\" target=\"_blank\" rel=\"noopener noreferrer\"> v-if 和 v-for 的优先级是什么？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/keepalive\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对 keep-alive 的理解是什么？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/key\" target=\"_blank\" rel=\"noopener noreferrer\"> 你知道 vue 中 key 的原理吗？说说你对它的理解</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/lifecycle\" target=\"_blank\" rel=\"noopener noreferrer\"> 请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/mixin\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对 vue 的 mixin 的理解，有什么应用场景？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/modifier\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 常用的修饰符有哪些有什么应用场景</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/new_vue\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 实例挂载的过程</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/nexttick\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 中的$nextTick 有什么作用？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/observable\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue.observable 你有了解过吗？说说看</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/permission\" target=\"_blank\" rel=\"noopener noreferrer\"> vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/show_if\" target=\"_blank\" rel=\"noopener noreferrer\"> v-show 和 v-if 有什么区别？使用场景分别是什么？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/spa\" target=\"_blank\" rel=\"noopener noreferrer\"> 你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/ssr\" target=\"_blank\" rel=\"noopener noreferrer\"> SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/structure\" target=\"_blank\" rel=\"noopener noreferrer\"> 说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/vnode\" target=\"_blank\" rel=\"noopener noreferrer\"> 什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue/vue3_vue2\" target=\"_blank\" rel=\"noopener noreferrer\"> vue3 有了解过吗？能说说跟 vue2 的区别吗？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue3\" target=\"_blank\" rel=\"noopener noreferrer\">vue3</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue3/composition\" target=\"_blank\" rel=\"noopener noreferrer\">Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue3/goal\" target=\"_blank\" rel=\"noopener noreferrer\">Vue3.0 的设计目标是什么？做了哪些优化</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue3/modal_component\" target=\"_blank\" rel=\"noopener noreferrer\">用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue3/performance\" target=\"_blank\" rel=\"noopener noreferrer\">Vue3.0 性能提升主要是通过哪几方面体现的？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue3/proxy\" target=\"_blank\" rel=\"noopener noreferrer\">Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue3/selector\" target=\"_blank\" rel=\"noopener noreferrer\">css 选择器有哪些？优先级？哪些属性可以继承？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/vue3/treeshaking\" target=\"_blank\" rel=\"noopener noreferrer\">说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/webpack\" target=\"_blank\" rel=\"noopener noreferrer\">webpack</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/webpack/HMR\" target=\"_blank\" rel=\"noopener noreferrer\">说说 webpack 的热更新是如何做到的？原理是什么？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/webpack/Loader_Plugin\" target=\"_blank\" rel=\"noopener noreferrer\">说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/webpack/Plugin\" target=\"_blank\" rel=\"noopener noreferrer\">说说 webpack 中常见的 Plugin？解决了什么问题？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/webpack/Rollup_Parcel_snowpack_Vite\" target=\"_blank\" rel=\"noopener noreferrer\">与 webpack 类似的工具还有哪些？区别？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/webpack/build_process\" target=\"_blank\" rel=\"noopener noreferrer\">说说 webpack 的构建流程?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/webpack/improve_build\" target=\"_blank\" rel=\"noopener noreferrer\">如何提高 webpack 的构建速度？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/webpack/performance\" target=\"_blank\" rel=\"noopener noreferrer\">说说如何借助 webpack 来优化前端性能？</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/webpack/proxy\" target=\"_blank\" rel=\"noopener noreferrer\">说说 webpack proxy 工作原理？为什么能解决跨域?</a></p>\n</li>\n<li>\n<p><a href=\"https://www.h7ml.cn/posts/interview/webpack/webpack\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 webpack 的理解？解决了什么问题？</a></p>\n</li>\n</ul>\n",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-26T10:13:08.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "design"
      ]
    },
    {
      "title": "javascript",
      "url": "https://www.h7ml.cn/posts/javascript/",
      "id": "https://www.h7ml.cn/posts/javascript/",
      "summary": "JavaScript 基本概念 JavaScript 数据类型 JavaScript 面向对象 JavaScript BOM JavaScript DOM JavaScript 事件 JavaScript 动画 JavaScript 高级程序设计读书笔记 JavaScript 原型与继承 JavaScript 数据类型 JavaScript 类型转换",
      "content_html": "<ul>\n<li><a href=\"./basic\">JavaScript 基本概念</a></li>\n<li><a href=\"./types\">JavaScript 数据类型</a></li>\n<li><a href=\"./object-oriented\">JavaScript 面向对象</a></li>\n<li><a href=\"./bom\">JavaScript BOM</a></li>\n<li><a href=\"./dom\">JavaScript DOM</a></li>\n<li><a href=\"./event\">JavaScript 事件</a></li>\n<li><a href=\"./animation\">JavaScript 动画</a></li>\n<li><a href=\"/posts/javascript/professional-js.html\" target=\"blank\">JavaScript 高级程序设计读书笔记</a></li>\n<li><a href=\"/posts/javascript/inheritance.html\" target=\"blank\">JavaScript 原型与继承</a></li>\n<li><a href=\"/posts/javascript/types.html\" target=\"blank\">JavaScript 数据类型</a></li>\n<li><a href=\"/posts/javascript/conversions.html\" target=\"blank\">JavaScript 类型转换</a></li>\n</ul>\n",
      "date_published": "2022-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "JavaScript 类型转换",
      "url": "https://www.h7ml.cn/posts/javascript/conversions.html",
      "id": "https://www.h7ml.cn/posts/javascript/conversions.html",
      "summary": "JavaScript 类型转换 温馨提示阅读[《你不知道的 JavaScript（中卷）》](https://www.ituring.com.cn/book/1563)和各个大佬的文章所归纳的总结，**如有异议按你的理解为主** ::: 将值从一种类型转换为另一种类型称为类型转换 在 JavaScript 中进行类型转换时，根据调用形式的不同可以分为以下两种: 显式类型转换 隐式类型转换 抽象操作 (内部的类型转换规则) 在了解类型转换前我们需要知道 JavaScript 的 抽象操作 (类型转换规则) 抽象操作 是指仅供内部使用的操作 ToPrimitive 将引用类型转换成相应的基本类型值 ToString 将非字符串值转换成字符串 ToBoolean 将非布尔值转换成布尔值 ToNumber 将非数字值转换成数字值 ToPrimitive ToPrimitive 用来处理引用类型到基本类型的类型转换 ToPrimitive 转换规则 检查是否存在 Symbol.toPrimitive() 基本类型直接返回 引用类型抛出 TypeError 错误 检查是否存在 valueOf() 基本类型直接返回 引用类型则继续调用 toString() 调用 toString() 基本类型直接返回 引用类型抛出 TypeError 错误",
      "content_html": "<h1> JavaScript 类型转换</h1>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">温馨提示阅读[《你不知道的 JavaScript（中卷）》](https://www.ituring.com.cn/book/1563)和各个大佬的文章所归纳的总结，**如有异议按你的理解为主** :::</p>\n<p>将值从一种类型转换为另一种类型称为<strong>类型转换</strong> <br> 在 <code>JavaScript</code> 中进行类型转换时，根据调用形式的不同可以分为以下两种:</p>\n<ul>\n<li><strong>显式类型转换</strong></li>\n<li><strong>隐式类型转换</strong></li>\n</ul>\n<h2> 抽象操作 (内部的类型转换规则)</h2>\n<p>在了解类型转换前我们需要知道 <code>JavaScript</code> 的 <strong>抽象操作</strong> (类型转换规则)</p>\n<blockquote>\n<p><strong>抽象操作</strong> 是指仅供内部使用的操作</p>\n</blockquote>\n<ul>\n<li><code>ToPrimitive</code> 将引用类型转换成相应的基本类型值</li>\n<li><code>ToString</code> 将非字符串值转换成字符串</li>\n<li><code>ToBoolean</code> 将非布尔值转换成布尔值</li>\n<li><code>ToNumber</code> 将非数字值转换成数字值</li>\n</ul>\n<h3> ToPrimitive</h3>\n<p><code>ToPrimitive</code> 用来处理引用类型到基本类型的类型转换</p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">ToPrimitive 转换规则</p>\n<ul>\n<li>检查是否存在 <code>Symbol.toPrimitive()</code>\n<ul>\n<li>基本类型直接返回</li>\n<li>引用类型抛出 <code>TypeError</code> 错误</li>\n</ul>\n</li>\n<li>检查是否存在 <code>valueOf()</code>\n<ul>\n<li>基本类型直接返回</li>\n<li>引用类型则继续调用 <code>toString()</code></li>\n</ul>\n</li>\n<li>调用 <code>toString()</code>\n<ul>\n<li>基本类型直接返回</li>\n<li>引用类型抛出 <code>TypeError</code> 错误</li>\n</ul>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意点</p>\n<ul>\n<li>使用 <code>Object.create(null)</code> 创建的对象没有原型，即不存在 <code>valueOf()</code> 和 <code>toString()</code>，当对其进行类型转换时会抛出 <code>TypeError</code> 错误</li>\n<li>在做显式类型转换时 <code>valueOf()</code> 和 <code>toString()</code> 的调用顺序会根据转换目标不同去做相应调整\n<ul>\n<li>默认情况下都是先调用 <code>valueOf()</code> 再调用 <code>toString()</code></li>\n<li>当需要转换的目标为字符串时，会先调用 <code>toString()</code> 再调用 <code>valueOf()</code></li>\n</ul>\n</li>\n</ul>\n</div>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> ToString</h3>\n<p><code>ToString</code> 用来处理非字符串到字符串的类型转换</p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">ToString 转换规则</p>\n<ul>\n<li>基本类型\n<ul>\n<li><code>undefined</code> =&gt; <code>'undefined'</code></li>\n<li><code>null</code> =&gt; <code>'null'</code></li>\n<li><code>true</code> =&gt; <code>'true'</code></li>\n<li><code>false</code> =&gt; <code>'false'</code></li>\n<li><code>number</code>\n<ul>\n<li>普通数值直接加引号</li>\n<li>极小和极大的数字将转换成指数形式的字符串</li>\n<li><code>+0 0 -0</code> =&gt; <code>'0'</code></li>\n<li><code>Infinity</code> =&gt; <code>'Infinity'</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>引用类型会先调用 <code>ToPrimitive</code> 逻辑将其转换成基本类型，如果返回的基本类型不是字符串，再遵循以上规则进行转换</li>\n</ul>\n</div>\n<h3> ToBoolean</h3>\n<p><code>ToBoolean</code> 用来处理非布尔值到布尔值的类型转换，在 <code>JavaScript</code> 中，布尔类型分为真值(<code>true</code>)和假值(<code>false</code>)</p>\n<ul>\n<li><strong>假值</strong>：可以被强制类型转换为 <code>false</code> 的值</li>\n<li><strong>真值</strong>：除假值之外的值</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">ToBoolean 转换规则</p>\n<ul>\n<li>以下值会被转换成假值(<code>false</code>)\n<ul>\n<li><strong><code>undefined</code></strong></li>\n<li><strong><code>null</code></strong></li>\n<li><strong><code>false</code></strong></li>\n<li><strong><code>+0 0 -0 NaN</code></strong></li>\n<li><strong><code>''</code></strong></li>\n</ul>\n</li>\n<li>除假值之外的值都会被转换成真值(<code>true</code>)</li>\n</ul>\n</div>\n<h3> ToNumber</h3>\n<p><code>ToNumber</code> 用来处理非数字值到数字值的类型转换</p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">ToNumber 转换规则</p>\n<ul>\n<li>基本类型\n<ul>\n<li><code>undefined</code> =&gt; <code>NaN</code></li>\n<li><code>null</code> =&gt; <code>0</code></li>\n<li><code>true</code> =&gt; <code>1</code></li>\n<li><code>false</code> =&gt; <code>0</code></li>\n<li><code>string</code>\n<ul>\n<li>空字符串(<code>''</code>) =&gt; <code>0</code></li>\n<li>非数字字符串 =&gt; <code>NaN</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>引用类型会先调用 <code>ToPrimitive</code> 逻辑将其转换成基本类型，如果返回的基本类型不是数值，再遵循以上规则进行转换</li>\n</ul>\n</div>\n<h2> 显式类型转换</h2>\n<p>显式类型转换是指显式的去调用类型转换方法</p>\n<ul>\n<li>转换成布尔值\n<ul>\n<li><code>Boolean()</code></li>\n</ul>\n</li>\n<li>转换成数值\n<ul>\n<li><code>Number()</code></li>\n<li><code>parseInt()</code></li>\n<li><code>parseFloat()</code></li>\n</ul>\n</li>\n<li>转换成字符串\n<ul>\n<li><code>String()</code></li>\n</ul>\n</li>\n</ul>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意点</p>\n<ul>\n<li><code>Number()</code> 转换的是整个值</li>\n<li><code>parseInt()</code> 和 <code>parseFloat()</code> 转换的是部分值，是对字符串逐个进行解析和转换，如果传入的参数不是字符串，会先对其进行字符串的转换</li>\n</ul>\n</div>\n<h2> 隐式类型转换</h2>\n<p>隐式类型转换是指在执行过程中，当实际操作的值与 <code>JavaScript</code> 内部期望得到的值不同时，就会对其做隐式类型转换(即不易察觉的类型转换)<br> 在 <code>JavaScript</code> 中有以下场景会发生隐式类型转换</p>\n<ul>\n<li>四则运算符 (<code>+ - * /</code>)</li>\n<li>相等运算符 (<code>==</code>)</li>\n<li>关系运算符 (<code>&gt; &lt; &gt;= &lt;=</code>)</li>\n<li>逻辑操作符 (<code>&amp;&amp; ||</code>)</li>\n<li>条件判断语句\n<ul>\n<li><code>if()</code></li>\n<li><code>while()</code></li>\n<li>三元运算符</li>\n</ul>\n</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">四则运算符运算规则</p>\n<ul>\n<li><code>-</code>(减) <code>*</code>(乘) <code>/</code>(除) 运算符: 先对操作数做 <code>ToNumber</code> 处理再执行运算</li>\n<li><code>+</code>(加) 运算符\n<ul>\n<li>做一元运算时，对操作数做 <code>ToNumber</code> 处理</li>\n<li>做二元运算时\n<ul>\n<li>当其中一个操作数为 <code>string</code> 时，将另一个操作数做 <code>ToString</code> 处理再执行字符串拼接</li>\n<li>当一个操作数为 <code>number</code> 另一个操作数为基本类型时，将基本类型做 <code>ToNumber</code> 处理再执行运算</li>\n<li>当一个操作数为 <code>number</code> 另一个操作数为引用类型时，都会先做 <code>ToString</code> 处理再执行字符串拼接</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">相等运算符运算规则</p>\n<ul>\n<li><code>boolean</code> 与其它类型进行比较时，将 <code>boolean</code> 做 <code>ToNumber</code> 处理</li>\n<li><code>string</code> 与 <code>number</code> 进行比较时，将 <code>string</code> 做 <code>ToNumber</code> 处理</li>\n<li><code>undefined</code> 与 <code>null</code> 比较时返回 <code>true</code></li>\n<li><code>undefined</code> <code>null</code> 与其它类型的比较时都返回 <code>false</code></li>\n<li><code>引用类型</code> 与 <code>基本类型</code> 进行比较时，将 <code>引用类型</code> 做 <code>ToPrimitive</code> 处理</li>\n<li><code>引用类型</code> 与 <code>引用类型</code> 比较时，直接判断引用地址是否一致</li>\n</ul>\n</div>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">关系运算符运算规则</p>\n<ul>\n<li>将引用类型做 <code>ToPrimitive</code> 处理</li>\n<li>如果两个参数都是 <code>string</code> 类型时进行 <code>Unicode 编码</code> 大小比较</li>\n<li>否则将两个参数做 <code>ToNumber</code> 处理，再进行数值大小比较</li>\n</ul>\n</div>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">在**逻辑操作符**与**条件判断语句**中都是做 `ToBoolean` 处理 :::</p>\n</div>\n",
      "date_published": "2019-08-16T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "javascript EventSource：实时服务器端推送",
      "url": "https://www.h7ml.cn/posts/javascript/eventSource.html",
      "id": "https://www.h7ml.cn/posts/javascript/eventSource.html",
      "summary": "javascript EventSource实时服务器端推送",
      "content_html": "<h1> javascript EventSource：实时服务器端推送</h1>\n<p>当涉及到向前端应用程序提供实时数据时，Web 开发人员需要一种可以无缝工作的解决方案。一般情况下，前端应用程序会定期向服务器发送请求以获取更新，但是这会浪费宝贵的带宽资源和服务器资源。在这种情况下，javascript EventSource 就成为了一种更为高效的解决方案。</p>\n<h2> 背景</h2>\n<p>在使用 chatgpt 时。实时的获取到 chatgpt 的回复。但是我发现在输入 prompt 后,只有一个请求。但是他的消息是实时动态显示的，起初以为使用了 WebSocket，但经过查看源码发现并没有使用 WebSocket。而是使用了 EventSource。</p>\n<h2> 什么是 EventSource？</h2>\n<p>javascript EventSource 是一个内置在现代浏览器中的 API，它允许服务器向客户端发送实时事件。该 API 建立一个持久化的连接，通过该连接，服务器可以随时向客户端推送数据。该 API 建立的连接基于 HTTP 协议，而不是 WebSocket，因此不需要使用其他库或框架，即可在应用程序中使用它。</p>\n<h2> EventSource 的工作原理</h2>\n<p>EventSource 基于 HTTP 协议实现，通过与服务器建立一个持续连接，实现了服务器向客户端推送事件数据的功能。在客户端，EventSource 对象通过一个 URL 发起与服务器的连接。连接成功后，服务器可以向客户端发送事件数据。在客户端，通过 EventSource 对象注册事件处理函数，以接收来自服务器的事件数据。</p>\n<p>以下是 EventSource 的工作原理：</p>\n<ol>\n<li>\n<p>客户端向服务器发起 HTTP GET 请求，请求一个特定的 URL。</p>\n</li>\n<li>\n<p>服务器接收请求，并在 HTTP 头中添加 \"Content-Type: text/event-stream\"。</p>\n</li>\n<li>\n<p>服务器建立一个持续的 HTTP 连接，向客户端发送数据，直到连接被关闭。</p>\n</li>\n<li>\n<p>当服务器有新的事件数据要发送时，它将这些数据以特定的格式发送给客户端。事件数据格式如下：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ol>\n<p>其中，event 字段表示事件名，data 字段表示事件数据。</p>\n<ol start=\"5\">\n<li>\n<p>客户端通过 EventSource 对象注册事件处理函数，以接收来自服务器的事件数据。当客户端接收到来自服务器的事件数据时，它将创建一个 Event 对象，并触发相应的事件处理函数，传递 Event 对象作为参数。Event 对象包含以下属性：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>当连接出现错误或被关闭时，客户端将触发 \"error\" 事件或 \"close\" 事件，以便进行错误处理或重新连接。总的来说，EventSource 建立了一种持久化的 HTTP 连接，实现了服务器向客户端实时推送事件数据的功能。它非常适合于需要实时更新的应用程序，例如聊天室、股票市场等等。</p>\n</li>\n</ol>\n<h2> 如何使用 javascript EventSource？</h2>\n<p>使用 EventSource 非常简单。在前端，我们只需要使用它提供的构造函数，指定从服务器接收事件的 URL 即可：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在这个例子中，我们将通过一个名为\"my-endpoint”的 URL 从服务器获取事件。服务器应该根据需要设置此 URL 并在客户端上公开它。</p>\n<p>一旦建立连接，服务器就可以使用以下语法向客户端发送事件：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这将向所有当前连接到 EventSource 实例的客户端发送一个名为\"eventName”的事件，并附带一个包含\"eventData”的数据对象。</p>\n<p>客户端可以使用以下语法来监听事件：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这将为名为\"eventName”的事件注册一个侦听器。每当服务器发送此事件时，客户端都会接收到一个带有事件数据的 Event 对象。在此例中，我们将其打印到控制台中。</p>\n<p>此外，EventSource 还提供了其他一些有用的功能，例如错误处理和自定义事件重试。例如，我们可以使用以下语法来处理与 EventSource 相关的错误：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这将为所有 EventSource 错误注册一个处理程序。每当出现错误时，客户端都会接收到一个带有错误信息的 Event 对象。在这个例子中，我们将其打印到控制台中。</p>\n<h2> 总结</h2>\n<p>总体来说，javascript EventSource 是一种非常有用的技术，可以使前端应用程序获得实时数据而无需频繁地从服务器获取更新。由于其内置于现代浏览器中，因此使用 EventSource 非常容易，而且不需要使用额外的库或框架。</p>\n<h3> EventSource 与 WebSocket Http 的对比</h3>\n<p>EventSource 和 WebSocket 都是用于实现客户端与服务器之间实时双向通信的技术，但它们在很多方面有着不同的特点和适用场景。</p>\n<ol>\n<li>\n<p>协议 EventSource 基于 HTTP 协议，使用的是 HTTP 的长连接机制，而 WebSocket 则是一种独立的协议，与 HTTP 没有关系。</p>\n</li>\n<li>\n<p>双向通信 WebSocket 支持双向通信，客户端和服务器都可以主动发送数据。而 EventSource 只支持服务器向客户端的单向通信，客户端只能接收数据，不能主动发送数据。</p>\n</li>\n<li>\n<p>数据格式 WebSocket 可以发送任意格式的数据，包括文本、二进制等。而 EventSource 仅支持纯文本格式，采用了一种特殊的格式来传输事件数据。</p>\n</li>\n<li>\n<p>浏览器兼容性 WebSocket 是 HTML5 新增的标准，兼容性相对较差，在一些旧版本的浏览器中不支持。而 EventSource 的兼容性相对较好，在大多数现代浏览器中都能够正常工作。</p>\n</li>\n<li>\n<p>实时性 WebSocket 的实时性更高，它的通信速度和性能都比 EventSource 更优秀。因为 WebSocket 是双向通信，数据传输的效率更高，而 EventSource 由于是单向通信，数据传输的速度会稍慢一些。</p>\n</li>\n<li>\n<p>跨域 WebSocket 和 EventSource 都可以跨域使用，但跨域的设置方式有所不同。</p>\n<ul>\n<li>\n<p>WebSocket 需要在服务器端进行配置，允许客户端连接。服务器需要在 HTTP 头中添加 \"Access-Control-Allow-Origin\" 字段，允许来自指定域名的客户端连接。</p>\n</li>\n<li>\n<p>EventSource 跨域时默认使用 CORS 机制。服务器只需在 HTTP 头中添加 \"Access-Control-Allow-Origin\" 字段，允许来自指定域名的客户端连接即可。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>浏览器兼容性</p>\n<p>WebSocket 和 EventSource 在浏览器兼容性方面有所不同。</p>\n<ul>\n<li>\n<p>WebSocket 在一些较老版本的浏览器中不被支持，例如 IE9 及以下版本。但在现代浏览器中，WebSocket 已经得到了广泛的支持。</p>\n</li>\n<li>\n<p>EventSource 则在较早的浏览器版本中也能够正常工作，包括 IE10 及以上版本、Firefox 6.0 及以上版本、Chrome 13.0 及以上版本等等。但在一些较老的浏览器中，如 Safari 5.1.7 及以下版本，EventSource 可能会遇到一些问题。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>总的来说，WebSocket 和 EventSource 在跨域和浏览器兼容性方面都有一些不同。在选择使用哪种技术时，需要根据具体的需求和目标浏览器版本来进行选择</p>\n<p>总的来说，WebSocket 和 EventSource 都有着自己的优点和适用场景。WebSocket 更适合需要双向通信的应用场景，例如实时游戏、在线协作等等。而 EventSource 则更适合需要单向数据推送的应用场景，例如实时监控、股票行情等等。因此，在选择使用哪种技术时，需要根据具体的需求进行选择。</p>\n<h2> 实例</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-03T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript",
        "eventsource"
      ]
    },
    {
      "title": "JavaScript 原型与继承",
      "url": "https://www.h7ml.cn/posts/javascript/inheritance.html",
      "id": "https://www.h7ml.cn/posts/javascript/inheritance.html",
      "summary": "简单讲讲 js 的继承，也是 js 的原型链问题的实际应用。 原型 原型和原型链都是来源于对象而服务于对象的概念： JavaScript 中一切引用类型都是对象，对象就是属性的集合。 Array 类型、Function 类型、Object 类型、Date 类型、RegExp 类型等都是引用类型。 原型与原型链 每一个对象从被创建开始就和另一个对象关联，从另一个对象上继承其属性，这个另一个对象就是原型。 当访问一个对象的属性时，先在对象的本身找，找不到就去对象的原型上找，如果还是找不到，就去对象的原型的原型上找，如此继续，直到找到为止。如果在最顶层的原型对象也没有找到，就返回undefined。这条由对象及其原型组成的链就叫做原型链。",
      "content_html": "<p>简单讲讲 js 的继承，也是 js 的原型链问题的实际应用。</p>\n<h2> 原型</h2>\n<p>原型和原型链都是来源于对象而服务于对象的概念：</p>\n<p>JavaScript 中一切引用类型都是对象，对象就是属性的集合。</p>\n<p>Array 类型、Function 类型、Object 类型、Date 类型、RegExp 类型等都是引用类型。</p>\n<h2> 原型与原型链</h2>\n<p>每一个对象从被创建开始就和另一个对象关联，从另一个对象上继承其属性，这个另一个对象就是原型。</p>\n<p>当访问一个对象的属性时，先在对象的本身找，找不到就去对象的原型上找，如果还是找不到，就去对象的原型的原型上找，如此继续，直到找到为止。如果在最顶层的原型对象也没有找到，就返回<code>undefined</code>。这条由对象及其原型组成的链就叫做原型链。</p>\n<h3> 原型的意义</h3>\n<ul>\n<li>原型链存在的意义就是继承：访问对象属性时，在对象本身找不到，就在原型链上一层一层找。就是一个对象可以访问其他对象的属性。</li>\n<li>继承存在的意义就是属性共享：一是代码重用，字面意思；二是可扩展，不同对象可能继承相同的属性，也可以定义只属于自己的属性。</li>\n</ul>\n<h3> 访问原型链</h3>\n<p><code>__proto__</code>属性虽然在 ECMAScript 6 语言规范中标准化，但是不推荐被使用，现在更推荐使用 <code>Object.getPrototypeOf</code>，</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>模拟原型链的查找</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 原型链示意图</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/GS5mqO.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>从上图我们可以看出</p>\n<ul>\n<li>引用类型都是对象，每个对象都有原型对象。</li>\n<li>对象都是由构造函数创建，对象的<code>__proto__</code>属性指向其原型对象，构造函数的<code>prototype</code>属性指向其创建的对象实例的原型对象，所以对象的<code>__proto__</code>属性等于创建它的构造函数的<code>prototype</code>属性。</li>\n<li>所有通过字面量表示法创建的普通对象的构造函数为 Object</li>\n<li>所有原型对象都是普通对象，构造函数为 Object</li>\n<li>所有函数的构造函数是 Function</li>\n<li>Object.prototype 没有原型对象</li>\n</ul>\n<h3> 简单总结</h3>\n<p>原型链就是多个对象通过 <code>__proto__</code> 的方式连接了起来的一个链表结构。</p>\n<ul>\n<li><code>Object</code> 是所有对象的父节点，所有对象都可以通过 <code>__proto__</code> 找到它</li>\n<li><code>Function</code> 是所有函数的父节点，所有函数都可以通过 <code>__proto__</code> 找到它</li>\n<li>函数的 prototype 是一个对象</li>\n<li>对象的 <code>__proto__</code> 属性指向原型, <code>__proto__</code> 将对象和原型连接起来组成了原型链</li>\n</ul>\n<h2> 创建对象</h2>\n<p>在理解对象继承之前得先弄明白创建对象这回事儿。</p>\n<h3> 工厂模式</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>工厂模式很好理解，实例化一个对象，在把传入的参数放入该对象，再返回。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/BUOPMK.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>缺点：无法进行对象识别。由于返回的对象都是由 Object 对象实例化出来的，但是开发过程中，需要创建很多种对象，肯定会有进行对象识别的需求，工厂模式显然无法完成我们这样的诉求。我们继续探索。</p>\n<h3> 构造函数模式</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/9P66Ik.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>从打印中可以看到 <code>car1</code> 与 <code>car</code> 的区别。</p>\n<p>构造函数模式能够很好的使用 <code>instanceof</code> 进行对象的识别，<code>Object</code> 对象是所有对象的顶层对象类，所有的对象都会继承他。对对象进行操作的各类方法就存放在 Object 对象里面。<code>function</code>实际上也是一个对象，从<code>typeof</code> 方法中可以体现出来</p>\n<p>缺点：但是无法解决引用类型的创建问题，我们每次对 Car 对象进行实例化的时候，都需要对 printBrand 方法进行创建，无法复用，浪费内存。要解决只能把他放到全局作用域。但是在全局作用域中定义的函数一般来说只能被某个对象调用，这会让全局作用域名不副实。并且也会失去封装性，我们来想象一下，如果该对象中有很多方法，那会让全局作用域充满了单独拎出来的方法，让代码可读性变差。</p>\n<h3> instanceof 原理</h3>\n<p>instanceof 主要用来判断对象是否属于某构造函数</p>\n<ul>\n<li>利用原型链，不停向上查找</li>\n<li>利用 <code>__proto__</code> 访问实例原型</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 原型模式</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个模式利用了对象的原型,将基本参数挂载在原型上面。</p>\n<p>缺点：省去了初始化参数，这一点有好有坏。最大的问题是对引用类型值的共享，car1 和 car2 实例在实例化以后还会与 Car 类存在关系。如果对其赋值基本类型值的话，会在实例化的对象当中创建，并且调用时会首先在实例化对象中寻找。而对引用类型值进行操作的时候，会直接在原型对象的引用类型值上进行操作，所以会在所有实例中共享。</p>\n<h3> 组合构造函数</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>利用原型自定义构造函数，每个实例都会存在一份实例的副本，同时利用原型方法共享的特性，最大程度节省了内存，也提供了向构造函数中传递参数的功能。为最佳实践。</p>\n<h3> 创建对象总结</h3>\n<ul>\n<li>我们在使用工厂模式的时候，发现了对象识别的问题，于是使用构造函数模式去解决这个问题。</li>\n<li>在使用构造函数时，发现了引用类型值创建的问题，无法对其复用。于是使用了原型模式。</li>\n<li>在原型模式中，引用类型值共享的问题又出现了。于是组合构造函数模式</li>\n<li>组合构造函数模式中，结合构造函数模式和对引用类型操作的良好处理和原型模式对方法的共享，达到了最佳方案。</li>\n</ul>\n<h2> 继承</h2>\n<h3> 原型链继承</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>原型链继承通俗易懂，利用原型链将两个类串起来。</p>\n<p>缺点</p>\n<ul>\n<li>要新增原型中属性或方法，必须要先 new 一个实例, 函数无法复用，造成内存的浪费。</li>\n<li>无法多继承</li>\n<li>创建子类实例时，无法向父类构造函数传参</li>\n</ul>\n<h3> 借用构造函数</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>基本思路就是在子类的构造函数的内部调用超类的构造函数。因为函数只是在特定的环境中执行代码的对象。借用构造函数的方式可以解决引用类型的问题。使用 call()和 apply()方法，在子类中调用超类。这样每个实例都会有自己的引用类型的副本了。</p>\n<p>缺点：和构造函数创建对象一致的问题，方法都得在构造函数中定义，导致函数无法复用，造成内存的浪费。</p>\n<h3> 组合继承</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>组合继承集借用构造函数方法和原型链继承两者之长，复用了方法，也解决了引用类型的问题。</p>\n<p>缺点：需要调用两次超类的构造函数，第一次是<code>OldCar.call(this,name)</code>,第二次是<code>new OldCar()</code>。下一步我们需要解决的是超类的两次调用问题。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的例子中，上半部分是最基本的对原型的赋值，而下班部分的对原型的赋值 A 的原型的构造函数会变成 Object（先 new Object 然后再赋值参数），所以需要显式的去增强构造函数。</p>\n<h3> 寄生组合继承</h3>\n<p>为了解决组合继承的痛点，出现了寄生组合继承。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>那么，我们来看看继承的过程中发生了什么。先对超类的原型进行一次浅复制。然后将中间对象的构造函数替换为普通类。为什么要进行这一步？因为对超类的原型进行浅复制以后，中间对象的构造函数变成了 Object，需要对该对象进行增强处理。最后将普通类的原型指向中间变量，这样就只需要调用一次超类就可以完成继承。</p>\n<h3> 继承的总结</h3>\n<ul>\n<li>在原型链继承中，我们又遇到了老对手引用类型值的共享问题。</li>\n<li>在借用构造函数进行继承中，方法共享问题，这个老对手又出现了。</li>\n<li>按照创建对象的经验，组合两者优点的组合继承将成为最佳方式，但是我们却发现了超类会被调用两次的问题。</li>\n<li>为了解决超类被调用两次的问题，寄生组合继承成为了最佳方案。</li>\n</ul>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/GS5mqO.png",
      "date_published": "2019-09-16T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "JavaScript 高级程序设计读书笔记",
      "url": "https://www.h7ml.cn/posts/javascript/professional-js.html",
      "id": "https://www.h7ml.cn/posts/javascript/professional-js.html",
      "summary": "2. HTML 中的 JavaScript 2.1 元素 基本参数： async charset crossorigin defer integrity language type &lt;script src=\"example.js\" /&gt;",
      "content_html": "<h2> 2. HTML 中的 JavaScript</h2>\n<h3> 2.1 元素</h3>\n<p>基本参数：</p>\n<ul>\n<li>async</li>\n<li>charset</li>\n<li>crossorigin</li>\n<li>defer</li>\n<li>integrity</li>\n<li>language</li>\n<li>type</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这种方式在 HTML 中不合法，应该采用</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 2.1.1 标签的放置</h4>\n<p>引用 js 时，应该将&lt;script&gt;放置在最后，如下</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 2.1.2 推迟的脚本</h4>\n<p>使用 defer 参数保证脚步在 DOMContentLoaded 事件之后进行加载。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>但是并非所有浏览器支持 defer，所以最好还是将&lt;script&gt;标签放在最后</p>\n<h4> 2.1.3 异步脚本</h4>\n<p>脚本加载顺序改变，但是都是在 DOMContentLoaded 事件之后进行加载。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 2.1.4 动态脚本加载</h4>\n<p>为了统一动态脚本加载行为，需要设置 async 参数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但是这种设置会损害资源获取队列的优先级。解决方法</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 2.1.5XHTML 中的改变</h4>\n<p>在 XHTML 中(&lt;)会被识别为标签的开始</p>\n<ul>\n<li>一种方法是用(&amp;lt;)代替(&lt;)；</li>\n<li>另一种方法是使用 CDATA</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但是并非所有 XHTML 解释器能够支持 CDATA，使用 js 注释解决</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2.2 内联代码与外部文件</h3>\n<p>虽然可以将内联代码嵌入 HTML，但是最好还是使用外部文件的方式。需要注意三点</p>\n<ul>\n<li>可维护性——js 代码与 HTML 分离，更好修理 BUG</li>\n<li>缓存——如果两个页面加载同一个 js，仅需加载一次，意味着更快的页面加载速度</li>\n<li>面向未来——XHTML 和 HTML 都可以使用</li>\n</ul>\n<p>基于 SPDY/HTTP2 使用外部文件时，能够减少相同 js 的下载</p>\n<h3> 2.3 文档模式</h3>\n<p>IE5.5 通过文档类型切换的使用，介绍了文档模式</p>\n<ul>\n<li>quirks mode：IE 变得像 IE5，通过省略文档开头的 doctype（使用所有）</li>\n<li>standard mode：更加标准</li>\n</ul>\n<p>以下几种 doctype 使用时，使用 standard mode</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>almost standard mode：这种模式具有许多标准特性，但不是严格。不同之处在于图片的放置</li>\n</ul>\n<p>以下几种 doctype 使用时，使用 almost standard mode</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2.4THE &lt;NOSCRIPT&gt; ELEMENT</h3>\n<p>&lt;noscript&gt;用于显示两种情况</p>\n<ul>\n<li>浏览区不支持脚本</li>\n<li>浏览器脚本关闭了</li>\n</ul>\n<p>例子如下</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 3.语言基础</h2>\n<h3> 3.1 语法</h3>\n<h4> 3.1.1 大小写敏感(Case-Sensitivity)</h4>\n<h4> 3.1.2 Identifiers</h4>\n<ul>\n<li>第一个字符必须是字母，下划线或者$</li>\n</ul>\n<p><strong>ECMAScript identifiers use camel case</strong>，举例如下</p>\n<p>firstSecond</p>\n<p>myCar</p>\n<p>doSomethingImportant</p>\n<h4> 3.1.3 注释</h4>\n<p>两种注释方式</p>\n<p>// single line comment</p>\n<p>/<em>This is a multi-line comment</em>/</p>\n<h4> 3.1.4 严格模式(Strict Mode)</h4>\n<ul>\n<li>\n<p>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</p>\n</li>\n<li>\n<p>消除代码运行的一些不安全之处，保证代码运行的安全；</p>\n</li>\n<li>\n<p>提高编译器效率，增加运行速度；</p>\n</li>\n<li>\n<p>为未来新版本的 Javascript 做好铺垫。</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 3.1.5 陈述(Statements)</h4>\n<ul>\n<li>\n<p>使用分号</p>\n</li>\n<li>\n<p>使用括号</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3.2 关键字与保留字(Keywords and Reserved Words)</h3>\n<ul>\n<li>Always reserved:\n<ul>\n<li>enum</li>\n</ul>\n</li>\n<li>Reserved in strict mode:\n<ul>\n<li>implements interface let</li>\n<li>package public protected static private</li>\n</ul>\n</li>\n<li>Reserved in module code:\n<ul>\n<li>await</li>\n</ul>\n</li>\n</ul>\n<h3> 3.3 变量</h3>\n<h4> 3.3.1 var 关键词</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 3.3.1.1 var 的声明域(Declaration Scope</h5>\n<h6> )</h6>\n<p>移除 var 后变成全局变量</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>严格模式时无法定义名为<em>evel</em>或<em>arguments</em></p>\n<h5> 3.3.1.2 var 声明提升(Declaration Hoisting)</h5>\n<p>运行以下代码</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实际的运行顺序</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.3.2 let 定义</h4>\n<ul>\n<li>let 与 var 的区别在于，let 是 block scoped，而 var 是 function scoped</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>let 不允许多次定义</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 3.3.2.1 暂时死区（Temporal Dead Zone）</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 3.3.2.2 全局声明</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 3.3.2.3 条件声明</h5>\n<p>对于条件声明不使用 let</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.3.2 const 定义</h4>\n<p>声明后无法重定义</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.3.3 声明风格</h4>\n<ul>\n<li>不使用 var</li>\n</ul>\n<p>使用 let 与 const 能够满足大部分使用场景</p>\n<ul>\n<li>使用 const 胜于 let</li>\n</ul>\n<p>在浏览器运行的过程中，保证某些变量不变</p>\n<h3> 3.4 数据类型</h3>\n<ul>\n<li>\"<strong>undefined</strong>\" if the value is undefined</li>\n<li>\"<strong>boolean</strong>\" if the value is a Boolean</li>\n<li>\"<strong>string</strong>\" if the value is a string</li>\n<li>\"<strong>number</strong>\" if the value is a number</li>\n<li>\"<strong>object</strong>\" if the value is an <strong>object</strong> (other than a function) or <strong>null</strong></li>\n<li>\"<strong>function</strong>\" if the value is a function</li>\n<li>\"<strong>symbol</strong>\" if the value is a Symbol</li>\n</ul>\n<h4> 3.4.1 Undefined 类型</h4>\n<ul>\n<li>声明变量后未初始化</li>\n<li>未声明的变量</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.4.2 Null 类型</h4>\n<p>null 值是一个空对象指针</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>undefined 是 null 的一种派生</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 3.4.3 Boolean 类型</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">DATA TYPE</th>\n<th style=\"text-align:left\">VALUES CONVERTED TO TRUE</th>\n<th style=\"text-align:left\">VALUES CONVERTED TO FALSE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Boolean</td>\n<td style=\"text-align:left\">true</td>\n<td style=\"text-align:left\">false</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:left\">Any nonempty string</td>\n<td style=\"text-align:left\">\"\" (empty string)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Number</td>\n<td style=\"text-align:left\">Any nonzero number (including infinity)</td>\n<td style=\"text-align:left\">0, NaN (See the “NaN” section later in this chapter.)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Object</td>\n<td style=\"text-align:left\">Any object</td>\n<td style=\"text-align:left\">null</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Undefined</td>\n<td style=\"text-align:left\">n/a</td>\n<td style=\"text-align:left\">undefined</td>\n</tr>\n</tbody>\n</table>\n<h4> 3.4.4 Number 类型</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不要测试某个特定的浮点值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 3.4.4.1 值域</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 3.4.4.2 NaN (<em>Not a Number</em>)</h5>\n<ul>\n<li>NaN 与任何值都不相等,因此使用 isNaN()进行判断</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 3.4.4.3 Number 转换</h5>\n<ul>\n<li>Number()——所有数据类型</li>\n<li>parseInt()——string=》number</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>parseFloat()——string=》number</li>\n</ul>\n<h4> 3.4.5 String 类型</h4>\n<p>三种表示方式(\")(')(`)</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 3.4.5.1 字符原意</h5>\n<ul>\n<li>\\xnn——十六进制表示</li>\n<li>\\unnnn——unicode 字符</li>\n</ul>\n<h5> 3.4.5.2 自然字符</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 3.4.5.3 转换为字符串</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 3.4.5.4 字面模版(Template Literals)</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 3.4.5.5 修改(Interpolation)</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 3.4.5.6 Template Literal Tag Functions</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.4.6 Symbol 类型</h4>\n<p>Symbol 类型创建一个独一无二的值。目的是为了保护独特的描述符，防止 propperty 冲突</p>\n<ul>\n<li>无法与 new 联用</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h5> 3.4.6.1 使用全局 Symbol 注册处(Using the Global Symbol Registry)</h5>\n<p>Symbol.for()检查是否存在相同 Symbol</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 3.4.6.2Well-Known Symbols（先跳过）</h5>\n<h4> 3.4.7 Object 类型</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>后续章节细讲</p>\n<h3> 3.5 操作符</h3>\n<h4> 3.5.1 一元操作符（跳过）</h4>\n<h4> 3.5.2 位操作符</h4>\n<ul>\n<li>~ NOT</li>\n<li>&amp; AND</li>\n<li>| OR</li>\n<li>^ XOR</li>\n<li>&lt;&lt; Left Shift</li>\n<li>&gt;&gt; Signed Right Shift</li>\n<li>&gt;&gt;&gt;Unsigned Right Shift</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.5.3 布尔操作符</h4>\n<ul>\n<li>！逻辑非</li>\n<li>&amp;&amp; 逻辑与</li>\n<li>|| 逻辑或</li>\n</ul>\n<h4> 3.5.6 Multiolicative Operators</h4>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.5.7 指数操作符</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.5.8 加法类运算符</h4>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.5.9 关系操作符(Relational Operators)</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.5.10 相等操作符</h4>\n<table>\n<thead>\n<tr>\n<th>EXPRESSION</th>\n<th style=\"text-align:left\">VALUE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>null == undefined</td>\n<td style=\"text-align:left\">true</td>\n</tr>\n<tr>\n<td>\"NaN\" == NaN</td>\n<td style=\"text-align:left\">false</td>\n</tr>\n<tr>\n<td>5 == NaN</td>\n<td style=\"text-align:left\">false</td>\n</tr>\n<tr>\n<td>NaN == NaN</td>\n<td style=\"text-align:left\">false</td>\n</tr>\n<tr>\n<td>NaN != NaN</td>\n<td style=\"text-align:left\">true</td>\n</tr>\n<tr>\n<td>false == 0</td>\n<td style=\"text-align:left\">true</td>\n</tr>\n<tr>\n<td>true == 1</td>\n<td style=\"text-align:left\">true</td>\n</tr>\n<tr>\n<td>true == 2</td>\n<td style=\"text-align:left\">false</td>\n</tr>\n<tr>\n<td>undefined == 0</td>\n<td style=\"text-align:left\">false</td>\n</tr>\n<tr>\n<td>null == 0</td>\n<td style=\"text-align:left\">false</td>\n</tr>\n<tr>\n<td>\"5\" == 5</td>\n<td style=\"text-align:left\">true</td>\n</tr>\n</tbody>\n</table>\n<h4> 3.5.11 条件操作符</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 3.5.12 赋值操作符(Assignment Operators)</h4>\n<ul>\n<li><strong>Multiply/assign</strong> (*=)</li>\n<li><strong>Divide/assign</strong> (/=)</li>\n<li><strong>Modulus/assign</strong> (%=)</li>\n<li><strong>Add/assign</strong> (+=)</li>\n<li><strong>Subtract/assign</strong> (-=)</li>\n<li><strong>Left shift/assign</strong> (&lt;&lt;=)</li>\n<li><strong>Signed right shift/assign</strong> (&gt;&gt;=)</li>\n<li><strong>Unsigned right shift/assign</strong> (&gt;&gt;&gt;=)</li>\n</ul>\n<h4> 3.5.13 注释(Comma Operator)</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 3.6 陈述(Statement)</h3>\n<ul>\n<li>if-else</li>\n<li>do-while</li>\n<li>while</li>\n<li>for</li>\n<li>for-in</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>for-of</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p>Labeled Statements</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>with statement</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n<h3> 3.7 函数</h3>\n<h2> 4. 变量、域与内存</h2>\n<h3> 4.1 原始值与引用值(PRIMITIVE AND REFERENCE VALUES)</h3>\n<ul>\n<li>原始值——simple atomic pieces of data,</li>\n<li>引用值——made up of multiple values.</li>\n</ul>\n<h4> 4.1.1 动态属性(Dynamic Properties)</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 4.1.2 拷贝值(Copying Values)</h4>\n<ul>\n<li>primitive value——深拷贝</li>\n<li>reference value——浅拷贝</li>\n</ul>\n<h4> 4.1.5 参数传递(Argument Passing)</h4>\n<p>参数传递的是拷贝值，基本类型传递拷贝的值，引用类型传递地址值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 4.1.6 确定类型</h4>\n<ul>\n<li>\n<p>typeof——基本类型</p>\n</li>\n<li>\n<p>instanceof——引用类型</p>\n</li>\n</ul>\n<h3> 4.2 执行上下文与值域(跳过)</h3>\n<h3> 4.3 垃圾回收(GARBAGE COLLECTION)</h3>\n<h4> 4.3.1 标记-清除算法 Mark-and-Sweep 机制</h4>\n<p>这个算法把\"对象是否不再需要\"简化定义为\"对象是否可以获得\"。这个算法假定设置一个叫做根 <strong>root</strong> 的对象（在 Javascript 里，根是全局对象）. 定期的, 垃圾回收器将从根开始, 找所有从根开始引用的对象, 然后找这些对象引用的对象, 从根开始,垃圾回收器将找到所有可以获得的对象和所有不能获得的对象.</p>\n<p>从 2012 年起, 所有现代浏览器都使用了标记-清除内存回收算法. 所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进.</p>\n<h4> 4.3.2 引用计数算法 (Reference Counting)</h4>\n<p>此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”. 如果没有引用指向该对象, 对象将被垃圾回收机制回收.</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 5 基本引用类型(Basic Reference Types)(快速过)</h2>\n<blockquote>\n<p>Reference types are also sometimes called <em>object definitions</em> because they describe the properties and methods that objects should have.</p>\n</blockquote>\n<h3> 5.1 Date 类型</h3>\n<p>Date 类型记录的是 1970 年一月一号为分界线的时间</p>\n<ul>\n<li>时间格式的转换 Date.parse()</li>\n<li>协调时间时</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5.1.1 继承工具</h4>\n<ul>\n<li>toLocaleString() 有 AM/PM</li>\n<li>toString() 带有时区，24 小时制</li>\n</ul>\n<h4> 5.1.2 时间格式工具</h4>\n<ul>\n<li>toDateString() 时分秒</li>\n<li>toTimeString() 时期</li>\n<li>toLocaleDateString()</li>\n<li>toLocaleTimeString()</li>\n<li>toUTCString()</li>\n</ul>\n<h3> 5.2 Regexp 类型</h3>\n<ul>\n<li>g: global mode</li>\n<li>i: case-insensitive</li>\n<li>m: multiline mode</li>\n<li>u: Unicode mode</li>\n<li>y: sticky mode</li>\n</ul>\n<h2> 6 引用类型 (Collection Reference Types)</h2>\n<h3> 6.1 Object 类型</h3>\n<ul>\n<li>两种创建方式</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 6.2 Array 类型</h3>\n<h4> 6.2.1 创建 Array</h4>\n<ul>\n<li>两种最基本的方式</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>两种附加形式（Array.from）</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6.2.2 Array Holes</h4>\n<p>逗号省略</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6.2.3 Indexing into Arrays</h4>\n<p>index 从 0 开始</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6.2.4 Detecting Arrays</h4>\n<p>在大多数情况下，instanceof Array 就足够了。然而，由于 instanceof Array 在 iframes 和 window 之间不能正常工作，Array.isArray()将是更为可靠的解决方案。</p>\n<p>不过，一定要检查浏览器的兼容性。如果您需要支持 IE8 或更低版本，Array.isArray()将无法工作(请参阅 Mozilla 的文档)。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6.2.5 迭代工具(Iterator Methods)</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6.2.6 复制与填充(Copy and Fill Method)</h4>\n<ul>\n<li>fill()</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>copyWithin()</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6.2.7 转换工具</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中 toLocaleString()会根据你机器的本地环境来返回字符串，它和 toString()返回的值在不同的本地环境下使用的符号可能变化；</p>\n<h4> 6.2.8 栈工具</h4>\n<ul>\n<li>pop()</li>\n<li>push()</li>\n</ul>\n<h4> 6.2.9 队列工具</h4>\n<ul>\n<li>\n<p>shift()——获取头部</p>\n</li>\n<li>\n<p>unshift()——加入尾部</p>\n</li>\n</ul>\n<h4> 6.2.10 Recordering Methods</h4>\n<ul>\n<li>reverse()</li>\n<li>sort()</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6.2.11 操作工具(Manipulation Methods)</h4>\n<ul>\n<li>concat()</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>slice()</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>splice()</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6.2.12 查找定位工具(Search and Location Methods)</h4>\n<ul>\n<li>严格相等(Strict Equivalence)</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>Predicate Search</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6.2.13 Iterative Methods</h4>\n<ul>\n<li>every()</li>\n<li>filter()</li>\n<li>forEach()</li>\n<li>map()</li>\n<li>some()</li>\n</ul>\n<h3> 6.3 类型化数组(TYPED ARRAYS)</h3>\n<p>JavaScript 类型化数组是一种类似数组的对象，并提供了一种用于访问原始二进制数据的机制。</p>\n<p>Web 应用程序变得越来越强大，尤其一些新增加的功能例如：音频视频编辑，访问 WebSockets 的原始数据等，很明显有些时候如果使用 JavaScript 代码可以快速方便地通过类型化数组来操作原始的二进制数据将会非常有帮助。</p>\n<h4> 6.3.1 使用 ArrayBuffers</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6.3.2 数据视图(DataViews)</h4>\n<ul>\n<li>DataView 是为了文件 IO 与网络 IO 设计</li>\n<li>DataView 必须必须由已经存在的 ArrayBuffer 创建</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 6.3.2.1ElementTyp</h5>\n<table>\n<thead>\n<tr>\n<th>ELEMENTTYPE</th>\n<th>BYTES</th>\n<th>DESCRIPTION</th>\n<th>C EQUIVALENT</th>\n<th>RANGE OF VALUES</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Int8</td>\n<td>1</td>\n<td>8-bit signed integer</td>\n<td>signed char</td>\n<td>–128 to 127</td>\n</tr>\n<tr>\n<td>Uint8</td>\n<td>1</td>\n<td>8-bit unsigned integer</td>\n<td>unsigned char</td>\n<td>0 to 255</td>\n</tr>\n<tr>\n<td>Int16</td>\n<td>2</td>\n<td>16-bit signed integer</td>\n<td>short</td>\n<td>–32768 to 32767</td>\n</tr>\n<tr>\n<td>Uint16</td>\n<td>2</td>\n<td>16-bit unsigned integer</td>\n<td>unsigned short</td>\n<td>0 to 65535</td>\n</tr>\n<tr>\n<td>Int32</td>\n<td>4</td>\n<td>32-bit signed integer</td>\n<td>int</td>\n<td>–2,147,483,648 to 2,147,483,647</td>\n</tr>\n<tr>\n<td>Uint32</td>\n<td>4</td>\n<td>32-bit unsigned integer</td>\n<td>unsigned int</td>\n<td>0 to 4,294,967,295</td>\n</tr>\n<tr>\n<td>Float32</td>\n<td>4</td>\n<td>32-bit IEEE-754 floating point</td>\n<td>float</td>\n<td>–3.4E+38 to +3.4E+38</td>\n</tr>\n<tr>\n<td>Float64</td>\n<td>8</td>\n<td>64-bit IEEE-754 floating point</td>\n<td>double</td>\n<td>–1.7E+308 to +1.7E+308</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>初始化为 0</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 6.3.2.2 大端与小端</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 6.3.2.3 Corner Cases</h5>\n<p>只有在拥有足够缓存空间时，DataView 完成读或写，否则提示 RangeError</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6.3.3 类型化数组(Typed Arrays)</h4>\n<p>Typed array 是另一种<em>ArrayBuffer</em>的形式</p>\n<p>以下函数不再支持</p>\n<ul>\n<li>concat()</li>\n<li>pop()</li>\n<li>push()</li>\n<li>shif()</li>\n<li>unshift()</li>\n<li>splice()</li>\n</ul>\n<p>新添两个函数</p>\n<ul>\n<li>set()</li>\n<li>subarray()</li>\n</ul>\n<h3> 6.4 Map 类型</h3>\n<h4> 6.4.1 基本借口</h4>\n<ul>\n<li>创建 Map</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>删除、添加与查询</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>Map 可是使用 javasctipt 的数据结构作为键值</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6.4.2 顺序与迭代</h4>\n<ul>\n<li>迭代</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6.4.3 Obiects 与 Maps 之间选择</h4>\n<ul>\n<li>\n<p>内存</p>\n<p>Map 大约会比 Object 多占用 50%</p>\n</li>\n<li>\n<p>插入效率</p>\n<p>Map 比 Object 快一些</p>\n</li>\n<li>\n<p>查找效率</p>\n<p>大型项目 Object 快</p>\n</li>\n<li>\n<p>删除效率</p>\n<p>Map 删除相比于 Object 非常快</p>\n</li>\n</ul>\n<h3> 6.5 WeakMap 类型</h3>\n<h4> 6.5.1 基本接口</h4>\n<p>基本和 map 一致</p>\n<h4> 6.5.2 Weak 键值</h4>\n<blockquote>\n<p>The “<strong>weak</strong>” designation stems from the fact that keys in a WeakMap are “weakly held,” meaning they are not counted as formal references that would otherwise prevent garbage collection.</p>\n</blockquote>\n<p>原生的 WeakMap 持有的是每个键对象的“弱引用”，这意味着在没有其他引用存在时垃圾回收能正确进行。原生 WeakMap 的结构是特殊且有效的，其用于映射的 key 只有在其没有被回收时才是有效的。</p>\n<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。</p>\n<h4> 6.5.3 不可迭代键值</h4>\n<p>WeakMap 的 key 是不可枚举的 (没有方法能给出所有的 key)。如果 key 是可枚举的话，其列表将会受垃圾回收机制的影响，从而得到不确定的结果。因此，如果你想要这种类型对象的 key 值的列表，你应该使用 Map</p>\n<h3> 6.6 Set 类型</h3>\n<h4> 6.6.1 基本接口</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>使用 SameValueZero 比较</li>\n</ul>\n<h3> 6.7 WeakSet 类型</h3>\n<h2> 8 Objects, Classes, and Object-Oriented Programming</h2>\n<h3> 8.1 理解 Objects</h3>\n<ul>\n<li>两种创建模式</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8.1.1 属性的类型(Types of Properties)</h4>\n<h5> 8.1.1.1 数据属性(Data Properties)</h5>\n<p>数据属性包含一个单独的数据地址，由这个地址进行读写操作</p>\n<p>数据属性拥有四个特性(attribute)</p>\n<ul>\n<li>[[Configurable]]——描述符是否可以改变</li>\n<li>[[Enumerable]]——是否可以迭代</li>\n<li>[[Writable]]——是否可以修改</li>\n<li>[[Value]]——默认为 undefined</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.1.1.2 访问器属性</h5>\n<ul>\n<li>[[Configurable]]</li>\n<li>[[Enumerable]]</li>\n<li>[[Get]]——属性读取时的返回值</li>\n<li>[[Set]]</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8.1.2 定义多个属性</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8.1.3 阅读属性值(Reading Property Attributes)</h4>\n<ul>\n<li>Object. getOwnPropertyDescriptor()查看属性描述符</li>\n</ul>\n<h4> 8.1.4 合并 Objects</h4>\n<ul>\n<li>Object.assign()</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8.1.5 Object Identity and Equality</h4>\n<ul>\n<li><a href=\"http://Object.is\" target=\"_blank\" rel=\"noopener noreferrer\">Object.is</a>()</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8.1.6 Enhanced Object Syntax</h4>\n<h5> 8.1.6.1 属性值简写(Property Value Shorthand)</h5>\n<p>ES6 中的新特性，键值与属性值相同时，可以简写</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.1.6.2 计算型属性值</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.1.6.3 简洁工具语法</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>与以上两种特性结合</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8.1.7 Object 结构</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.1.7.1 嵌套解构</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>不完全解构</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>参数上下文匹配</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 8.2 Object 创建</h3>\n<h4> 8.2.1 工厂方法(The Factory Pattern)</h4>\n<p>工厂方式以用于软件工程抽象特定 object 的设计模式而闻名</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8.2.2 函数构建模式(The Function Constructor Pattern)</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.2.2.1 构造函数(Constructors as Functions)</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.2.2.2 构造函数的问题</h5>\n<p>构造函数在 ECMASScript 中同样是 Object</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8.2.3 原型模式</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.2.3.1 原型工作原理</h5>\n<p>对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型。不像每个对象都有__proto__属性来标识自己所继承的原型，只有函数才有 prototype 属性。</p>\n<ul>\n<li><code>hasOwnProperty()</code> ignores inherited properties</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 8.3 继承</h3>\n<p>js 中只有 Implementation inheritance ，因为 Interface inheritance is not possible in ECMAScript because functions do not have signatures.</p>\n<h4> 8.3.1 原型链</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.3.1.1 默认原型</h5>\n<p>所有引用类型默认由 Object 继承，因此拥有 Object.prototype 的函数</p>\n<h5> 8.3.1.2 原型与实例的关系</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.3.1.2 Working with Methods</h5>\n<p>函数重载</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8.3.2 借用构造函数(Constructor Stealing)</h4>\n<ul>\n<li>避免了引用类型的属性被所有实例共享</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>可以在 Child 中向 Parent 传参</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>缺点：方法都在构造函数中定义，每次创建实例都会创建一遍方法。</p>\n<h4> 8.3.3 组合继承</h4>\n<p>原型链继承和经典继承双剑合璧。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8.3.4 原型继承</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</p>\n<p>缺点：</p>\n<p>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p>\n<h4> 8.3.5 寄生继承</h4>\n<p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p>\n<h4> 8.3.6 寄生组合继承</h4>\n<p>为了方便大家阅读，在这里重复一下组合继承的代码：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>组合继承最大的缺点是会调用两次父构造函数。</p>\n<p>一次是设置子类型实例的原型的时候：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>一次在创建子类型实例的时候：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>回想下 new 的模拟实现，其实在这句中，我们会执行：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在这里，我们又会调用了一次 Parent 构造函数。</p>\n<p>所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为<code>colors</code>，属性值为<code>['red', 'blue', 'green']</code>。</p>\n<p>那么我们该如何精益求精，避免这一次重复调用呢？</p>\n<p>如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？</p>\n<p>看看如何实现：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最后我们封装一下这个继承方法：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>引用《JavaScript 高级程序设计》中对寄生组合式继承的夸赞就是：</p>\n<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>\n<h3> 8.4 Class</h3>\n<h4> 8.4.1 class 定义基础</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>function 声明挂起，class 声明不会</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.4.1.1 class 构成</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8.4.2 class 构造函数</h4>\n<h5> 8.4.2.1 Instantiation</h5>\n<ol>\n<li>a new object 创建在内存</li>\n<li>[[Prototype]]指针被分配到构造函数原型</li>\n<li>构造函数的 this 被分配到 new object</li>\n<li>构造函数执行</li>\n<li>如果构造函数返回 object，就返回 object；否则被生成的 new object 返回</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.4.2.2 将 class 看作特殊函数</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>class 标识符拥有 prototype 属性，属性拥有 constructor 属性又引用 class 本身</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>构造函数与 class 的关系</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8.4.3 实例，原型与 class 成员</h4>\n<h5> 8.4.3.1 示例成员(Instance Members)</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.4.3.2 原型与访问器</h5>\n<ul>\n<li>primitives and objects 不可以直接加入到 class 内的原型</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>get set</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.4.3.3 静态 class 方法与访问器</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.4.3.4 无函数原型与 class 成员</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.4.3.5 迭代与生成</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8.4.4 继承</h4>\n<h5> 8.4.4.1 继承基础</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.4.4.2 构造函数、Homeobjects 与 super()</h5>\n<ul>\n<li>super()用于子类的构造函数中或者静态方法中</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.4.4.3 抽象基类(Abstract Base Classes)</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.4.4.4 由已经建类型继承(Inheriting from Built-in Types)</h5>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 8.4.4.5 类掺合(Class Mixins)</h5>\n<h2> 10 函数</h2>\n<p>function 是 Object 类型，属于 Function 的实例。因此函数名仅仅是指向 function objects 的指针，对于函数本身不是必要的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 10.1 箭头函数(Arrow Function)</h3>\n<ul>\n<li>当一个参数时箭头函数不需要括号</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>只有一行代码，可省略花括号</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 10.2 函数名</h3>\n<ul>\n<li>函数名只是指向函数的指针，可以有很多指向该函数的指针</li>\n</ul>\n<h3> 10.3 理解 Argument</h3>\n<ul>\n<li>argument 内在表示为 array，因此函数不关心传入参数的数量</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>argument 可与 named argument 结合使用</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 10.3.1 箭头函数中的 arguments</h4>\n<ul>\n<li>arguments 只可通过 name token 使用</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 10.4 不重载(No Overloading)</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 10.5 初始参数值</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>使用初始化参数时，argument 不可以反应初始化参数</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 10.5.1 参数初始化范围与暂时死区(Default Parameter Scope and Temporal Dead Zone)</h4>\n<ul>\n<li>暂时性死区</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 10.6 参数传递与剩余参数(SPREAD ARGUMENTS AND REST PARAMETERS)</h3>\n<h4> 10.6.1 参数传递</h4>\n<ul>\n<li>分离出 array 中的变量</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 10.6.2 剩余参数</h4>\n<ul>\n<li>rest parameter 只能使用在在最后</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 10.7 函数声明与函数表达</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 10.8 函数与值</h3>\n<ul>\n<li>从函数返回函数</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 10.9 函数内部</h3>\n<h4> 10.9.1 this</h4>\n<ul>\n<li>function 的上下文是动态的</li>\n<li>箭头函数的上下文在定义是确定</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 10.9.2 caller</h4>\n<p>该特性是非标准的，请尽量不要在生产环境中使用它！</p>\n<h4> 10.9.3 new.target</h4>\n<p>new.target 属性允许你检测函数或构造方法是否是通过<em>new</em>运算符被调用的。在通过 new 运算符被初始化的函数或构造方法中，new.target 返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是 undefined。</p>\n<h3> 10.10 函数属性与工具(FUNCTION PROPERTIES AND METHODS)</h3>\n<ul>\n<li>apply()</li>\n</ul>\n<p>apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。</p>\n<ul>\n<li>call()</li>\n</ul>\n<p>call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。</p>\n<h3> 10.11 函数表达</h3>\n<ul>\n<li>function 声明</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种方式有一个关键特性 ——<em>function declaration hoisting</em></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>function expression</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对于<em>function declaration hoisting</em>这个特性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 10.12 递归</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 10.13 尾调用优化</h3>\n<p><strong>尾调用</strong>是指一个函数里的最后一个动作是返回一个函数的调用结果的情形，即最后一步新调用的返回值直接被当前函数的返回结果。</p>\n<p>\"<strong>尾调用优化</strong>\"（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。</p>\n<p>举个例子</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>在 ES6 优化之前\n<ol>\n<li>到达 outerFunction 函数主体，第一栈帧压入中</li>\n<li>执行 outerFunction 主体，到达 return</li>\n<li>到达 innerFunction 函数主体，第二栈帧压入中</li>\n<li>执行 innerFunction 主体，返回值被估计</li>\n<li>返回值传递给 outerFunction</li>\n<li>栈压出</li>\n</ol>\n</li>\n<li>在 ES6 优化后\n<ol>\n<li>到达 outerFunction 函数主体，第一栈帧压入中</li>\n<li>执行 outerFunction 主体，到达 return</li>\n<li>由于 innnerFunction 的返回值也是 outerFunction 的返回值，引擎识别出 first stack frame 可以被安全压出</li>\n<li>outerFunction 栈帧压出</li>\n<li>执行到 innerFunction，栈帧压入</li>\n<li>执行 innerFunction 主体，返回值被估计</li>\n<li>innerFunction 栈帧压出</li>\n</ol>\n</li>\n</ul>\n<p>两者明显的差别在于第一个执行会引起一个多余的栈帧</p>\n<p>ES6 尾调用优化的核心在于调用记录只有一项</p>\n<h4> 10.13.1 尾调用优化的条件</h4>\n<ul>\n<li>代码在 strct mode 下执行</li>\n<li>返回值是调用函数</li>\n<li>尾调用之后没有其他执行</li>\n<li>尾函数不是闭包</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 10.13.2 尾调用优化代码</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 10.14 闭包(CLOSURES)</h3>\n<p>匿名函数与闭包两者经常被混淆</p>\n<p>闭包就是能够读取其他函数内部变量的函数。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>\n<p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>\n<h4> 10.14.1 The this object</h4>\n<p>在这个上下文（执行环境）中匿名函数并没有绑定到任何一个对象中，意味着 this 指向 window（除非这个上下文（执行环境）是在严格模式下执行的，而严格模式下该 this 指向 undefined）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 10.14.2 内存泄漏</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>只要匿名函数存在，element 至少为 1</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 10.15 立刻调用函数表达(IMMEDIATELY INVOKED FUNCTION EXPRESSIONS)</h3>\n<h3> 10.16 模块模式</h3>\n<p>模块模式是为单例模式添加私有变量和私有方法，并减少全局变量的使用</p>\n",
      "date_published": "2019-08-16T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "javascript 数据类型",
      "url": "https://www.h7ml.cn/posts/javascript/types.html",
      "id": "https://www.h7ml.cn/posts/javascript/types.html",
      "summary": "javascript 数据类型 温馨提示阅读[《JavaScript 高级程序设计（第 4 版）》](https://www.ituring.com.cn/book/2472)和各个大佬的文章所归纳的总结，**如有异议按你的理解为主** ::: JavaScript 中的数据类型分为基本数据类型和引用数据类型 基本类型 注: 基本数据类型也可以叫原始数据类型 在 ES2020 标准下的 JavaScript 一共有以下 7 种基本类型 undefined 未定义 null 空指针 boolean 布尔值 string 字符串 number 数值 symbol 独一无二的值 (ES6 引入) bigint 大整数 (ES2020 引入) 基本类型总结 基本类型仅保存原始值，不存在属性和方法 基本类型存储在 栈内存 中 保存基本类型的变量是 按值 (by value) 访问 的，操作的就是存储在变量中的实际值 复制基本类型时会创建该值的第二个副本 (独立使用，互不干扰)",
      "content_html": "<h1> javascript 数据类型</h1>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">温馨提示阅读[《JavaScript 高级程序设计（第 4 版）》](https://www.ituring.com.cn/book/2472)和各个大佬的文章所归纳的总结，**如有异议按你的理解为主** :::</p>\n<p><code>JavaScript</code> 中的数据类型分为基本数据类型和引用数据类型</p>\n<h2> 基本类型</h2>\n<blockquote>\n<p>注: 基本数据类型也可以叫原始数据类型</p>\n</blockquote>\n<p>在 <code>ES2020</code> 标准下的 <code>JavaScript</code> 一共有以下 7 种基本类型</p>\n<ul>\n<li><strong><code>undefined</code></strong> 未定义</li>\n<li><strong><code>null</code></strong> 空指针</li>\n<li><strong><code>boolean</code></strong> 布尔值</li>\n<li><strong><code>string</code></strong> 字符串</li>\n<li><strong><code>number</code></strong> 数值</li>\n<li><strong><code>symbol</code></strong> 独一无二的值 (<a href=\"https://es6.ruanyifeng.com/#docs/symbol\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 引入</a>)</li>\n<li><strong><code>bigint</code></strong> 大整数 (<a href=\"https://es6.ruanyifeng.com/#docs/number#BigInt-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\" target=\"_blank\" rel=\"noopener noreferrer\">ES2020 引入</a>)</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">基本类型总结</p>\n<ul>\n<li>基本类型仅保存原始值，不存在属性和方法</li>\n<li>基本类型存储在 <strong>栈内存</strong> 中</li>\n<li>保存基本类型的变量是 <strong>按值 (by value) 访问</strong> 的，操作的就是存储在变量中的实际值</li>\n<li>复制基本类型时会创建该值的第二个副本 (独立使用，互不干扰)</li>\n</ul>\n</div>\n</div>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">为什么原始值不存在属性和方法，但 'hello world'.toString() 可以正确执行为了方便操作原始值 `ECMAScript` 提供了 3 种特殊的引用类型：`Boolean` `Number` `String`，每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，在执行完后再销毁这个包装对象 :::</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 引用类型</h2>\n<p>在 <code>JavaScript</code> 中除了基本类型，其他的都是引用类型，常见的引用类型如下</p>\n<ul>\n<li><strong><code>Object</code></strong> 对象</li>\n<li><strong><code>Array</code></strong> 数组</li>\n<li><strong><code>Function</code></strong> 函数</li>\n<li><strong><code>Date</code></strong> 日期与时间</li>\n<li><strong><code>RegExp</code></strong> 正则表达式</li>\n<li><strong><code>Set</code></strong> 类似于数组但成员的值都是唯一的 (<a href=\"https://es6.ruanyifeng.com/#docs/set-map#Set\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 引入</a>)</li>\n<li><strong><code>WeakSet</code></strong> (<a href=\"https://es6.ruanyifeng.com/#docs/set-map#WeakSet\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 引入</a>)</li>\n<li><strong><code>Map</code></strong> 类似于对象也是键值对的集合 (<a href=\"https://es6.ruanyifeng.com/#docs/set-map#Map\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 引入</a>)</li>\n<li><strong><code>WeakMap</code></strong> (<a href=\"https://es6.ruanyifeng.com/#docs/set-map#WeakMap\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 引入</a>)</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">引用类型总结</p>\n<ul>\n<li>因为 <code>JavaScript</code> 不允许直接访问内存位置(不能直接操作对象所在的内存空间)，所以引用类型在 <strong>栈内存</strong> 中存储的是地址(内存指针)，而引用类型中的数据(方法或属性)是存储在 <strong>堆内存</strong> 中</li>\n<li>保存引用类型的变量是 <strong>按引用 (by reference) 访问</strong> ，实际上操作的是对该对象的引用而非实际的对象本身</li>\n<li>复制引用类型时只会复制内存指针</li>\n</ul>\n</div>\n</div>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">栈内存和堆内存</p>\n<ul>\n<li><strong>栈内存</strong>\n<ul>\n<li>存储基本数据类型和堆内存地址</li>\n<li>是连续的内存空间</li>\n</ul>\n</li>\n<li><strong>堆内存</strong>\n<ul>\n<li>存储引用数据类型和闭包中的变量</li>\n<li>不是连续的内存空间</li>\n</ul>\n</li>\n<li>了解更多请点击 <a href=\"https://github.com/chenqf/frontEndBlog/issues/9\" target=\"_blank\" rel=\"noopener noreferrer\">JS 中的栈内存和堆内存</a></li>\n</ul>\n</div>\n<h2> 类型判断</h2>\n<p>常见的五种判断方式</p>\n<ul>\n<li><strong><code>typeof</code></strong></li>\n<li><strong><code>instanceof</code></strong></li>\n<li><strong><code>constructor</code></strong></li>\n<li><strong><code>Array.isArray()</code></strong></li>\n<li><strong><code>Object.prototype.toString</code></strong></li>\n</ul>\n<h3> typeof</h3>\n<ul>\n<li>除 <strong><code>null</code></strong> 外的基本类型都能准确判断</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">为什么 typeof null === 'object' 在 `JavaScript` 最初的实现中，`JavaScript` 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 `0`。由于 `null` 代表的是空指针（大多数平台下值为 `0x00`），因此`null` 的类型标签是 `0`，`typeof null` 也因此返回 `\"object\"` —— [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#typeof_null) :::</p>\n<ul>\n<li>除 <strong><code>function</code></strong> 外的引用类型均返回 <code>object</code></li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> instanceof</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof\" target=\"_blank\" rel=\"noopener noreferrer\"><code>instanceof</code></a> 用于检测构造函数的 <code>prototype</code> 属性是否存在于实例对象的原型链上</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">instanceof 总结</p>\n<ul>\n<li><code>instanceof</code> 不能判断基本类型，对于引用类型只能判断原型链上的从属关系</li>\n<li><code>instanceof</code> 并不完全可靠，因为构造函数的 <code>prototype</code> 属性可能会被修改\n<ul>\n<li>修改原型的方法\n<ul>\n<li>使用 <code>ES6</code> 提供的 <a href=\"https://es6.ruanyifeng.com/?search=%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B&amp;x=0&amp;y=0#docs/reflect#Reflect-setPrototypeOfobj-newProto\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Reflect.setPrototypeOf()</code></a> 方法</li>\n<li>借助于非标准的 <code>__proto__</code> 伪属性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n</div>\n<h3> constructor</h3>\n<p>实例对象可以通过 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor\" target=\"_blank\" rel=\"noopener noreferrer\"><code>constructor</code></a> 属性去访问它的构造函数</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">constructor 总结</p>\n<ul>\n<li><code>constructor</code> 可以判断除 <code>undefined</code> 和 <code>null</code> 外的所有基本类型和引用类型(<code>undefined</code> 和 <code>null</code> 不存在构造函数)</li>\n<li><code>constructor</code> 并不完全可靠，因为构造函数的 <code>prototype</code> 属性可能会被修改，从而造成 <code>constructor</code> 属性指向不准确</li>\n</ul>\n</div>\n<h3> Array.isArray()</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Array.isArray()</code></a> 用于判断一个值是否是数组 (<code>Array</code>)</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Object.prototype.toString</h3>\n<ul>\n<li>每个对象都有一个 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\" target=\"_blank\" rel=\"noopener noreferrer\"><code>toString()</code></a> 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用，默认情况下 <code>toString()</code> 方法被每个 <code>Object</code> 对象继承。如果此方法在自定义对象中未被覆盖 <code>toString()</code> 返回 <code>\"[object type]\"</code> 其中 <code>type</code> 是对象的类型</li>\n<li>为了每个对象都能通过 <code>Object.prototype.toString()</code> 来检测，需要以 <code>Function.prototype.call()</code> 或者 <code>Function.prototype.apply()</code> 的形式来调用</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>toString</code> 方法的在 <a href=\"https://es5.github.io/#x15.2.4.2\" target=\"_blank\" rel=\"noopener noreferrer\"><code>ECMAScript 5</code></a> 下的大致执行过程</p>\n<ol>\n<li>如果 <code>this</code> 是 <code>undefined</code> 返回 <code>[object Undefined]</code></li>\n<li>如果 <code>this</code> 是 <code>null</code> 返回 <code>[object Null]</code></li>\n<li>让 <code>O</code> 成为 <code>ToObject(this)</code> 的结果</li>\n<li>让 <code>class</code> 成为 <code>O</code> 的内部属性 <code>[[Class]]</code> 的值</li>\n<li>返回由 <strong><code>\"[object \"</code></strong> <strong><code>class</code></strong> <strong><code>\"]\"</code></strong> 三个部分组成的字符串</li>\n</ol>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意点</p>\n<p>不同 <code>ECMAScript</code> 版本对 <code>toString</code> 方法的规范都有所不同</p>\n<p><a href=\"https://juejin.cn/post/6972878737582850062#heading-27\" target=\"_blank\" rel=\"noopener noreferrer\">Object.prototype.toString 方法的原理</a></p>\n</div>\n",
      "date_published": "2019-08-16T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript 数据类型"
      ]
    },
    {
      "title": "深度解析 URL Scheme",
      "url": "https://www.h7ml.cn/posts/javascript/urlScheme.html",
      "id": "https://www.h7ml.cn/posts/javascript/urlScheme.html",
      "summary": "深入介绍了 URL Scheme 在前端开发中的作用及实际应用，包括使用场景、实现原理、开发注意事项等，帮助读者更好地理解和使用 URL Scheme。",
      "content_html": "<h1> 深度解析 URL Scheme</h1>\n<p>当我们使用移动应用时，我们通常会通过点击链接或按钮来跳转到其他页面或应用。在 <code>iOS</code> 和 <code>Android</code> 系统中，这些链接或按钮是通过 <code>URL Scheme</code> 实现的。</p>\n<p><code>URL Scheme</code> 是一种在移动设备上通过链接或按钮调用应用程序的机制。它允许开发者在应用程序内部注册特殊的 <code>URL</code>，当用户点击带有该 <code>URL</code> 的链接或按钮时，系统会自动打开相应的应用程序，并执行相应的操作。</p>\n<p>从前端角度来看，当我们在网页中包含了带有 URL Scheme 的链接或按钮时，我们可以使用以下代码来触发它们：</p>\n<blockquote>\n<p>URL Scheme（Uniform Resource Locator Scheme）是一种标准化的协议，可以用于在应用程序之间传递数据和命令。它在移动应用程序中得到广泛应用，可以让不同应用程序之间实现无缝集成。本文将深入探讨 URL Scheme 在前端开发中的应用及其实现方式。</p>\n</blockquote>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>其中，<code>urlscheme</code> 是应用程序的<code> URL Scheme</code>，<code>action</code> 是应用程序内部的操作。</p>\n<p>除此之外，我们还可以通过 <code>JavaScript</code> 来触发 <code>URL Scheme</code>。例如，以下代码将通过 <code>JavaScript</code> 调用 <code>URL Scheme</code> 打开邮件应用程序：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>从应用角度来看，<code>URL Scheme</code> 可以实现很多有趣的功能。以下是一些常见的应用场景：</p>\n<ol>\n<li>打开特定的页面</li>\n</ol>\n<p>应用程序可以注册一个特定的 <code>URL Scheme</code>，以便在应用程序内部打开特定的页面。例如，<code>Facebook</code> 应用程序可以注册 <code>fb://scheme</code>，以便在应用程序内部打开用户的个人资料页面：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol start=\"2\">\n<li>向应用程序传递参数</li>\n</ol>\n<p>应用程序可以通过 <code>URL Scheme</code> 接收参数，以便在打开应用程序时执行特定的操作。例如，支付宝可以接收一个参数来打开特定的收款页面：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"3\">\n<li>调用其他应用程序</li>\n</ol>\n<p>应用程序可以通过 <code>URL Scheme</code> 调用其他应用程序。例如，一个应用程序可以调用地图应用程序来显示某个地点的位置：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol start=\"4\">\n<li>打开系统设置页面</li>\n</ol>\n<p>应用程序可以通过 <code>URL Scheme</code> 打开系统设置页面，以便让用户修改应用程序的设置。例如，以下代码将打开 <code>Wi-Fi</code> 设置页面：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>总的来说，<code>URL Scheme</code> 是移动应用程序中非常有用的机制。它可以使应用程序更加智能化和高效化，同时也为开发者提供了更多的灵活性和创造力。</p>\n<h2> URL Scheme 的基本原理</h2>\n<p><code>URL Scheme</code> 是一种特殊的 <code>URL</code>，它不是用于访问 <code>Web</code> 页面的，而是用于唤起移动应用程序并传递参数。一个 <code>URL Scheme</code> 包含两个主要部分：<code>Scheme</code> 和 <code>Host</code>。例如，<code>myapp://action?param1=value1&amp;param2=value2</code> 就是一个 <code>URL Scheme</code>，其中 <code>Scheme</code> 是 <code>myapp</code>，<code>Host</code> 是 <code>action</code>。</p>\n<p>当用户点击一个 <code>URL Scheme</code> 链接时，操作系统会检查是否有已经安装了该应用程序。如果已经安装，则会打开该应用程序，并将链接中的参数传递给应用程序。如果应用程序没有安装，则无法执行该操作。</p>\n<h2> URL Scheme 的用途</h2>\n<p><code>URL Scheme</code> 可以用于实现许多有用的功能。以下是一些常见的应用：</p>\n<h3> 打开应用程序</h3>\n<p><code>URL Scheme</code> 可以用于打开应用程序，这通常用于应用程序之间的集成。例如，如果您的应用程序需要与另一个应用程序共享数据，您可以使用 <code>URL Scheme</code> 打开该应用程序并将数据传递给它。</p>\n<h3> 执行操作</h3>\n<p><code>URL Scheme</code> 还可以用于执行应用程序中的操作。例如，您可以使用 <code>URL Scheme</code> 执行搜索操作、分享操作、支付操作等等。</p>\n<h3> 激活特定页面</h3>\n<p><code>URL Scheme</code> 还可以用于激活应用程序中的特定页面。例如，您可以使用 <code>URL Scheme</code> 打开应用程序并转到用户的购物车页面。</p>\n<h2> URL Scheme 的实现方式</h2>\n<p><code>URL Scheme</code> 的实现方式取决于您正在开发的平台和编程语言。以下是一些常见的实现方式：</p>\n<h3> HTML 中使用</h3>\n<p>在 <code>HTML</code> 中，您可以使用 <code>&lt;a&gt;</code> 标签来创建一个 <code>URL Scheme</code> 链接。例如：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> JavaScript 中使用</h3>\n<p>在 <code>JavaScript</code> 中，您可以使用 <code>window.location.href</code> 属性来打开一个 <code>URL Scheme</code> 链接。例如：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> iOS 中使用</h3>\n<p>在 <code>iOS</code> 中，您可以使用 <code>UIApplication</code> 类的 <code>openURL:</code> 方法来打开一个 <code>URL Scheme</code> 链接。例如：</p>\n<div class=\"language-swift line-numbers-mode\" data-ext=\"swift\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> Android 中使用</h3>\n<p>在 <code>Android</code> 中，您可以使用 <code>Intent</code> 类来打开一个 <code>URL Scheme</code> 链接。例如：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> URL Scheme 的注冊</h2>\n<p>在 <code>iOS</code> 中，要注册自定义的 <code>URL Scheme</code>，需要在 <code>Xcode</code> 中进行以下配置：</p>\n<ol>\n<li>\n<p>在项目的 <code>Info.plist</code> 文件中，添加一个新的 <code>key</code>，<code>CFBundleURLTypes</code>。</p>\n</li>\n<li>\n<p>在 <code>CFBundleURLTypes</code> 中添加一个新的 <code>CFBundleURLName key</code>，用于指定 <code>URL Scheme</code> 的名称。</p>\n</li>\n<li>\n<p>在 <code>CFBundleURLTypes</code> 中添加一个新的 <code>CFBundleURLSchemes key</code>，用于指定 <code>URL Scheme</code> 的字符串，例如 <code>myapp</code>。</p>\n</li>\n<li>\n<p>在 <code>CFBundleURLTypes</code> 中添加一个新的 <code>CFBundleURLTypes key</code>，用于指定 <code>URL Scheme</code> 支持的 <code>URL</code> 类型，例如 <code>public.url</code>。</p>\n</li>\n</ol>\n<p>完成以上配置后，就可以在应用程序中使用自定义的 <code>URL Scheme</code> 来进行跳转了。</p>\n<p>在 Android 中，要注册自定义的 <code>URL Scheme</code>，需要在 <code>AndroidManifest.xml</code> 文件中进行以下配置：</p>\n<p>在 <code>AndroidManifest.xml</code> 文件中添加一个新的 <code>&lt;intent-filter&gt;</code> 元素，用于指定<code> URL Scheme</code> 支持的协议。</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中，<code>&lt;data&gt;</code> 元素用于指定 <code>URL Scheme</code> 的名称，<code>&lt;action&gt;</code> 元素用于指定动作为 <code>VIEW</code>，表示浏览操作，<code>&lt;category&gt;</code> 元素用于指定类别为 <code>DEFAULT</code> 和 <code>BROWSABLE</code>，表示该 <code>URL Scheme</code> 可以被浏览器调用。</p>\n<p>完成以上配置后，就可以在应用程序中使用自定义的 <code>URL Scheme</code> 来进行跳转了。</p>\n<p>需要注意的是，自定义的 <code>URL Scheme </code>可能存在安全隐患，因此建议在使用时进行相应的安全措施，例如限制特定来源的 <code>URL Scheme</code> 调用，对 <code>URL</code> 参数进行验证等。</p>\n<p>除了在应用程序中注册 <code>URL Scheme</code> 以外，还可以通过以下方式进行拓展：</p>\n<ol>\n<li>\n<p>深度链接深度链接是指将应用程序内的特定内容与 <code>URL Scheme</code> 关联起来，以便用户在从其他应用程序或网站中点击链接时，可以直接跳转到对应的内容。深度链接需要在应用程序中进行特定的处理，例如解析 <code>URL</code> 参数、显示对应的页面等。</p>\n</li>\n<li>\n<p>Universal Links <code>Universal Links</code> 是一种新的跳转方式，它能够在应用程序内通过 <code>HTTP/HTTPS</code> 协议直接访问应用程序内的特定内容，无需通过 <code>URL Scheme</code> 进行跳转。<code>Universal Links</code> 需要在应用程序中进行特定的配置，并在对应的域名中添加特定的配置文件，以便系统能够识别并跳转到应用程序内的内容。</p>\n</li>\n<li>\n<p>应用内搜索应用内搜索是指在应用程序内搜索特定的内容，例如商品、文章等，而不需要从其他应用程序或网站中跳转过来。应用内搜索需要在应用程序中进行特定的处理，例如实现搜索逻辑、显示搜索结果等。</p>\n</li>\n</ol>\n<p>总的来说，通过拓展 <code>URL Scheme</code> 的应用，可以实现更加丰富的应用间跳转和内容分享，提高应用程序的使用体验和用户粘性。但同时需要注意安全性和隐私保护，避免 <code>URL Scheme</code> 被恶意利用。</p>\n<h2> URL Scheme 的使用</h2>\n<p><code>URL Scheme</code> 可以用于在应用程序之间进行跳转和传递数据。下面是 <code>URL Scheme</code> 的一些常见使用场景：</p>\n<ol>\n<li>\n<p>打开应用程序内特定页面：通过指定 <code>URL Scheme</code> 和相应参数，可以直接打开应用程序内的特定页面，例如打开某个商品的详情页面、用户个人信息页面等。</p>\n</li>\n<li>\n<p>启动应用程序并执行特定操作：通过指定 <code>URL Scheme</code> 和相应参数，可以启动应用程序并执行特定操作，例如启动应用程序并执行搜索操作、购买操作等。</p>\n</li>\n<li>\n<p>与第三方应用程序进行交互：通过指定 <code>URL Scheme</code> 和相应参数，可以与第三方应用程序进行交互，例如打开某个网页、分享内容等。</p>\n</li>\n</ol>\n<p>需要注意的是，<code>URL Scheme</code> 的使用需要进行相应的安全措施，避免因 <code>URL</code> 参数被恶意篡改而导致安全问题。在应用程序中使用 <code>URL Scheme</code> 时，需要对 <code>URL</code> 参数进行验证，避免恶意输入或者篡改 <code>URL</code> 参数。例如，可以使用加密算法对 <code>URL</code> 参数进行加密，确保数据安全性。同时，也需要限制特定来源的 <code>URL Scheme</code> 调用，避免恶意应用程序利用 <code>URL Scheme</code> 进行攻击。</p>\n<h2> URL Scheme 的安全性</h2>\n<p><code>URL Scheme</code> 是一种用于应用程序之间通信的协议，其中包含了用于打开和调用其他应用程序的特定链接。但是，由于 <code>URL Scheme</code> 是公开的，它们可能会面临一些安全风险。</p>\n<p>其中一种常见的安全风险是恶意应用程序可以利用 <code>URL Scheme</code> 打开其他应用程序并进行恶意操作，比如在用户不知情的情况下访问他们的个人信息或执行一些恶意代码。例如，一个恶意应用程序可能会在用户点击某个看似无害的链接时，利用该链接打开其他应用程序，并执行一些危险的操作。</p>\n<p>另外，<code>URL Scheme</code> 本身也可能存在一些漏洞和安全问题。例如:</p>\n<ol>\n<li>\n<p>隐私泄露：通过 <code>URL Scheme</code> 打开应用程序可以直接传递参数给应用程序，这些参数可以包含敏感信息。如果不加以限制，这些参数可以被其他应用程序恶意利用，导致隐私泄露问题。</p>\n</li>\n<li>\n<p>恶意攻击：由于 <code>URL Scheme</code> 是开放的，任何应用程序都可以使用它来与其他应用程序交互。如果开发人员不加以限制，恶意应用程序可能利用 <code>URL Scheme</code> 对用户进行攻击，例如伪装成其他应用程序来获取用户的敏感信息。</p>\n</li>\n<li>\n<p>越权操作：<code>URL Scheme</code> 可以用于直接启动应用程序的某些特定操作，例如发送短信、打电话、发邮件等。如果不加以限制，这些操作可能会被滥用，例如利用 <code>URL Scheme</code> 来发送垃圾短信、拨打骚扰电话等。</p>\n</li>\n<li>\n<p>为了解决这些安全问题，开发人员需要在实现 <code>URL Scheme</code> 时注意以下几点：</p>\n</li>\n<li>\n<p>参数校验：应用程序应该对传入的参数进行有效性校验，避免非法参数的传递。</p>\n</li>\n<li>\n<p>权限控制：应用程序应该限制哪些应用程序可以使用自己的 <code>URL Scheme</code>，并且在实现操作时考虑到用户权限的问题，例如发送短信、打电话等操作需要得到用户的明确授权。</p>\n</li>\n<li>\n<p>安全认证：在一些敏感操作中，如支付、修改用户信息等操作，应用程序应该对用户进行身份认证，避免恶意攻击。</p>\n</li>\n</ol>\n<p>总之，开发人员需要认真考虑应用程序与其他应用程序的交互方式，避免因 <code>URL Scheme</code> 实现不当导致的安全问题。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2024-04-08T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript",
        "URL Scheme"
      ]
    },
    {
      "title": "JavaScript WebkitSpeechRecognition：使用语音识别技术增强 Web 应用程序",
      "url": "https://www.h7ml.cn/posts/javascript/webkitSpeechRecognition.html",
      "id": "https://www.h7ml.cn/posts/javascript/webkitSpeechRecognition.html",
      "summary": "JavaScript WebkitSpeechRecognition：使用语音识别技术增强Web应用程序",
      "content_html": "<h1> JavaScript WebkitSpeechRecognition：使用语音识别技术增强 Web 应用程序</h1>\n<p>WebkitSpeechRecognition 是一种 JavaScript API，它可以让您的 Web 应用程序使用语音识别技术。使用 WebkitSpeechRecognition，您可以让用户通过说话来与您的 Web 应用程序进行交互，这可以使您的应用程序更加易于使用，也可以为用户提供更加人性化的体验。</p>\n<h2> WebkitSpeechRecognition 的基本概念</h2>\n<p>WebkitSpeechRecognition 是 Webkit 浏览器中的一个 API，它提供了一种将用户的语音转换为文本的方法。该 API 允许您使用 JavaScript 控制语音识别过程，并获取识别结果。</p>\n<h3> WebkitSpeechRecognition API 的基本概念如下</h3>\n<h4> SpeechRecognition 对象：SpeechRecognition 对象是 WebkitSpeechRecognition API 的核心对象，它表示语音识别过程。您可以使用 SpeechRecognition 对象来控制语音识别过程，例如开始识别、停止识别等</h4>\n<h4> 语音识别事件：SpeechRecognition 对象会触发多个事件，以便您在语音识别过程中获取信息。例如，onresult 事件会在识别成功后触发，onerror 事件会在识别失败时触发</h4>\n<h4> 识别结果：语音识别过程的主要输出是识别结果。识别结果是一个包含一个或多个识别的文本字符串的数组。您可以使用识别结果来理解用户说了什么，并相应地更新您的应用程序</h4>\n<h2> 如何使用 WebkitSpeechRecognition</h2>\n<p>要使用 WebkitSpeechRecognition API，您需要遵循以下步骤：</p>\n<ol>\n<li>创建 SpeechRecognition 对象：使用以下代码创建 SpeechRecognition 对象：</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol start=\"2\">\n<li>设置语言：使用以下代码设置语音识别的语言：</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果未指定语言，则 WebkitSpeechRecognition 默认使用浏览器的语言。</p>\n<ol start=\"3\">\n<li>监听事件：使用以下代码监听语音识别事件：</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在上面的代码中，我们使用 onresult 事件来监听语音识别结果。当识别成功时，该事件会触发，并将识别结果作为参数传递给事件处理程序。</p>\n<ol start=\"4\">\n<li>开始和停止识别：使用以下代码开始和停止语音识别：</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在上面的代码中，我们使用 start 方法开始语音识别，使用 stop 方法停止语音识别。</p>\n<h2> 使用 WebkitSpeechRecognition 的示例</h2>\n<h3> 使用语音输入来搜索 Baidu</h3>\n\n<h3> Vue 3 代码实现</h3>\n\n<h3> React 代码实现</h3>\n\n<p>在上面的示例中，我们创建了一个 SpeechRecognition 对象，并将其设置为英语语言。我们还创建了一个搜索框和一个搜索按钮，用户可以在搜索框中输入搜索词并点击搜索按钮来进行搜索。</p>\n<p>我们使用 onresult 事件来监听语音识别结果，并将其设置为搜索框的值。我们还使用 addEventListener 方法来监听搜索按钮的点击事件和键盘事件，以便在用户按下回车键或空格键时触发搜索。</p>\n<p>最后，我们在按下空格键时使用 start 方法开始语音识别，在松开空格键时使用 stop 方法停止语音识别。</p>\n<h2> WebkitSpeechRecognition 的局限性</h2>\n<p>尽管 WebkitSpeechRecognition 可以让 Web 应用程序使用语音识别技术，但它仍然存在一些局限性。以下是一些常见的局限性：</p>\n<ol>\n<li>浏览器支持：WebkitSpeechRecognition API 只能在 Webkit 浏览器中使用，因此无法在其他浏览器中使用。</li>\n<li>语音识别质量：语音识别技术的质量取决于多个因素，例如用户的发音、语音识别引擎的质量等。因此，WebkitSpeechRecognition 可能无法准确地识别所有用户的语音。</li>\n<li>隐私问题：由于 WebkitSpeechRecognition 需要访问用户的麦克风，因此可能会引起隐私问题。如果您的应用程序需要使用 WebkitSpeechRecognition，请确保遵循适当的隐私保护措施。</li>\n</ol>\n<h2> WebkitSpeechRecognition 兼容性</h2>\n<ul>\n<li>Chrome 25+</li>\n<li>Edge 79+</li>\n<li>Firefox 44+</li>\n<li>Opera 27+</li>\n<li>Safari 6+ 需要注意的是，不同浏览器可能有不同的语音识别引擎，因此识别结果可能会有所不同。此外，由于 WebkitSpeechRecognition API 是实验性的，因此其行为和特性可能会在未来版本中发生变化。</li>\n</ul>\n<p>如果你要使用 WebkitSpeechRecognition API，请务必进行充分的测试和容错处理，以确保你的应用在不同浏览器和设备上都能正常运行。</p>\n<h2> 结论</h2>\n<p>WebkitSpeechRecognition 是一种有用的 JavaScript API，它可以使您的 Web 应用程序更加易于使用，并为用户提供更加人性化的体验。虽然 WebkitSpeechRecognition 有一些局限性，但它仍然是一种有用的技术，可以让您的应用程序更加智能化。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-04T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript",
        "webkitSpeechRecognition"
      ]
    },
    {
      "title": "Linux 基础操作",
      "url": "https://www.h7ml.cn/posts/linux/",
      "id": "https://www.h7ml.cn/posts/linux/",
      "summary": "无界面安装 WARNING 这里不展示虚拟机安装镜像的过程 B 站视频 open in new window installation界面",
      "content_html": "<h3> 无界面安装</h3>\n<p>WARNING</p>\n<p>这里不展示虚拟机安装镜像的过程</p>\n<p><a href=\"https://www.bilibili.com/video/BV1pT4y1U77E?spm_id_from=333.337.search-card.all.click&amp;vd_source=335bcf5c499188a85a8e39829a56fcae\" target=\"_blank\" rel=\"noopener noreferrer\">B 站视频 open in new window</a></p>\n<h3> <code>installation</code>界面</h3>\n<p>镜像安装完成后会出现这个界面</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209022246046.png\" alt=\"image-20220902224634255\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220902224634255</figcaption></figure>\n<p>按 r 刷新之后会有三个感叹号</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209022248613.png\" alt=\"image-20220902224805585\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220902224805585</figcaption></figure>\n<p>分别是：5 磁盘设置、8 密码设置、9 创建用户</p>\n<h3> 按 5 进行磁盘设置</h3>\n<p>之后依次按 c、c、c，之后的界面是这样</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209022250019.png\" alt=\"image-20220902225026986\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220902225026986</figcaption></figure>\n<h3> 按 8 进行秘密设置</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209022252951.png\" alt=\"image-20220902225233917\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220902225233917</figcaption></figure>\n<p>这里会进行两次密码输入，</p>\n<ol>\n<li>第一次设置</li>\n<li>第二次确认输入</li>\n<li>最后输入 yes</li>\n<li>回到<code>installation</code>界面按 b 保存</li>\n</ol>\n<h3> 安装完成</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209022257616.png\" alt=\"image-20220902225745585\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220902225745585</figcaption></figure>\n<p>在此界面按回车键（Enter）完成安装</p>\n<h3> 登录</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209022258237.png\" alt=\"image-20220902225857209\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220902225857209</figcaption></figure>\n<p>输入用户名：root</p>\n<p>输入密码：xxxxx</p>\n<h2> 目录结构</h2>\n<h3> /bin</h3>\n<p>是<code>Binary</code>的缩写，这个目录存放着最经常常用的命令</p>\n<h3> /sbin</h3>\n<p>s 就是<code>Super User</code>的意思，这里存放的是系统管理员使用的系统管理程序</p>\n<h3> /home</h3>\n<p>存放普通用户的主目录，在<code>Linux</code>中每个用户都有一个自己的目录，一般该目录是以用户买的账号命名的</p>\n<h3> /root</h3>\n<p>该目录系统管理员，也城作为超级权限者的用户主目录</p>\n<h3> /lib</h3>\n<p>系统开机所需要最基本的动态连接共享库，其作用类似于<code>Windows</code>里的 DLL 文件。几乎所有的应用程序都需要用这些共享库</p>\n<h3> /lost+found</h3>\n<p>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件</p>\n<h3> /etc</h3>\n<p>所有的系统管理所需要的配置文件和子目录。</p>\n<h3> /usr</h3>\n<p>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于<code>windows</code>下的<code>program files</code>目录。</p>\n<h3> /boot</h3>\n<p>这里存放的是启动<code>Liux</code>时使用的一些核心文件，包括一些连接文件以及镜像文件，自己的安装别放这里。</p>\n<h3> /proc</h3>\n<p>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</p>\n<h3> /srv</h3>\n<p><code>service</code>缩写，该目录存放一些服务启动之后需要提取的数据。</p>\n<h3> /sys</h3>\n<p>这是<code>iux2.6</code>内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统<code>sysfs</code></p>\n<h3> /tmp</h3>\n<p>这个目录是用来存放一些临时文件的</p>\n<h3> /dev</h3>\n<p>类似于<code>windows</code>的设备管理器，把所有的硬件用文件的形式存储。</p>\n<h3> /media(CentOS6)</h3>\n<p><code>linux</code>系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，<code>linux</code>会把识别的设备挂载到这个目录下。</p>\n<p><code>CentOS7</code>迁移到<code>/run/media</code></p>\n<h3> /mnt</h3>\n<p>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在<code>/mnt</code>/上，然后进入该目录就可以查看里的内容了</p>\n<h3> /opt</h3>\n<p>这是给主机额外安装软件所摆放的目录。比如你安装一个<code>ysq</code>数据库则就可以放到这个目录下。默认是空的。</p>\n<h3> /var</h3>\n<p>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>\n<h2> vim 软键盘</h2>\n<p><strong>vim 用过一些插件可以实现和 IDE 一样的功能</strong></p>\n<p>Vim 是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>\n<p><strong>Linux 中，必须会使用 Vim（查看内容，编辑内容，保存内容）</strong></p>\n<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。</p>\n<p>vim 则可以说是程序开发者的一项很好用的工具。</p>\n<p>可以理解 vim 是 vi 的升级版</p>\n<p>连 vim 的官方网站 (<a href=\"http://www.vim.org\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/R-C.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三种使用模式</h2>\n<p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）</strong>。这三种模式的作用分别是：</p>\n<h3> <strong>命令模式：</strong></h3>\n<p>用户刚刚启动 vi/vim，便进入了命令模式。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/4fd4be4bb88845e0b7f41e867617d7ac.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/d5a40e5a140a4cedb7295c6c9c1d711d.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。比如我们此时按下 i，并不会输入一个字符，i 被当作了一个命令。</p>\n<p>以下是常用的几个命令：</p>\n<ul>\n<li><code>i</code> 切换到输入模式，以输入字符。</li>\n<li><code>x</code> 删除当前光标所在处的字符。</li>\n<li><code>:</code> 切换到底线命令模式，以在最底一行输入命令。如果是便捷模式，需要退出便捷模式<code>ESC</code></li>\n</ul>\n<p><strong>若想要编辑文本：</strong> 启动<code>Vim</code>，进入了命令模式，按下 i，切换到输入模式。</p>\n<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>\n<h3> 输入模式</h3>\n<p>在命令模式下按下 i 就进入了输入模式。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/8d56ceca1d32437f993a9b034492d8d3.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>在输入模式中，可以使用以下按键：</p>\n<ul>\n<li>字符按键以及 Shift 组合，输入字符</li>\n<li><code>ENTER</code>，回车键，换行</li>\n<li><code>BACK SPACE</code>，退格键，删除光标前一个字符</li>\n<li><code>DEL</code>，删除键，删除光标后一个字符</li>\n<li>方向键，在文本中移动光标</li>\n<li><code>HOME/END</code>，移动光标到行首/行尾</li>\n<li><code>Page Up/Page Down</code>，上/下翻页</li>\n<li><code>Insert</code>，切换光标为输入/替换模式，光标将变成竖线/下划线</li>\n<li><code>ESC</code>，退出输入模式，切换到命令模式</li>\n</ul>\n<h3> 底线命令模式</h3>\n<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/1eb4505e2ce94a289a15ecdd9c564491.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>\n<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>\n<p><strong>q 退出程序</strong></p>\n<p><strong>w 保存文件</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/c18ef81b791946f095584f4d520e0667.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>按 ESC 键可随时退出底线命令模式。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/25286118bf024e4ebcf26cbae5e6d5d5.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/a4fb10889a3b4c3abf9470addc3606aa.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<h3> 完整的演示</h3>\n<blockquote>\n<p><strong>说明新建或者编辑文件，按 i 进入编辑模式，编写内容，编写完成后退出编辑模式，esc，退出之后进入底线命令模式：wq 保存退出！</strong></p>\n</blockquote>\n<h2> <strong>Vim 按键说明</strong></h2>\n<h3> <strong>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</strong></h3>\n<table>\n<thead>\n<tr>\n<th>移动光标的方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>h 或 向左箭头键(←)</strong></td>\n<td><strong>光标向左移动一个字符</strong></td>\n</tr>\n<tr>\n<td><strong>j 或 向下箭头键(↓)</strong></td>\n<td><strong>光标向下移动一个字符</strong></td>\n</tr>\n<tr>\n<td><strong>k 或 向上箭头键(↑)</strong></td>\n<td><strong>光标向上移动一个字符</strong></td>\n</tr>\n<tr>\n<td><strong>l 或 向右箭头键(→)</strong></td>\n<td><strong>光标向右移动一个字符</strong></td>\n</tr>\n<tr>\n<td><code>[Ctrl] + [f]</code></td>\n<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>\n</tr>\n<tr>\n<td><code>[Ctrl] + [b]</code></td>\n<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>\n</tr>\n<tr>\n<td><code>[Ctrl] + [d]</code></td>\n<td>屏幕『向下』移动半页</td>\n</tr>\n<tr>\n<td><code>[Ctrl] + [u]</code></td>\n<td>屏幕『向上』移动半页</td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td>光标移动到非空格符的下一行</td>\n</tr>\n<tr>\n<td><code>-</code></td>\n<td>光标移动到非空格符的上一行</td>\n</tr>\n<tr>\n<td><strong><code>n&lt;span space&gt;</code></strong></td>\n<td>**那个 n 表示『数字』，例如 20 。按下数字后再按空格键，</td>\n</tr>\n<tr>\n<td>光标会向右移动这一行的 n 个字符。 数字 加 空格**</td>\n<td></td>\n</tr>\n<tr>\n<td><code>0</code> 或功能键<code>[Home]</code></td>\n<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>\n</tr>\n<tr>\n<td><code>$</code> 或功能键<code>[End]</code></td>\n<td>移动到这一行的最后面字符处(常用)</td>\n</tr>\n<tr>\n<td><code>H</code></td>\n<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>\n</tr>\n<tr>\n<td><code>M</code></td>\n<td>光标移动到这个屏幕的中央那一行的第一个字符</td>\n</tr>\n<tr>\n<td><code>L</code></td>\n<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>\n</tr>\n<tr>\n<td><code>G</code></td>\n<td>移动到这个档案的最后一行(常用)</td>\n</tr>\n<tr>\n<td><code>nG</code></td>\n<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td>\n</tr>\n<tr>\n<td><code>gg</code></td>\n<td>移动到这个档案的第一行，相当于 1G 啊！(常用)</td>\n</tr>\n<tr>\n<td><strong><code>n&lt;span Enter&gt;</code></strong></td>\n<td><strong>n 为数字。光标向下移动 n 行(常用)</strong></td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>搜索替换</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>/word</code></td>\n<td>向光标之下寻找一个名称为 <code>word</code> 的字符串。</td>\n</tr>\n<tr>\n<td>例如要在档案内搜寻 <code>vbird</code> 这个字符串，就输入 <code>/vbird</code> 即可！(常用)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>?word</code></td>\n<td>向光标之上寻找一个字符串名称为 <code>word</code> 的字符串。</td>\n</tr>\n<tr>\n<td><code>n</code></td>\n<td>这个 <code>n</code> 是英文按键。代表重复前一个搜寻的动作。</td>\n</tr>\n</tbody>\n</table>\n<p>举例来说：如果刚刚我们执行 <code>/vbird</code> 去向下搜寻 <code>vbird</code> 这个字符串，则按下 <code>n</code> 后，<br>\n会向下继续搜寻下一个名称为 <code>vbird</code> 的字符串。如果是执行 <code>?vbird</code> 的 | | <code>N</code> | 这个 <code>N</code> 是英文按键。与 <code>n</code> 刚好相反，为『反向』进行前一个搜寻动作。<br>\n例如 <code>/vbird</code> 后，按下 <code>N</code> 则表示『向上』搜寻 <code>vbird</code> 。 |</p>\n<table>\n<thead>\n<tr>\n<th>删除、 复制与粘贴</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>x, X</code></td>\n<td>在一行字当中，x 为向后删除一个字符 (相当于 <code>[del]</code> 按键)，</td>\n</tr>\n<tr>\n<td>X 为向前删除一个字符(相当于 <code>[backspace]</code> 亦即是退格键) (常用)</td>\n<td></td>\n</tr>\n<tr>\n<td><code>nx</code></td>\n<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， <code>『10x』</code>。</td>\n</tr>\n<tr>\n<td><code>dd</code></td>\n<td>删除游标所在的那一整行(常用)</td>\n</tr>\n<tr>\n<td><code>dw</code></td>\n<td>删除游标所在的一个词</td>\n</tr>\n<tr>\n<td><code>ndd</code></td>\n<td>n 为数字。删除光标所在的向下 n 行，例如 <code>20dd</code> 则是删除 20 行 (常用)</td>\n</tr>\n<tr>\n<td><code>d1G</code></td>\n<td>删除光标所在到第一行的所有数据</td>\n</tr>\n<tr>\n<td><code>dG</code></td>\n<td>删除光标所在到最后一行的所有数据</td>\n</tr>\n<tr>\n<td><code>d$</code></td>\n<td>删除游标所在处，到该行的最后一个字符</td>\n</tr>\n<tr>\n<td><code>d0</code></td>\n<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>\n</tr>\n<tr>\n<td><code>yy</code></td>\n<td>复制游标所在的那一行(常用)</td>\n</tr>\n<tr>\n<td><code>yw</code></td>\n<td>复制游标所在的一个词</td>\n</tr>\n<tr>\n<td><code>nyy</code></td>\n<td>n 为数字。复制光标所在的向下 n 行，例如 <code>20yy</code> 则是复制 20 行(常用)</td>\n</tr>\n<tr>\n<td><code>y1G</code></td>\n<td>复制游标所在行到第一行的所有数据</td>\n</tr>\n<tr>\n<td><code>yG</code></td>\n<td>复制游标所在行到最后一行的所有数据</td>\n</tr>\n<tr>\n<td><code>y0</code></td>\n<td>复制光标所在的那个字符到该行行首的所有数据</td>\n</tr>\n<tr>\n<td><code>y$</code></td>\n<td>复制光标所在的那个字符到该行行尾的所有数据</td>\n</tr>\n<tr>\n<td><code>p, P</code></td>\n<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！</td>\n</tr>\n</tbody>\n</table>\n<p>举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后，<br>\n那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。<br>\n但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用) | | <code>J</code> | 将光标所在行与下一行的数据结合成同一行 | | <code>c</code> | 重复删除多个数据，例如向下删除 10 行，<code>[ 10cj ]</code> | | <strong><code>u</code></strong> | <strong>复原前一个动作。(常用)</strong> | | <strong><code>[Ctrl]+r</code></strong> | <strong>重做上一个动作。(常用)</strong> | | <code>crystalift+6（^）</code> | 移动到行头 | | `crystalift+4 （ | $）` 移动到行尾 | | <code>n+shift+g</code> | n 为数字。移动到页头 | | <code>crystalift+g</code> | 移动到页尾 | | <code>n+shift+g</code> | n 为数字。移动到目标行 |</p>\n<h3> <strong>第二部分：一般模式切换到编辑模式的可用的按钮说明</strong></h3>\n<table>\n<thead>\n<tr>\n<th>进入输入或取代的编辑模式</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>i, I</code></td>\n<td><strong>进入输入模式<code>(Insert mode)</code>：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用)</strong></td>\n</tr>\n<tr>\n<td><code>a, A</code></td>\n<td>进入输入模式<code>(Insert mode)</code>：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td>\n</tr>\n<tr>\n<td><code>o, O</code></td>\n<td>进入输入模式<code>(Insert mode)</code>：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用)</td>\n</tr>\n<tr>\n<td><code>r, R</code></td>\n<td>进入取代模式<code>(Replace mode)</code>：r 只会取代光标所在的那一个字符一次；R 会一直取代光标所在的文字，直到按下 <code>ESC</code> 为止；(常用)</td>\n</tr>\n<tr>\n<td><strong><code>[Esc]</code></strong></td>\n<td><strong>退出编辑模式，回到一般模式中(常用)</strong></td>\n</tr>\n</tbody>\n</table>\n<h3> <strong>第三部分：一般模式切换到指令行模式的可用的按钮说明</strong></h3>\n<table>\n<thead>\n<tr>\n<th>指令行的储存、离开等指令</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong><code>:w</code></strong></td>\n<td><strong>将编辑的数据写入硬盘档案中(常用)</strong></td>\n</tr>\n<tr>\n<td><strong><code>:w!</code></strong></td>\n<td><strong>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</strong></td>\n</tr>\n<tr>\n<td><strong><code>:q</code></strong></td>\n<td><strong>离开 vi (常用)</strong></td>\n</tr>\n<tr>\n<td><strong><code>:q!</code></strong></td>\n<td><strong>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</strong></td>\n</tr>\n<tr>\n<td><strong><code>:wq</code></strong></td>\n<td><strong>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</strong></td>\n</tr>\n<tr>\n<td><strong><code>ZZ</code></strong></td>\n<td><strong>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</strong></td>\n</tr>\n<tr>\n<td><code>:w [filename]</code></td>\n<td>将编辑的数据储存成另一个档案（类似另存新档）</td>\n</tr>\n<tr>\n<td><code>:r [filename]</code></td>\n<td>在编辑的数据中，读入另一个档案的数据。亦即将 <code>『filename』</code> 这个档案内容加到游标所在行后面</td>\n</tr>\n<tr>\n<td><code>:n1,n2 w [filename]</code></td>\n<td>将 <code>n1</code> 到 <code>n2</code> 的内容储存成 <code>filename</code> 这个档案。</td>\n</tr>\n<tr>\n<td><code>:! command</code></td>\n<td>暂时离开 <code>vi</code> 到指令行模式下执行 <code>command</code> 的显示结果！例如 <code>『:! ls /home』</code>即可在 <code>vi</code> 当中看 <code>/home</code> 底下以 <code>ls</code> 输出的档案信息！</td>\n</tr>\n<tr>\n<td><strong><code>:set nu</code> 设置行号，代码中</strong></td>\n<td><strong>显示行号，设定之后，会在每一行的前缀显示该行的行号</strong></td>\n</tr>\n<tr>\n<td><code>:set nonu</code></td>\n<td>与 <code>set nu</code> 相反，为取消行号！</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</p>\n</blockquote>\n<h2> 查看网络 IP 和 网关</h2>\n<h3> 查看虚拟网络编辑器</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220902124633366.png\" alt=\"image-20220902124633366\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220902124633366</figcaption></figure>\n<h3> 修改虚拟网卡 Ip</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220902124802103.png\" alt=\"image-20220902124802103\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220902124802103</figcaption></figure>\n<h3> 查看网关</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220902124941641.png\" alt=\"image-20220902124941641\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220902124941641</figcaption></figure>\n<h3> 查看 windows 环境的中 VMnet8 网络配置</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220902125021997.png\" alt=\"image-20220902125021997\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220902125021997</figcaption></figure>\n<h2> 配置网络 ip 地址</h2>\n<h3> ifconfig 配置网络接口</h3>\n<p><code>ifconfig :network interfaces configuring</code> 网络接口配置</p>\n<p>1、基本语法</p>\n<ul>\n<li><code>ifconfig</code> （功能描述：显示所有网络接口的配置信息）</li>\n</ul>\n<p>2、案例实操</p>\n<ul>\n<li>查看当前网络 <code>ip</code></li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> ping 测试主机之间网络连通性</h3>\n<p>1、基本语法</p>\n<ul>\n<li><code>ping</code> 目的主机 （功能描述：测试当前服务器是否可以连接目的主机）</li>\n</ul>\n<p>2、案例实操</p>\n<ul>\n<li>测试当前服务器是否可以连接百度</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 修改 IP 地址</h3>\n<p><strong>1、查看 IP 配置文件</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209031230958.png\" alt=\"image-20220903123026917\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220903123026917</figcaption></figure>\n<p>以下标红的项必须修改，有值的按照下面的值修改，没有该项的要增加。</p>\n<div class=\"language-visual line-numbers-mode\" data-ext=\"visual\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改后</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209031228706.png\" alt=\"image-20220903122820674\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220903122820674</figcaption></figure>\n<p>编辑完后，按键盘 <code>esc</code> ，然后输入 <code>:wq</code> 回车即可。</p>\n<p><strong>2、执行 <code>service network restart</code> 重启网络</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220902123712391.png\" alt=\"image-20220902123712391\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220902123712391</figcaption></figure>\n<h3> 修改 IP 地址后可能会遇到的问题</h3>\n<ol>\n<li>物理机能 <code>ping</code> 通虚拟机，但是虚拟机 <code>ping</code> 不通物理机,一般都是因为物理机的防火墙问题,把防火墙关闭就行</li>\n<li>虚拟机能 <code>Ping</code> 通物理机,但是虚拟机 <code>Ping</code> 不通外网,一般都是因为<code>DNS</code> 的设置有问题</li>\n<li>虚拟机 <code>Ping www.baidu.com</code> 显示域名未知等信息,一般查看<code>GATEWAY</code> 和<code>DNS</code> 设置是否正确</li>\n<li>如果以上全部设置完还是不行，需要关闭 <code>NetworkManager</code> 服务\n<ol>\n<li><code>systemctl stop NetworkManager</code> 关闭</li>\n<li><code>systemctl disable NetworkManager</code> 禁用</li>\n</ol>\n</li>\n<li>如果检查发现 <code>systemctl status network</code> 有问题 需要检查<code>ifcfg-ens33</code></li>\n</ol>\n<h3> 下面是 red hat/CentOs7 关闭防火墙的命令</h3>\n<p>1:查看防火状态</p>\n<ul>\n<li>systemctl status firewalld</li>\n<li>service iptables status</li>\n</ul>\n<p>2:暂时关闭防火墙</p>\n<ul>\n<li>systemctl stop firewalld</li>\n<li>service iptables stop</li>\n</ul>\n<p>3:永久关闭防火墙</p>\n<ul>\n<li>systemctl disable firewalld</li>\n<li>chkconfig iptables off</li>\n</ul>\n<p>4:重启防火墙</p>\n<ul>\n<li>systemctl enable firewalld</li>\n<li>service iptables restart</li>\n</ul>\n<p>5:永久关闭后重启</p>\n<p>//暂时还没有试过</p>\n<ul>\n<li>chkconfig iptables on</li>\n</ul>\n<h2> 配置主机名</h2>\n<h3> 修改主机名称</h3>\n<p><strong>1、基本语法</strong></p>\n<p><code>hostname</code> （功能描述：查看当前服务器的主机名称）</p>\n<p><code>Hostnamectl</code>（查看详细信息）使用<code>hostnamectl set-hostname [自定义名称]</code> 可强制更改不需要重启</p>\n<p><strong>2、案例实操</strong></p>\n<ol>\n<li>查看当前服务器主机名称</li>\n</ol>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol start=\"2\">\n<li>如果感觉此主机名不合适，我们可以进行修改。通过编辑/etc/hostname 文件</li>\n</ol>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>修改完成后重启生效。</p>\n<h3> 修改 hosts 映射文件</h3>\n<p>修改 <code>linux</code> 的主机映射文件（<code>hosts</code> 文件） 后续在 <code>hadoop</code> 阶段，虚拟机会比较多，配置时通常会采用主机名的方式配置，比较简单方便。 不用刻意记 <code>ip</code> 地址。</p>\n<ol>\n<li>打开<code>/etc/hosts</code></li>\n</ol>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>添加如下内容</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"2\">\n<li>重启设备，重启后，查看主机名，已经修改成功</li>\n</ol>\n<p>修改 <code>windows</code> 的主机映射文件（<code>hosts</code> 文件）</p>\n<ol>\n<li>进入 <code>C:\\Windows\\System32\\drivers\\etc</code> 路径</li>\n<li>打开 <code>hosts</code> 文件并添加如下内容</li>\n</ol>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 远程登录</h2>\n<p><code>Windows</code>: <code>Xshell</code>, <code>SSH</code> <code>Secure</code> <code>crystalell</code>, <code>SecureCRT</code>,<code>FinalShell</code></p>\n<p><code>MacOS</code> :<code>iTerm2</code>，<code>Royal TSX</code></p>\n<h2> CentOS Node</h2>\n<p><a href=\"https://registry.npmmirror.com/binary.html?path=node/v16.17.0/\" target=\"_blank\" rel=\"noopener noreferrer\">官网 open in new window</a></p>\n<h2> <strong>第一步 在 CentOS 找好安装位置</strong></h2>\n<p><strong>x86 架构</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220914105129045.png\" alt=\"image-20220914105129045\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220914105129045</figcaption></figure>\n<p><strong>让你一步到位的命令</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>url 拆解</strong></p>\n<p><a href=\"https://npm.taobao.org/mirrors/node/v16.17.0\" target=\"_blank\" rel=\"noopener noreferrer\">https://npm.taobao.org/mirrors/node/v16.17.0</a> node 版本号</p>\n<p>node-v16.17.0-linux-x64.tar.gz 对应架构的文件名</p>\n<h2> 第二步 解压压缩文件</h2>\n<p><strong>执行一下命令</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>进入到 node-v16.17.0-linux-x64.tar.gz，执行一下命令安装 Node.js 的依赖组件</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>重命名 node-v12.16.1-linux-x64.tar.gz 文件夹为 Node.js</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 第三步 部署 bin 文件并建立软连接（类似于 Windows 中配置环境变量）</h2>\n<p><strong>进入到/usr/local/temp/Node.js/bin 你会看到</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220914105914750.png\" alt=\"image-20220914105914750\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220914105914750</figcaption></figure>\n<p>ln 指令用于创建关联</p>\n<p>依次<strong>执行以下命令</strong></p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最后在终端输入 node -v</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220914110030726.png\" alt=\"image-20220914110030726\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220914110030726</figcaption></figure>\n<p>出现这个就完成</p>\n<h2> 安装 yarn</h2>\n<h3> 配置<a href=\"https://so.csdn.net/so/search?q=yarn&amp;spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener noreferrer\">yarnopen in new window</a>官方 yum 存储库</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 安装</h3>\n<h3> 验证</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Centos7 Mysql 安装</h2>\n<h2> 1、下载</h2>\n<p><a href=\"https://downloads.mysql.com/archives/community/\" target=\"_blank\" rel=\"noopener noreferrer\">https://downloads.mysql.com/archives/community/</a></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209241517826.png\" alt=\"image-20220924151733781\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220924151733781</figcaption></figure>\n<p>上传到 Linux</p>\n<p>或一键下载</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 2、解压</h2>\n<p>将文件移动到一个目录中</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209241522610.png\" alt=\"image-20220924152215578\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220924152215578</figcaption></figure>\n<p>解包文件</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209241523418.png\" alt=\"image-20220924152302390\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220924152302390</figcaption></figure>\n<h2> 3、安装</h2>\n<p><code>--nodeps --force</code> 为强制安装</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>必须安装以上顺序安装</p>\n<h2> 4、问题</h2>\n<p>安装完成后不出意外的话输入初始化命令就成功了</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果出现以下报错</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209241526354.png\" alt=\"image-20220924152648318\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220924152648318</figcaption></figure>\n<p>那可能是缺少 openssl10</p>\n<p>在 Linux 中安装 openssl10，进行<a href=\"https://so.csdn.net/so/search?q=OpenSSL&amp;spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener noreferrer\">OpenSSLopen in new window</a>升级（用 yum 升不上去，用 rpm 包简单有效）</p>\n<p>阿里云下载链接</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>下载后进行安装</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>最终安装过程图</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209241531110.png\" alt=\"image-20220924153111079\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220924153111079</figcaption></figure>\n<h2> 5、启动</h2>\n<h3> 初始化 Nysql</h3>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 添加权限</h3>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 启动服务</h3>\n<h3> 查看初始密码</h3>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209241535995.png\" alt=\"image-20220924153531953\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220924153531953</figcaption></figure>\n<h3> 登入 Mysql</h3>\n<h3> 问题</h3>\n<p>这里我在登录的时候是遇到了两个问题</p>\n<p>报错 1</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>没有<code>libncurses.so.5</code>，可能有<code>libncurses.so</code>不同版本的文件，使用命令全局查找</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209241555581.png\" alt=\"image-20220924155547536\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220924155547536</figcaption></figure>\n<p>之后将<code>/usr/lib64</code>下找到的<code>libncurses.so</code> 版本和<code>libncurses.so.5</code>进行链接</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>报错 2</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>与上同理，全局查找<code>libtinfo</code>将文件与 <code>libtinfo.so.5</code> 进行链接</p>\n<p>最终登录效果</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209241600997.png\" alt=\"image-20220924160043962\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220924160043962</figcaption></figure>\n<h3> 修改密码</h3>\n<div class=\"language-mysql line-numbers-mode\" data-ext=\"mysql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 查看数据库</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209241610492.png\" alt=\"image-20220924161008432\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220924161008432</figcaption></figure>\n<h2> 6、navicat 远程链接</h2>\n<p>点击新建链接使用 SSH</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209241636943.png\" alt=\"image-20220924163623897\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220924163623897</figcaption></figure>\n<h3> 链接失败 1130</h3>\n<p><strong>1130 - Host ‘<a href=\"http://xxx.xxx.xxx.xxx\" target=\"_blank\" rel=\"noopener noreferrer\">xxx.xxx.xxx.xxx</a>’ is not allowed to connect to this MySQL server</strong><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209241640679.jpeg\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h4> a.问题分析</h4>\n<p>某某 ip 不被允许连接这个 MySQL 服务，排除服务器防火墙没开放 3306 端口的情况</p>\n<h4> b.解决办法</h4>\n<p>连接远端服务器，登录进去到 MySQL，查看名为 mysql 的数据库中的一个名字叫 user 的表，一般来讲如果出现 1130 代码问题，大概率是 MySQL 登录用户的 host 权限是 localhost 或其他，把登录用户对应的 host 改成%即可，%意为任意 ip 地址 <img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209241637979.png\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h4> c.解决步骤</h4>\n<div class=\"language-powershell line-numbers-mode\" data-ext=\"powershell\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2.接着说可能会出现的其他问题：失败 2059</p>\n<h3> 链接失败 2059</h3>\n<p><strong>2059 - Authentication plugin ‘caching_sha2_password’ cannot be loaded: xxxxxxxxxx</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209241639127.jpeg\" alt=\"在这里插入图片描述\" tabindex=\"0\" loading=\"lazy\"><figcaption>在这里插入图片描述</figcaption></figure>\n<h4> a.问题分析</h4>\n<p>这个问题存在于 MySQL8.0 及以后的版本，MySQL8.0 对密码的加密方式进行了修改，由原来的 mysql_native_password 方式，改成了 caching_sha2_password 方式，导致了支持 mysql_native_password 方式的<a href=\"https://so.csdn.net/so/search?q=Navicat&amp;spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener noreferrer\">Navicatopen in new window</a>无法成功连接 MySQL8.0</p>\n<h4> b.问题解决</h4>\n<p>修改 MySQL 数据库的密码加密方式，并使用加密方式修改覆盖原来的密码，保证相同密码加密后的一致，密码改成 Navicat 支持的 mysql_native_password 方式 <img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209241639153.png\" alt=\"在这里插入图片描述\" loading=\"lazy\"></p>\n<h4> c.解决步骤</h4>\n<div class=\"language-powershell line-numbers-mode\" data-ext=\"powershell\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 7、Node 链接 Mysql8 的一些问题</h2>\n<p><code>node.js</code>连接 mysql 出现错误： <code>ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client</code></p>\n<p>目前是因为版本问题</p>\n<h3> 解决办法</h3>\n<p>1、找到 MYSQL 的安装路径下的 bin 目录，这里是：C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin，然后在命令行工具进入，如下图</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209242139725.png\" alt=\"在这里插入图片描述\" tabindex=\"0\" loading=\"lazy\"><figcaption>在这里插入图片描述</figcaption></figure>\n<p>2、登录 mysql 数据库。即继续在命令行工具输入：<code>mysql -u root -p</code>。然后输入自己数据库的密码，进入数据库</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209242139775.png\" alt=\"在这里插入图片描述\" tabindex=\"0\" loading=\"lazy\"><figcaption>在这里插入图片描述</figcaption></figure>\n<p>3、接着输入</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>上面<code>’123456’</code>是我的数据库密码，将其改为自己的即可。</p>\n<p>这里<code>root'@'localhost'</code> 对应的是 <code>mysql</code>数据库的<code>user</code>表的键和值，我这里的<code>root</code>的<code>host</code>是<code>%</code>，所以为<code>root'@'%'</code></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209242143111.png\" alt=\"image-20220924214308072\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220924214308072</figcaption></figure>\n<p>4、最后在输入下面这个命令，然后回车。</p>\n<p>第三步第四步的截图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209242139810.png\" alt=\"在这里插入图片描述\" tabindex=\"0\" loading=\"lazy\"><figcaption>在这里插入图片描述</figcaption></figure>\n<p>然后就可以连上数据库了。</p>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/linux/202209022246046.png",
      "date_published": "2021-06-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "linux"
      ]
    },
    {
      "title": "Linux 常用命令",
      "url": "https://www.h7ml.cn/posts/linux/command.html",
      "id": "https://www.h7ml.cn/posts/linux/command.html",
      "summary": "文件目录类（频繁） pwd 显示当前工作目录的绝对路径 pwd:print working directory 打印工作目录 基本语法 pwd （功能描述：显示当前工作目录的绝对路径） 案例实操 显示当前工作目录的绝对路径 [root@hadoop101 ~]# pwd /root",
      "content_html": "<h2> 文件目录类（频繁）</h2>\n<h2> pwd 显示当前工作目录的绝对路径</h2>\n<p><code>pwd:print working directory</code> 打印工作目录</p>\n<p><strong>基本语法</strong></p>\n<p><code>pwd</code> （功能描述：显示当前工作目录的绝对路径）</p>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>显示当前工作目录的绝对路径</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> ls 列出目录的内容</h2>\n<p><code>ls:list</code> 列出目录内容</p>\n<p><strong>基本语法</strong></p>\n<p><code>ls [选项] [目录或是文件]</code></p>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-a</code></td>\n<td>全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)</td>\n</tr>\n<tr>\n<td><code>-l</code></td>\n<td>长数据串列出，包含文件的属性与权限等等数据(常用)等价于“ll”</td>\n</tr>\n</tbody>\n</table>\n<p><strong>显示说明</strong></p>\n<p>每行列出的信息依次是：<strong>文件类型与权限 链接数 文件属主 文件属组文件大小用 byte 来表示 建立或最近修改的时间 名字</strong></p>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>查看当前目录的所有内容信息</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> cd 切换目录</h2>\n<p><strong>基本语法</strong></p>\n<p><code>cd [参数]</code></p>\n<p><strong>参数说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>cd</code> 绝对路径</td>\n<td>切换路径</td>\n</tr>\n<tr>\n<td><code>cd</code> 相对路径</td>\n<td>切换路径</td>\n</tr>\n<tr>\n<td><code>cd</code> ~或者 <code>cd</code></td>\n<td>回到自己的家目录</td>\n</tr>\n<tr>\n<td><code>cd -</code></td>\n<td>回到上一次所在目录</td>\n</tr>\n<tr>\n<td><code>cd ..</code></td>\n<td>回到当前目录的上一级目录</td>\n</tr>\n<tr>\n<td><code>cd -P</code></td>\n<td>跳转到实际物理路径，而非快捷方式路径</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>使用绝对路径切换到 <code>root</code> 目录</li>\n</ul>\n<div class=\"language-hs line-numbers-mode\" data-ext=\"hs\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>使用相对路径切换到“公共的”目录</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>表示回到自己的家目录，亦即是 <code>/root</code> 这个目录</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p><code>cd</code>- 回到上一次所在目录</p>\n</li>\n<li>\n<p>表示回到当前目录的上一级目录，亦即是 “<code>/root/</code>公共的”的上一级目录的意思</p>\n</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> mkdir 创建一个新的目录</h2>\n<p><code>mkdir:Make directory</code> 建立目录</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>mkdir [选项] 要创建的目录</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-p</td>\n<td>创建多层目录</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>创建一个目录</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>创建一个多级目录</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> rmdir 删除一个空的目录</h2>\n<p><code>rmdir:Remove directory</code> 移除目录</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>rmdir</code> 要删除的空目录</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>删除一个空的文件夹</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> touch 创建空文件</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>touch</code> 文件名称</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> cp 复制文件或目录</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>cp [选项] source dest</code> （功能描述：复制<code>source</code>文件到<code>dest</code>）</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-r</code></td>\n<td>递归复制整个文件夹</td>\n</tr>\n</tbody>\n</table>\n<p><strong>参数说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>source</code></td>\n<td>源文件</td>\n</tr>\n<tr>\n<td><code>dest</code></td>\n<td>目标文件</td>\n</tr>\n</tbody>\n</table>\n<p><strong>经验技巧</strong></p>\n<p>强制覆盖不提示的方法：\\cp</p>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>复制文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>递归复制整个文件夹</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> rm 删除文件或目录</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>rm [选项] deleteFile</code> （功能描述：递归删除目录中所有内容）</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-r</code></td>\n<td>递归删除目录中所有内容</td>\n</tr>\n<tr>\n<td><code>-f</code></td>\n<td>强制执行删除操作，而不提示用于进行确认</td>\n</tr>\n<tr>\n<td><code>-v</code></td>\n<td>显示指令的详细执行过程</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>删除目录中的内容</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>递归删除目录中所有内容</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> mv 移动文件与目录或重命名</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>mv oldNameFile newNameFile</code> （功能描述：重命名） - <code>mv /temp/movefile /targetFolder</code> （功能描述：移动文件）</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>重命名</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>移动文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> cat 查看文件内容</h2>\n<p>查看文件内容，从第一行开始显示。</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>cat [选项]</code> 要查看的文件</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-n</code></td>\n<td>显示所有行的行号，包括空行。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>经验技巧</strong></p>\n<ul>\n<li>一般查看比较小的文件，一屏幕能显示全的。</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>查看文件内容并显示行号</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> more 文件内容分屏查看器</h2>\n<p>more 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more 指令中内置了若干快捷键，详见操作说明。</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>more 要查看的文件</li>\n</ul>\n<p><strong>操作说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>空白键 (space)</code></td>\n<td>代表向下翻一页</td>\n</tr>\n<tr>\n<td><code>Enter</code></td>\n<td>代表向下翻『一行』</td>\n</tr>\n<tr>\n<td><code>q</code></td>\n<td>代表立刻离开 <code>more</code> ，不再显示该文件内容。<code>Ctrl+F</code> 向下滚动一屏</td>\n</tr>\n<tr>\n<td><code>Ctrl+F</code></td>\n<td>向下滚动一屏</td>\n</tr>\n<tr>\n<td><code>Ctrl+B</code></td>\n<td>返回上一屏</td>\n</tr>\n<tr>\n<td><code>=</code></td>\n<td>输出当前行的行号</td>\n</tr>\n<tr>\n<td><code>:f</code></td>\n<td>输出文件名和当前行的行号</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>采用 <code>more</code> 查看文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> less 分屏显示文件内容</h2>\n<p>less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>less 要查看的文件</li>\n</ul>\n<p><strong>操作说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>空白键</code></td>\n<td>向下翻动一页</td>\n</tr>\n<tr>\n<td><code>[pagedown]</code></td>\n<td>向下翻动一页</td>\n</tr>\n<tr>\n<td><code>[pageup]</code></td>\n<td>向上翻动一页</td>\n</tr>\n<tr>\n<td><code>/字串</code></td>\n<td>向下搜寻『字串』的功能 n：向下查找 N：向上查找</td>\n</tr>\n<tr>\n<td><code>?字串</code></td>\n<td>向上搜寻『字串』的功能 n：向上查找 N：向下查找</td>\n</tr>\n<tr>\n<td><code>q</code></td>\n<td>离开 less 这个程序</td>\n</tr>\n</tbody>\n</table>\n<p><strong>经验技巧</strong></p>\n<ul>\n<li>用<code>SecureCRT</code>时<code>[pagedown]</code>和<code>[pageup]</code>可能会出现无法识别的问题</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>采用 less 查看文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> echo 输出内容到控制台</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>echo [选项] [输出内容]</code></li>\n</ul>\n<p><strong>选项说明</strong></p>\n<ul>\n<li><code>-e：</code> 支持反斜线控制的字符转换</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>控制字符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\\\</code></td>\n<td>输出\\本身</td>\n</tr>\n<tr>\n<td><code>\\n</code></td>\n<td>换行符</td>\n</tr>\n<tr>\n<td><code>\\t</code></td>\n<td>制表符，也就是 Tab 键</td>\n</tr>\n</tbody>\n</table>\n<p>案例实操</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> head 显示文件头部内容</h2>\n<p><code>head</code> 用于显示文件的开头部分内容，默认情况下 <code>head</code> 指令显示文件的前 10 行内容。</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>head</code> 文件 （功能描述：查看文件头 10 行内容）</li>\n<li><code>head -n 5</code> 文件 （功能描述：查看文件头 5 行内容，5 可以是任意行数）</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-n&lt;行数&gt;</code></td>\n<td>指定显示头部内容的行数</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>查看文件的头 2 行</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> tail 输出文件尾部内容</h2>\n<p>tail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容。</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>tail 文件</code> （功能描述：查看文件尾部 10 行内容）</li>\n<li><code>tail -n 5 文件</code> （功能描述：查看文件尾部 5 行内容，5 可以是任意行数）</li>\n<li><strong><code>tail -f 文件</code> （功能描述：实时追踪该文档的所有更新）</strong></li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-n&lt;行数&gt;</code></td>\n<td>输出文件尾部 n 行内容</td>\n</tr>\n<tr>\n<td><code>-f</code></td>\n<td>显示文件最新追加的内容，监视文件变化</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>查看文件尾 1 行内容</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>实时追踪该档的所有更新</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> <strong>&gt;</strong> 输出重定向和 <strong>&gt;&gt;</strong> 追加</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>ls-l &gt;文件 (功能描述:列表的内容写入文件 a.txt 中(覆盖写))</li>\n<li>ls-al &gt;&gt;文件 (功能描述:列表的内容追加到文件 aa.txt 的末尾)</li>\n<li>cat 文件 1 &gt; 文件 2 (功能描述:将文件 1 的内容覆盖到文件 2)</li>\n<li>echo “内容” &gt;&gt; 文件</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>将 ls 查看信息写入到文件中</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>将 ls 查看信息追加到文件中</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>采用 echo 将 hello 单词追加到文件中</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> <strong>ln</strong> 软链接</h2>\n<p>软链接也称为符号链接，类似于 windows 里的快捷方式，有自己的数据块，主要存放</p>\n<p>了链接其他文件的路径。</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>ln -s</code> [原文件或目录] [软链接名] (功能描述:给原文件创建一个软链接)</li>\n</ul>\n<p><strong>经验技巧</strong></p>\n<ul>\n<li>\n<p>删除软链接: <code>rm -rf</code> 软链接名，而不是 <code>rm -rf</code> 软链接名/</p>\n</li>\n<li>\n<p>如果使用 <code>rm -rf</code> 软链接名/ 删除，<strong>会把软链接对应的真实目录下内容删掉</strong></p>\n</li>\n<li>\n<p>查询:通过 <code>ll</code> 就可以查看，列表属性第 1 位是 l，尾部会有位置指向。</p>\n</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>创建软连接</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>删除软连接(注意不要写最后的/)</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>进入软连接实际物理路径</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> <strong>history</strong> 查看已经执行过历史命令</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>history (功能描述:查看已经执行过历史命令)</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>查看已经执行过的历史命令</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 文件目录类（频繁）</h2>\n<h2> pwd 显示当前工作目录的绝对路径</h2>\n<p><code>pwd:print working directory</code> 打印工作目录</p>\n<p><strong>基本语法</strong></p>\n<p><code>pwd</code> （功能描述：显示当前工作目录的绝对路径）</p>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>显示当前工作目录的绝对路径</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> ls 列出目录的内容</h2>\n<p><code>ls:list</code> 列出目录内容</p>\n<p><strong>基本语法</strong></p>\n<p><code>ls [选项] [目录或是文件]</code></p>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-a</code></td>\n<td>全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)</td>\n</tr>\n<tr>\n<td><code>-l</code></td>\n<td>长数据串列出，包含文件的属性与权限等等数据(常用)等价于“ll”</td>\n</tr>\n</tbody>\n</table>\n<p><strong>显示说明</strong></p>\n<p>每行列出的信息依次是：<strong>文件类型与权限 链接数 文件属主 文件属组文件大小用 byte 来表示 建立或最近修改的时间 名字</strong></p>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>查看当前目录的所有内容信息</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> cd 切换目录</h2>\n<p><strong>基本语法</strong></p>\n<p><code>cd [参数]</code></p>\n<p><strong>参数说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>cd</code> 绝对路径</td>\n<td>切换路径</td>\n</tr>\n<tr>\n<td><code>cd</code> 相对路径</td>\n<td>切换路径</td>\n</tr>\n<tr>\n<td><code>cd</code> ~或者 <code>cd</code></td>\n<td>回到自己的家目录</td>\n</tr>\n<tr>\n<td><code>cd -</code></td>\n<td>回到上一次所在目录</td>\n</tr>\n<tr>\n<td><code>cd ..</code></td>\n<td>回到当前目录的上一级目录</td>\n</tr>\n<tr>\n<td><code>cd -P</code></td>\n<td>跳转到实际物理路径，而非快捷方式路径</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>使用绝对路径切换到 <code>root</code> 目录</li>\n</ul>\n<div class=\"language-hs line-numbers-mode\" data-ext=\"hs\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>使用相对路径切换到“公共的”目录</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>表示回到自己的家目录，亦即是 <code>/root</code> 这个目录</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p><code>cd</code>- 回到上一次所在目录</p>\n</li>\n<li>\n<p>表示回到当前目录的上一级目录，亦即是 “<code>/root/</code>公共的”的上一级目录的意思</p>\n</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> mkdir 创建一个新的目录</h2>\n<p><code>mkdir:Make directory</code> 建立目录</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>mkdir [选项] 要创建的目录</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-p</td>\n<td>创建多层目录</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>创建一个目录</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>创建一个多级目录</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> rmdir 删除一个空的目录</h2>\n<p><code>rmdir:Remove directory</code> 移除目录</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>rmdir</code> 要删除的空目录</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>删除一个空的文件夹</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> touch 创建空文件</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>touch</code> 文件名称</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> cp 复制文件或目录</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>cp [选项] source dest</code> （功能描述：复制<code>source</code>文件到<code>dest</code>）</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-r</code></td>\n<td>递归复制整个文件夹</td>\n</tr>\n</tbody>\n</table>\n<p><strong>参数说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>source</code></td>\n<td>源文件</td>\n</tr>\n<tr>\n<td><code>dest</code></td>\n<td>目标文件</td>\n</tr>\n</tbody>\n</table>\n<p><strong>经验技巧</strong></p>\n<p>强制覆盖不提示的方法：\\cp</p>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>复制文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>递归复制整个文件夹</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> rm 删除文件或目录</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>rm [选项] deleteFile</code> （功能描述：递归删除目录中所有内容）</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-r</code></td>\n<td>递归删除目录中所有内容</td>\n</tr>\n<tr>\n<td><code>-f</code></td>\n<td>强制执行删除操作，而不提示用于进行确认</td>\n</tr>\n<tr>\n<td><code>-v</code></td>\n<td>显示指令的详细执行过程</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>删除目录中的内容</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>递归删除目录中所有内容</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> mv 移动文件与目录或重命名</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>mv oldNameFile newNameFile</code> （功能描述：重命名） - <code>mv /temp/movefile /targetFolder</code> （功能描述：移动文件）</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>重命名</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>移动文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> cat 查看文件内容</h2>\n<p>查看文件内容，从第一行开始显示。</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>cat [选项]</code> 要查看的文件</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-n</code></td>\n<td>显示所有行的行号，包括空行。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>经验技巧</strong></p>\n<ul>\n<li>一般查看比较小的文件，一屏幕能显示全的。</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>查看文件内容并显示行号</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> more 文件内容分屏查看器</h2>\n<p>more 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more 指令中内置了若干快捷键，详见操作说明。</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>more 要查看的文件</li>\n</ul>\n<p><strong>操作说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>空白键 (space)</code></td>\n<td>代表向下翻一页</td>\n</tr>\n<tr>\n<td><code>Enter</code></td>\n<td>代表向下翻『一行』</td>\n</tr>\n<tr>\n<td><code>q</code></td>\n<td>代表立刻离开 <code>more</code> ，不再显示该文件内容。<code>Ctrl+F</code> 向下滚动一屏</td>\n</tr>\n<tr>\n<td><code>Ctrl+F</code></td>\n<td>向下滚动一屏</td>\n</tr>\n<tr>\n<td><code>Ctrl+B</code></td>\n<td>返回上一屏</td>\n</tr>\n<tr>\n<td><code>=</code></td>\n<td>输出当前行的行号</td>\n</tr>\n<tr>\n<td><code>:f</code></td>\n<td>输出文件名和当前行的行号</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>采用 <code>more</code> 查看文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> less 分屏显示文件内容</h2>\n<p>less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>less 要查看的文件</li>\n</ul>\n<p><strong>操作说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>空白键</code></td>\n<td>向下翻动一页</td>\n</tr>\n<tr>\n<td><code>[pagedown]</code></td>\n<td>向下翻动一页</td>\n</tr>\n<tr>\n<td><code>[pageup]</code></td>\n<td>向上翻动一页</td>\n</tr>\n<tr>\n<td><code>/字串</code></td>\n<td>向下搜寻『字串』的功能 n：向下查找 N：向上查找</td>\n</tr>\n<tr>\n<td><code>?字串</code></td>\n<td>向上搜寻『字串』的功能 n：向上查找 N：向下查找</td>\n</tr>\n<tr>\n<td><code>q</code></td>\n<td>离开 less 这个程序</td>\n</tr>\n</tbody>\n</table>\n<p><strong>经验技巧</strong></p>\n<ul>\n<li>用<code>SecureCRT</code>时<code>[pagedown]</code>和<code>[pageup]</code>可能会出现无法识别的问题</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>采用 less 查看文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> echo 输出内容到控制台</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>echo [选项] [输出内容]</code></li>\n</ul>\n<p><strong>选项说明</strong></p>\n<ul>\n<li><code>-e：</code> 支持反斜线控制的字符转换</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>控制字符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\\\</code></td>\n<td>输出\\本身</td>\n</tr>\n<tr>\n<td><code>\\n</code></td>\n<td>换行符</td>\n</tr>\n<tr>\n<td><code>\\t</code></td>\n<td>制表符，也就是 Tab 键</td>\n</tr>\n</tbody>\n</table>\n<p>案例实操</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> head 显示文件头部内容</h2>\n<p><code>head</code> 用于显示文件的开头部分内容，默认情况下 <code>head</code> 指令显示文件的前 10 行内容。</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>head</code> 文件 （功能描述：查看文件头 10 行内容）</li>\n<li><code>head -n 5</code> 文件 （功能描述：查看文件头 5 行内容，5 可以是任意行数）</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-n&lt;行数&gt;</code></td>\n<td>指定显示头部内容的行数</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>查看文件的头 2 行</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> tail 输出文件尾部内容</h2>\n<p>tail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容。</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>tail 文件</code> （功能描述：查看文件尾部 10 行内容）</li>\n<li><code>tail -n 5 文件</code> （功能描述：查看文件尾部 5 行内容，5 可以是任意行数）</li>\n<li><strong><code>tail -f 文件</code> （功能描述：实时追踪该文档的所有更新）</strong></li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-n&lt;行数&gt;</code></td>\n<td>输出文件尾部 n 行内容</td>\n</tr>\n<tr>\n<td><code>-f</code></td>\n<td>显示文件最新追加的内容，监视文件变化</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>查看文件尾 1 行内容</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>实时追踪该档的所有更新</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> <strong>&gt;</strong> 输出重定向和 <strong>&gt;&gt;</strong> 追加</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>ls-l &gt;文件 (功能描述:列表的内容写入文件 a.txt 中(覆盖写))</li>\n<li>ls-al &gt;&gt;文件 (功能描述:列表的内容追加到文件 aa.txt 的末尾)</li>\n<li>cat 文件 1 &gt; 文件 2 (功能描述:将文件 1 的内容覆盖到文件 2)</li>\n<li>echo “内容” &gt;&gt; 文件</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>将 ls 查看信息写入到文件中</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>将 ls 查看信息追加到文件中</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>采用 echo 将 hello 单词追加到文件中</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> <strong>ln</strong> 软链接</h2>\n<p>软链接也称为符号链接，类似于 windows 里的快捷方式，有自己的数据块，主要存放</p>\n<p>了链接其他文件的路径。</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>ln -s</code> [原文件或目录] [软链接名] (功能描述:给原文件创建一个软链接)</li>\n</ul>\n<p><strong>经验技巧</strong></p>\n<ul>\n<li>\n<p>删除软链接: <code>rm -rf</code> 软链接名，而不是 <code>rm -rf</code> 软链接名/</p>\n</li>\n<li>\n<p>如果使用 <code>rm -rf</code> 软链接名/ 删除，<strong>会把软链接对应的真实目录下内容删掉</strong></p>\n</li>\n<li>\n<p>查询:通过 <code>ll</code> 就可以查看，列表属性第 1 位是 l，尾部会有位置指向。</p>\n</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>创建软连接</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>删除软连接(注意不要写最后的/)</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>进入软连接实际物理路径</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> <strong>history</strong> 查看已经执行过历史命令</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>history (功能描述:查看已经执行过历史命令)</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>查看已经执行过的历史命令</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 时间日期类</h2>\n<h2> <strong>date</strong> 显示当前时间</h2>\n<p><strong>基本语法</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li><code>date</code> (功能描述:显示当前时间)</li>\n<li><code>date +%Y</code> (功能描述:显示当前年份)</li>\n<li><code>date +%m</code> (功能描述:显示当前月份)</li>\n<li><code>date +%d</code> (功能描述:显示当前是哪一天)</li>\n<li><code>date \"+%Y-%m-%d %H:%M:%S\"</code> (功能描述:显示年月日时分秒)</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-d&lt;时间字符串&gt;</td>\n<td>显示指定“时间字符串”表示时间，而非当前时间</td>\n</tr>\n<tr>\n<td>-s&lt;日期时间&gt;</td>\n<td>设置系统日期时间</td>\n</tr>\n</tbody>\n</table>\n<p><strong>参数说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&lt;+日期时间格式&gt;</td>\n<td>指定显示时使用的日期时间格式</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>显示当前时间信息</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>显示当前时间年月日</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>显示当前时间年月日时分秒</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> <strong>date</strong> 显示非当前时间</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>date -d '1 days ago'</code>(功能描述:显示前一天时间)</li>\n<li><code>date -d '-1 days ago'</code>(功能描述:显示明天时间)</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>显示前一天</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>显示明天时间</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> <strong>date</strong> 设置系统时间</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>date -s 字符串时间</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>设置系统当前时间</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> <strong>cal</strong> 查看日历</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>cal [选项] (功能描述:不加选项，显示本月日历)</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>具体某一年</td>\n<td>显示这一年</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>\n<p>查看当前月的日历</p>\n</li>\n<li>\n<p>查看 2017 年的日历</p>\n</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 用户管理命令</h2>\n<h2> useradd 添加新用户</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>useradd</code> 用户名 (功能描述:添加新用户)</li>\n<li><code>useradd -g</code> 组名 用户名 (功能描述:添加新用户到某个组)</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-c comment</code></td>\n<td>指定一段注释性描述。</td>\n</tr>\n<tr>\n<td><code>-d</code></td>\n<td>目录 指定用户主目录，如果此目录不存在，则同时使用-m 选项，可以创建主目录。</td>\n</tr>\n<tr>\n<td><code>-g</code></td>\n<td>用户组 指定用户所属的用户组。</td>\n</tr>\n<tr>\n<td><code>-G</code></td>\n<td>用户组，用户组 指定用户所属的附加组。</td>\n</tr>\n<tr>\n<td><strong><code>-m</code></strong></td>\n<td><strong>自动创建这个用户的主目录 /home/qinjiang</strong></td>\n</tr>\n<tr>\n<td><code>-s</code></td>\n<td>Shell 文件 指定用户的登录 Shell。</td>\n</tr>\n<tr>\n<td><code>-u</code></td>\n<td>用户号 指定用户的用户号，如果同时有-o 选项，则可以重复使用其他用户的标识号。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>添加一个用户</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> <strong>passwd</strong> 设置用户密码</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>passwd</code> 用户名 (功能描述:设置用户密码)</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>设置用户的密码</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 查看用户是否存在</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>id</code> 用户名</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>看用户是否存在</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> cat /etc/passwd 查看创建了哪些用户</h2>\n<ul>\n<li>案例实操</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209031822555.png\" alt=\"image-20220903182240503\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220903182240503</figcaption></figure>\n<h2> su 切换用户</h2>\n<p><code>su: swith user</code> 切换用户</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>su</code>用户名称 (功能描述:切换用户，只能获得用户的执行权限，不能获得环境变量)</li>\n<li><code>su -</code> 用户名称 (功能描述:切换到用户并获得该用户的环境变量及执行权限)</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>切换用户</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>root 超级用户</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209031827268.png\" alt=\"image-20220903182757221\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220903182757221</figcaption></figure>\n<p><strong>普通用户</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209031828923.png\" alt=\"image-20220903182828864\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220903182828864</figcaption></figure>\n<h2> <strong>userdel</strong> 删除用户</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>userdel</code> 用户名 (功能描述:删除用户但保存用户主目录)</li>\n<li><code>userdel -r</code> 用户名 <strong>2</strong>) (功能描述:用户和用户主目录，都删除</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-r</code></td>\n<td>删除用户的同时，删除与用户相关的所有文件。</td>\n</tr>\n<tr>\n<td><code>-c comment</code></td>\n<td>指定一段注释性描述。</td>\n</tr>\n<tr>\n<td><code>-d</code></td>\n<td>目录 指定用户主目录，如果此目录不存在，则同时使用-m 选项，可以创建主目录。</td>\n</tr>\n<tr>\n<td><code>-g</code></td>\n<td>用户组 指定用户所属的用户组。</td>\n</tr>\n<tr>\n<td><code>-G</code></td>\n<td>用户组，用户组 指定用户所属的附加组。</td>\n</tr>\n<tr>\n<td><strong><code>-m</code></strong></td>\n<td><strong>自动创建这个用户的主目录 /home/qinjiang</strong></td>\n</tr>\n<tr>\n<td><code>-s</code></td>\n<td>Shell 文件 指定用户的登录 Shell。</td>\n</tr>\n<tr>\n<td><code>-u</code></td>\n<td>用户号 指定用户的用户号，如果同时有-o 选项，则可以重复使用其他用户的标识号。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>删除用户但保存用户主目录</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>删除用户和用户主目录，都删除</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> <strong>who</strong> 查看登录用户信息</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>whoami</code> (功能描述:显示自身用户名称)</li>\n<li><code>who am i</code> (功能描述:显示登录用户的用户名以及登陆时间)</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>显示自身用户名称</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>显示登录用户的用户名</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> <strong>sudo</strong> 设置普通用户具有 <strong>root</strong> 权限</h2>\n<ul>\n<li>添加 <strong><code>atguigu</code></strong> 用户，并对其设置密码。</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>修改配置文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>修改 <code>/etc/sudoers</code> 文件，找到下面一行(91 行)，在 <code>root</code> 下面添加一行，如下所示:</p>\n<div class=\"language-visual line-numbers-mode\" data-ext=\"visual\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>或者配置成采用 <code>sudo</code> 命令时，不需要输入密码</p>\n<div class=\"language-visual line-numbers-mode\" data-ext=\"visual\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改完毕，现在可以用 <code>atguigu</code> 帐号登录，然后用命令 <code>sudo</code> ，即可获得 <code>root</code> 权限进行 操作。</p>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>用普通用户在<code>/opt</code> 目录下创建一个文件夹</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> <strong>usermod</strong> 修改用户</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>usermod -g</code> 用户组 用户名</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-g</code></td>\n<td>修改用户的初始登录组，给定的组必须存在。默认组 id 是 1。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>将用户加入到用户组</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 锁定账号</h2>\n<p><strong><code>root</code> 冻结这个账号，一旦冻结，这个人就登录不上系统了</strong></p>\n<p>可使用的选项：</p>\n<ul>\n<li><strong><code>-l</code> 锁定口令，即禁用账号。</strong></li>\n<li><code>-u</code> 口令解锁。</li>\n<li><code>-d</code> 使账号无口令。</li>\n<li><code>-f</code> 强迫用户下次登录时修改口令。</li>\n</ul>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>此命令将用户 <code>kuangshen</code>的口令删除，这样用户 <code>kuangshen</code>下一次登录时，系统就不再允许该用户登录了。</p>\n<p><code>passwd</code> 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录</p>\n<h2> 用户组管理</h2>\n<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 <code>Linux</code> 系统对用户组的规定有所不同，</p>\n<p>如<code>Linux</code>下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>\n<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对 <code>/etc/group</code>文件的更新。</p>\n<h2> <strong>groupadd</strong> 新增组</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>groupadd</code> 组名</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-m</code></td>\n<td>自动创建者用户的主目录 <code>/home/xiaohe</code></td>\n</tr>\n<tr>\n<td><code>-g</code></td>\n<td>给用户分配组！</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>添加一个<code>xitianqujing</code>组</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> groupdel 删除组</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>groupdel</code> 组名</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>删除<code>xitianqujing</code>组</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> groupmod 修改组</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>groupmod -n</code> 新组名 老组名</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-n&lt;新组名&gt;</code></td>\n<td>指定工作组的新组名</td>\n</tr>\n<tr>\n<td><code>-g</code></td>\n<td>GID 为用户组指定新的组标识号</td>\n</tr>\n<tr>\n<td><code>-o</code></td>\n<td>与<code>-g</code>选项同时使用，用户组的新 GID 可以与系统已有用户组的 GID 相同。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>修改<code>atguigu</code>组名称为<code>atguigu1</code></li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 查看创建了哪些组</h2>\n<p><strong>cat /etc/group</strong></p>\n<p><strong>基本操作</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 文件权限</h2>\n<h2> 文件属性</h2>\n<p><code>Linux</code>系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。 为了保护系统的安全性，<code>Linux</code>系统对不同的用户访问同一文件(包括目录文件)的权限做 了不同的规定。在<code>Linux</code>中我们可以使用<code>ll</code>或者 l<code>s -l</code>命令来显示一个文件的属性以及文件所属 的用户和组。</p>\n<p><strong>从左到右的 10 个字符表示</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209041105760.png\" alt=\"查看源图像\" tabindex=\"0\" loading=\"lazy\"><figcaption>查看源图像</figcaption></figure>\n<p>如果没有权限，就会出现减号<code>[ - ]</code>而已。从左至右用 0-9 这些数字来表示:</p>\n<ul>\n<li>0 首位表示类型\n<ul>\n<li>在<code>Linux</code>中第一个字符代表这个文件是目录、文件或链接文件等等</li>\n<li><code>-</code> 代表文件</li>\n<li><code>d</code> 代表目录</li>\n<li><code>l</code> 链接文档(<code>link file</code>)</li>\n</ul>\n</li>\n<li>第 1-3 位确定属主(该文件的所有者)拥有该文件的权限。---<code>User</code></li>\n<li>第 4-6 位确定属组(所有者的同组用户)拥有该文件的权限，---<code>Group</code></li>\n<li>第 7-9 位确定其他用户拥有该文件的权限 ---<code>Other</code></li>\n</ul>\n<p><strong>rwx 作用文件和目录的不同解释</strong></p>\n<ul>\n<li>\n<p>作用到文件:</p>\n<ul>\n<li><code>[ r ]</code>代表可读(<code>read</code>): 可以读取，查看</li>\n<li><code>[ w ]</code>代表可写(<code>write</code>): 可以修改，但是不代表可以删除该文件，删除一个文件的<strong>前提条件是对该文件所在的目录有写权限，才能删除该文件</strong></li>\n<li><code>[ x ]</code>代表可执行(<code>execute</code>):可以被系统执行</li>\n</ul>\n</li>\n<li>\n<p>作用到目录:</p>\n<ul>\n<li><code>[ r ]</code>代表可读(<code>read</code>): 可以读取，ls 查看目录内容</li>\n<li><code>[ w ]</code>代表可写(<code>write</code>): 可以修改，目录内创建+删除+重命名目录</li>\n<li><code>[ x ]</code>代表可执行(<code>execute</code>):可以进入该目录</li>\n</ul>\n</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209041112121.png\" alt=\"image-20220904111228091\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220904111228091</figcaption></figure>\n<ul>\n<li>如果查看到是文件:链接数指的是硬链接个数。</li>\n<li>如果查看的是文件夹:链接数指的是子文件夹个数。</li>\n</ul>\n<h2> <strong>chmod</strong> 改变权限</h2>\n<p><strong>基本语法</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209041113882.png\" alt=\"image-20220904111325854\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220904111325854</figcaption></figure>\n<ul>\n<li>第一种方式变更权限</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>第二种方式变更权限</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>经验技巧</strong></p>\n<ul>\n<li>u:所有者 g:所有组 o:其他人 a:所有人(u、g、o 的总和)</li>\n<li>r=4 w=2 x=1 rwx=4+2+1=7</li>\n</ul>\n<p>这里的 421 其实就是二进制的转换，每个选项上有值则为 1，‘-’则为 0。</p>\n<p>例如：rwx = 0111 = 7、 r-x = 0101 = 5 、r-x = 0101 = 5 ，所以得 755</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/202209041131915.png\" alt=\"image-20220904113147886\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220904113147886</figcaption></figure>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>修改文件使其所属主用户具有执行权限</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>修改文件使其所属组用户具有执行权限</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>修改文件所属主用户执行权限,并使其他用户具有执行权限</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>采用数字的方式，设置文件所有者、所属组、其他用户都具有可读可写可执行权限。</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>修改整个文件夹里面的所有文件的所有者、所属组、其他用户都具有可读可写可 执行权限。</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> <strong>chown</strong> 改变所有者</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>chown [选项] [最终用户] [文件或目录] （功能描述:改变文件或者目录的所有者）</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-R</td>\n<td>递归操作</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>修改文件所有者</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>递归改变文件所有者和所有组</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> chgrp 改变所属组</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>chgrp [最终用户组] [文件或目录]（功能描述:改变文件或者目录的所属组）</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>修改文件的所属组</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 压缩解压缩（频繁）</h2>\n<h2> <strong>gzip/gunzip</strong> 压缩</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>gzip</code> 文件 (功能描述:压缩文件，只能将文件压缩为<code>*.gz</code> 文件)</li>\n<li><code>gunzip</code> 文件<code>.gz</code> (功能描述:解压缩文件命令)</li>\n</ul>\n<p><strong>经验技巧</strong></p>\n<ul>\n<li>只能压缩文件不能压缩目录</li>\n<li>不保留原来的文件</li>\n<li>同时多个文件会产生多个压缩包</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li><code>gzip</code>压缩</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>gunzip 解压缩文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> <strong>zip/unzip</strong> 压缩</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>zip</code> [选项] <code>XXX.zip</code> 将要压缩的内容（功能描述:压缩文件和目录的命令）</li>\n<li><code>unzip</code> [选项] <code>XXX.zip</code> （功能描述:解压缩文件）</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>zip 选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-r</code></td>\n<td>压缩目录</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>unzip 选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-d</code>&lt;目录&gt;</td>\n<td>指定解压后文件的存放目录</td>\n</tr>\n</tbody>\n</table>\n<p><strong>经验技巧</strong></p>\n<ul>\n<li><code>zip</code> 压缩命令在<code>windows/linux</code>都通用，可以压缩目录且保留源文件。</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>压缩 <code>houge.txt</code> 和<code>bailongma.txt</code>，压缩后的名称为<code>mypackage.zip</code></li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>解压 <code>mypackage.zip</code></li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>解压<code>mypackage.zip</code>到指定目录<code>-d</code></li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> <strong>tar</strong> 打包</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>tar [选项] XXX.tar.gz 将要打包进去的内容 （功能描述:打包目录，压缩后的文件格式.tar.gz)</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-c</code></td>\n<td>产生<code>.tar</code> 打包文件</td>\n</tr>\n<tr>\n<td><code>-v</code></td>\n<td>显示详细信息</td>\n</tr>\n<tr>\n<td><code>-f</code></td>\n<td>指定压缩后的文件名 <code>-z</code> 打包同时压缩</td>\n</tr>\n<tr>\n<td><code>-x</code></td>\n<td>解包<code>.tar</code> 文件</td>\n</tr>\n<tr>\n<td><code>-C</code></td>\n<td>解压到指定目录</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>压缩多个文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>压缩目录</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>解压到当前目录</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>解压到指定目录</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 磁盘查看与分区</h2>\n<h2> du 查看文件和目录占用的磁盘空间</h2>\n<p><code>du: disk usage</code>磁盘占用情况</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>du</code> 目录/文件 （功能描述：显示目录下每个子目录的磁盘使用情况）</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-h</code></td>\n<td>以人们较易阅读的 <code>GBytes</code>, <code>MBytes</code>, <code>KBytes</code> 等格式自行显示；</td>\n</tr>\n<tr>\n<td><code>-a</code></td>\n<td>不仅查看子目录大小，还要包括文件</td>\n</tr>\n<tr>\n<td><code>-c</code></td>\n<td>显示所有的文件和子目录大小后，显示总和</td>\n</tr>\n<tr>\n<td><code>-s</code></td>\n<td>只显示总和</td>\n</tr>\n<tr>\n<td><code>--max-depth=n</code></td>\n<td>指定统计子目录的深度为第 n</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>查看当前用户主目录占用的磁盘空间大小</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> df 查看磁盘空间使用情况</h2>\n<p><code>df: disk free</code> 空余磁盘</p>\n<p><strong>基本语法</strong></p>\n<p><code>df</code> 选项 （功能描述：列出文件系统的整体磁盘使用量，检查文件系统的磁盘空间占 用情况)</p>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-h</code></td>\n<td>以人们较易阅读的 <code>GBytes</code>, <code>MBytes</code>, <code>KBytes</code> 等格式自行显示；</td>\n</tr>\n</tbody>\n</table>\n<h2> lsblk 查看设备挂载情况</h2>\n<p><strong>基本语法</strong></p>\n<p><code>lsblk</code> （功能描述：查看设备挂载情况）</p>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-f</code></td>\n<td>查看详细的设备挂载情况，显示文件系统信息</td>\n</tr>\n</tbody>\n</table>\n<h2> mount/umount 挂载/卸载</h2>\n<p>对于 Linux 用户来讲，不论有几个分区，分别分给哪一个目录使用，它总归就是一个根 目录、一个独立且唯一的文件结构。</p>\n<p>Linux 中每个分区都是用来组成整个文件系统的一部分，它在用一种叫做“挂载”的处理 方法，它整个文件系统中包含了一整套的文件和目录，并将一个分区和一个目录联系起来， 要载入的那个分区将使它的存储空间在这个目录下获得。</p>\n<p><strong>挂载前准备（必须要有光盘或者已经连接镜像文件）</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220905141419004.png\" alt=\"image-20220905141419004\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220905141419004</figcaption></figure>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220905141435031.png\" alt=\"image-20220905141435031\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220905141435031</figcaption></figure>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>mount [-t vfstype] [-o options] device dir</code> （功能描述：挂载设备）</li>\n<li><code>umount</code> 设备文件名或挂载点 （功能描述：卸载设备）</li>\n</ul>\n<p><strong>参数说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-t vfstyp</code></td>\n<td>指定文件系统的类型，通常不必指定。mount 会自动选择正确的类 型。</td>\n</tr>\n</tbody>\n</table>\n<p>常用类型有：<br>\n光盘或光盘镜像：iso9660<br>\nDOS fat16 文件系统：msdos<br>\nWindows 9x fat32 文件系统：vfat<br>\nWindows NT ntfs 文件系统：ntfs<br>\nMount Windows 文件网络共享：smbfs<br>\nUNIX(LINUX) 文件网络共享：nfs | | <code>-o options</code> | 主要用来描述设备或档案的挂接方式。<br>\n常用的参数有：<br>\n<code>loop</code>：用来把一个文件当成硬盘分区挂接上系统<br>\n<code>ro</code>：采用只读方式挂接设备<br>\n<code>rw</code>：采用读写方式挂接设备<br>\n<code>iocharset</code>：指定访问文件系统所用字符集 | | <code>device</code> | 要挂接<code>(mount)</code>的设备 | | <code>dir</code> | 设备在系统上的挂接点<code>(mount point)</code> |</p>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>挂载光盘镜像文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>卸载光盘镜像文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>设置开机自动挂载</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>添加红框中的内容，保存退出</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220905142329559.png\" alt=\"image-20220905142329559\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220905142329559</figcaption></figure>\n<h2> fdisk 分区</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>fdisk -l</code> （功能描述：查看磁盘分区详情）</li>\n<li><code>fdisk</code> 硬盘设备名 （功能描述：对新增硬盘进行分区操作）</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>-l</strong></td>\n<td>显示所有硬盘的分区列表</td>\n</tr>\n</tbody>\n</table>\n<p><strong>经验技巧</strong></p>\n<ul>\n<li>该命令必须在 root 用户下才能使用</li>\n</ul>\n<p><strong>功能说明</strong></p>\n<ul>\n<li>\n<p>Linux 分区</p>\n<ul>\n<li><code>Device</code>：分区序列</li>\n<li><code>Boot</code>：引导</li>\n<li><code>Start</code>：从 X 磁柱开始</li>\n<li><code>End</code>：到 Y 磁柱结束</li>\n<li><code>Blocks</code>：容量</li>\n<li><code>Id</code>：分区类型 ID</li>\n<li><code>System</code>：分区类型</li>\n</ul>\n</li>\n<li>\n<p>分区操作按键说明</p>\n<ul>\n<li><code>m</code>：显示命令列表</li>\n<li><code>p</code>：显示当前磁盘分区</li>\n<li><code>n</code>：新增分区</li>\n<li><code>w</code>：写入分区信息并退出</li>\n<li><code>q</code>：不保存分区信息直接退出</li>\n</ul>\n</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>查看系统分区情况</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 进程管理（频繁）</h2>\n<p>进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地 址空间，并占用一定的系统资源。</p>\n<h2> ps 查看当前系统进程状态</h2>\n<p><code>ps:process status</code> 进程</p>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>ps aux | grep xxx</code> （功能描述：查看系统中所有进程）</li>\n<li><code>ps -ef | grep xxx</code> （功能描述：可以查看子父进程之间的关系）</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>a</code></td>\n<td>列出带有终端的所有用户的进程</td>\n</tr>\n<tr>\n<td><code>x</code></td>\n<td>列出当前用户的所有进程</td>\n</tr>\n<tr>\n<td><code>u</code></td>\n<td>面向用户友好的显示风格</td>\n</tr>\n<tr>\n<td><code>-e</code></td>\n<td>列出所有进程</td>\n</tr>\n<tr>\n<td><code>-u</code></td>\n<td>列出某个用户关联的所有进程</td>\n</tr>\n<tr>\n<td><code>-f</code></td>\n<td>显示完整格式的进程列表</td>\n</tr>\n</tbody>\n</table>\n<p><strong>功能说明</strong></p>\n<ul>\n<li><code>ps aux</code> 显示信息说明\n<ul>\n<li><code>USER</code>：该进程是由哪个用户产生的</li>\n<li><code>PID</code>：进程的 ID 号</li>\n<li><code>%CPU</code>：该进程占用 CPU 资源的百分比，占用越高，进程越耗费资源；</li>\n<li><code>%MEM</code>：该进程占用物理内存的百分比，占用越高，进程越耗费资源；</li>\n<li><code>VSZ</code>：该进程占用虚拟内存的大小，单位 KB；</li>\n<li><code>RSS</code>：该进程占用实际物理内存的大小，单位 KB；</li>\n<li><code>TTY</code>：该进程是在哪个终端中运行的。对于 <code>CentOS</code> 来说，<code>tty1</code> 是图形化终端，</li>\n<li><code>tty2-tty6</code> 是本地的字符界面终端。<code>pts/0-255</code> 代表虚拟终端。</li>\n<li><code>STAT</code>：进程状态。常见的状态有：R：运行状态、S：睡眠状态、T：暂停状态、Z：僵尸状态、s：包含子进程、l：多线程、+：前台显示</li>\n<li><code>START</code>：该进程的启动时间</li>\n<li><code>TIME</code>：该进程占用 CPU 的运算时间，注意不是系统时间</li>\n<li><code>COMMAND</code>：产生此进程的命令名</li>\n</ul>\n</li>\n<li><code>ps -ef</code> 显示信息说明\n<ul>\n<li><code>UID</code>：用户 ID</li>\n<li><code>PID</code>：进程 ID</li>\n<li><code>PPID</code>：父进程 ID</li>\n<li><code>C</code>：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高</li>\n<li><code>STIME</code>：进程启动的时间</li>\n<li><code>TTY</code>：完整的终端名称</li>\n<li><code>TIME</code>：CPU 时间</li>\n<li><code>CMD</code>：启动进程所用的命令和参数</li>\n</ul>\n</li>\n</ul>\n<p><strong>经验技巧</strong></p>\n<ul>\n<li>如果想查看进程的 CPU 占用率和内存占用率，可以使用 aux</li>\n<li>如果想查看进程的父进程 ID 可以使用 e</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220905164243982.png\" alt=\"image-20220905164243982\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220905164243982</figcaption></figure>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220905164305340.png\" alt=\"image-20220905164305340\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220905164305340</figcaption></figure>\n<h2> kill 终止进程</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>kill</code> [选项] 进程号 （功能描述：通过进程号杀死进程）</li>\n<li><code>killall</code> 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这 在系统因负载过大而变得很慢时很有用)</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-9</code></td>\n<td>表示强迫进程立即停止</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>杀死浏览器进程</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>通过进程名称杀死进程</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> pstree 查看进程树</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>pstree</code> [选项]</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-p</code></td>\n<td>显示进程的 <code>PID</code></td>\n</tr>\n<tr>\n<td><code>-u</code></td>\n<td>显示进程的所属用户</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>显示进程 <code>pid</code></li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>显示进程所属用户</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> top 实时监控系统进程状态</h2>\n<p><strong>基本命令</strong></p>\n<ul>\n<li><code>top</code> [选项]</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-d</code></td>\n<td>秒数 指定 top 命令每隔几秒更新。默认是 3 秒在 top 命令的交互模式当中可以执行的命令：</td>\n</tr>\n<tr>\n<td><code>i</code></td>\n<td>使 top 不显示任何闲置或者僵死进程。</td>\n</tr>\n<tr>\n<td><code>-p</code></td>\n<td>通过指定监控进程 ID 来仅仅监控某个进程的状态。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>操作说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>P</code></td>\n<td>以 <code>CPU</code> 使用率排序，默认就是此项</td>\n</tr>\n<tr>\n<td><code>M</code></td>\n<td>以内存的使用率排序</td>\n</tr>\n<tr>\n<td><code>N</code></td>\n<td>以 <code>PID</code> 排序</td>\n</tr>\n<tr>\n<td><code>q</code></td>\n<td>退出 <code>top</code></td>\n</tr>\n</tbody>\n</table>\n<p><strong>查询结果字段解释</strong></p>\n<ul>\n<li>第一行信息为任务队列信息</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>内容</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>12:26:46</code></td>\n<td>系统当前时间</td>\n</tr>\n<tr>\n<td><code>up 1 day, 13:32</code></td>\n<td>系统的运行时间，本机已经运行 1 天 13 小时 32 分钟</td>\n</tr>\n<tr>\n<td><code>2 users</code></td>\n<td>当前登录了两个用户</td>\n</tr>\n<tr>\n<td><code>load average: 0.00, 0.00, 0.00</code></td>\n<td>系统在之前 1 分钟，5 分钟，15 分钟的平均负载。一般认为小于 1 时，负载较小。如果大于 1，系统已经超出负荷。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>第二行为进程信息</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>内容</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Tasks: 95 total</code></td>\n<td>系统中的进程总数</td>\n</tr>\n<tr>\n<td><code>1 running</code></td>\n<td>正在运行的进程数</td>\n</tr>\n<tr>\n<td><code>94 sleeping</code></td>\n<td>睡眠的进程</td>\n</tr>\n<tr>\n<td><code>0 stopped</code></td>\n<td>正在停止的进程</td>\n</tr>\n<tr>\n<td><code>0 zombie</code></td>\n<td>僵尸进程。如果不是 0，需要手工检查僵尸进</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>第三行为 CPU 信息</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>内容</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Cpu(s): 0.1%us</code></td>\n<td>用户模式占用的 CPU 百分比</td>\n</tr>\n<tr>\n<td><code>0.1%sy</code></td>\n<td>系统模式占用的 CPU 百分比</td>\n</tr>\n<tr>\n<td><code>0.0%ni</code></td>\n<td>改变过优先级的用户进程占用的 CPU 百分比</td>\n</tr>\n<tr>\n<td><code>99.7%id</code></td>\n<td>空闲 CPU 的 CPU 百分比</td>\n</tr>\n<tr>\n<td><code>0.1%wa</code></td>\n<td>等待输入/输出的进程的占用 CPU 百分比</td>\n</tr>\n<tr>\n<td><code>0.0%hi</code></td>\n<td>硬中断请求服务占用的 CPU 百分比</td>\n</tr>\n<tr>\n<td><code>0.1%si</code></td>\n<td>软中断请求服务占用的 CPU 百分</td>\n</tr>\n<tr>\n<td><code>0.0%st st（Steal time）</code></td>\n<td>虚拟时间百分比。就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>第四行为物理内存信息</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>内容</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Mem: 625344k total</code></td>\n<td>物理内存的总量，单位 KB</td>\n</tr>\n<tr>\n<td><code>571504k used</code></td>\n<td>已经使用的物理内存数量</td>\n</tr>\n<tr>\n<td><code>53840k free</code></td>\n<td>空闲的物理内存数量，我们使用的是虚拟机，总共只分配了 628MB 内存，所以只有 53MB 的空闲内存了</td>\n</tr>\n<tr>\n<td><code>65800k buffers</code></td>\n<td>作为缓冲的内存数量</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>第五行为交换分区（swap）信息</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>内容</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Swap: 524280k total</code></td>\n<td>交换分区（虚拟内存）的总大小</td>\n</tr>\n<tr>\n<td><code>0k used</code></td>\n<td>已经使用的交互分区的大小</td>\n</tr>\n<tr>\n<td><code>524280k free</code></td>\n<td>空闲交换分区的大小</td>\n</tr>\n<tr>\n<td><code>409280k cached</code></td>\n<td>作为缓存的交互分区的大小</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>执行上述命令后，可以按 P、M、N 对查询出的进程结果进行排</p>\n<h2> netstat 显示网络状态和端口占用信息</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>netstat -anp | grep</code> 进程号 （功能描述：查看该进程网络)</li>\n<li><code>netstat –nlp | grep</code> 端口号 （功能描述：查看网络端口号占用情况)</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-a</code></td>\n<td>显示所有正在监听（listen）和未监听的套接字（socket）</td>\n</tr>\n<tr>\n<td><code>-n</code></td>\n<td>拒绝显示别名，能显示数字的全部转化成数字</td>\n</tr>\n<tr>\n<td><code>-l</code></td>\n<td>仅列出在监听的服务状态</td>\n</tr>\n<tr>\n<td><code>-p</code></td>\n<td>表示显示哪个进程在调用</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>通过进程号查看 sshd 进程的网络信息</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>查看某端口号是否被占用</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> crontab 系统定时任务</h2>\n<h2> crontab 服务管理</h2>\n<ul>\n<li>crontab 服务管理</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> crontab 定时任务设置</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>crontab</code> [选项</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-e</code></td>\n<td>编辑 <code>crontab</code> 定时任务</td>\n</tr>\n<tr>\n<td><code>-l</code></td>\n<td>查询 <code>crontab</code> 任务</td>\n</tr>\n<tr>\n<td><code>-r</code></td>\n<td>删除当前用户所有的 <code>crontab</code> 任务</td>\n</tr>\n</tbody>\n</table>\n<p><strong>参数说明</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>进入 crontab 编辑界面。会打开 vim 编辑你的工作。例如：<code>*****</code>执行的任务</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>含义</th>\n<th>范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第一个“*”</td>\n<td>一小时当中的第几分钟</td>\n<td>0-59</td>\n</tr>\n<tr>\n<td>第二个“*”</td>\n<td>一天当中的第几小时</td>\n<td>0-23</td>\n</tr>\n<tr>\n<td>第三个“*”</td>\n<td>一个月当中的第几天</td>\n<td>1-31</td>\n</tr>\n<tr>\n<td>第四个“*”</td>\n<td>一年当中的第几月</td>\n<td>1-12</td>\n</tr>\n<tr>\n<td>第五个“*”</td>\n<td>一周当中的星期几</td>\n<td>0-7（ 0 和 7 都 代 表 星 期日）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>特殊符号</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特殊符</th>\n<th>号 含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>*</code></td>\n<td>代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一次的意思。</td>\n</tr>\n<tr>\n<td><code>，</code></td>\n<td>代表不连续的时间。比如“<code>0 8,12,16 * * * 命令</code>”，</td>\n</tr>\n<tr>\n<td>就代表在每天的 8 点 0 分，12 点 0 分，16 点 0 分都执行一次命令</td>\n<td></td>\n</tr>\n<tr>\n<td><code>-</code></td>\n<td>代表连续的时间范围。比如“<code>0 5 * * 1-6 命令</code>”，代表在周一到周六的凌晨 5 点 0 分执行命令</td>\n</tr>\n<tr>\n<td><code>*/n</code></td>\n<td>代表每隔多久执行一次。比如“<code>_/10 _ * * * 命令</code>”，代表每隔 10 分钟就执行一遍命令</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>特定时间执行命令</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>45 22 * * * 命令</code></td>\n<td>每天 22 点 45 分执行命令</td>\n</tr>\n<tr>\n<td><code>0 17 * * 1 命令</code></td>\n<td>每周 1 的 17 点 0 分执行命令</td>\n</tr>\n<tr>\n<td><code>0 5 1,15 * * 命令</code></td>\n<td>每月 1 号和 15 号的凌晨 5 点 0 分执行命令</td>\n</tr>\n<tr>\n<td><code>40 4 * * 1-5 命令</code></td>\n<td>每周一到周五的凌晨 4 点 40 分执行命令</td>\n</tr>\n<tr>\n<td><code>*/10 4 * * * 命令</code></td>\n<td>每天的凌晨 4 点，每隔 10 分钟执行一次命令</td>\n</tr>\n<tr>\n<td><code>0 0 1,15 * 1 命令</code></td>\n<td>每月 1 号和 15 号，每周 1 的 0 点 0 分都会执行命令。注意：星期几和几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>每隔 1 分钟，向<code>/root/bailongma.txt</code> 文件中添加一个 11 的数字</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 软件包管理（频繁）</h2>\n<h2> RPM 包管理</h2>\n<p><code>RPM（RedHat Package Manager）</code>，<code>RedHat</code>软件包管理工具，类似<code>windows</code>里面的<code>setup.exe</code> 是<code>Linux</code>这系列操作系统里面的打包安装工具，它虽然是<code>RedHat</code>的标志，但理念是通用的。 <code>RPM</code>包的名称格式 <code>Apache-1.3.23-11.i386.rpm</code></p>\n<ul>\n<li><code>“apache”</code> 软件名称</li>\n<li><code>“1.3.23-11”</code>软件的版本号，主版本和此版本</li>\n<li><code>“i386”</code>是软件所运行的硬件平台，<code>Intel</code> 32 位处理器的统称</li>\n<li><code>“rpm”</code>文件扩展名，代表 RPM 包</li>\n</ul>\n<h3> 查询命令（rpm -qa）</h3>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>rpm -qa</code> （功能描述：查询所安装的所有 rpm 软件包）</li>\n</ul>\n<p><strong>经验技巧</strong></p>\n<ul>\n<li>由于软件包比较多，一般都会采取过滤。<code>rpm -qa | grep rpm</code>软件包</li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>查询<code>firefox</code>软件安装情况</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 卸载命令（rpm -e）</h3>\n<p><strong>基本语法</strong></p>\n<ul>\n<li><code>rpm -e</code> RPM 软件</li>\n<li><code>rpm -e --nodeps</code> 软件</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-e</code></td>\n<td>卸载软件包</td>\n</tr>\n<tr>\n<td><code>--nodeps</code></td>\n<td>卸载软件时，不检查依赖。这样的话，那些使用该软件包的软件在此之后可能就不能正常工作了。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>卸载<code>firefox</code>软件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 安装命令（rpm -ivh）</h3>\n<p><strong>基本语法</strong></p>\n<p><code>rpm -ivh</code> RPM 包全名</p>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-i</code></td>\n<td><code>install</code>，安装</td>\n</tr>\n<tr>\n<td><code>-v</code></td>\n<td><code>--verbose</code>，显示详细信息</td>\n</tr>\n<tr>\n<td><code>-h</code></td>\n<td><code>--hash</code>，进度条</td>\n</tr>\n<tr>\n<td><code>--nodeps</code></td>\n<td>安装前不检查依赖</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>安装<code>firefox</code>软件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> YUM 仓库配置</h2>\n<p>YUM（全称为 <code>Yellow dog Updater, Modified）</code>是一个在 <code>Fedora</code> 和 <code>RedHat</code> 以及 <code>CentOS</code> 中的 <code>Shell</code> 前端软件包管理器。基于 <code>RPM</code> 包管理，能够从指定的服务器自动下载 RPM 包 并且安装，<strong>可以自动处理依赖性关系</strong>，并且一次安装所有依赖的软件包，无须繁琐地一次 次下载、安装。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220905173104955.png\" alt=\"image-20220905173104955\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220905173104955</figcaption></figure>\n<h3> 常用命令</h3>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>yum [选项] [参数]</li>\n</ul>\n<p><strong>选项说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-y</code></td>\n<td>对所有提问都回答“yes\"</td>\n</tr>\n</tbody>\n</table>\n<p><strong>参数说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>install</code></td>\n<td>安装 <code>rpm</code> 软件包</td>\n</tr>\n<tr>\n<td><code>update</code></td>\n<td>更新 <code>rpm</code> 软件包</td>\n</tr>\n<tr>\n<td><code>check-update</code></td>\n<td>检查是否有可用的更新 <code>rpm</code> 软件包</td>\n</tr>\n<tr>\n<td><code>remove</code></td>\n<td>删除指定的 <code>rpm</code> 软件包</td>\n</tr>\n<tr>\n<td><code>list</code></td>\n<td>显示软件包信息</td>\n</tr>\n<tr>\n<td><code>clean</code></td>\n<td>清理 <code>yum</code> 过期的缓存</td>\n</tr>\n<tr>\n<td><code>deplist</code></td>\n<td>显示 <code>yum</code> 软件包的所有依赖关系</td>\n</tr>\n</tbody>\n</table>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>采用 <code>yum</code> 方式安装 <code>firefox</code></li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 修改网络 YUM 源</h3>\n<p>默认的系统 YUM 源，需要连接国外 <code>apache</code> 网站，网速比较慢，可以修改关联的网络 YUM 源为国内镜像的网站，比如网易 <code>163</code>,<code>aliyun</code> 等</p>\n<ul>\n<li>安装 <code>wget</code>, <code>wget</code> 用来从指定的 <code>URL</code> 下载文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>在<code>/etc/yum.repos.d/</code>目录下，备份默认的 <code>repos</code> 文件</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>下载网易 163 或者是 <code>aliyun</code> 的 <code>repos</code> 文件,任选其一</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20220905173807424.png\" alt=\"image-20220905173807424\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220905173807424</figcaption></figure>\n<ul>\n<li>使用下载好的 <code>repos</code> 文件替换默认的 <code>repos</code> 文件。例如:用 <code>CentOS7-Base-163.repo</code> 替换 <code>CentOS-Base.rep</code></li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>清理旧缓存数据，缓存新数据</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>测试</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://static.h7ml.cn/vitepress/assets/images/linux/202209031822555.png",
      "date_published": "2021-06-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "linux"
      ]
    },
    {
      "title": "NAS",
      "url": "https://www.h7ml.cn/posts/linux/nas.html",
      "id": "https://www.h7ml.cn/posts/linux/nas.html",
      "summary": "NAS 主要用于 Docker 服务、影视管理和文件存储备用这三方面。群晖 NAS 在使用前，注意以下几点： 选择「控制面板」&gt;「文件服务」&gt;「SMB」&gt;「高级设置」，将最小 SMB 协议 设为 SMB1，避免部分应用发现了 NAS 但无法打开共享文件。 选择「控制面板」&gt;「任务计划」&gt;「新增」&gt;「计划的任务」&gt;「用户定义的脚本」，给 NAS 建立定时任务脚本。 SSD 缓存对家用的 NAS 性能提升不大，没必要加。 DS/Transmission 套件：用于 PT 下载 (禁用 DHT，半小时停止做种)。 Synology Drive Server 套件：电脑文件备份。 Hyper Backup：本地多硬盘备份，防止一个硬盘丢失后重要文件损坏，比如 docker 容器的本地配置文件夹。 群晖系统分布在所有硬盘，拔出一个不影响使用。但应用会有影响？",
      "content_html": "<p>NAS 主要用于 Docker 服务、影视管理和文件存储备用这三方面。群晖 NAS 在使用前，注意以下几点：</p>\n<ul>\n<li>选择「控制面板」&gt;「文件服务」&gt;「SMB」&gt;「高级设置」，将最小 SMB 协议 设为 SMB1，避免部分应用发现了 NAS 但无法打开共享文件。</li>\n<li>选择「控制面板」&gt;「任务计划」&gt;「新增」&gt;「计划的任务」&gt;「用户定义的脚本」，给 NAS 建立定时任务脚本。</li>\n<li>SSD 缓存对家用的 NAS 性能提升不大，没必要加。</li>\n<li>DS/Transmission 套件：用于 PT 下载 (禁用 DHT，半小时停止做种)。</li>\n<li>Synology Drive Server 套件：电脑文件备份。</li>\n<li>Hyper Backup：本地多硬盘备份，防止一个硬盘丢失后重要文件损坏，比如 docker 容器的本地配置文件夹。</li>\n<li>群晖系统分布在所有硬盘，拔出一个不影响使用。但应用会有影响？</li>\n</ul>\n<h2> NAS Docker</h2>\n<p>NAS Docker 建议指定本地端口，否则重启容器会让端口发生改变，重启不会不影响 docker 配置。升级容器镜像，不影响内部数据库。群晖的「Docker 导出」只会导出安装镜像和配置，但不包括容器内部使用的数据库，用处不大。</p>\n<p><strong>Docker 容器安装</strong>：</p>\n<p>推荐用 <code>docker-compose.yml</code> 安装 Docker，镜像会自动同步到 NAS 的容器列表中。docker-compose 使用参考 <a href=\"http://ttrss.henry.wang/zh/#%E9%80%9A%E8%BF%87-docker-compose-%E9%83%A8%E7%BD%B2\" target=\"_blank\" rel=\"noopener noreferrer\">TTRSS docker-composeopen in new window</a>。</p>\n<ol>\n<li>选择「控制面板」&gt;「终端机和 SNMP」，启动 SSH 功能。</li>\n<li>putty 连接群晖 SSH，进入 <code>docker-compose.yml</code> 所在路径，比如 <code>cd /volume3/storage</code>。</li>\n<li>通过终端在同目录下运行 <code>sudo docker-compose up -d</code> 后等待部署完成。</li>\n<li>关闭 SSH 功能。</li>\n</ol>\n<p>注意：root 用户需在命令前添加 <code>sudo</code>，否则会提示 <code>Permission denied</code>。</p>\n<h2> Docker 容器</h2>\n<h3> 常用</h3>\n<ul>\n<li><a href=\"https://registry.hub.docker.com/r/linuxserver/qbittorrent/\" target=\"_blank\" rel=\"noopener noreferrer\">qbittorrentopen in new window</a>：需修改所有默认端口，否则容易报错。PT 下载关闭 <code>BitTorrent - DHT</code> 和其他隐私选项，半小时停止做种，将下载文件添加 Everyone 权限，其他设置参考 <a href=\"https://blog.csdn.net/weixin_45120915/article/details/114691473\" target=\"_blank\" rel=\"noopener noreferrer\">群晖使用 qbittorrentopen in new window</a>。</li>\n<li><a href=\"https://docs.photoprism.app/\" target=\"_blank\" rel=\"noopener noreferrer\">PhotoPrismopen in new window</a>：基于 ai 私有化部署的个人相册。如果部署时出错，则尝试删除数据库文件夹下的内容。地点标记功能非常强大，类似本地版 Google Photos。</li>\n<li><a href=\"https://github.com/AragonSnow/qiandao\" target=\"_blank\" rel=\"noopener noreferrer\">qiandaoopen in new window</a>：自动签到开源框架，需搭配浏览器扩展 <a href=\"https://github.com/ckx000/get-cookies\" target=\"_blank\" rel=\"noopener noreferrer\">get-cookiesopen in new window</a> 使用，可导出配置。</li>\n<li><a href=\"https://containrrr.dev/watchtower/\" target=\"_blank\" rel=\"noopener noreferrer\">watchtoweropen in new window</a>：监控并更新 Docker 容器。\n<ul>\n<li>监控指定名称的镜像：<code>docker run -d --name watchtower -v /var/run/docker.sock:/var/run/docker.sock containrrr/watchtower --cleanup --run-once nginx redis</code>。本案例只更新名为「nginx」和「redis」的容器，其他容器将被忽略。</li>\n<li>指定容器的 compose 命令中添加 lable <code>com.centurylinklabs.watchtower.enable=false</code>，可禁止该容器的监控和更新。</li>\n</ul>\n</li>\n</ul>\n<h3> 资讯</h3>\n<ul>\n<li>RSSHub：无需保存数据，pubData 为 GMT 时区，普通用户无法更改，Docker Timezone 设置也不会有改变。</li>\n<li>Huginn：定期备份抓取脚本，数据库保存在本地。</li>\n<li>Tiny Tiny RSS：定期备份订阅源和设置，自动更新，可配置全文插件 <a href=\"https://registry.hub.docker.com/r/wangqiru/mercury-parser-api\" target=\"_blank\" rel=\"noopener noreferrer\">mercury-parser-apiopen in new window</a>。</li>\n<li><a href=\"https://github.com/easychen/checkchan-dist\" target=\"_blank\" rel=\"noopener noreferrer\">Check 酱 open in new window</a>：监测网页内容变化，并发送异动到微信。亦支持 http status、json 和 rss 监测。配合自架云端，关电脑后也能运行。同类工具有 <a href=\"https://github.com/dgtlmoon/changedetection.io\" target=\"_blank\" rel=\"noopener noreferrer\">changedetection.ioopen in new window</a>。</li>\n</ul>\n<h3> 娱乐</h3>\n<ul>\n<li><a href=\"https://github.com/alist-org/alist\" target=\"_blank\" rel=\"noopener noreferrer\">AListopen in new window</a>：开源的网盘管理工具，还支持对象存储，本地存储，FTP 等等。</li>\n<li><a href=\"https://github.com/Difegue/LANraragi\" target=\"_blank\" rel=\"noopener noreferrer\">LANraragiopen in new window</a>：免费开源的漫画管理器，支持 zip/rar/targz/lzma/7z/xz/cbz/cbr/pdf 多种格式，可从网页和 <a href=\"https://github.com/Difegue/LANraragi/blob/32cc991e8c5bae3bbd57d163278048c50159ae9f/tools/Documentation/advanced-usage/external-readers.md\" target=\"_blank\" rel=\"noopener noreferrer\">第三方客户端 open in new window</a> 浏览。</li>\n<li><a href=\"https://github.com/Suwayomi/docker-tachidesk\" target=\"_blank\" rel=\"noopener noreferrer\">Tachiyomiopen in new window</a>：开源的漫画阅读应用，通过安装扩展插件，可以方便地订阅并聚合漫画源。使用前，需进入 Extensions，点右上角的 Enabled Languages 按钮，设置为中文源，然后会在页面底部发现中文漫画源。安装源后，进入 Souces 中点击进入对应源。</li>\n<li><a href=\"https://github.com/hectorqin/reader\" target=\"_blank\" rel=\"noopener noreferrer\">readeropen in new window</a>：阅读 3 的服务器版，摆脱客户端，网页版即可查看。自定义替换进入文章页面左侧的「设置」-「过滤规则管理」。</li>\n<li><a href=\"https://github.com/talebook/talebook\" target=\"_blank\" rel=\"noopener noreferrer\">Tale Bookopen in new window</a>：基于 Calibre 的简单的个人图书管理系统，支持在线阅读，但阅读体验不强且 Bug 较多，个人更喜欢直接用 PC 端查看。</li>\n<li><a href=\"https://github.com/zzcabc/Docker_Buildx_Danmuji\" target=\"_blank\" rel=\"noopener noreferrer\">Bilibili_Danmujiopen in new window</a>：B 站直播礼物答谢、定时广告、关注感谢，自动回复工具，房管工具，自动打卡，Bilibili 直播弹幕姬 (使用 websocket 协议)，java 版 B 站弹幕姬。部署 Docker 时需更新 jdr release 文件。</li>\n</ul>\n<h3> 自动化</h3>\n<ul>\n<li><a href=\"https://blog.csdn.net/alex_yangchuansheng/article/details/122295193\" target=\"_blank\" rel=\"noopener noreferrer\">n8nopen in new window</a>：开源 IFTTT 工具，偏重于云服务。</li>\n<li><a href=\"https://github.com/monicahq/monica\" target=\"_blank\" rel=\"noopener noreferrer\">Monicaopen in new window</a>：Monica 允许人们记录所有关于朋友和家人的重要事情。喜欢和他们一起的活动。你最后一次打电话给某人的时候，你们谈了些什么。它会帮助你记住他们孩子的名字和年龄。它还能提醒你打电话给一个很久没联系的人。Monica 的容器设置查看 <a href=\"https://github.com/monicahq/docker\" target=\"_blank\" rel=\"noopener noreferrer\">Monica Dockeropen in new window</a>。</li>\n<li><a href=\"https://supermanito.github.io/Helloworld/#/\" target=\"_blank\" rel=\"noopener noreferrer\">supermanito/Helloworldopen in new window</a>：京东签到等脚本，功能很强大，没怎么研究。</li>\n<li><a href=\"https://registry.hub.docker.com/r/dorowu/ubuntu-desktop-lxde-vnc\" target=\"_blank\" rel=\"noopener noreferrer\">ubuntu-desktop-lxde-vncopen in new window</a>：能在 Docker 上运行的 Ubuntu 桌面版，适合挂载要长期运行的程序。测试 OBS 时，对内存要求不高，但 CPU 直冲 100%，fps 只有 7。</li>\n</ul>\n<h3> 待了解</h3>\n<ul>\n<li><a href=\"https://github.com/lsky-org/lsky-pro\" target=\"_blank\" rel=\"noopener noreferrer\">兰空图床 open in new window</a>：图床已经部署在七牛云，用 Picgo 上传，没感觉有必要用它。</li>\n<li><a href=\"https://github.com/EstrellaXD/Auto_Bangumi\" target=\"_blank\" rel=\"noopener noreferrer\">AutoBangumiopen in new window</a>：自动追番器，用以替代自我审查的 Bilibili。</li>\n<li><a href=\"https://github.com/jxxghp/nas-tools/wiki/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B\" target=\"_blank\" rel=\"noopener noreferrer\">nas-toolsopen in new window</a>：号称能自动整理文件，但测试识别中很容易出错，暂不考虑。</li>\n<li>Emby、Plex：流媒体方案，暂不考虑。</li>\n<li>Clash：代理服务器。</li>\n</ul>\n<h2> 影视整理</h2>\n<p>下载文件后，用 tinyMediaManager 重命名并下载 NFO 和影视封面，最后放置于分类文件夹。</p>\n<p><a href=\"https://www.tinymediamanager.org/download/\" target=\"_blank\" rel=\"noopener noreferrer\">tinyMediaManageropen in new window</a> v4 免费版足够个人使用，v3 作偶尔补充使用，搜索首选语言改为「大陆简体」更精准。<a href=\"#footnote1\">[1]</a></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> NAS 硬盘</h2>\n<p>插入新硬盘，新建储存空间，使用 Btrfs 或 Basic 格式。SHR 是群晖的智能 RAID 格式，不适用于硬盘容量不同的情况。</p>\n<table>\n<thead>\n<tr>\n<th>硬盘</th>\n<th>容量</th>\n<th>到期时间（5 年）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>硬盘 1</td>\n<td>10T</td>\n<td>2025-06-18</td>\n</tr>\n<tr>\n<td>硬盘 2</td>\n<td>4T</td>\n<td>2023-01-24</td>\n</tr>\n<tr>\n<td>硬盘 3</td>\n<td>14T</td>\n<td>2027-02-11</td>\n</tr>\n<tr>\n<td>硬盘 4</td>\n<td>8T</td>\n<td>2026-01-06</td>\n</tr>\n<tr>\n<td>冷备份</td>\n<td>2T</td>\n<td>2014-10</td>\n</tr>\n</tbody>\n</table>\n<p>换下的机械硬盘做冷备份，存储照片等长期数据。</p>\n<p>硬盘临期后，用大容量硬盘替换。选择「存储池」&gt;「更改 RAID 类型」，无损转换 basic 到 Raid1。不过，不同容量硬盘组 RAID，只能以最小磁盘容量计使用空间。</p>\n<p>更换硬盘后，注意将数据连同文件夹用 file station 复制过去 (按住 Shift 选中所有你要的文件点右键 移动到...)，关机卸载旧盘。如果该硬盘涉及套件位置，注意检查设置。<a href=\"#footnote2\">[2]</a></p>\n<p>共享文件迁移：选择「控制面板」&gt;「共享文件夹」，把你的共享文件夹位置修改到新储存空间。<a href=\"#footnote3\">[3]</a></p>\n<hr>\n<ol>\n<li>\n<p><a href=\"https://post.smzdm.com/p/a0d67m2z/\" target=\"_blank\" rel=\"noopener noreferrer\">群晖 NAS 使用 Emby+tMM 打造全平台观影畅爽体验（附下载地址）open in new window</a> <a href=\"#footnote-ref1\">↩︎</a></p>\n</li>\n<li>\n<p><a href=\"https://www.bigzhang.com/3264.html\" target=\"_blank\" rel=\"noopener noreferrer\">如何把群晖 NAS 上的套件搬到另外个硬盘上 open in new window</a> <a href=\"#footnote-ref2\">↩︎</a></p>\n</li>\n<li>\n<p><a href=\"https://blog.csdn.net/hilaryfrank/article/details/109722319\" target=\"_blank\" rel=\"noopener noreferrer\">群晖 NAS 跨存储空间移动共享文件夹 (NAS 新增磁盘)open in new window</a> <a href=\"#footnote-ref3\">↩︎</a></p>\n</li>\n</ol>\n",
      "date_published": "2023-01-19T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "linux"
      ]
    },
    {
      "title": "Linux-Shell编程",
      "url": "https://www.h7ml.cn/posts/linux/shell.html",
      "id": "https://www.h7ml.cn/posts/linux/shell.html",
      "summary": "Shell Shell 概述 image-20221026104446000 Linux 提供的 Shell 解析器有 /bin/sh /bin/bash /usr/bin/sh /usr/bin/bash /bin/tcsh /bin/csh",
      "content_html": "<h2> Shell</h2>\n<h2> Shell 概述</h2>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/linux/image-20221026104446000.png\" alt=\"image-20221026104446000\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221026104446000</figcaption></figure>\n<ul>\n<li>Linux 提供的 Shell 解析器有</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>bash 和 sh 的关系</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>Centos 默认的解析器是 bash</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Shell 入门</h2>\n<p>脚本格式</p>\n<h3> 第一个 Shell</h3>\n<p><strong>脚本：helloworld.s</strong></p>\n<p>创建一个 Shell 脚本，输出 helloworld</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 <a href=\"http://helloworld.sh\" target=\"_blank\" rel=\"noopener noreferrer\">helloworld.sh</a> 中输入如下内容</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>脚本的常用执行方式</strong></p>\n<h4> 第一种</h4>\n<p>采用 bash 或 sh+脚本的相对路径或绝对路径（不用赋予脚本+x 权限） sh+脚本的相对路径</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>sh+脚本的绝对路径</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>bash+脚本的相对路径</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>bash+脚本的绝对路径</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 第二种</h4>\n<p>采用输入脚本的绝对路径或相对路径执行脚本**（必须具有可执行权限+x)**</p>\n<p>首先要赋予 <code>helloworld.sh</code> 脚本的+x 权限</p>\n<p><strong>执行脚本</strong></p>\n<p>相对路径</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>绝对路径</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>WARNING</p>\n<p>注意：第一种执行方法，本质是 bash 解析器帮你执行脚本，所以脚本本身不需要执行 权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。</p>\n<h4> 第三种</h4>\n<p>在脚本的路径前加上“.”或者 sourc</p>\n<p>有以下脚本</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>分别使用 sh，bash，./ 和 . 的方式来执行，结果如下：</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>原因：</strong></p>\n<ul>\n<li>前两种方式都是在当前 <code>shell</code> 中打开一个子 <code>shell</code> 来执行脚本内容，当脚本内容结束，则子 <code>shell</code> 关闭，回到父 <code>shell</code> 中。</li>\n<li>第三种，也就是使用在脚本路径前加“.”或者 <code>source</code> 的方式，**可以使脚本内容在当前<code>shell</code> 里执行，而无需打开子 <code>shell！</code>**这也是为什么我们每次要修改完<code>/etc/profile</code> 文件以后，需要 <code>source</code> 一下的原因。</li>\n<li>开子 <code>shell</code> 与不开子 <code>shell</code> 的区别就在于，环境变量的继承关系，如在子 <code>shell</code> 中设置的当前变量，父 <code>shell</code> 是不可见的</li>\n</ul>\n<h2> 变量</h2>\n<h2> 系统预定义变量</h2>\n<p>常用系统变量 PWD、USER...</p>\n<ul>\n<li>查看系统变量的值</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>显示当前 Shell 中所有变量：set</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 自定义变量</h2>\n<p><strong>基本语法</strong></p>\n<ul>\n<li>定义变量：变量名=变量值，<strong>注意，=号前后不能有空格</strong></li>\n<li>撤销变量：unset 变量名</li>\n<li>声明静态变量：readonly 变量，<strong>注意：不能 unset</strong></li>\n</ul>\n<p><strong>变量定义规则</strong></p>\n<ul>\n<li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头，<strong>环境变量名建议大写</strong>。</li>\n<li>等号两侧不能有空格</li>\n<li>在 bash 中，<strong>变量默认类型都是字符串类型，无法直接进行数值运算</strong>。</li>\n<li>变量的值<strong>如果有空格，需要使用双引号或单引号括起来</strong></li>\n</ul>\n<p><strong>案例实操</strong></p>\n<ul>\n<li>定义变量 A</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>给变量 A 重新赋值</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>撤销变量 A</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>声明静态的变量 B=2，不能 unset</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>变量的值如果有空格，需要使用双引号或单引号括起来</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>可把变量提升为全局环境变量，可供其他 Shell 程序使用，<strong>export 变量名</strong></li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>发现并没有打印输出变量 B 的值。</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>TIP</p>\n<p>在子 <code>Shell</code> 中声明或者改变全局的变量<strong>都不会影响父 <code>Shell</code> 中的变量</strong></p>\n<h2> 字符串</h2>\n<p>字符串是 shell 编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。</p>\n<h3> 单引号</h3>\n<p>单引号字符串的限制：</p>\n<ul>\n<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>\n<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li>\n</ul>\n<h3> 双引号</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>双引号的优点：</p>\n<ul>\n<li>双引号里可以有变量</li>\n<li>双引号里可以出现转义字符</li>\n</ul>\n<h2> 数组</h2>\n<p><code>bash</code>支持一维数组**（不支持多维数组）<strong>，并且</strong>没有限定数组的大小**。</p>\n<p>类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p>\n<h3> 定义数组</h3>\n<p>在 Shell 中，用括号来表示数组，数组元素用\"空格\"符号分割开。定义数组的一般形式为：</p>\n<p>例如：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>或者</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>还可以单独定义数组的各个分量：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以不使用连续的下标，而且下标的范围没有限制。</p>\n<h3> 读取数组</h3>\n<p>读取数组元素值的一般格式是：</p>\n<p>例如：</p>\n<p>使用 <strong>@</strong> 符号可以获取数组中的所有元素，例如：</p>\n<h3> 获取数组的长度</h3>\n<p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 特殊变量</h2>\n<h3> $n</h3>\n<p>功能描述：n 为数字，$0 代表该脚本名称，<code>$1-$9</code> 代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如<code>${10}</code></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> $</h3>\n<p>功能描述：获取所有输<strong>入参数个数</strong>，常用于循环，判断参数的个数是否正确以及加强脚本的健壮性</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> @</h3>\n<ul>\n<li><code>$*</code> 这个变量代表<strong>命令行中所有的参数</strong>，<code>$*</code>把所有的参数<strong>看成一个整体</strong></li>\n<li><code>$@</code> 这个变量也代表<strong>命令行中所有的参数</strong>，不过<code>$@</code>把<strong>每个参数区分对待</strong></li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> $？</h3>\n<p><code>$？</code><strong>最后一次执行的命令的返回状态</strong>。如果这个变量的值为 0，证明上一 个命令正确执行；如果这个变量的值为非 0（具体是哪个数，由命令自己来决定），则证明 上一个命令执行不正确了。</p>\n<p>判断 <a href=\"http://helloworld.sh\" target=\"_blank\" rel=\"noopener noreferrer\">helloworld.sh</a> 脚本是否正确执</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 运算符</h2>\n<p>运算符有两种写法</p>\n<ul>\n<li><code>((表达式))</code></li>\n<li><code>[ 表达式 ]</code> 注意 [] 里面左右要有空格</li>\n</ul>\n<h2> 算术运算符</h2>\n<p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+</td>\n<td>加法</td>\n<td><code>expr $a + $b</code> 结果为 30。</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减法</td>\n<td><code>expr $a - $b</code> 结果为 -10。</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘法</td>\n<td><code>expr $a \\* $b</code> 结果为 200。</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除法</td>\n<td><code>expr $b / $a</code> 结果为 2。</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取余</td>\n<td><code>expr $b % $a</code> 结果为 0。</td>\n</tr>\n<tr>\n<td>=</td>\n<td>赋值</td>\n<td>a=$b 把变量 b 的值赋给 a。</td>\n</tr>\n<tr>\n<td>==</td>\n<td>相等。用于比较两个数字，相同则返回 true。</td>\n<td>[ $a == $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不相等。用于比较两个数字，不相同则返回 true。</td>\n<td>[ $a != $b ] 返回 true。</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>**注意：**条件表达式要放在方括号之间，并且要有空格，例如: <strong>[b]</strong> 是错误的，必须写成 <strong>[ $a == $b ]</strong>。</p>\n</blockquote>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>TIP</p>\n<ul>\n<li>乘号<code>(*)</code>前边必须加反斜杠()才能实现乘法运算；</li>\n<li><code>if...then...fi</code> 是条件语句，后续将会讲解。</li>\n<li>在 <code>MAC</code> 中 <code>shell</code> 的 <code>expr</code> 语法是：<strong><code>$((表达式))</code></strong>，此处表达式中的 <code>\"*\"</code> 不需要转义符号 \"\" 。</li>\n</ul>\n<h2> 关系运算符</h2>\n<p><strong>关系运算符只支持数字，不支持字符串，除非字符串的值是数字</strong>。</p>\n<p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-eq</td>\n<td>检测两个数是否相等，相等返回 true。</td>\n<td>[ $a -eq $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>-ne</td>\n<td>检测两个数是否不相等，不相等返回 true。</td>\n<td>[ $a -ne $b ] 返回 true。</td>\n</tr>\n<tr>\n<td>-gt</td>\n<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>\n<td>[ $a -gt $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>-lt</td>\n<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>\n<td>[ $a -lt $b ] 返回 true。</td>\n</tr>\n<tr>\n<td>-ge</td>\n<td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td>\n<td>[ $a -ge $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>-le</td>\n<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>\n<td>[ $a -le $b ] 返回 true。</td>\n</tr>\n</tbody>\n</table>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>:::TIP</p>\n<p>这里我们使用 <code>((表达式))</code> 来做判断的话。在 <code>((表达式))</code> 中就可以写 <code>&lt;,&gt;,&lt;=,&gt;=,=</code>这些数学的运算符号</p>\n<p>:::</p>\n<h2> 逻辑运算符</h2>\n<p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p>\n<p>| 运算符 | 说明       | 举例                                        |<br>\n| ------ | ---------- | ------------------------------------------- | --------- | -------------- | --- | ------------------------ |<br>\n| &amp;&amp;     | 逻辑的 AND | [[$a -lt 100 &amp;&amp; a -lt 100 |     | $b -gt 100]] 返回 true |</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 字符串运算符</h2>\n<p>下表列出了常用的字符串运算符，假定变量 a 为 \"abc\"，变量 b 为 \"efg\"：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>说明</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>检测两个字符串是否相等，相等返回 true。</td>\n<td>[ $a = $b ] 返回 false。</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>检测两个字符串是否不相等，不相等返回 true。</td>\n<td>[ $a != $b ] 返回 true。</td>\n</tr>\n<tr>\n<td>-z</td>\n<td>检测字符串长度是否为 0，为 0 返回 true。</td>\n<td>[ -z $a ] 返回 false。</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>检测字符串长度是否不为 0，不为 0 返回 true。</td>\n<td>[ -n \"$a\" ] 返回 true。</td>\n</tr>\n<tr>\n<td>$</td>\n<td>检测字符串是否不为空，不为空返回 true。</td>\n<td>[ $a ] 返回 true。</td>\n</tr>\n</tbody>\n</table>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 文件测试运算符</h2>\n<p>文件测试运算符用于检测 Unix 文件的各种属性。</p>\n<p>属性检测描述如下：</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>说明</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-b file</td>\n<td>检测文件是否是块设备文件，如果是，则返回 true。</td>\n<td>[ -b $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-c file</td>\n<td>检测文件是否是字符设备文件，如果是，则返回 true。</td>\n<td>[ -c $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-d file</td>\n<td>检测文件是否是目录，如果是，则返回 true。</td>\n<td>[ -d $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>\n<td>[ -f $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-g file</td>\n<td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td>\n<td>[ -g $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-k file</td>\n<td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>\n<td>[ -k $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-p file</td>\n<td>检测文件是否是有名管道，如果是，则返回 true。</td>\n<td>[ -p $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-u file</td>\n<td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td>\n<td>[ -u $file ] 返回 false。</td>\n</tr>\n<tr>\n<td>-r file</td>\n<td>检测文件是否可读，如果是，则返回 true。</td>\n<td>[ -r $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-w file</td>\n<td>检测文件是否可写，如果是，则返回 true。</td>\n<td>[ -w $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-x file</td>\n<td>检测文件是否可执行，如果是，则返回 true。</td>\n<td>[ -x $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-s file</td>\n<td>检测文件是否为空（文件大小是否大于 0），不为空返回 true。</td>\n<td>[ -s $file ] 返回 true。</td>\n</tr>\n<tr>\n<td>-e file</td>\n<td>检测文件（包括目录）是否存在，如果是，则返回 true。</td>\n<td>[ -e $file ] 返回 true。</td>\n</tr>\n</tbody>\n</table>\n<p>其他检查符：</p>\n<ul>\n<li><strong>-S</strong>: 判断某文件是否 socket。</li>\n<li><strong>-L</strong>: 检测文件是否存在并且是一个符号链接。</li>\n</ul>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 流程控制（重点）</h2>\n<h2> if else</h2>\n<h3> fi</h3>\n<p>if 语句语法格式：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>写成一行（适用于终端命令提示符）：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>TIP</p>\n<p>末尾的 <strong>fi</strong> 就是 <strong>if</strong> 倒过来拼写，后面还会遇到类似的。</p>\n<p>简单的说就是和<code>JS</code>中的 <code>if() { }</code> 这里的 <code>{}</code> 代表一个区域表示<code>if</code>成立了执行这个区域里面的代码，但在<code>Shell</code>中 <code>{}</code> 有这其他的含义，所以 <strong><code>if</code> 代表开始 <code>fi</code> 代表结束把中间的代码框起来表示<code>if</code>成立后执行的代码。</strong></p>\n<p><strong>其中 if 后的语句成功执行就会跳转到 then 后的语句，否则不跳转</strong>，then 表示判断成功后要执行的语句。</p>\n<h3> if else</h3>\n<p>if else 语法格式：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> if else-if else</h3>\n<p><code>if else-if else</code> 语法格式：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>if else 的 <strong>[...]</strong> 判断语句中大于使用 <strong>-gt</strong>，小于使用 <strong>-lt</strong>。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果使用 <strong>((...))</strong> 作为判断语句，大于和小于可以直接使用 <strong>&gt;</strong> 和 <strong>&lt;</strong>。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以下实例判断两个变量是否相等：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果：</p>\n<p>if else 语句经常与 test 命令结合使用，如下所示：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果：</p>\n<h2> case ... esac</h2>\n<p><strong><code>case ... esac</code></strong> 为多选择语句，<strong>与其他语言中的 <code>switch ... case</code> 语句类似</strong>，是一种多分支选择结构，每个 <code>case</code> 分支用右圆括号开始，用两个分号 <strong>;;</strong> 表示 break，即执行结束，跳出整个 <code>case ... esac</code> 语句，<code>esac</code>（就是 <code>case</code> 反过来）作为结束标记。</p>\n<p>可以用 case 语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。</p>\n<p><strong><code>case ... esac</code></strong> 语法格式如下：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>case</code> 工作方式如上所示，取值后面必须为单词 <strong>in</strong>，每一模式必须以右括号结束。取值可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至 <strong>;;</strong>。</p>\n<p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p>\n<p>下面的脚本提示输入 1 到 4，与每一种模式进行匹配：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输入不同的内容，会有不同的结果，例如：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> for 循环</h2>\n<p>与其他编程语言类似，<code>Shell</code>支持<code>for</code>循环。</p>\n<p><strong>写法一</strong></p>\n<p><code>for</code>循环一般格式为</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>写成一行：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>TIP</p>\n<p>这里 <code>do</code> 和 <code>done</code> 就和 <code>{ }</code> 一样来确定范围</p>\n<p>当变量值在列表里，<code>for</code> 循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的 <code>shell</code> 命令和语句。<code>in</code> 列表可以包含替换、字符串和文件名。</p>\n<p><code>in</code>列表是可选的，如果不用它，for 循环使用命令行的位置参数。</p>\n<p>例如，顺序输出当前列表中的数字：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>顺序输出字符串中的字符：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果：</p>\n<p><strong>写法二</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从 1 加到 100 ,<code>for1.sh</code></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> while 语句</h2>\n<p><code>while</code> 循环用于不断执行一系列命令，也用于从输入文件中读取数据。其语法格式为：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以下是一个基本的 <code>while</code> 循环，测试条件是：如果 <code>int</code> 小于等于 5，那么条件返回真。<code>int</code> 从 1 开始，每次循环处理时，<code>int</code> 加 1。运行上述脚本，返回数字 1 到 5，然后终止。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行脚本，输出：</p>\n<p>以上实例使用了 <code>Bash let</code> 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：<a href=\"https://www.runoob.com/linux/linux-comm-let.html\" target=\"_blank\" rel=\"noopener noreferrer\">Bash let 命令 open in new window</a>。</p>\n<p><code>while</code>循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量<code>FILM</code>，按<code>&lt;Ctrl-D&gt;</code>结束循环。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 无限循环</h3>\n<p>无限循环语法格式：</p>\n<p>或者</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>或者</p>\n<h2> until 循环</h2>\n<p><code>until</code> 循环执行一系列命令直至条件为 true 时停止。</p>\n<p><code>until</code> 循环与 <code>while</code> 循环在处理方式上刚好相反。</p>\n<p>一般 <code>while</code> 循环优于 <code>until</code> 循环，但在某些时候—也只是极少数情况下，<code>until</code> 循环更加有用。</p>\n<p><code>until</code> 语法格式:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>condition</code> 一般为条件表达式，如果返回值为 <code>false</code>，则继续执行循环体内的语句，否则跳出循环。</p>\n<p>以下实例我们使用 <code>until</code> 命令来输出 <code>0 ~ 9</code> 的数字：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果为：</p>\n<h2> 跳出循环</h2>\n<p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell 使用两个命令来实现该功能：<strong>break</strong> 和 <strong>continue</strong>。</p>\n<h3> break 命令</h3>\n<p>break 命令允许跳出所有循环（终止执行后面的所有循环）。</p>\n<p>下面的例子中，脚本进入死循环直至用户输入数字大于 5。要跳出这个循环，返回到 shell 提示符下，需要使用 break 命令。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>执行以上代码，输出结果为：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> continue</h3>\n<p><code>continue</code> 命令与 <code>break</code> 命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>\n<p>对上面的例子进行修改：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行代码发现，当输入大于 5 的数字时，该例中的循环不会结束，语句 <strong>echo \"游戏结束\"</strong> 永远不会被执行。</p>\n<h2> 函数</h2>\n<h2> 函数定义</h2>\n<p><code>linux shell</code> 可以用户定义函数，然后在 shell 脚本中可以随便调用。</p>\n<p><code>shell</code>中函数的定义格式如下：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>说明：</p>\n<ul>\n<li>1、可以带<code>function fun()</code> 定义，也可以直接<code>fun()</code> 定义,不带任何参数。</li>\n<li>2、参数返回，可以显示加：<code>return</code> 返回，如果不加，将以最后一条命令运行结果，作为返回值。 <code>return</code>后跟数值<code>n(0-255）</code></li>\n</ul>\n<p>下面的例子定义了一个函数并进行调用：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面定义一个带有<code>return</code>语句的函数：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出类似下面：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>函数返回值在调用该函数后通过 <code>$?</code> 来获得。</p>\n<p>TIP</p>\n<p>注意：<strong>所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分</strong>，直至<code>shell</code>解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>\n<h2> 函数参数</h2>\n<p>在<code>Shell</code>中，调用函数时可以向其传递参数。在函数体内部，通过 <code>$n</code> 的形式来获取参数的值，例如，<code>$1</code>表示第一个参数，$2 表示第二个参数...</p>\n<p>带参数的函数示例：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>TIP</p>\n<p>注意，<code>$10</code> 不能获取第十个参数，<strong>获取第十个参数需要<code>${10}</code>。当<code>n&gt;=10</code>时，需要使用<code>${n}</code>来获取参数</strong>。</p>\n<p>另外，还有几个特殊字符用来处理参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数处理</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$#</td>\n<td>传递到脚本或函数的参数个数</td>\n</tr>\n<tr>\n<td>$*</td>\n<td>以一个单字符串显示所有向脚本传递的参数</td>\n</tr>\n<tr>\n<td>$$</td>\n<td>脚本运行的当前进程 ID 号</td>\n</tr>\n<tr>\n<td>$!</td>\n<td>后台运行的最后一个进程的 ID 号</td>\n</tr>\n<tr>\n<td>$@</td>\n<td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>\n</tr>\n<tr>\n<td>$-</td>\n<td>显示 Shell 使用的当前选项，与 set 命令功能相同。</td>\n</tr>\n<tr>\n<td>$?</td>\n<td>显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。</td>\n</tr>\n</tbody>\n</table>\n<h2> 获取函数的返回值</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>TIP</p>\n<p>函数没有<code>return</code>的时候返回值是<strong>最后一行代码的执行结果</strong>。</p>\n<h2> 正侧表达式</h2>\n<h2> 基本正侧表达式</h2>\n<p>正则表达式和通配符的区别：</p>\n<ul>\n<li>正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配. <code>grep</code>、<code>awk</code>、<code>sed</code> 等命令可以支持正则表达式。</li>\n<li>通配符<code>（ ？[]）</code>是用来匹配符合条件的文件名<code>*</code>，通配符是完全匹配。<code>ls</code>、<code>find</code>、<code>cp</code> 等命令不支持正则表达式，所有只能使用 <code>shell</code> 自己的通配符来进行匹配了。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>*</code></td>\n<td>前一个字符匹配 0 次或者任意多次</td>\n</tr>\n<tr>\n<td><code>.</code></td>\n<td>匹配除了换行符外任意一个字符</td>\n</tr>\n<tr>\n<td><code>^</code></td>\n<td>匹配行首，</td>\n</tr>\n<tr>\n<td>例如：<code>^hello</code>会匹配以<code>hello</code>开头的行。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>匹配行首，</td>\n</tr>\n<tr>\n<td>例如：<code>hello$</code>会匹配以<code>hello</code>开头的行。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>[ ]</code></td>\n<td>匹配括号中指定的任意一个字符，只匹配一个字符</td>\n</tr>\n<tr>\n<td><code>[ ^]</code></td>\n<td>匹配除中括号的字符意外的任意一个字符。</td>\n</tr>\n<tr>\n<td>例如：<code>[^0-9]</code>匹配任意一个非数字字符。</td>\n<td></td>\n</tr>\n<tr>\n<td><code>\\</code></td>\n<td>转义符。用于将特殊符号的含义取消</td>\n</tr>\n<tr>\n<td><code>{n}</code></td>\n<td>表示其前面的字符签好出现 n 次。</td>\n</tr>\n<tr>\n<td>例如：<code>[0-9]{4}</code>匹配 4 位数字，<code>[1][3-8][0-9]{9}</code> 匹配手机号码</td>\n<td></td>\n</tr>\n<tr>\n<td><code>{n,}</code></td>\n<td>表示七千亩的字符出现不小于 n 次。</td>\n</tr>\n<tr>\n<td>例如：<code>[0-9]{2,}</code>表示两位及以上的数字</td>\n<td></td>\n</tr>\n<tr>\n<td><code>{n,m}</code></td>\n<td>表示其前面的字符至少出现 n 次，最多出现 m 次。</td>\n</tr>\n<tr>\n<td>例如：<code>[a-z]{6,8}</code>匹配 6 到 8 为的小写子母。</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 常用正侧表达式</h2>\n<p>| 字符 | 描述 |<br>\n| --- | --- | --- | --- |<br>\n| <code>\\</code> | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。 |<br>\n| 例如：<code>“n”</code>匹配字符<code>“n”</code>。<code>“\\n”</code>匹配一个换行符。序列<code>“\\\\”</code>匹配<code>“\\”</code>而<code>“\\(”</code>则匹配<code>“(”</code>。 |<br>\n| <code>^</code> | 匹配输入字符串的开始位置。如果设置了 <code>RegExp</code> 对象的 <code>Multiline</code> 属性，<code>^</code>也匹配<code>“\\n”</code>或<code>“\\r”</code>之后的位置。 |<br>\n| <code>$</code> | 匹配输入字符串的结束位置。如果设置了 <code>RegExp</code> 对象的 <code>Multiline</code> 属性，$也匹配<code>“\\n”</code>或<code>“\\r”</code>之前的位置。 |<br>\n| <code>*</code> | 匹配前面的子表达式零次或多次。 |<br>\n| 例如：<code>zo*</code>能匹配<code>“z”</code>以及<code>“zoo”</code>。<code>*</code>等价于<code>{0,}</code>。 |<br>\n| <code>+</code> | 匹配前面的子表达式一次或多次。 |<br>\n| 例如：<code>“zo+”</code>能匹配<code>“zo”</code>以及<code>“zoo”</code>，但不能匹配<code>“z”</code>。<code>+</code>等价于<code>{1,}</code>。 |<br>\n| <code>?</code> | 匹配前面的子表达式零次或一次。 |<br>\n| 例如：<code>“do(es)?”</code>可以匹配<code>“do”</code>或<code>“does”</code>中的<code>“do”</code>。<code>?</code>等价于<code>{0,1}</code>。 |<br>\n| <code>{n}</code> | <code>n</code> 是一个非负整数。匹配确定的 <code>n</code> 次。 |<br>\n| 例如：<code>“o{2}”</code>不能匹配<code>“Bob”</code>中的<code>“o”</code>，但是能匹配<code>“food”</code>中的两个 o。 |<br>\n| <code>{n,}</code> | <code>n</code> 是一个非负整数。至少匹配 <code>n</code> 次。 |<br>\n| 例如：<code>“o{2,}”</code>不能匹配<code>“Bob”</code>中的<code>“o”</code>，但能匹配<code>“foooood”</code>中的所有 <code>o</code>。<code>“o{1,}”</code>等价于<code>“o+”</code>。<code>“o{0,}”</code>则等价于<code>“o*”</code>。 |<br>\n| <code>{n,m}</code> | <code>m</code> 和 <code>n</code> 均为非负整数，其中 <code>n&lt;=m</code>。最少匹配 <code>n</code> 次且最多匹配 <code>m</code> 次。 |<br>\n| 例如：<code>“o{1,3}”</code>将匹配<code>“fooooood”</code>中的前三个 <code>o</code>。<code>“o{0,1}”</code>等价于<code>“o?”</code>。请注意在逗号和两个数之间不能有空格。 |<br>\n| <code>?</code> | 当该字符紧跟在任何一个其他限制符<code>（*,+,?，{n}，{n,}，{n,m}）</code>后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。 |<br>\n| 例如：对于字符串<code>“oooo”</code>，<code>“o+?”</code>将匹配单个<code>“o”</code>，而<code>“o+”</code>将匹配所有“o”。 |<br>\n| <code>.</code> | 匹配除<code>“\\n”</code>之外的任何单个字符。要匹配包括<code>“\\n”</code>在内的任何字符，请使用像<code>“[.\\n]”</code>的模式。 |<br>\n| <code>(pattern)</code> | 匹配 <code>pattern</code> 并获取这一匹配。所获取的匹配可以从产生的 <code>Matches</code> 集合得到，在 <code>VBScript</code> 中使用 <code>SubMatches</code> 集合，在 <code>JScript</code> 中则使用<code>$0…$9</code> 属性。要匹配圆括号字符，请使用“”或“”或“”。 |<br>\n| <code>(?:pattern)</code> | 匹配 <code>pattern</code> 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符<code>“( | )”</code>来组合一个模式的各个部分是很有用。 |<br>\n| 例如<code>“industr(?:y | ies)”</code>就是一个比<code>“industry | industries”</code>更简略的表达式。 |<br>\n| <code>(?=pattern)</code> | 正向预查，在任何匹配 <code>pattern</code> 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。 |<br>\n| 例如：<code>“Windows(?=95 | 98 | NT | 2000)”</code>能匹配<code>“Windows2000”</code>中的<code>“Windows”</code>，但不能匹配<code>“Windows3.1”</code>中的<code>“Windows”</code>。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |<br>\n| <code>(?!pattern)</code> | 负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。 |<br>\n| 例如<code>“Windows(?!95 | 98 | NT | 2000)”</code>能匹配<code>“Windows3.1”</code>中的<code>“Windows”</code>，但不能匹配<code>“Windows2000”</code>中的<code>“Windows”</code>。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 |<br>\n| <code>x | y</code> | 匹配 x 或 y。 |<br>\n| 例如：<code>“z | food”</code>能匹配<code>“z”</code>或<code>“food”</code>。<code>“(z | f)ood”</code>则匹配<code>“zood”</code>或<code>“food”</code>。 |<br>\n| <code>[xyz]</code> | 字符集合。匹配所包含的任意一个字符。 |<br>\n| 例如：<code>“[abc]”</code>可以匹配<code>“plain”</code>中的<code>“a”</code>。 |<br>\n| <code>[^xyz]</code> | 负值字符集合。匹配未包含的任意字符。 |<br>\n| 例如：<code>“[^abc]”</code>可以匹配<code>“plain”</code>中的<code>“p”</code>。 |<br>\n| <code>[a-z]</code> | 字符范围。匹配指定范围内的任意字符。 |<br>\n| 例如：<code>“[a-z]”</code>可以匹配<code>“a”</code>到<code>“z”</code>范围内的任意小写字母字符。 |<br>\n| <code>[^a-z]</code> | 负值字符范围。匹配任何不在指定范围内的任意字符。 |<br>\n| 例如：<code>“[^a-z]”</code>可以匹配任何不在<code>“a”</code>到<code>“z”</code>范围内的任意字符。 |<br>\n| <code>\\b</code> | 匹配一个单词边界，也就是指单词和空格间的位置。 |<br>\n| 例如：<code>“er\\b”</code>可以匹配<code>“never”</code>中的<code>“er”</code>，但不能匹配<code>“verb”</code>中的<code>“er”</code>。 |<br>\n| <code>\\B</code> | 匹配非单词边界。<code>“er\\B</code>”能匹配<code>“verb”</code>中的<code>“er”</code>，但不能匹配<code>“never”</code>中的<code>“er”</code>。 |<br>\n| <code>\\cx</code> | 匹配由 <code>x</code> 指明的控制字符。 |<br>\n| 例如：<code>\\cM</code> 匹配一个 <code>Control-M</code> 或回车符。<code>x</code> 的值必须为 <code>A-Z</code> 或 <code>a-z</code> 之一。否则，将 <code>c</code> 视为一个原义的<code>“c”</code>字符。 |<br>\n| <code>\\d</code> | 匹配一个数字字符。等价于<code>[0-9]</code>。 |<br>\n| <code>\\D</code> | 匹配一个非数字字符。等价于<code>[^0-9]</code>。 |<br>\n| <code>\\f</code> | 匹配一个换页符。等价于<code>\\x0c</code> 和<code>\\cL</code>。 |<br>\n| <code>\\n</code> | 匹配一个换行符。等价于<code>\\x0a</code> 和<code>\\cJ</code>。 |<br>\n| <code>\\r</code> | 匹配一个回车符。等价于<code>\\x0d</code> 和<code>\\cM</code>。 |<br>\n| <code>\\s</code> | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于<code>[\\f\\n\\r\\t\\v]</code>。 |<br>\n| <code>\\S</code> | 匹配任何非空白字符。等价于<code>[^\\f\\n\\r\\t\\v]</code>。 |<br>\n| <code>\\t</code> | 匹配一个制表符。等价于<code>\\x09</code> 和<code>\\cI</code>。 |<br>\n| <code>\\v</code> | 匹配一个垂直制表符。等价于<code>\\x0b</code> 和<code>\\cK</code>。 |<br>\n| <code>\\w</code> | 匹配包括下划线的任何单词字符。等价于<code>“[A-Za-z0-9_]”</code>。 |<br>\n| <code>\\W</code> | 匹配任何非单词字符。等价于<code>“[^a-za-z0-9_]”</code>。 |<br>\n| <code>\\xn</code> | 匹配 <code>n</code>，其中 <code>n</code> 为十六进制转义值。十六进制转义值必须为确定的两个数字长。 |<br>\n| 例如：<code>“\\x41”</code>匹配<code>“A”</code>。<code>“\\x041”</code>则等价于<code>“\\x04&amp;1”</code>。正则表达式中可以使用 <code>ASCII</code> 编码。. |<br>\n| <code>\\num</code> | 匹配 <code>num</code>，其中 <code>num</code> 是一个正整数。对所获取的匹配的引用。 |<br>\n| 例如：<code>“(.)\\1”</code>匹配两个连续的相同字符。 |<br>\n| <code>\\n</code> | 标识一个八进制转义值或一个向后引用。如果<code>\\n</code> 之前至少 <code>n</code> 个获取的子表达式，则 <code>n</code> 为向后引用。否则，如果 <code>n</code> 为八进制数字<code>（0-7）</code>，则 <code>n</code> 为一个八进制转义值。 |<br>\n| <code>\\nm</code> | 标识一个八进制转义值或一个向后引用。如果<code>\\nm</code> 之前至少有 <code>nm</code> 个获得子表达式，则 <code>nm</code> 为向后引用。如果<code>\\nm</code> 之前至少有 <code>n</code> 个获取，则 <code>n</code> 为一个后跟文字 <code>m</code> 的向后引用。如果前面的条件都不满足，若 <code>n</code> 和 <code>m</code> 均为八进制数字<code>（0-7）</code>，则<code>\\nm</code> 将匹配八进制转义值 <code>nm</code>。 |<br>\n| <code>\\nml</code> | 如果 <code>n</code> 为八进制数字<code>（0-3）</code>，且 <code>m</code> 和 <code>l</code> 均为八进制数字<code>（0-7）</code>，则匹配八进制转义值 <code>nml</code>。 |<br>\n| <code>\\un</code> | 匹配 <code>n</code>，其中 <code>n</code> 是一个用四个十六进制数字表示的 <code>Unicode</code> 字符。 |<br>\n| 例如：<code>\\u00A9</code> 匹配版权符号<code>（?）</code>。 |</p>\n<h2> 文本处理工具</h2>\n<h2> cut 命令</h2>\n<h3> 语法</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>使用说明:</strong></p>\n<p>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。</p>\n<p>如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</p>\n<p><strong>参数:</strong></p>\n<ul>\n<li>-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。</li>\n<li>-c ：以字符为单位进行分割。</li>\n<li>-d ：自定义分隔符，默认为制表符。</li>\n<li>-f ：与-d 一起使用，指定显示哪个区域。</li>\n<li>-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的 范围之内，该字符将被写出；否则，该字符将被排除</li>\n</ul>\n<h3> 实例</h3>\n<p>当你执行 who 命令时，会输出类似如下的内容：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果我们想提取每一行的第 3 个字节，就这样：</p>\n<h2> awk 命令</h2>\n<h3> 语法</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>选项参数说明：</strong></p>\n<ul>\n<li><code>-F fs or --field-separator fs</code> 指定输入文件折分隔符，fs 是一个字符串或者是一个正则表达式，如-F:。</li>\n<li><code>-v var=value or --asign var=value</code> 赋值一个用户定义变量。</li>\n<li><code>-f scripfile or --file scriptfile</code> 从脚本文件中读取<code>awk</code>命令。</li>\n<li><code>-mf nnn and -mr nnn</code> 对<code>nnn</code>值设置内在限制，<code>-mf</code>选项限制分配给<code>nnn</code>的最大块数目；<code>-mr</code>选项限制记录的最大数目。这两个功能是 Bell 实验室版<code>awk</code>的扩展功能，在标准<code>awk</code>中不适用。</li>\n<li><code>-W compact or --compat, -W traditional or --traditional</code> 在兼容模式下运行<code>awk</code>。所以<code>gawk</code>的行为和标准的<code>awk</code>完全一样，所有的<code>awk</code>扩展都被忽略。</li>\n<li><code>-W copyleft or --copyleft, -W copyright or --copyright</code> 打印简短的版权信息。</li>\n<li><code>-W help or --help, -W usage or --usage</code> 打印全部<code>awk</code>选项和每个选项的简短说明。</li>\n<li><code>-W lint or --lint</code> 打印不能向传统<code>unix</code>平台移植的结构的警告。</li>\n<li><code>-W lint-old or --lint-old</code> 打印关于不能向传统<code>unix</code>平台移植的结构的警告。</li>\n<li><code>-W posix</code> 打开兼容模式。但有以下限制，不识别：/x、函数关键字、<code>func</code>、换码序列以及当<code>fs</code>是一个空格时，将新行作为一个域分隔符；操作符<strong>和</strong>=不能代替<sup>和</sup>=；<code>fflush</code>无效。</li>\n<li><code>-W re-interval or --re-inerval</code> 允许间隔正则表达式的使用，参考(<code>grep</code>中的<code>Posix</code>字符类)，如括号表达式<code>[[:alpha:]]</code>。</li>\n<li><code>-W source program-text or --source program-text</code> 使用 p<code>rogram-text</code>作为源代码，可与-f 命令混用。</li>\n<li><code>-W version or --version</code> 打印 bug 报告信息的版本。</li>\n</ul>\n<h3> 基本用法</h3>\n<p>log.txt 文本内容如下：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>用法一：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>实例：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>用法二：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>实例：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>用法三：</p>\n<p>实例：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>用法四：</p>\n<p>实例：</p>\n<h3> 运算符</h3>\n<p>| 运算符                      | 描述                             |<br>\n| --------------------------- | -------------------------------- | --- | ------ |<br>\n| = += -= *= /= %= ^= **= | 赋值                             |<br>\n| ?:                          | C 条件表达式                     |<br>\n|                             |                                  |     | 逻辑或 |<br>\n| &amp;&amp;                          | 逻辑与                           |<br>\n| ~ 和 !~                     | 匹配正则表达式和不匹配正则表达式 |<br>\n| &lt; &lt;= &gt; &gt;= != ==             | 关系运算符                       |<br>\n| 空格                        | 连接                             |<br>\n| + -                        | 加，减                           |<br>\n| * / %                      | 乘，除与求余                     |<br>\n| + - !                      | 一元加，减和逻辑非               |<br>\n| ^ ***                    | 求幂                             |<br>\n| ++ --                       | 增加或减少，作为前缀或后缀       |<br>\n| $                           | 字段引用                         |<br>\n| in                          | 数组成员                         |</p>\n<p>过滤第一列大于 2 的行</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>过滤第一列等于 2 的行</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>过滤第一列大于 2 并且第二列等于'Are'的行</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h3> 内建变量</h3>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>$n</code></td>\n<td>当前记录的第 n 个字段，字段间由<code>FS</code>分隔</td>\n</tr>\n<tr>\n<td><code>$0</code></td>\n<td>完整的输入记录</td>\n</tr>\n<tr>\n<td><code>ARGC</code></td>\n<td>命令行参数的数目</td>\n</tr>\n<tr>\n<td><code>ARGIND</code></td>\n<td>命令行中当前文件的位置(从 0 开始算)</td>\n</tr>\n<tr>\n<td><code>ARGV</code></td>\n<td>包含命令行参数的数组</td>\n</tr>\n<tr>\n<td><code>CONVFMT</code></td>\n<td>数字转换格式(默认值为<code>%.6g</code>)<code>ENVIRON</code>环境变量关联数组</td>\n</tr>\n<tr>\n<td><code>ERRNO</code></td>\n<td>最后一个系统错误的描述</td>\n</tr>\n<tr>\n<td><code>FIELDWIDTHS</code></td>\n<td>字段宽度列表(用空格键分隔)</td>\n</tr>\n<tr>\n<td><code>FILENAME</code></td>\n<td>当前文件名</td>\n</tr>\n<tr>\n<td><code>FNR</code></td>\n<td>各文件分别计数的行号</td>\n</tr>\n<tr>\n<td><code>FS</code></td>\n<td>字段分隔符(默认是任何空格)</td>\n</tr>\n<tr>\n<td><code>IGNORECASE</code></td>\n<td>如果为真，则进行忽略大小写的匹配</td>\n</tr>\n<tr>\n<td><code>NF</code></td>\n<td>一条记录的字段的数目</td>\n</tr>\n<tr>\n<td><code>NR</code></td>\n<td>已经读出的记录数，就是行号，从 1 开始</td>\n</tr>\n<tr>\n<td><code>OFMT</code></td>\n<td>数字的输出格式(默认值是<code>%.6g)</code></td>\n</tr>\n<tr>\n<td><code>OFS</code></td>\n<td>输出字段分隔符，默认值与输入字段分隔符一致。</td>\n</tr>\n<tr>\n<td><code>ORS</code></td>\n<td>输出记录分隔符(默认值是一个换行符)</td>\n</tr>\n<tr>\n<td><code>RLENGTH</code></td>\n<td>由<code>match</code>函数所匹配的字符串的长度</td>\n</tr>\n<tr>\n<td><code>RS</code></td>\n<td>记录分隔符(默认是一个换行符)</td>\n</tr>\n<tr>\n<td><code>RSTART</code></td>\n<td>由<code>match</code>函数所匹配的字符串的第一个位置</td>\n</tr>\n<tr>\n<td><code>SUBSEP</code></td>\n<td>数组下标分隔符(默认值是<code>/034</code>)</td>\n</tr>\n</tbody>\n</table>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h3> 使用正则，字符串匹配</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>~ 表示模式开始。// 中是模式。</strong></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h3> 忽略大小写</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h3> 模式取反</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h3> awk 脚本</h3>\n<p>关于 awk 脚本，我们需要注意两个关键词 BEGIN 和 END。</p>\n<ul>\n<li 这里面放的是执行前的语句=\"\">BEGIN</li>\n<li 这里面放的是处理完所有的行后要执行的语句=\"\">END</li>\n<li 这里面放的是处理每一行时要执行的语句=\"\"></li>\n</ul>\n<p>假设有这么一个文件（学生成绩表）：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们的 awk 脚本如下：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们来看一下执行结果：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h3> 另外一些实例</h3>\n<p>AWK 的 hello world 程序为：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>计算文件大小</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从文件中找出长度大于 80 的行：</p>\n<p>打印九九乘法表</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 发送消息案例</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://static.h7ml.cn/vitepress/assets/images/linux/image-20221026104446000.png",
      "date_published": "2021-06-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "linux"
      ]
    },
    {
      "title": "mysql",
      "url": "https://www.h7ml.cn/posts/mysql/",
      "id": "https://www.h7ml.cn/posts/mysql/",
      "summary": "数据库相关概念 MySQL 安装 SQL 概述 DDL:操作数据库 DDL:操作表 dml 约束 数据库设计",
      "content_html": "<ul>\n<li>\n<p><a href=\"/posts/mysql/init.html\" target=\"blank\">数据库相关概念</a></p>\n</li>\n<li>\n<p><a href=\"/posts/mysql/install.html\" target=\"blank\">MySQL 安装</a></p>\n</li>\n<li>\n<p><a href=\"/posts/mysql/sql.html\" target=\"blank\">SQL 概述</a></p>\n</li>\n<li>\n<p><a href=\"/posts/mysql/ddl.html\" target=\"blank\">DDL:操作数据库</a></p>\n</li>\n<li>\n<p><a href=\"/posts/mysql/ddltable.html\" target=\"blank\">DDL:操作表</a></p>\n</li>\n<li>\n<p><a href=\"/posts/mysql/dml.html\" target=\"blank\">dml</a></p>\n</li>\n<li>\n<p><a href=\"/posts/mysql/constraint.html\" target=\"blank\">约束</a></p>\n</li>\n<li>\n<p><a href=\"/posts/mysql/design.html\" target=\"blank\">数据库设计</a></p>\n</li>\n</ul>\n",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "事物",
      "url": "https://www.h7ml.cn/posts/mysql/affair.html",
      "id": "https://www.h7ml.cn/posts/mysql/affair.html",
      "summary": "事务 概述 数据库的事务（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令。 事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败。 事务是一个不可分割的工作逻辑单元。 这些概念不好理解，接下来举例说明，如下图有一张表 image-20220910095758027",
      "content_html": "<h2> 事务</h2>\n<h2> 概述</h2>\n<blockquote>\n<p>数据库的事务（Transaction）是一种机制、一个操作序列，包含了<mark>一组数据库操作命令</mark>。</p>\n<p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令<mark>要么同时成功，要么同时失败</mark>。</p>\n<p>事务是一个不可分割的工作逻辑单元。</p>\n</blockquote>\n<p>这些概念不好理解，接下来举例说明，如下图有一张表</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100957062.png\" alt=\"image-20220910095758027\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095758027</figcaption></figure>\n<p>张三和李四账户中各有 100 块钱，现李四需要转换 500 块钱给张三，具体的转账操作为</p>\n<ul>\n<li>第一步：查询李四账户余额</li>\n<li>第二步：从李四账户金额 -500</li>\n<li>第三步：给张三账户金额 +500</li>\n</ul>\n<p>现在假设在转账过程中第二步完成后出现了异常第三步没有执行，就会造成李四账户金额少了 500，而张三金额并没有多 500；这样的系统是有问题的。如果解决呢？使用事务可以解决上述问题</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100958661.png\" alt=\"image-20220910095800626\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095800626</figcaption></figure>\n<p>从上图可以看到在转账前开启事务，如果出现了异常回滚事务，三步正常执行就提交事务，这样就可以完美解决问题。</p>\n<h2> 语法</h2>\n<ul>\n<li>\n<p>开启事务</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>提交事务</p>\n</li>\n<li>\n<p>回滚事务</p>\n</li>\n</ul>\n<h2> 代码验证</h2>\n<ul>\n<li>\n<p>环境准备</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>不加事务演示问题</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>整体执行结果肯定会出问题，我们查询账户表中数据，发现李四账户少了 500。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100958711.png\" alt=\"image-20220910095804689\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095804689</figcaption></figure>\n</li>\n<li>\n<p>添加事务 sql 如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面 sql 中的执行成功进选择执行提交事务，而出现问题则执行回滚事务的语句。以后我们肯定不可能这样操作，而是在 java 中进行操作，在 java 中可以抓取异常，没出现异常提交事务，出现异常回滚事务。</p>\n</li>\n</ul>\n<h2> 事务的四大特征</h2>\n<ul>\n<li>\n<p>原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败</p>\n</li>\n<li>\n<p>一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态</p>\n</li>\n<li>\n<p>隔离性（Isolation） :多个事务之间，操作的可见性</p>\n</li>\n<li>\n<p>持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</p>\n</li>\n</ul>\n<blockquote>\n<p>==说明：==</p>\n<p>mysql 中事务是自动提交的。</p>\n<p>也就是说我们不添加事务执行 sql 语句，语句执行完毕会自动的提交事务。</p>\n<p>可以通过下面语句查询默认提交方式：</p>\n<p>查询到的结果是 1 则表示自动提交，结果是 0 表示手动提交。当然也可以通过下面语句修改提交方式</p>\n</blockquote>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/mysql/202209100957062.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "约束",
      "url": "https://www.h7ml.cn/posts/mysql/constraint.html",
      "id": "https://www.h7ml.cn/posts/mysql/constraint.html",
      "summary": "约束 image-20220910100133140 上面表中可以看到表中数据存在一些问题： id 列一般是用标示数据的唯一性的，而上述表中的 id 为 1 的有三条数据，并且 马花疼 没有 id 进行标示 柳白 这条数据的 age 列的数据是 3000，而人也不可能活到 3000 岁 马运 这条数据的 math 数学成绩是-5，而数学学得再不好也不可能出现负分 柳青 这条数据的 english 列（英文成绩）值为 null，而成绩即使没考也得是 0 分",
      "content_html": "<h2> 约束</h2>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209101001177.png\" alt=\"image-20220910100133140\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910100133140</figcaption></figure>\n<p>上面表中可以看到表中数据存在一些问题：</p>\n<ul>\n<li>\n<p>id 列一般是用标示数据的唯一性的，而上述表中的 id 为 1 的有三条数据，并且 <code>马花疼</code> 没有 id 进行标示</p>\n</li>\n<li>\n<p><code>柳白</code> 这条数据的 age 列的数据是 3000，而人也不可能活到 3000 岁</p>\n</li>\n<li>\n<p><code>马运</code> 这条数据的 math 数学成绩是-5，而数学学得再不好也不可能出现负分</p>\n</li>\n<li>\n<p><code>柳青</code> 这条数据的 english 列（英文成绩）值为 null，而成绩即使没考也得是 0 分</p>\n</li>\n</ul>\n<p>针对上述数据问题，我们就可以从数据库层面在添加数据的时候进行限制，这个就是约束。</p>\n<h2> 概念</h2>\n<ul>\n<li>\n<p>约束是作用于表中列上的规则，用于限制加入表的数据</p>\n<p>例如：我们可以给 id 列加约束，让其值不能重复，不能为 null 值。</p>\n</li>\n<li>\n<p>约束的存在保证了数据库中数据的正确性、有效性和完整性</p>\n<p>添加约束可以在添加数据的时候就限制不正确的数据，年龄是 3000，数学成绩是-5 分这样无效的数据，继而保障数据的完整性。</p>\n</li>\n</ul>\n<h2> 分类</h2>\n<ul>\n<li>\n<p><strong>非空约束： 关键字是 NOT NULL</strong></p>\n<p>保证列中所有的数据不能有 null 值。</p>\n<p>例如：id 列在添加 <code>马花疼</code> 这条数据时就不能添加成功。</p>\n</li>\n<li>\n<p><strong>唯一约束：关键字是 UNIQUE</strong></p>\n<p>保证列中所有数据各不相同。</p>\n<p>例如：id 列中三条数据的值都是 1，这样的数据在添加时是绝对不允许的。</p>\n</li>\n<li>\n<p><strong>主键约束： 关键字是 PRIMARY KEY</strong></p>\n<p>主键是一行数据的唯一标识，要求非空且唯一。一般我们都会给没张表添加一个主键列用来唯一标识数据。</p>\n<p>例如：上图表中 id 就可以作为主键，来标识每条数据。那么这样就要求数据中 id 的值不能重复，不能为 null 值。</p>\n</li>\n<li>\n<p><strong>检查约束： 关键字是 CHECK</strong></p>\n<p>保证列中的值满足某一条件。</p>\n<p>例如：我们可以给 age 列添加一个范围，最低年龄可以设置为 1，最大年龄就可以设置为 300，这样的数据才更合理些。</p>\n<blockquote>\n<p>注意：MySQL 不支持检查约束。</p>\n<p>这样是不是就没办法保证年龄在指定的范围内了？从数据库层面不能保证，以后可以在 java 代码中进行限制，一样也可以实现要求。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>默认约束： 关键字是 DEFAULT</strong></p>\n<p>保存数据时，未指定值则采用默认值。</p>\n<p>例如：我们在给 english 列添加该约束，指定默认值是 0，这样在添加数据时没有指定具体值时就会采用默认给定的 0。</p>\n</li>\n<li>\n<p><strong>外键约束： 关键字是 FOREIGN KEY</strong></p>\n<p>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。</p>\n<p>外键约束现在可能还不太好理解，后面我们会重点进行讲解。</p>\n</li>\n</ul>\n<h2> 非空约束</h2>\n<ul>\n<li>\n<p>概念</p>\n<p>非空约束用于保证列中所有数据不能有 NULL 值</p>\n</li>\n<li>\n<p>语法</p>\n<ul>\n<li>\n<p>添加约束</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>删除约束</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div></li>\n</ul>\n</li>\n</ul>\n<h2> 唯一约束</h2>\n<ul>\n<li>\n<p>概念</p>\n<p>唯一约束用于保证列中所有数据各不相同</p>\n</li>\n<li>\n<p>语法</p>\n<ul>\n<li>\n<p>添加约束</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>删除约束</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div></li>\n</ul>\n</li>\n</ul>\n<h2> 主键约束</h2>\n<ul>\n<li>\n<p>概念</p>\n<p>主键是一行数据的唯一标识，要求非空且唯一</p>\n<p>一张表只能有一个主键</p>\n</li>\n<li>\n<p>语法</p>\n<ul>\n<li>\n<p>添加约束</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>删除约束</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div></li>\n</ul>\n</li>\n</ul>\n<h2> 默认约束</h2>\n<ul>\n<li>\n<p>概念</p>\n<p>保存数据时，未指定值则采用默认值</p>\n</li>\n<li>\n<p>语法</p>\n<ul>\n<li>\n<p>添加约束</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>删除约束</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div></li>\n</ul>\n</li>\n</ul>\n<h2> 约束练习</h2>\n<p><strong>根据需求，为表添加合适的约束</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面一定给出了具体的要求，我们可以根据要求创建这张表，并为每一列添加对应的约束。建表语句如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过上面语句可以创建带有约束的 <code>emp</code> 表，约束能不能发挥作用呢。接下来我们一一进行验证，先添加一条没有问题的数据</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li><strong>验证主键约束，非空且唯一</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>执行结果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100950468.png\" alt=\"image-20220910095026441\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095026441</figcaption></figure>\n<p>从上面的结果可以看到，字段 <code>id</code> 不能为 null。那我们重新添加一条数据，如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>执行结果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100950957.png\" alt=\"image-20220910095023930\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095023930</figcaption></figure>\n<p>从上面结果可以看到，1 这个值重复了。所以主键约束是用来限制数据非空且唯一的。那我们再添加一条符合要求的数据</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>执行结果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100950499.png\" alt=\"image-20220910095021461\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095021461</figcaption></figure>\n<ul>\n<li><strong>验证非空约束</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>执行结果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100950046.png\" alt=\"image-20220910095019017\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095019017</figcaption></figure>\n<p>从上面结果可以看到，<code>ename</code> 字段的非空约束生效了。</p>\n<ul>\n<li><strong>验证唯一约束</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>执行结果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100950481.png\" alt=\"image-20220910095016451\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095016451</figcaption></figure>\n<p>从上面结果可以看到，<code>ename</code> 字段的唯一约束生效了。</p>\n<ul>\n<li><strong>验证默认约束</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>执行完上面语句后查询表中数据，如下图可以看到王五这条数据的 bonus 列就有了默认值 0。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100950457.png\" alt=\"image-20220910095013431\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095013431</figcaption></figure>\n<p>==注意：默认约束只有在不给值时才会采用默认值。如果给了 null，那值就是 null 值。==</p>\n<p>如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>执行完上面语句后查询表中数据，如下图可以看到赵六这条数据的 bonus 列的值是 null。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100950789.png\" alt=\"image-20220910095009756\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095009756</figcaption></figure>\n<ul>\n<li><strong>验证自动增长： auto_increment 当列是数字类型 并且唯一约束</strong></li>\n</ul>\n<p>重新创建 <code>emp</code> 表，并给 id 列添加自动增长</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>接下来给 emp 添加数据，分别验证不给 id 列添加值以及给 id 列添加 null 值，id 列的值会不会自动增长：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 外键约束</h2>\n<h3> 概述</h3>\n<p>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。</p>\n<p>如何理解上面的概念呢？如下图有两张表，员工表和部门表：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100950395.png\" alt=\"image-20220910095002366\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095002366</figcaption></figure>\n<p>员工表中的 dep_id 字段是部门表的 id 字段关联，也就是说 1 号学生张三属于 1 号部门研发部的员工。现在我要删除 1 号部门，就会出现错误的数据（员工表中属于 1 号部门的数据）。而我们上面说的两张表的关系只是我们认为它们有关系，此时需要通过外键让这两张表产生数据库层面的关系，这样你要删除部门表中的 1 号部门的数据将无法删除。</p>\n<h3> 语法</h3>\n<ul>\n<li>添加外键约束</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>删除外键约束</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 练习</h3>\n<p>根据上述语法创建员工表和部门表，并添加上外键约束：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>添加数据</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>此时删除 <code>研发部</code> 这条数据，会发现无法删除。</p>\n<p>删除外键</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>重新添加外键</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>",
      "image": "https://static.h7ml.cn/vitepress/assets/images/mysql/202209101001177.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "DDL:操作数据库",
      "url": "https://www.h7ml.cn/posts/mysql/ddl.html",
      "id": "https://www.h7ml.cn/posts/mysql/ddl.html",
      "summary": "DDL:操作数据库 我们先来学习 DDL 来操作数据库。而操作数据库主要就是对数据库的增删查操作。 查询 查询所有的数据库 SHOW DATABASES;",
      "content_html": "<h2> DDL:操作数据库</h2>\n<p>我们先来学习 DDL 来操作数据库。而操作数据库主要就是对数据库的增删查操作。</p>\n<h2> 查询</h2>\n<p>查询所有的数据库</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>运行上面语句效果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100908686.png\" alt=\"image-20220910090812642\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090812642</figcaption></figure>\n<p>上述查询到的是的这些数据库是 mysql 安装好自带的数据库，我们以后不要操作这些数据库。</p>\n<h2> 创建数据库</h2>\n<ul>\n<li><strong>创建数据库</strong>：</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>运行语句效果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100908036.png\" alt=\"image-20220910090808988\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090808988</figcaption></figure>\n<p>而在创建数据库的时候，我并不知道 db1 数据库有没有创建，直接再次创建名为 db1 的数据库就会出现错误。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100908835.png\" alt=\"image-20220910090806785\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090806785</figcaption></figure>\n<p>为了避免上面的错误，在创建数据库的时候先做判断，如果不存在再创建。</p>\n<ul>\n<li><strong>创建数据库(判断，如果不存在则创建)</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>运行语句效果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100908394.png\" alt=\"image-20220910090801352\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090801352</figcaption></figure>\n<p>从上面的效果可以看到虽然 db1 数据库已经存在，再创建 db1 也没有报错，而创建 db2 数据库则创建成功。</p>\n<h2> 删除数据库</h2>\n<ul>\n<li><strong>删除数据库</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li><strong>删除数据库(判断，如果存在则删除)</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>运行语句效果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100907863.png\" alt=\"image-20220910090758815\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090758815</figcaption></figure>\n<h2> 使用数据库</h2>\n<p>数据库创建好了，要在数据库中创建表，得先明确在哪儿个数据库中操作，此时就需要使用数据库。</p>\n<ul>\n<li><strong>使用数据库</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li><strong>查看当前使用的数据库</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>运行语句效果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100907430.png\" alt=\"image-20220910090753385\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090753385</figcaption></figure>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/mysql/202209100908686.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "DDL:操作表",
      "url": "https://www.h7ml.cn/posts/mysql/ddltable.html",
      "id": "https://www.h7ml.cn/posts/mysql/ddltable.html",
      "summary": "DDL:操作表 操作表也就是对表进行增（Create）删（Retrieve）改（Update）查（Delete）。 查询表 查询当前数据库下所有表名称 我们创建的数据库中没有任何表，因此我们进入 mysql 自带的 mysql 数据库，执行上述语句查看 image-20220910090749302",
      "content_html": "<h2> DDL:操作表</h2>\n<p>操作表也就是对表进行增（Create）删（Retrieve）改（Update）查（Delete）。</p>\n<h2> 查询表</h2>\n<ul>\n<li><strong>查询当前数据库下所有表名称</strong></li>\n</ul>\n<p>我们创建的数据库中没有任何表，因此我们进入 mysql 自带的 mysql 数据库，执行上述语句查看</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100907344.png\" alt=\"image-20220910090749302\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090749302</figcaption></figure>\n<ul>\n<li><strong>查询表结构</strong></li>\n</ul>\n<p>查看 mysql 数据库中 func 表的结构，运行语句如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100907412.png\" alt=\"image-20220910090745367\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090745367</figcaption></figure>\n<h2> 创建表</h2>\n<ul>\n<li><strong>创建表</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>注意：最后一行末尾，不能加逗号</p>\n</blockquote>\n<p>知道了创建表的语句，那么我们创建创建如下结构的表</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100907433.png\" alt=\"image-20220910090741389\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090741389</figcaption></figure>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行语句如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100907724.png\" alt=\"image-20220910090737679\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090737679</figcaption></figure>\n<h2> 数据类型</h2>\n<p>MySQL 支持多种类型，可以分为三类：</p>\n<ul>\n<li>\n<p>数值</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>日期</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>字符串</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n<blockquote>\n<p>注意：其他类型参考资料中的《MySQL 数据类型].xlsx》</p>\n</blockquote>\n<p><strong>案例：</strong></p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>语句设计如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 删除表</h2>\n<ul>\n<li>\n<p><strong>删除表</strong></p>\n</li>\n<li>\n<p><strong>删除表时判断表是否存在</strong></p>\n</li>\n</ul>\n<p>运行语句效果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100907228.png\" alt=\"image-20220910090731175\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090731175</figcaption></figure>\n<h2> 修改表</h2>\n<ul>\n<li><strong>修改表名</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><strong>添加一列</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><strong>修改数据类型</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><strong>修改列名和数据类型</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><strong>删除列</strong></li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://static.h7ml.cn/vitepress/assets/images/mysql/202209100907344.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "数据库设计",
      "url": "https://www.h7ml.cn/posts/mysql/design.html",
      "id": "https://www.h7ml.cn/posts/mysql/design.html",
      "summary": "数据库设计 数据库设计简介 软件的研发步骤 image-20220910095431929 数据库设计概念 数据库设计就是根据业务系统的具体需求，结合我们所选用的 DBMS，为这个业务系统构造出最优的数据存储模型。 建立数据库中的表结构以及表与表之间的关联关系的过程。 有哪些表？表里有哪些字段？表和表之间有什么关系？ 数据库设计的步骤 需求分析（数据是什么? 数据具有哪些属性? 数据与属性的特点是什么） 逻辑分析（通过 ER 图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统） 如下图就是 ER(Entity/Relation)图： image-20220910095440504 物理设计（根据数据库自身的特点把逻辑设计转换为物理设计） 维护设计（1.对新的需求进行建表；2.表优化） 表关系 一对一 如：用户 和 用户详情 一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能 image-20220910095444549 上图左边是用户的详细信息，而我们真正在展示用户信息时最长用的则是上图右边红框所示，所以我们会将详细信息查分成两周那个表。 一对多 如：部门 和 员工 一个部门对应多个员工，一个员工对应一个部门。如下图： image-20220910095448786 多对多 如：商品 和 订单 一个商品对应多个订单，一个订单包含多个商品。如下图： image-20220910095451925",
      "content_html": "<h2> 数据库设计</h2>\n<h2> 数据库设计简介</h2>\n<ul>\n<li>\n<p>软件的研发步骤</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100954963.png\" alt=\"image-20220910095431929\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095431929</figcaption></figure>\n</li>\n<li>\n<p>数据库设计概念</p>\n<ul>\n<li>数据库设计就是根据业务系统的具体需求，结合我们所选用的 DBMS，为这个业务系统构造出最优的数据存储模型。</li>\n<li>建立数据库中的<mark>表结构</mark>以及<mark>表与表之间的关联关系</mark>的过程。</li>\n<li>有哪些表？表里有哪些字段？表和表之间有什么关系？</li>\n</ul>\n</li>\n<li>\n<p>数据库设计的步骤</p>\n<ul>\n<li>\n<p>需求分析（数据是什么? 数据具有哪些属性? 数据与属性的特点是什么）</p>\n</li>\n<li>\n<p>逻辑分析（通过 ER 图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统）</p>\n<p>如下图就是 ER(Entity/Relation)图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100954530.png\" alt=\"image-20220910095440504\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095440504</figcaption></figure>\n</li>\n<li>\n<p>物理设计（根据数据库自身的特点把逻辑设计转换为物理设计）</p>\n</li>\n<li>\n<p>维护设计（1.对新的需求进行建表；2.表优化）</p>\n</li>\n</ul>\n</li>\n<li>\n<p>表关系</p>\n<ul>\n<li>\n<p>一对一</p>\n<ul>\n<li>如：用户 和 用户详情</li>\n<li>一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100954571.png\" alt=\"image-20220910095444549\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095444549</figcaption></figure>\n<p>上图左边是用户的详细信息，而我们真正在展示用户信息时最长用的则是上图右边红框所示，所以我们会将详细信息查分成两周那个表。</p>\n</li>\n<li>\n<p>一对多</p>\n<ul>\n<li>\n<p>如：部门 和 员工</p>\n</li>\n<li>\n<p>一个部门对应多个员工，一个员工对应一个部门。如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100954816.png\" alt=\"image-20220910095448786\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095448786</figcaption></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>多对多</p>\n<ul>\n<li>\n<p>如：商品 和 订单</p>\n</li>\n<li>\n<p>一个商品对应多个订单，一个订单包含多个商品。如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100954953.png\" alt=\"image-20220910095451925\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095451925</figcaption></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2> 表关系(一对多)</h2>\n<ul>\n<li>\n<p>一对多</p>\n<ul>\n<li>如：部门 和 员工</li>\n<li>一个部门对应多个员工，一个员工对应一个部门。</li>\n</ul>\n</li>\n<li>\n<p>实现方式</p>\n<p>==在多的一方建立外键，指向一的一方的主键==</p>\n</li>\n<li>\n<p>案例</p>\n<p>我们还是以 <code>员工表</code> 和 <code>部门表</code> 举例:</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100954593.png\" alt=\"image-20220910095455573\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095455573</figcaption></figure>\n<p>经过分析发现，员工表属于多的一方，而部门表属于一的一方，此时我们会在员工表中添加一列（dep_id），指向于部门表的主键（id）：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100954824.png\" alt=\"image-20220910095458797\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095458797</figcaption></figure>\n<p>建表语句如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>查看表结构模型图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100955443.png\" alt=\"image-20220910095502423\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095502423</figcaption></figure>\n</li>\n</ul>\n<h2> 表关系(多对多)</h2>\n<ul>\n<li>\n<p>多对多</p>\n<ul>\n<li>如：商品 和 订单</li>\n<li>一个商品对应多个订单，一个订单包含多个商品</li>\n</ul>\n</li>\n<li>\n<p>实现方式</p>\n<p>==建立第三张中间表，中间表至少包含两个外键，分别关联两方主键==</p>\n</li>\n<li>\n<p>案例</p>\n<p>我们以 <code>订单表</code> 和 <code>商品表</code> 举例：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100955775.png\" alt=\"image-20220910095505739\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095505739</figcaption></figure>\n<p>经过分析发现，订单表和商品表都属于多的一方，此时需要创建一个中间表，在中间表中添加订单表的外键和商品表的外键指向两张表的主键：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100955162.png\" alt=\"image-20220910095509140\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095509140</figcaption></figure>\n<p>建表语句如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-auto line-numbers-mode\" data-ext=\"auto\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100955410.png\" alt=\"image-20220910095514389\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095514389</figcaption></figure>\n<h2> 数据库设计案例</h2>\n<p>根据下图设计表及表和表之间的关系：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100955077.png\" alt=\"image-20220910095518049\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095518049</figcaption></figure>\n<p>经过分析，我们分为 <code>专辑表</code> <code>曲目表</code> <code>短评表</code> <code>用户表</code> 4 张表。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100955318.png\" alt=\"image-20220910095522282\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095522282</figcaption></figure>\n<p>一个专辑可以有多个曲目，一个曲目只能属于某一张专辑，所以专辑表和曲目表的关系是<mark>一对多</mark>。</p>\n<p>一个专辑可以被多个用户进行评论，一个用户可以对多个专辑进行评论，所以专辑表和用户表的关系是 <mark>多对多</mark>。</p>\n<p>一个用户可以发多个短评，一个短评只能是某一个人发的，所以用户表和短评表的关系是 <mark>一对多</mark>。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100955488.png\" alt=\"image-20220910095531461\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910095531461</figcaption></figure>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/mysql/202209100954963.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "DML",
      "url": "https://www.h7ml.cn/posts/mysql/dml.html",
      "id": "https://www.h7ml.cn/posts/mysql/dml.html",
      "summary": "DML 主要是对数据进行增（insert）删（delete）改（update）操作。 添加数据 给指定列添加数据 INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…);",
      "content_html": "<p>DML 主要是对数据进行增（insert）删（delete）改（update）操作。</p>\n<h2> 添加数据</h2>\n<h3> 给指定列添加数据</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 给全部列添加数据</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 批量添加数据</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 练习</h3>\n<p>为了演示以下的增删改操作是否操作成功，故先将查询所有数据的语句介绍给大家：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>-- 给指定列添加数据</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>-- 给所有列添加数据，列名的列表可以省略的</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>-- 批量添加数据</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 修改数据</h2>\n<h3> 修改表数据</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>注意：</p>\n<p>修改语句中如果不加条件，则将所有数据都修改！像上面的语句中的中括号，表示在写 sql 语句中可以省略这部分练习</p>\n<p>将张三的性别改为女</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>将张三的生日改为 1999-12-12 分数改为 99.99</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>上面语句的执行完后查询到的结果是：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100907602.png\" alt=\"image-20220910090812642\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090812642</figcaption></figure>\n<h2> 删除数据</h2>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>练习</p>\n<p>-- 删除张三记录</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>-- 删除 stu 表中所有的数据</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>",
      "image": "https://static.h7ml.cn/vitepress/assets/images/mysql/202209100907602.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "数据库相关概念",
      "url": "https://www.h7ml.cn/posts/mysql/init.html",
      "id": "https://www.h7ml.cn/posts/mysql/init.html",
      "summary": "数据库相关概念 今日目标： 完成 MySQL 的安装及登陆基本操作 能通过 SQL 对数据库进行 CRUD 能通过 SQL 对表进行 CRUD 能通过 SQL 对数据进行 CRUD 以前我们做系统，数据持久化的存储采用的是文件存储。存储到文件中可以达到系统关闭数据不会丢失的效果，当然文件存储也有它的弊端。 假设在文件中存储以下的数据： 姓名 年龄 性别 住址 张三 23 男 北京西三旗 李四 24 女 北京西二旗 王五 25 男 西安软件新城",
      "content_html": "<h2> 数据库相关概念</h2>\n<p><strong>今日目标：</strong></p>\n<blockquote>\n<ul>\n<li>完成 MySQL 的安装及登陆基本操作</li>\n<li>能通过 SQL 对数据库进行 CRUD</li>\n<li>能通过 SQL 对表进行 CRUD</li>\n<li>能通过 SQL 对数据进行 CRUD</li>\n</ul>\n</blockquote>\n<p>以前我们做系统，数据持久化的存储采用的是文件存储。存储到文件中可以达到系统关闭数据不会丢失的效果，当然文件存储也有它的弊端。</p>\n<p>假设在文件中存储以下的数据：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>现要修改李四这条数据的性别数据改为男，我们现学习的 IO 技术可以通过将所有的数据读取到内存中，然后进行修改再存到该文件中。通过这种方式操作存在很大问题，现在只有三条数据，如果文件中存储 1T 的数据，那么就会发现内存根本就存储不了。</p>\n<p>现需要既能持久化存储数据，也要能避免上述问题的技术使用在我们的系统中。数据库就是这样的一门技术。</p>\n<h2> 数据库</h2>\n<ul>\n<li>\n<p>==存储和管理数据的仓库，数据是有组织的进行存储。==</p>\n</li>\n<li>\n<p>数据库英文名是 DataBase，简称 DB。</p>\n</li>\n</ul>\n<p>数据库就是将数据存储在硬盘上，可以达到持久化存储的效果。那又是如何解决上述问题的？使用数据库管理系统。</p>\n<h2> 数据库管理系统</h2>\n<ul>\n<li>==管理数据库的大型软件==</li>\n<li>英文：DataBase Management System，简称 DBMS</li>\n</ul>\n<p>在电脑上安装了数据库管理系统后，就可以通过数据库管理系统创建数据库来存储数据，也可以通过该系统对数据库中的数据进行数据的增删改查相关的操作。我们平时说的 MySQL 数据库其实是 MySQL 数据库管理系统。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910627.png\" alt=\"image-20220910091042576\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910091042576</figcaption></figure>\n<p>通过上面的描述，大家应该已经知道了 <code>数据库管理系统</code> 和 <code>数据库</code> 的关系。那么有有哪些常见的数据库管理系统呢？</p>\n<h2> 常见的数据库管理系统</h2>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910394.png\" alt=\"image-20220910091039354\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910091039354</figcaption></figure>\n<p>接下来对上面列举的数据库管理系统进行简单的介绍：</p>\n<ul>\n<li>Oracle：收费的大型数据库，Oracle 公司的产品</li>\n<li>==MySQL==： 开源免费的中小型数据库。后来 Sun 公司收购了 MySQL，而 Sun 公司又被 Oracle 收购</li>\n<li>SQL Server：MicroSoft 公司收费的中型的数据库。C#、.net 等语言常使用</li>\n<li>PostgreSQL：开源免费中小型的数据库</li>\n<li>DB2：IBM 公司的大型收费数据库产品</li>\n<li>SQLite：嵌入式的微型数据库。如：作为 Android 内置数据库</li>\n<li>MariaDB：开源免费中小型的数据库</li>\n</ul>\n<p>我们课程上学习的是 MySQL 数据库管理系统，PostgreSQL 在一些公司也有使用，此时大家肯定会想以后在公司中如果使用我们没有学习过程的 PostgreSQL 数据库管理系统怎么办？这点大家大可不必担心，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910953.png\" alt=\"image-20220910091035909\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910091035909</figcaption></figure>\n<p>我们可以通过数据库管理系统操作数据库，对数据库中的数据进行增删改查操作，而怎么样让用户跟数据库管理系统打交道呢？就可以通过一门编程语言（SQL）来实现。</p>\n<h2> SQL</h2>\n<ul>\n<li>英文：Structured Query Language，简称 SQL，结构化查询语言</li>\n<li>操作关系型数据库的编程语言</li>\n<li>定义操作所有关系型数据库的统一标准，可以使用 SQL 操作所有的关系型数据库管理系统，以后工作中如果使用到了其他的数据库管理系统，也同样的使用 SQL 来操作。</li>\n</ul>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910627.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "MySQL 安装",
      "url": "https://www.h7ml.cn/posts/mysql/install.html",
      "id": "https://www.h7ml.cn/posts/mysql/install.html",
      "summary": "MySQL 安装 MySQL 安装 安装环境:Win10 64 位 &gt; 软件版本:MySQL 5.7.24 解压版 下载 https://downloads.mysql.com/archives/community/",
      "content_html": "<h2> MySQL 安装</h2>\n<h2> MySQL 安装</h2>\n<blockquote>\n<p><strong>安装环境:Win10 64 位</strong> &gt; <strong>软件版本:MySQL 5.7.24 解压版</strong></p>\n</blockquote>\n<h3> 下载</h3>\n<p><a href=\"https://downloads.mysql.com/archives/community/\" target=\"_blank\" rel=\"noopener noreferrer\">https://downloads.mysql.com/archives/community/</a></p>\n<p>点开上面的链接就能看到如下界面：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910202.png\" alt=\"image-20220910091031160\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910091031160</figcaption></figure>\n<p>选择选择和自己<strong>系统位数</strong>相对应的版本点击右边的<code>Download</code>，此时会进到另一个页面，同样在接近页面底部的地方找到如下图所示的位置：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910424.png\" alt=\"image-20220910091025377\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910091025377</figcaption></figure>\n<p>不用理会上面的登录和注册按钮，直接点击 <code>No thanks, just start my download.</code> 就可以下载。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910106.png\" alt=\"image-20201109134805641\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20201109134805641</figcaption></figure>\n<h3> 安装(解压)</h3>\n<p>下载完成后我们得到的是一个压缩包，将其解压，我们就可以得到 MySQL 5.7.24 的软件本体了(就是一个文件夹)，我们可以把它放在你想安装的位置。</p>\n<hr>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910785.png\" alt=\"image-20220910091016740\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910091016740</figcaption></figure>\n<h3> MySQL 卸载</h3>\n<p>如果你想卸载 MySQL，也很简单。</p>\n<p>右键开始菜单，选择<code>命令提示符(管理员)</code>，打开黑框。</p>\n<ol>\n<li>敲入<code>net stop mysql</code>，回车。</li>\n</ol>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910614.png\" alt=\"image-20220910091013576\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910091013576</figcaption></figure>\n<ol start=\"2\">\n<li>再敲入<code>mysqld -remove mysql</code>，回车。</li>\n</ol>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910808.png\" alt=\"image-20220910091011772\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910091011772</figcaption></figure>\n<ol start=\"3\">\n<li>最后删除 MySQL 目录及相关的环境变量。</li>\n</ol>\n<p><strong>至此，MySQL 卸载完成！</strong></p>\n<h2> MySQL 配置</h2>\n<h3> 添加环境变量</h3>\n<blockquote>\n<p>环境变量里面有很多选项，这里我们只用到<code>Path</code>这个参数。为什么在初始化的开始要添加环境变量呢？ 在黑框(即 CMD)中输入一个可执行程序的名字，Windows 会先在环境变量中的<code>Path</code>所指的路径中寻找一遍，如果找到了就直接执行，没找到就在当前工作目录找，如果还没找到，就报错。我们添加环境变量的目的就是能够在任意一个黑框直接调用 MySQL 中的相关程序而不用总是修改工作目录，大大简化了操作。</p>\n</blockquote>\n<p>右键<code>此电脑</code>→<code>属性</code>，点击<code>高级系统设置</code></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910164.png\" alt=\"image-20220910091008123\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910091008123</figcaption></figure>\n<p>点击<code>环境变量</code></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910546.png\" alt=\"image-20220910091004470\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910091004470</figcaption></figure>\n<p>在<code>系统变量</code>中新建 MYSQL_HOME</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910851.png\" alt=\"image-20220910091002806\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910091002806</figcaption></figure>\n<p>在<code>系统变量</code>中找到并<strong>双击</strong><code>Path</code></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910782.png\" alt=\"image-20220910091000734\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910091000734</figcaption></figure>\n<p>点击<code>新建</code></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209101003366.png\" alt=\"image-20220910100356330\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910100356330</figcaption></figure>\n<p>最后点击确定。</p>\n<p><strong>如何验证是否添加成功？</strong></p>\n<p>右键开始菜单(就是屏幕左下角)，选择<code>命令提示符(管理员)</code>，打开黑框，敲入<code>mysql</code>，回车。 如果提示<code>Can't connect to MySQL server on 'localhost'</code>则证明添加成功； 如果提示<code>mysql不是内部或外部命令，也不是可运行的程序或批处理文件</code>则表示添加添加失败，请重新检查步骤并重试。</p>\n<h3> 新建配置文件</h3>\n<p>新建一个文本文件，内容如下：</p>\n<div class=\"language-properties line-numbers-mode\" data-ext=\"properties\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>把上面的文本文件另存为，在保存类型里选<code>所有文件 (*.*)</code>，文件名叫<code>my.ini</code>，存放的路径为 MySQL 的<code>根目录</code>(例如我的是<code>D:\\software\\mysql-5.7.24-winx64</code>,根据自己的 MySQL 目录位置修改)。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100909134.png\" alt=\"image-20201109142704951\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20201109142704951</figcaption></figure>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100909420.png\" alt=\"image-20201109142737584\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20201109142737584</figcaption></figure>\n<p>上面代码意思就是配置数据库的默认编码集为 utf-8 和默认存储引擎为 INNODB。</p>\n<h3> 初始化 MySQL</h3>\n<p>在刚才的黑框中敲入<code>mysqld --initialize-insecure</code>，回车，稍微等待一会，如果出现没有出现报错信息(如下图)则证明 data 目录初始化没有问题，此时再查看 MySQL 目录下已经有 data 目录生成。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100909484.png\" alt=\"image-20201109140955772\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20201109140955772</figcaption></figure>\n<p>tips：如果出现如下错误</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100909288.png\" alt=\"image-20201109135848054\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20201109135848054</figcaption></figure>\n<p>是由于权限不足导致的，去<code>C:\\Windows\\System32</code> 下以管理员方式运行 cmd.exe</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100909686.png\" alt=\"image-20220910090916571\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090916571</figcaption></figure>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100909802.png\" alt=\"image-20220910090914682\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090914682</figcaption></figure>\n<h3> 注册 MySQL 服务</h3>\n<p>在黑框里敲入<code>mysqld -install</code>，回车。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100909337.png\" alt=\"image-20220910090912230\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090912230</figcaption></figure>\n<p>现在你的计算机上已经安装好了 MySQL 服务了。</p>\n<p>MySQL 服务器</p>\n<h3> 启动 MySQL 服务</h3>\n<p>在黑框里敲入<code>net start mysql</code>，回车。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100909282.png\" alt=\"image-20220910090906166\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090906166</figcaption></figure>\n<h3> 修改默认账户密码</h3>\n<p>在黑框里敲入<code>mysqladmin -u root password 1234</code>，这里的<code>1234</code>就是指默认管理员(即 root 账户)的密码，可以自行修改成你喜欢的。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100909112.png\" alt=\"image-20220910090903002\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090903002</figcaption></figure>\n<p><strong>至此，MySQL 5.7 解压版安装完毕！</strong></p>\n<h3> 退出</h3>\n<p>退出 mysql：</p>\n<h3> MySQL 数据模型</h3>\n<p><strong>关系型数据库：</strong></p>\n<blockquote>\n<p>关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能互相连接的 二维表 组成的数据库</p>\n</blockquote>\n<p>如下图，<code>订单信息表</code> 和 <code>客户信息表</code> 都是有行有列二维表我们将这样的称为关系型数据库。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100908517.png\" alt=\"image-20220910090859406\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090859406</figcaption></figure>\n<p>接下来看关系型数据库的优点：</p>\n<ul>\n<li>都是使用表结构，格式一致，易于维护。</li>\n<li>使用通用的 SQL 语言操作，使用方便，可用于复杂查询。\n<ul>\n<li>关系型数据库都可以通过 SQL 进行操作，所以使用方便。</li>\n<li>复杂查询。现在需要查询 001 号订单数据，我们可以看到该订单是 1 号客户的订单，而 1 号订单是李聪这个客户。以后也可以在一张表中进行统计分析等操作。</li>\n</ul>\n</li>\n<li>数据存储在磁盘中，安全。</li>\n</ul>\n<p><strong>数据模型：</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100908236.png\" alt=\"image-20220910090846126\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090846126</figcaption></figure>\n<p>如上图，我们通过客户端可以通过数据库管理系统创建数据库，在数据库中创建表，在表中添加数据。创建的每一个数据库对应到磁盘上都是一个文件夹。比如可以通过 SQL 语句创建一个数据库（数据库名称为 db1），语句如下。该语句咱们后面会学习。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100908656.png\" alt=\"image-20220910090843543\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090843543</figcaption></figure>\n<p>我们可以在数据库安装目录下的 data 目录下看到多了一个 <code>db1</code> 的文件夹。所以，<strong>在 MySQL 中一个数据库对应到磁盘上的一个文件夹。</strong></p>\n<p>而一个数据库下可以创建多张表，我们到 MySQL 中自带的 mysql 数据库的文件夹目录下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100908898.png\" alt=\"image-20220910090839791\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090839791</figcaption></figure>\n<p>而上图中右边的 <code>db.frm</code> 是表文件，<code>db.MYD</code> 是数据文件，通过这两个文件就可以查询到数据展示成二维表的效果。</p>\n<p><strong>小结：</strong></p>\n<ul>\n<li>MySQL 中可以创建多个数据库，每个数据库对应到磁盘上的一个文件夹</li>\n<li>在每个数据库中可以创建多个表，每张都对应到磁盘上一个 frm 文件</li>\n<li>每张表可以存储多条数据，数据会被存储到磁盘中 MYD 文件中</li>\n</ul>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/mysql/202209100910202.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "多表查询",
      "url": "https://www.h7ml.cn/posts/mysql/multi-table-queries.html",
      "id": "https://www.h7ml.cn/posts/mysql/multi-table-queries.html",
      "summary": "多表查询是从多张表中一次性的查询出我们想要的数据",
      "content_html": "<p>多表查询是从多张表中一次性的查询出我们想要的数据</p>\n",
      "date_published": "2022-12-14T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "SQL概述",
      "url": "https://www.h7ml.cn/posts/mysql/sql.html",
      "id": "https://www.h7ml.cn/posts/mysql/sql.html",
      "summary": "SQL 概述 了解了数据模型后，接下来我们就学习 SQL 语句，通过 SQL 语句对数据库、表、数据进行增删改查操作。 SQL 简介 英文：Structured Query Language，简称 SQL 结构化查询语言，一门操作关系型数据库的编程语言 定义操作所有关系型数据库的统一标准 对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言” 通用语法 SQL 语句可以单行或多行书写，以分号结尾。 image-20220910090836346 如上，以分号结尾才是一个完整的 sql 语句。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 同样的一条 sql 语句写成下图的样子，一样可以运行处结果。 image-20220910090831935 注释 单行注释: -- 注释内容 或 #注释内容(MySQL 特有) image-20220910090829243 GFDWQ 111111111111111111111 注意：使用-- 添加单行注释时，--后面一定要加空格，而#没有要求。 多行注释: /* 注释 */",
      "content_html": "<h2> SQL 概述</h2>\n<p>了解了数据模型后，接下来我们就学习 SQL 语句，通过 SQL 语句对数据库、表、数据进行增删改查操作。</p>\n<h2> SQL 简介</h2>\n<ul>\n<li>英文：Structured Query Language，简称 SQL</li>\n<li>结构化查询语言，一门操作关系型数据库的编程语言</li>\n<li>定义操作所有关系型数据库的统一标准</li>\n<li>对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”</li>\n</ul>\n<h2> 通用语法</h2>\n<ul>\n<li>\n<p>SQL 语句可以单行或多行书写，以分号结尾。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100916954.png\" alt=\"image-20220910090836346\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090836346</figcaption></figure>\n<p>如上，以分号结尾才是一个完整的 sql 语句。</p>\n</li>\n<li>\n<p>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</p>\n<p>同样的一条 sql 语句写成下图的样子，一样可以运行处结果。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100916982.png\" alt=\"image-20220910090831935\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090831935</figcaption></figure>\n</li>\n<li>\n<p>注释</p>\n<ul>\n<li>\n<p>单行注释: -- 注释内容 或 #注释内容(MySQL 特有)</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100916099.png\" alt=\"image-20220910090829243\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090829243</figcaption></figure>\n<p><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100916488.png\" alt=\"image-20220910090824707\" loading=\"lazy\"> GFDWQ 111111111111111111111</p>\n<blockquote>\n<p>注意：使用-- 添加单行注释时，--后面一定要加空格，而#没有要求。</p>\n</blockquote>\n</li>\n<li>\n<p>多行注释: /* 注释 */</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2> SQL 分类</h2>\n<ul>\n<li>\n<p>DDL(Data Definition Language) ： 数据定义语言，用来定义数据库对象：数据库，表，列等</p>\n<p>DDL 简单理解就是用来操作数据库，表等</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100916598.png\" alt=\"image-20220910090818084\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090818084</figcaption></figure>\n</li>\n<li>\n<p>DML(Data Manipulation Language) 数据操作语言，用来对数据库中表的数据进行增删改</p>\n<p>DML 简单理解就对表中数据进行增删改</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/mysql/202209100916681.png\" alt=\"image-20220910090815829\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090815829</figcaption></figure>\n</li>\n<li>\n<p>DQL(Data Query Language) 数据查询语言，用来查询数据库中表的记录(数据)</p>\n<p>DQL 简单理解就是对数据进行查询操作。从数据库表中查询到我们想要的数据。</p>\n</li>\n<li>\n<p>DCL(Data Control Language) 数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户</p>\n<p>DML 简单理解就是对数据库进行权限控制。比如我让某一个数据库表只能让某一个用户进行操作等。</p>\n</li>\n</ul>\n<blockquote>\n<p>注意： 以后我们最常操作的是 <code>DML</code> 和 <code>DQL</code> ，因为我们开发中最常操作的就是数据。</p>\n</blockquote>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/mysql/202209100916954.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "mysql"
      ]
    },
    {
      "title": "navicat",
      "url": "https://www.h7ml.cn/posts/navicat/",
      "id": "https://www.h7ml.cn/posts/navicat/",
      "summary": "navicat 使用 通过上面的学习，我们发现在命令行中写 sql 语句特别不方便，尤其是编写创建表的语句，我们只能在记事本上写好后直接复制到命令行进行执行。那么有没有刚好的工具提供给我们进行使用呢？ 有。 navicat 概述 Navicat for MySQL 是管理和开发 MySQL 或 MariaDB 的理想解决方案。 这套全面的前端工具为数据库管理、开发和维护提供了一款直观而强大的图形界面。 官网： http://www.navicat.com.cnopen in new window",
      "content_html": "<h2> navicat 使用</h2>\n<p>通过上面的学习，我们发现在命令行中写 sql 语句特别不方便，尤其是编写创建表的语句，我们只能在记事本上写好后直接复制到命令行进行执行。那么有没有刚好的工具提供给我们进行使用呢？ 有。</p>\n<h2> navicat 概述</h2>\n<ul>\n<li>Navicat for MySQL 是管理和开发 MySQL 或 MariaDB 的理想解决方案。</li>\n<li>这套全面的前端工具为数据库管理、开发和维护提供了一款直观而强大的图形界面。</li>\n<li>官网： <a href=\"http://www.navicat.com.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.navicat.com.cnopen in new window</a></li>\n</ul>\n<h2> navicat 安装</h2>\n<h2> navicat 使用</h2>\n<h3> 建立和 mysql 服务的连接</h3>\n<p>第一步： 点击连接，选择 MySQL</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/navicat/202209100907677.png\" alt=\"image-20220910090726636\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090726636</figcaption></figure>\n<p>第二步：填写连接数据库必要的信息</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/navicat/202209100907813.png\" alt=\"image-20220910090723770\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090723770</figcaption></figure>\n<p>以上操作没有问题就会出现如下图所示界面：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/navicat/202209100907289.png\" alt=\"image-20220910090720240\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090720240</figcaption></figure>\n<h3> 操作</h3>\n<p>连接成功后就能看到如下图界面：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/navicat/202209100907883.png\" alt=\"image-20220910090716834\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090716834</figcaption></figure>\n<ul>\n<li><strong>修改表结构</strong></li>\n</ul>\n<p>通过下图操作修改表结构：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/navicat/202209100907308.png\" alt=\"image-20220910090713257\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090713257</figcaption></figure>\n<p>点击了设计表后即出现如下图所示界面，在图中红框中直接修改字段名，类型等信息：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/navicat/202209100907673.png\" alt=\"image-20220910090709631\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090709631</figcaption></figure>\n<ul>\n<li><strong>编写 SQL 语句并执行</strong></li>\n</ul>\n<p>按照如下图所示进行操作即可书写 SQL 语句并执行 sql 语句。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/navicat/202209100907067.png\" alt=\"image-20220910090707027\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220910090707027</figcaption></figure>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/navicat/202209100907677.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "navicat"
      ]
    },
    {
      "title": "高可用配置",
      "url": "https://www.h7ml.cn/posts/nginx/Keepalived.html",
      "id": "https://www.h7ml.cn/posts/nginx/Keepalived.html",
      "summary": "高可用配置 安装 Keepalived 编译安装 下载地址 open in new window 使用 ./configure 编译安装 如遇报错提示 configure: error: !!! OpenSSL is not properly installed on your system. !!! !!! Can not include OpenSSL headers files. !!!",
      "content_html": "<h2> 高可用配置</h2>\n<h2> 安装 Keepalived</h2>\n<h3> 编译安装</h3>\n<p><a href=\"https://www.keepalived.org/download.html#\" target=\"_blank\" rel=\"noopener noreferrer\">下载地址 open in new window</a></p>\n<p>使用 <code>./configure</code> 编译安装</p>\n<p>如遇报错提示</p>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>安装依赖</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> yum 安装</h3>\n<h2> 配置</h2>\n<p>使用 yum 安装后配置文件在:<code>/etc/keepalived/keepalived.conf</code></p>\n<h3> 最小配置</h3>\n<ul>\n<li>第一台机器</li>\n</ul>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>第二台机器</li>\n</ul>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>启动服务</li>\n</ul>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "nginx"
      ]
    },
    {
      "title": "nginx",
      "url": "https://www.h7ml.cn/posts/nginx/",
      "id": "https://www.h7ml.cn/posts/nginx/",
      "summary": "安装 目录 配置与应用场景 反向代理与负载均衡 高可用配置 Https 证书配置 多域名转发",
      "content_html": "<ul>\n<li>\n<p><a href=\"/posts/nginx/install.html\" target=\"blank\">安装</a></p>\n</li>\n<li>\n<p><a href=\"/posts/nginx/mkdir.html\" target=\"blank\">目录</a></p>\n</li>\n<li>\n<p><a href=\"/posts/nginx/virtualhost.html\" target=\"blank\">配置与应用场景</a></p>\n</li>\n<li>\n<p><a href=\"/posts/nginx/proxy.html\" target=\"blank\">反向代理与负载均衡</a></p>\n</li>\n<li>\n<p><a href=\"/posts/nginx/Keepalived.html\" target=\"blank\">高可用配置</a></p>\n</li>\n<li>\n<p><a href=\"/posts/nginx/https.html\" target=\"blank\">Https 证书配置</a></p>\n</li>\n<li>\n<p><a href=\"/posts/nginx/multiDomainForwarding.html\" target=\"blank\">多域名转发</a></p>\n</li>\n</ul>\n",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "nginx"
      ]
    },
    {
      "title": "Https 证书配置",
      "url": "https://www.h7ml.cn/posts/nginx/https.html",
      "id": "https://www.h7ml.cn/posts/nginx/https.html",
      "summary": "Https 证书配置 不安全的 http 协议 http 在传输的过程中都是明文，这导致在客户端到服务器请求的过程中会被拦截数据导致数据泄露。 对称加密 image-20220907133558872",
      "content_html": "<h2> Https 证书配置</h2>\n<h2> 不安全的 http 协议</h2>\n<p>http 在传输的过程中都是<strong>明文</strong>，这导致在客户端到服务器请求的<strong>过程中会被拦截数据导致数据泄露</strong>。</p>\n<h3> 对称加密</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220907133558872.png\" alt=\"image-20220907133558872\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220907133558872</figcaption></figure>\n<p><strong>对称加密</strong>可以通过加密算法给数据进行安全一点的加密，但是这样也很容易破解。</p>\n<ul>\n<li>客户端使用<strong>加密算法</strong>对数据进行加密</li>\n<li>服务端通过<strong>相同加密算法</strong>对数据进行解密</li>\n</ul>\n<p>这样一来就完成了一次加密请求。</p>\n<p>但是如果加密算法泄露了，这样一来拦截者就可以对数据进行篡改了，因为客户端的代码都是开源的，他通过去解读加密算法的代码就可以获取到。</p>\n<h3> 非对称加密</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220915153358600.png\" alt=\"image-20220915153358600\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220915153358600</figcaption></figure>\n<p>非对称加密就是在客户端中有一把<strong>公钥</strong>（理解成一窜字符），在服务端有一把<strong>私钥</strong>。</p>\n<ul>\n<li>在客户端<strong>第一次请求</strong>服务器时，<strong>服务器会返回一把公钥</strong>。</li>\n<li><strong>客户端通过公钥给数据加密</strong>进行请求数据，服务器通过私钥对数据进行解密**（公钥是公开大家都能看到的）**。</li>\n<li>服务端通过私钥解密后在<strong>用私钥加密要返回的数据</strong>，在返回给客户端，客户端在通过公钥进行解密**（私钥只有服务端知道）**。</li>\n</ul>\n<blockquote>\n<p>这种加密一定要满足一个条件，<strong>公钥加密公钥解不开，且私钥不能泄露</strong>。</p>\n</blockquote>\n<p>但即使是这样也有是有漏洞的：</p>\n<ul>\n<li>例如我<strong>在你客户端请求的过程中让你请求我的服务器</strong>（反向代理），然后我带着你请求的参数去请求你的后端服务器。</li>\n<li>之后我<strong>将服务器返回的公钥存储起来</strong>，然后我伪造一个公钥给你。</li>\n<li><strong>当你在请求的时候就是用的我给你的公钥加密的</strong>，这样一来我就可以<strong>通过我的私钥进行解密拿到明文数据</strong>。</li>\n<li>然后我<strong>将拿到的数据在通过存储的服务器返回的公钥进行加密，返回给服务器。</strong></li>\n<li>这样一来就完成了数据的拦截。</li>\n</ul>\n<p>所有不管是对称加密还是非对称加密都是不安全的。</p>\n<h2> CA 证书</h2>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20221014144324807.png\" alt=\"image-20221014144324807\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221014144324807</figcaption></figure>\n<p>通过上述的<strong>对称加密</strong>和<strong>非对称加密</strong>，我们知道不管是哪种在网络传输过程中都会被人给拦截篡改，所以都不安全，为了解决这一问题就有了<strong>CA 证书</strong>这么一个认证机构。</p>\n<p>首先他是怎么工作的：</p>\n<ul>\n<li>在服务器下发公钥时，服务器会提交一些<strong>资料（这个资料是在服务器的某个目录下的文件）<strong>给 CA 机构来</strong>验证身份</strong>。</li>\n<li>身份验证成功后会<strong>CA 机构会将服务器提交的公钥进行加密</strong>，通过<strong>CA.私钥加算法</strong>来生成一个<strong>证书</strong>。</li>\n<li>之后服务器就不会将公钥下发给客户端了，而是<strong>把证书给客户端</strong>。\n<ul>\n<li>这里在服务器下发证书的过程中，也是可以被拦截者给篡改的，也是可以解开的。</li>\n<li>但如果拦截者解开了证书拿到了公钥，在对公钥进行加密返回给客户端，但这样是无法认证成功的，因为<strong>CA 的私钥是一种特殊的私钥，他是操作系统内置的私钥，CA 认证机构是不在网络中传输的</strong>，所以只要你篡改了，客户端和 CA 机构都是不认的。</li>\n</ul>\n</li>\n<li>客户端拿到证书后通过<strong>CA 的公钥进行解密得到服务器的公钥</strong>。</li>\n</ul>\n<p>操作系统内置的证书：</p>\n<p>Windows：cmd 输入 certmgr.msc</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20221014144636291.png\" alt=\"image-20221014144636291\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221014144636291</figcaption></figure>\n<p>这里有你所有的证书包括第三方下载的证书都在这。</p>\n<h2> 证书安装</h2>\n<p><a href=\"https://cloud.tencent.com/document/product/400/35244\" target=\"_blank\" rel=\"noopener noreferrer\">腾讯云 open in new window</a></p>\n<h2> 已安装的 Nginx 上开启 SSL 模块并配置 https</h2>\n<p>安装目录是 <strong>/usr/local/nginx</strong>，</p>\n<p>源码解压目录是 <strong>/usr/local/src/nginx-1.22.0</strong></p>\n<p>1、切换到 Nginx 安装目录下的 sbin 目录</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>2、将 Nginx 停止运行</p>\n<p>3、切换到源码解压目录</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>4、查看 Nginx 原有的模块配置</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>5、在**configure arguments:**后面显示的原有的 configure 参数如下：</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20221014162914185.png\" alt=\"image-20221014162914185\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221014162914185</figcaption></figure>\n<p>6、在已有的配置基础上新增 **--with-http_ssl_module，**形成新的配置命令，并在源码目录运行下面的命令</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>7、配置完成后，继续运行命令 <strong>make</strong></p>\n<p><strong>切记：这里不要进行 make install，否则就是覆盖安装</strong></p>\n<p>8、备份原有已安装好的 nginx 文件</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>9、将刚刚编译好的 nginx 文件覆盖掉原有的 nginx</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>10、查看是否已经加入成功</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>此时看到 ssl 模块已经被加载</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20221014163203113.png\" alt=\"image-20221014163203113\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20221014163203113</figcaption></figure>\n<p>11、配置 https Server</p>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>12、启动 Nginx，访问 https 域名，即可访问成功。</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>",
      "image": "https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220907133558872.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "nginx"
      ]
    },
    {
      "title": "安装",
      "url": "https://www.h7ml.cn/posts/nginx/install.html",
      "id": "https://www.h7ml.cn/posts/nginx/install.html",
      "summary": "安装 版本区别 常用版本分为四大阵营 Nginx 开源版 open in new window Nginx plus 商业版 open in new window openrestyopen in new window Tengineopen in new window",
      "content_html": "<h2> 安装</h2>\n<h2> 版本区别</h2>\n<p>常用版本分为四大阵营</p>\n<ul>\n<li>\n<p><a href=\"http://nginx.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx 开源版 open in new window</a></p>\n</li>\n<li>\n<p><a href=\"https://www.nginx.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx plus 商业版 open in new window</a></p>\n</li>\n<li>\n<p><a href=\"http://openresty.org/cn/\" target=\"_blank\" rel=\"noopener noreferrer\">openrestyopen in new window</a></p>\n</li>\n<li>\n<p><a href=\"http://tengine.taobao.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Tengineopen in new window</a></p>\n</li>\n</ul>\n<p>Nginx 的安装可以选择源码编译的方式也可以使用宝塔面板安装，本文采用的是源码编译安装。</p>\n<h2> 下载 Nginx</h2>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220906163814476.png\" alt=\"image-20220906163814476\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220906163814476</figcaption></figure>\n<h2> 使用源码编译安装</h2>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 如果出现警告或报错</h3>\n<p><strong>提示：</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>安装 gcc</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>提示：</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>安装 perl 库</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>提示：</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>安装 zlib 库:</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>出现这个代表安装成功</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> <strong>接下来执行</strong></h3>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> <strong>启动 nginx</strong></h3>\n<p><strong>进入安装好的目录 <code>/usr/local/nginx/sbin</code></strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 关于防火墙</h3>\n<p><strong>关闭防火墙</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>禁止防火墙开机启动</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>放行端口</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>重启防火墙</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 安装成系统服务</h3>\n<p><strong>创建服务脚本</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>服务脚本内容</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>重新加载系统服务</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>启动服务</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>查看服务是否启动成功</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220906171209767.png\" alt=\"image-20220906171209767\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220906171209767</figcaption></figure>\n<p><strong>开机启动</strong></p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>",
      "image": "https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220906163814476.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "nginx"
      ]
    },
    {
      "title": "目录",
      "url": "https://www.h7ml.cn/posts/nginx/mkdir.html",
      "id": "https://www.h7ml.cn/posts/nginx/mkdir.html",
      "summary": "目录 目录结构 进入 Nginx 的主目录我们可以看到这些文件夹 ├── client_body_temp ├── conf │ ├── fastcgi.conf │ ├── fastcgi.conf.default │ ├── fastcgi_params │ ├── fastcgi_params.default │ ├── koi-utf │ ├── koi-win │ ├── mime.types │ ├── mime.types.default │ ├── nginx.conf │ ├── nginx.conf.default │ ├── scgi_params │ ├── scgi_params.default │ ├── uwsgi_params │ ├── uwsgi_params.default │ └── win-utf ├── fastcgi_temp ├── html │ ├── 50x.html │ └── index.html ├── logs │ ├── access.log │ ├── error.log │ └── nginx.pid ├── proxy_temp ├── sbin │ └── nginx ├── scgi_temp └── uwsgi_temp",
      "content_html": "<h2> 目录</h2>\n<h2> 目录结构</h2>\n<p>进入 Nginx 的主目录我们可以看到这些文件夹</p>\n<div class=\"language-crystal line-numbers-mode\" data-ext=\"crystal\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中这几个文件夹在刚安装后是没有的，主要用来存放运行过程中的临时文件</p>\n<ul>\n<li>client_body_temp</li>\n<li>fastcgi_temp</li>\n<li>proxy_temp</li>\n<li>scgi_temp</li>\n</ul>\n<p><strong>conf</strong></p>\n<ul>\n<li>用来存放配置文件相关</li>\n</ul>\n<p><strong>html</strong></p>\n<ul>\n<li>用来存放静态文件的默认目录 html、css 等</li>\n</ul>\n<p><strong>sbin</strong></p>\n<ul>\n<li>nginx 的主程序</li>\n</ul>\n<h2> 基本运行原理</h2>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220907111607186.png\" alt=\"image-20220907111607186\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220907111607186</figcaption></figure>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220907111607186.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "nginx"
      ]
    },
    {
      "title": "nginx多域名转发配置",
      "url": "https://www.h7ml.cn/posts/nginx/multiDomainForwarding.html",
      "id": "https://www.h7ml.cn/posts/nginx/multiDomainForwarding.html",
      "summary": "Nginx 是一个高性能的 Web 服务器和反向代理服务器。它可以用来配置多个域名和路由规则，将请求转发到不同的后端服务器或者处理请求本身。在这篇文章中，我们将讨论如何使用 Nginx 配置多域名转发。 假设我们有两个域名，分别是 example.com 和 example.net。我们希望将这两个域名分别转发到不同的后端服务器上。我们需要进行以下步骤：",
      "content_html": "<p>Nginx 是一个高性能的 Web 服务器和反向代理服务器。它可以用来配置多个域名和路由规则，将请求转发到不同的后端服务器或者处理请求本身。在这篇文章中，我们将讨论如何使用 Nginx 配置多域名转发。</p>\n<p>假设我们有两个域名，分别是 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener noreferrer\">example.com</a> 和 <a href=\"http://example.net\" target=\"_blank\" rel=\"noopener noreferrer\">example.net</a>。我们希望将这两个域名分别转发到不同的后端服务器上。我们需要进行以下步骤：</p>\n<h3> 1. 安装 Nginx</h3>\n<p>首先，我们需要在服务器上安装 Nginx。在 Linux 系统中，可以使用 apt-get 或 yum 等包管理器进行安装。安装完成后，我们可以使用以下命令来检查 Nginx 是否已经启动：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 2. 配置 Nginx</h3>\n<p>接下来，我们需要配置 Nginx，让它能够转发请求。打开 Nginx 的配置文件，一般在/etc/nginx/nginx.conf 中。在 http 块中添加以下代码：</p>\n<div class=\"language-nginx.conf line-numbers-mode\" data-ext=\"nginx.conf\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>接下来，我们需要配置 Nginx，让它能够转发请求。打开 Nginx 的配置文件，一般在/etc/nginx/nginx.conf 中。在 http 块中添加以下代码：</p>\n<div class=\"language-nginx.conf line-numbers-mode\" data-ext=\"nginx.conf\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在上面的代码中，我们定义了两个 server 块，分别对应 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener noreferrer\">example.com</a> 和 <a href=\"http://example.net\" target=\"_blank\" rel=\"noopener noreferrer\">example.net</a> 的请求。其中 listen 80 表示监听 80 端口，server_name 表示该 server 块所对应的域名，location /表示处理根路径下的请求。在 location 块中，我们使用了 proxy_pass 指令将请求转发到对应的后端服务器。</p>\n<p>在最后的 upstream 块中，我们定义了两个后端服务器的地址。这些地址可以是 IP 地址或者域名。</p>\n<h3> 3. 重启 Nginx</h3>\n<p>修改完成配置文件后，我们需要重启 Nginx，使配置生效。使用以下命令重启 Nginx：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 4. 测试转发</h3>\n<p>现在，我们可以使用浏览器访问 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener noreferrer\">example.com</a> 和 <a href=\"http://example.net\" target=\"_blank\" rel=\"noopener noreferrer\">example.net</a> 来测试转发是否生效。如果一切顺利，请求应该会被转发到对应的后端服务器上。</p>\n<h3> 总结</h3>\n<p>在本文中，我们介绍了如何使用 Nginx 配置多域名转发。通过配置 Nginx 的 server 块和 upstream 块，我们可以将请求转发到不同的后端服务器上。如果您需要更复杂的路由规则，可以参考 Nginx 官方文档和在线社区的资源。</p>\n",
      "date_published": "2023-03-04T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "nginx"
      ]
    },
    {
      "title": "反向代理与负载均衡",
      "url": "https://www.h7ml.cn/posts/nginx/proxy.html",
      "id": "https://www.h7ml.cn/posts/nginx/proxy.html",
      "summary": "反向代理与负载均衡 反向代理 当用户不能直接访问应用服务器时候，这时候就通过Nginx去带着你的参数去访问应用服务器，之后在把数据返回给网关（路由器），在由网关把数据传输到用户。 image-20220909155253447",
      "content_html": "<h2> 反向代理与负载均衡</h2>\n<h2> 反向代理</h2>\n<p>当用户不能直接访问应用服务器时候，这时候就通过<code>Nginx</code>去带着你的参数去访问应用服务器，之后在把数据返回给网关（路由器），在由网关把数据传输到用户。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220909155253447.png\" alt=\"image-20220909155253447\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220909155253447</figcaption></figure>\n<h2> 正向代理</h2>\n<p>如果把外网的<code>Internet</code>想象成一个巨大的资源库，则内网中的客户端要访问<code>Internet</code>，则需要通过代理服务器来访问，这种代理服务就称为正向代理，下面是正向代理的原理图。</p>\n<p>由于工作环境原因，日常工作只能局限于单位的局域网，如果想要访问互联网，怎么办呢？这就需要用到正向代理，本人经常用正向代理来进行上网。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220909155954732.png\" alt=\"image-20220909155954732\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220909155954732</figcaption></figure>\n<h2> 传统公司系统架构</h2>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220909162133603.png\" alt=\"image-20220909162133603\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220909162133603</figcaption></figure>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220909162405739.png\" alt=\"image-20220909162405739\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220909162405739</figcaption></figure>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220909162157266.png\" alt=\"image-20220909162157266\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220909162157266</figcaption></figure>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220909162405739.png\" alt=\"image-20220909162405739\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220909162405739</figcaption></figure>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220909162246272.png\" alt=\"image-20220909162246272\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220909162246272</figcaption></figure>\n<h2> 反向代理设置</h2>\n<p>修改<code>nginx.conf</code> 配置。</p>\n<blockquote>\n<p>注意每个<code>{}</code>里面每一行结束都需写<code>;</code>。（坑）</p>\n</blockquote>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p>proxy_pass: 可以设置具体的主机 ip，也可以设置完整的域名。</p>\n</li>\n<li>\n<p>设置域名时，一定要带上域名前缀</p>\n</li>\n</ul>\n<p>例如<code>www.atguigu.com</code>和<code>atguigu.com</code>,意义就不一样了。</p>\n<p><code>proxy_pass http://www.atguigu.com/</code></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/202209111518300.png\" alt=\"image-20220911151833258\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220911151833258</figcaption></figure>\n<p><code>proxy_pass http://atguigu.com/</code></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/202209111515886.png\" alt=\"image-20220911151541839\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220911151541839</figcaption></figure>\n<p>可以发现设置<code>proxy_pass http://atguigu.com/</code>后浏览器的地址拦就变了，不在是我们的 IP 站点而变成了代理的地址。</p>\n<ul>\n<li>Status Code: 302 Moved Temporarily（临时重定向）</li>\n<li>Location: <code>http://www.atguigu.com/</code></li>\n</ul>\n<p>302 也就是临时重定向到另一个站点，这个站点就是 Location 的值。</p>\n<p>还有一点就是在代理 https 的域名如果也这么设置也会重定向，例如<code>www.baidu.com</code>，就是 https 协议的域名。</p>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这样设置也会重定向，后面会讲到 https 协议代理。</p>\n<h2> 负载均衡</h2>\n<h3> 什么是负载均衡</h3>\n<p>所谓负载均衡，就是 Nginx 把请求均匀的分摊给上游的应用服务器，这样即使某一个服务器宕机也不会影响请求的处理，或者当应用服务器扛不住了，可以随时进行扩容</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/202209111606565.png\" alt=\"image-20220911160604530\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220911160604530</figcaption></figure>\n<h3> 基于反向代理的负载均衡</h3>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 负载均衡策略</h2>\n<h3> 轮询</h3>\n<p>默认情况下使用轮询方式，逐一转发，这种方式适用于无状态请求。</p>\n<h3> weight(权重)</h3>\n<p>指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。</p>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>down：表示当前的 server 暂时不参与负载</li>\n<li>weight：默认为 1.weight 越大，负载的权重就越大。</li>\n<li>backup： 其它所有的非 backup 机器 down 或者忙的时候，请求 backup 机器。</li>\n</ul>\n<p><strong>轮询的弊端</strong>：无法保持会话</p>\n<h3> ip_hash</h3>\n<p>根据客户端的 ip 地址转发同一台服务器，可以保持回话。</p>\n<h3> least_conn</h3>\n<p>最少连接访问</p>\n<h3> url_hash</h3>\n<p>根据用户访问的 url 定向转发请求</p>\n<h3> fair</h3>\n<p>根据后端服务器响应时间转发请求</p>\n<h3> 动静分离</h3>\n<h4> 配置反向代理</h4>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 增加每一个 location</h4>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 使用一个 location</h4>\n<p>使用正则</p>\n<h5> <strong>location 前缀</strong></h5>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>/</code></td>\n<td>通用匹配，任何请求都会匹配到</td>\n</tr>\n<tr>\n<td><code>=</code></td>\n<td>精准匹配，不是以指定模式开头</td>\n</tr>\n<tr>\n<td><code>~</code></td>\n<td>正则匹配，区分大小写</td>\n</tr>\n<tr>\n<td><code>~*</code></td>\n<td>正则匹配，不区分大小写</td>\n</tr>\n<tr>\n<td><code>^~</code></td>\n<td>非正则匹配，匹配以指定模式开头的 location</td>\n</tr>\n</tbody>\n</table>\n<h5> <strong>location 匹配顺序</strong></h5>\n<ul>\n<li>多个正则 location 直接按书写顺序匹配，成功后就不会继续往后面匹配</li>\n<li>普通（非正则）location 会一直往下，直到找到匹配度最高的（最大前缀匹配）</li>\n<li>当普通 location 与正则 location 同时存在，如果正则匹配成功,则不会再执行普通匹配</li>\n<li>所有类型 location 存在时，“=”匹配 &gt; “^~”匹配 &gt; 正则匹配 &gt; 普通（最大前缀匹配）</li>\n</ul>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> <strong>alias 与 root</strong></h5>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>root 用来设置根目录，而 alias 在接受请求的时候在路径上不会加上 location。</p>\n<ul>\n<li>1）alias 指定的目录是准确的，即 location 匹配访问的 path 目录下的文件直接是在 alias 目录下查找的；</li>\n<li>2）root 指定 的目录是 location 匹配访问的 path 目录的上一级目录,这个 path 目录一定要是真实存在 root 指定目录下的；</li>\n<li>3）使用 alias 标签的目录块中不能使用 rewrite 的 break（具体原因不明）；另外，alias 指定的目录后面必须要加上\"/\"符 号！！</li>\n<li>4）alias 虚拟目录配置中，location 匹配的 path 目录如果后面不带\"/\"，那么访问的 url 地址中这个 path 目录后 面加不加\"/\"不影响访问，访问时它会自动加上\"/\"； 但是如果 location 匹配的 path 目录后面加上\"/\"，那么访问的 url 地 址中这个 path 目录必须要加上\"/\"，访问时它不会自动加上\"/\"。如果不加上\"/\"，访问就会失败！</li>\n<li>5）root 目录配置 中，location 匹配的 path 目录后面带不带\"/\"，都不会影响访问。</li>\n</ul>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220909155253447.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "nginx"
      ]
    },
    {
      "title": "配置与应用场景",
      "url": "https://www.h7ml.cn/posts/nginx/virtualhost.html",
      "id": "https://www.h7ml.cn/posts/nginx/virtualhost.html",
      "summary": "配置与应用场景 域名解析 image-20220909095951565 浏览器、Nginx 与 HTTP 协议 电脑拿到 IP 地址、首先会先发送 TCP/IP 协议（HTTP 或 HTTPS 协议在 TCP/IP 协议之上，TCP/IP 协议只能传输二进制数据）。 在宽带（电信、联通、移动）的主干网上会进过很多个网关（也可以理解为路由器）。 从家里的网关=&gt;&gt;小区的网关=&gt;&gt;服务商的网关=&gt;&gt;（电信、联通、移动）的网关=&gt;&gt;区域的网关=&gt;&gt;市里的网关=&gt;&gt;全国的总网关=&gt;&gt;最后才到主干网上。 HTTPS 就是在这个过程中给你是数据进行了加密。",
      "content_html": "<h2> 配置与应用场景</h2>\n<h2> 域名解析</h2>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220909095951565.png\" alt=\"image-20220909095951565\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220909095951565</figcaption></figure>\n<h3> 浏览器、Nginx 与 HTTP 协议</h3>\n<ul>\n<li>电脑拿到 IP 地址、首先会先发送 TCP/IP 协议（HTTP 或 HTTPS 协议在 TCP/IP 协议之上，TCP/IP 协议只能传输二进制数据）。</li>\n<li>在宽带（电信、联通、移动）的主干网上会进过很多个网关（也可以理解为路由器）。</li>\n<li>从家里的网关=&gt;&gt;小区的网关=&gt;&gt;服务商的网关=&gt;&gt;（电信、联通、移动）的网关=&gt;&gt;区域的网关=&gt;&gt;市里的网关=&gt;&gt;全国的总网关=&gt;&gt;最后才到主干网上。</li>\n<li>HTTPS 就是在这个过程中给你是数据进行了加密。</li>\n</ul>\n<h2> 虚拟主机的原理</h2>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样的话一台主机就可以给外界公布一个公网 IP，如果公网 IP 只绑定了一个 IP 地址上，这样就有可能会造成<strong>性能过剩</strong>，因为这一台主机不会时时的高访问。</p>\n<p>如果将多个域名绑定到一台主机上，在<strong>通过 Nginx 服务器来判断你访问的是哪一个域名</strong>，之后在返回给你对应的资源</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220909111838691.png\" alt=\"image-20220909111838691\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220909111838691</figcaption></figure>\n<h3> 本地域名解析</h3>\n<p>找到本地主机的 hosts 文件 <code>C:\\Windows\\System32\\drivers\\etc</code></p>\n<p>在最后加上：</p>\n<p>IP 地址 域名</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 公网域名配置与泛域名解析</h3>\n<p>首先需要一个域名，购买渠道阿里云、腾讯云，这里已阿里云</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220909131341414.png\" alt=\"image-20220909131341414\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220909131341414</figcaption></figure>\n<p><strong>主机记录</strong></p>\n<ul>\n<li>第一种：指定前缀的，例如 www 之类的。</li>\n<li>第二种：不填，例如我现在的域名是 <a href=\"http://gopeak.cn\" target=\"_blank\" rel=\"noopener noreferrer\">gopeak.cn</a> ,也会匹配到 <code>www.gopeak.cn</code>。</li>\n<li>第三种：填 <code>*</code>（通配符），这样所有的二级，三级等域名<strong>都会匹配到当前主机上</strong></li>\n</ul>\n<p><strong>记录值</strong>：也就是主机名</p>\n<h3> 配置多个虚拟主机</h3>\n<p><strong>域名设置</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220909144630354.png\" alt=\"image-20220909144630354\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220909144630354</figcaption></figure>\n<p><strong>Nginx 设置</strong></p>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 最小配置</h3>\n<h4> worker_processes</h4>\n<ul>\n<li><code>worker_processes 1</code>; 默认为 1，表示<strong>开启一个业务进程</strong></li>\n</ul>\n<h4> worker_connections</h4>\n<ul>\n<li><code>worker_connections 1024</code>; <strong>单个业务</strong>进程可接受连接数</li>\n</ul>\n<h4> include mime.types</h4>\n<ul>\n<li><code>include mime.types</code>; 引入<code>http mime</code>类型，<strong>在请求头中标明服务端给客户端返回的文件是什么类型的文件</strong>。</li>\n</ul>\n<h4> default_type application/octet-stream</h4>\n<ul>\n<li><code>default_type application/octet-stream</code>; <strong>如果<code>mime</code>类型没匹配上</strong>，默认使用二进制流的方式传输。</li>\n</ul>\n<h4> sendfile on</h4>\n<ul>\n<li><code>sendfile on</code>; 使用<code>linux</code>的 <code>sendfile(socket, file, len)</code> 高效网络传输，也就是数据 0 拷贝。</li>\n</ul>\n<p><strong>未开启<code>sendfile</code></strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220907111843362.png\" alt=\"image-20220907111843362\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220907111843362</figcaption></figure>\n<p><strong>开启<code>sendfile</code>后</strong></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220907111937461.png\" alt=\"image-20220907111937461\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220907111937461</figcaption></figure>\n<h4> keepalive_timeout 65</h4>\n<ul>\n<li>keepalive_timeout 65;</li>\n</ul>\n<h4> server</h4>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220907112032197.png\" alt=\"image-20220907112032197\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220907112032197</figcaption></figure>\n<h3> 虚拟主机配置</h3>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 虚拟主机</h4>\n<p>原本一台服务器只能对应一个站点，通过虚拟主机技术可以虚拟化成多个站点同时对外提供服务</p>\n<h4> servername 匹配规则</h4>\n<p>我们需要注意的是<code>servername</code>匹配分先后顺序，写在前面的匹配上就不会继续往下匹配了。</p>\n<h4> 完整匹配</h4>\n<p>我们可以在同一<code>servername</code>中匹配多个域名</p>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> 通配符匹配</h4>\n<h4> 通配符结束匹配</h4>\n<h4> 正则匹配</h4>\n<div class=\"language-nginx line-numbers-mode\" data-ext=\"nginx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>",
      "image": "https://static.h7ml.cn/vitepress/assets/images/nginx/image-20220909095951565.png",
      "date_published": "2022-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "nginx"
      ]
    },
    {
      "title": "react",
      "url": "https://www.h7ml.cn/posts/react/",
      "id": "https://www.h7ml.cn/posts/react/",
      "summary": "概念 什么是不可变数据 - React 强调的『不可变数据结构』怎么实现? 各流派 React 状态管理对比和原理实现 在无状态组件每一次函数上下文执行的时候，react 用什么方式记录了 hooks 的状态？ 多个 react-hooks 用什么来记录每一个 hooks 的顺序的 ？ 换个问法！为什么不能条件语句中，声明 hooks? hooks 声明为什么在组件的最顶部？ function 函数组件中的 useState，和 class 类组件 setState 有什么区别？ react 是怎么捕获到 hooks 的执行上下文，是在函数组件内部的？ useEffect,useMemo 中，为什么 useRef 不需要依赖注入，就能访问到最新的改变值？ useMemo 是怎么对值做缓存的？如何应用它优化性能？ 为什么两次传入 useState 的值相同，函数组件不更新? ...",
      "content_html": "<h2> 概念</h2>\n<ol>\n<li>什么是不可变数据 - <a href=\"https://juejin.cn/post/6844903859618332680\" target=\"_blank\" rel=\"noopener noreferrer\">React 强调的『不可变数据结构』怎么实现?</a></li>\n<li><a href=\"https://juejin.cn/post/6990162313256894471\" target=\"_blank\" rel=\"noopener noreferrer\">各流派 React 状态管理对比和原理实现</a></li>\n<li>在无状态组件每一次函数上下文执行的时候，react 用什么方式记录了 hooks 的状态？</li>\n<li>多个 react-hooks 用什么来记录每一个 hooks 的顺序的 ？ 换个问法！为什么不能条件语句中，声明 hooks? hooks 声明为什么在组件的最顶部？</li>\n<li>function 函数组件中的 useState，和 class 类组件 setState 有什么区别？</li>\n<li>react 是怎么捕获到 hooks 的执行上下文，是在函数组件内部的？</li>\n<li>useEffect,useMemo 中，为什么 useRef 不需要依赖注入，就能访问到最新的改变值？</li>\n<li>useMemo 是怎么对值做缓存的？如何应用它优化性能？</li>\n<li>为什么两次传入 useState 的值相同，函数组件不更新?</li>\n<li>...</li>\n</ol>\n<h2> 收藏夹</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6908895801116721160\" target=\"_blank\" rel=\"noopener noreferrer\">「react 进阶」年终送给 react 开发者的八条优化建议(篇幅较长，占用 20-30 分钟)</a></li>\n<li><a href=\"https://pomb.us/build-your-own-react/\" target=\"_blank\" rel=\"noopener noreferrer\">Build your own React</a></li>\n<li><a href=\"https://react.iamkasong.com/me.html\" target=\"_blank\" rel=\"noopener noreferrer\">React 技术揭秘</a></li>\n<li><a href=\"https://github.com/BUPTlhuanyu/ReactNote\" target=\"_blank\" rel=\"noopener noreferrer\">对 react 相关代码库以及框架的源码进行了一定的分析</a></li>\n</ul>\n",
      "date_published": "2022-01-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "react"
      ]
    },
    {
      "title": "concurrent",
      "url": "https://www.h7ml.cn/posts/react/concurrent.html",
      "id": "https://www.h7ml.cn/posts/react/concurrent.html",
      "summary": "concurrent 模式 react diff 原理 The Plan for React 18 为数据获取挂起——描述了一种在 React 组件中获取数据的新机制。https://reactjs.org/docs/concurrent-mode-suspense.html 并发用户界面模式——展示了一些基于并发模式和挂起模式的用户界面模式。https://reactjs.org/docs/concurrent-mode-patterns.html 采用并发模式——说明了如何在项目中尝试并发模式。https://reactjs.org/docs/concurrent-mode-adoption.html 并发模式 API 参考——实验版本中可用的新 API 文档。https://reactjs.org/docs/concurrent-mode-reference.html",
      "content_html": "<h2> concurrent 模式</h2>\n<h3> react diff 原理</h3>\n<ul>\n<li><a href=\"https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html\" target=\"_blank\" rel=\"noopener noreferrer\">The Plan for React 18</a></li>\n<li>为数据获取挂起——描述了一种在 React 组件中获取数据的新机制。<a href=\"https://reactjs.org/docs/concurrent-mode-suspense.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://reactjs.org/docs/concurrent-mode-suspense.html</a></li>\n<li>并发用户界面模式——展示了一些基于并发模式和挂起模式的用户界面模式。<a href=\"https://reactjs.org/docs/concurrent-mode-patterns.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://reactjs.org/docs/concurrent-mode-patterns.html</a></li>\n<li>采用并发模式——说明了如何在项目中尝试并发模式。<a href=\"https://reactjs.org/docs/concurrent-mode-adoption.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://reactjs.org/docs/concurrent-mode-adoption.html</a></li>\n<li>并发模式 API 参考——实验版本中可用的新 API 文档。<a href=\"https://reactjs.org/docs/concurrent-mode-reference.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://reactjs.org/docs/concurrent-mode-reference.html</a></li>\n</ul>\n",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "react"
      ]
    },
    {
      "title": "diff",
      "url": "https://www.h7ml.cn/posts/react/diff.html",
      "id": "https://www.h7ml.cn/posts/react/diff.html",
      "summary": "react diff 原理 概念 调和函数(源码)是在fiber树构(对比更新)过程中对旧fiber节点与新reactElement进行比较, 判定旧fiber节点是否可以复用的一个比较函数.",
      "content_html": "<h2> react diff 原理</h2>\n<h3> 概念</h3>\n<p>调和函数(<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L1274-L1410\" target=\"_blank\" rel=\"noopener noreferrer\">源码</a>)是在<code>fiber树构(对比更新)</code>过程中对<code>旧fiber节点</code>与<code>新reactElement</code>进行比较, 判定<code>旧fiber节点</code>是否可以复用的一个比较函数.</p>\n<p>调和函数仅是<code>fiber树构造</code>过程中的一个环节, 所以在深入理解这个函数之前, 建议对<code>fiber树构造</code>有一个宏观的理解(可以参考前文 fiber 树构造(初次创建), fiber 树构造(对比更新), 本节重点探讨其算法的实现细节.</p>\n<p>它的主要作用:</p>\n<ol>\n<li>给新增,移动,和删除节点设置<code>fiber.flags</code>(新增, 移动: <code>Placement</code>, 删除: <code>Deletion</code>)</li>\n<li>如果是需要删除的<code>fiber</code>, <a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L275-L294\" target=\"_blank\" rel=\"noopener noreferrer\">除了自身打上<code>Deletion</code>之外, 还要将其添加到父节点的<code>effects</code>链表中</a>(正常副作用队列的处理是在<code>completeWork</code>函数, 但是该节点(被删除)会脱离<code>fiber</code>树, 不会再进入<code>completeWork</code>阶段, 所以在<code>beginWork</code>阶段提前加入副作用队列).</li>\n</ol>\n<h3> 特性</h3>\n<p>算法复杂度低, 从上至下比较整个树形结构, 时间复杂度被缩短到 O(n)</p>\n<h3> 基本原理</h3>\n<ol>\n<li>比较对象: <code>fiber</code>对象与<code>ReactElement</code>对象相比较.\n<ul>\n<li>注意: 此处有一个误区, 并不是两棵 fiber 树相比较, 而是<code>旧fiber</code>对象与<code>新ReactElement</code>对象向比较, 结果生成新的<code>fiber子节点</code>.</li>\n<li>可以理解为输入<code>ReactElement</code>, 经过<code>reconcileChildren()</code>之后, 输出<code>fiber</code>.</li>\n</ul>\n</li>\n<li>比较方案:\n<ul>\n<li>单节点比较</li>\n<li>可迭代节点比较</li>\n</ul>\n</li>\n</ol>\n<h4> 单节点比较</h4>\n<p>单节点的逻辑比较简明, 先直接看<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L1135-L1233\" target=\"_blank\" rel=\"noopener noreferrer\">源码</a>:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol>\n<li>如果是新增节点, 直接新建 fiber, 没有多余的逻辑</li>\n<li>如果是对比更新\n<ul>\n<li>如果<code>key</code>和<code>type</code>都相同(即: <code>ReactElement.key</code> === <code>Fiber.key</code> 且 <code>Fiber.elementType === ReactElement.type</code>), 则复用</li>\n<li>否则新建</li>\n</ul>\n</li>\n</ol>\n<p>注意: 复用过程是调用<code>useFiber(child, element.props)</code>创建<code>新的fiber</code>对象, 这个<code>新fiber对象.stateNode = currentFirstChild.stateNode</code>, 即<code>stateNode</code>属性得到了复用, 故 DOM 节点得到了复用.</p>\n<h3> 可迭代节点比较(数组类型, [Symbol.iterator]=fn,[@@iterator]=fn)</h3>\n<p>可迭代节点比较, 在<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L1346-L1362\" target=\"_blank\" rel=\"noopener noreferrer\">源码中</a>被分为了 2 个部分:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中<code>reconcileChildrenArray函数</code>(针对数组类型)和<code>reconcileChildrenIterator</code>(针对可迭代类型)的核心逻辑几乎一致, 下文将分析<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactChildFiber.old.js#L771-L924\" target=\"_blank\" rel=\"noopener noreferrer\"><code>reconcileChildrenArray()</code>函数</a>. 如果是新增节点, 所有的比较逻辑都无法命中, 只有<code>对比更新</code>过程, 才有实际作用, 所以下文重点分析<code>对比更新</code>的情况.</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>reconcileChildrenArray</code>函数源码看似很长, 梳理其主干之后, 其实非常清晰.</p>\n<p>通过形参, 首先明确比较对象是<code>currentFirstChild: Fiber | null</code>和<code>newChildren: Array&lt;*&gt;</code>:</p>\n<ul>\n<li><code>currentFirstChild</code>: 是一个<code>fiber</code>节点, 通过<code>fiber.sibling</code>可以将兄弟节点全部遍历出来. 所以可以将<code>currentFirstChild</code>理解为链表头部, 它代表一个序列, 源码中被记为<code>oldFiber</code>.</li>\n<li><code>newChildren</code>: 是一个数组, 其中包含了若干个<code>ReactElement</code>对象. 所以<code>newChildren</code>也代表一个序列.</li>\n</ul>\n<p>所以<code>reconcileChildrenArray</code>实际就是 2 个序列之间的比较(<code>链表oldFiber</code>和<code>数组newChildren</code>), 最后返回合理的<code>fiber</code>序列.</p>\n<p>上述代码中, 以注释分割线为界限, 整个核心逻辑分为 2 步骤:</p>\n<ol>\n<li>第一次循环: 遍历最长<code>公共</code>序列(key 相同), 公共序列的节点都视为可复用\n<ul>\n<li>如果<code>newChildren序列</code>被遍历完, 那么<code>oldFiber序列</code>中剩余节点都视为删除(打上<code>Deletion</code>标记)</li>\n<li>如果<code>oldFiber序列</code>被遍历完, 那么<code>newChildren序列</code>中剩余节点都视为新增(打上<code>Placement</code>标记)</li>\n</ul>\n</li>\n<li>第二次循环: 遍历剩余<code>非公共</code>序列, 优先复用 oldFiber 序列中的节点\n<ul>\n<li>在对比更新阶段(非初次创建<code>fiber</code>, 此时<code>shouldTrackSideEffects</code>被设置为 true). 第二次循环遍历完成之后, <code>oldFiber序列中</code>没有匹配上的节点都视为删除(打上<code>Deletion</code>标记)</li>\n</ul>\n</li>\n</ol>\n<p>假设有如下图所示 2 个初始化序列:</p>\n<figure><img src=\"https://7kms.github.io/react-illustration-series/static/before-traverse.71633a39.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>接下来第一次循环, 会遍历公共序列<code>A,B</code>, 生成的 fiber 节点<code>fiber(A), fiber(B)</code>可以复用.</p>\n<figure><img src=\"https://7kms.github.io/react-illustration-series/static/traverse1.a0313cc2.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>最后第二次循环, 会遍历剩余序列<code>E,C,X,Y</code>:</p>\n<ul>\n<li>生成的 fiber 节点<code>fiber(E), fiber(C)</code>可以复用. 其中<code>fiber(C)</code>节点发生了位移(打上<code>Placement</code>标记).</li>\n<li><code>fiber(X), fiber(Y)</code>是新增(打上<code>Placement</code>标记).</li>\n<li>同时<code>oldFiber</code>序列中的<code>fiber(D)</code>节点确定被删除(打上<code>Deletion</code>标记).</li>\n</ul>\n<figure><img src=\"https://7kms.github.io/react-illustration-series/static/traverse2.a5a39d1b.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>整个主干逻辑就介绍完了, 接下来贴上完整源码</p>\n<blockquote>\n<p>第一次循环</p>\n</blockquote>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>第二次循环</p>\n</blockquote>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 结果</h3>\n<p>无论是单节点还是可迭代节点的比较, 最终的目的都是生成下级子节点. 并在<code>reconcileChildren</code>过程中, 给一些有副作用的节点(新增, 删除, 移动位置等)打上副作用标记, 等待 commit 阶段(参考 fiber 树渲染的处理.</p>\n<h2> 总结</h2>\n<p>本节介绍了 React 源码中, <code>fiber构造循环</code>阶段用于生成下级子节点的<code>reconcileChildren</code>函数(函数中的算法被称为调和算法), 并演示了<code>可迭代节点比较</code>的图解示例. 该算法十分巧妙, 其核心逻辑把<code>newChildren序列</code>分为 2 步遍历, 先遍历公共序列, 再遍历非公共部分, 同时复用<code>oldFiber</code>序列中的节点.</p>\n",
      "image": "https://7kms.github.io/react-illustration-series/static/before-traverse.71633a39.png",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "react"
      ]
    },
    {
      "title": "hook-api",
      "url": "https://www.h7ml.cn/posts/react/hook-api.html",
      "id": "https://www.h7ml.cn/posts/react/hook-api.html",
      "summary": "useEffect 依赖执行关系 useEffect 第二个参数[]如何影响 fn 的执行？换句话说，它的第二个参数是如何影响 fiber 创建 Passive Effect 的？ 不包含第二个参数 useEffect(() =&gt; {})，Mount &amp; Update 时，每次 render 时都会创建一个 Passive Effect; 包含一个空数组[]作为依赖项 useEffect(() =&gt; {}, [])，它会在 mount 时，创建 Passive Effect 包含一个依赖项[dep]，它会在 mount 时，dep 依赖项变化时，创建 Passive Effect",
      "content_html": "<h2> useEffect 依赖执行关系</h2>\n<p><code>useEffect</code> 第二个参数[]如何影响 fn 的执行？换句话说，它的第二个参数是如何影响 <code>fiber</code> 创建 <code>Passive Effect</code> 的？</p>\n<ol>\n<li>不包含第二个参数 <code>useEffect(() =&gt; {})</code>，<code>Mount</code> &amp; <code>Update</code> 时，每次 <code>render</code> 时都会创建一个 <code>Passive Effect</code>;</li>\n<li>包含一个空数组[]作为依赖项 <code>useEffect(() =&gt; {}, [])</code>，它会在 <code>mount</code> 时，创建 <code>Passive Effect</code></li>\n<li>包含一个依赖项<code>[dep]</code>，它会在 mount 时，dep 依赖项变化时，创建 Passive Effect</li>\n</ol>\n<h2> fn 和 componentDidMount 的执行时机分别是什么？</h2>\n<p><strong>过程</strong></p>\n<p>render 阶段到 commit 阶段，传递的时包含不同 fiber 节点的 effect 的链表，commit 阶段时将状态变化（Effect）渲染在视图中</p>\n<ul>\n<li>渲染视图前，beforeMutation 阶段</li>\n<li>渲染视图中，mutation 阶段，Placement 会执行 appendChild，DOM 节点插入到视图中</li>\n<li>渲染视图后，layout 阶段，调用 componentDidMount</li>\n</ul>\n<ol>\n<li>useEffect 时 commit 完成后异步调用</li>\n<li>componentDidMount 是 commit 阶段完成视图更新（mutation 阶段）后，在 layout 阶段同步调用</li>\n<li>useLayoutEffect 和 componentDidMount 调用时机一致，也是在 layout 阶段同步调用</li>\n</ol>\n<figure><img src=\"https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/hooks-api.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<!-- `useEffect` 可以看成 `componentDidMount / componentDidUpdate / componentWillUnmount` 这 3 个生命周期函数的替代。\n\n但其实他们并不是完全等价，**useEffect 是在浏览器渲染结束之后才执行的，而这三个生命周期函数是在浏览器渲染之前同步执行的**，React 还有一个官方的 hook 是完全等价于这三个生命周期函数的，叫 useLayoutEffect。 -->\n<h2> 相关文章</h2>\n<ul>\n<li><a href=\"https://www.yuque.com/lxylona/note/tlc8hz#RnPvS\" target=\"_blank\" rel=\"noopener noreferrer\">React Hooks: 深入剖析 useMemo 和 useEffect</a></li>\n</ul>\n",
      "image": "https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/hooks-api.png",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "react"
      ]
    },
    {
      "title": "hook",
      "url": "https://www.h7ml.cn/posts/react/hook.html",
      "id": "https://www.h7ml.cn/posts/react/hook.html",
      "summary": "react hook 原理 Hook 原理(概览) hook 的实现 讲 hooks 之前提出一个问题：为什么 hooks 不能写在条件语句之中？",
      "content_html": "<h2> react hook 原理</h2>\n<ul>\n<li><a href=\"https://7kms.github.io/react-illustration-series/main/hook-summary\" target=\"_blank\" rel=\"noopener noreferrer\">Hook 原理(概览)</a></li>\n<li><a href=\"https://react.iamkasong.com/hooks/create.html\" target=\"_blank\" rel=\"noopener noreferrer\">hook 的实现</a></li>\n</ul>\n<p><strong>讲 hooks 之前提出一个问题：为什么 hooks 不能写在条件语句之中？</strong></p>\n<p>我们在初始化 hooks 的时候，<code>fiber</code> 的结构是长什么样的呢？</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当我们执行 <code>updateNum</code> 怎么去更新我们的应用呢？</p>\n<p>如上，创建一个 <code>hooks</code> 链表结构，存储在 <code>fiber</code> 的 <code>memoizedState</code> 属性上，next 指针指向下一个 <code>hooks</code></p>\n<h3> 创建更新对象</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>对于 <code>App</code> 来说，点击 <code>p</code> 标签产生的 <code>update</code> 的 <code>action</code> 为 <code>num =&gt; num + 1</code>。</p>\n<p>如果我们改写下 <code>App</code> 的 <code>onClick</code>：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>那么点击 <code>p</code> 标签会产生三个 <code>update</code>。</p>\n<h3> 合并更新</h3>\n<p>这些 <code>update</code> 是如何组合在一起呢？</p>\n<p>答案是：他们会形成<strong>环状单向链表</strong>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>环状链表操作不太容易理解，这里我们详细讲解下。</p>\n<p>当产生第一个<code>update</code>（我们叫他<code>u0</code>），此时<code>queue.pending === null</code>。</p>\n<p><code>update.next = update;</code>即<code>u0.next = u0</code>，他会和自己首尾相连形成<code>单向环状链表</code>。</p>\n<p>然后<code>queue.pending = update;</code>即<code>queue.pending = u0</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当产生第二个<code>update</code>（我们叫他<code>u1</code>），<code>update.next = queue.pending.next;</code>，此时<code>queue.pending.next === u0</code>，即<code>u1.next = u0</code>。</p>\n<p><code>queue.pending.next = update;</code>，即<code>u0.next = u1</code>。</p>\n<p>然后<code>queue.pending = update;</code>即<code>queue.pending = u1</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>你可以照着这个例子模拟插入多个<code>update</code>的情况，会发现<code>queue.pending</code>始终指向最后一个插入的<code>update</code>。</p>\n<p>这样做的好处是，当我们要遍历<code>update</code>时，<code>queue.pending.next</code>指向第一个插入的<code>update</code>。</p>\n<h3> 简单实现</h3>\n<p>详情略...</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "react"
      ]
    },
    {
      "title": "immer",
      "url": "https://www.h7ml.cn/posts/react/immer.html",
      "id": "https://www.h7ml.cn/posts/react/immer.html",
      "summary": "react immer 不可变数据 阮一峰 ECMAScript 6 入门 带你重学 ES6 | proxy 带你重学 ES6 | Reflect 实现双向绑定 Proxy 比 defineproperty 优劣如何?",
      "content_html": "<h2> react immer 不可变数据</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/proxy\" target=\"_blank\" rel=\"noopener noreferrer\">阮一峰 ECMAScript 6 入门</a></li>\n<li><a href=\"https://juejin.cn/post/6857319959774265358\" target=\"_blank\" rel=\"noopener noreferrer\">带你重学 ES6 | proxy</a></li>\n<li><a href=\"https://juejin.cn/post/6859162309449744391\" target=\"_blank\" rel=\"noopener noreferrer\">带你重学 ES6 | Reflect</a></li>\n<li><a href=\"https://juejin.cn/post/6844903601416978439\" target=\"_blank\" rel=\"noopener noreferrer\">实现双向绑定 Proxy 比 defineproperty 优劣如何?</a></li>\n</ul>\n<h3> 为什么强调不可变数据</h3>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如上，点击后就会发现 obj 引用没变，但是 <code>obj.others.age</code> 修改了，然后也被重新渲染了，这是由于这就是引用类型的副作用导致的。</p>\n<p>解决方案</p>\n<ol>\n<li>浅复制：只能复制一层</li>\n<li>深克隆：我们不仅要考虑到正则、Symbol、Date 等特殊类型,还要考虑到原型链和循环引用的处理，性能消耗大！</li>\n<li>深克隆的的性能相比于浅克隆大打折扣,但是浅克隆又不能从根本上杜绝引用类型的副作用，使用 immutable：\n<ul>\n<li>即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</li>\n</ul>\n</li>\n</ol>\n<h3> 实现简单的 immutable</h3>\n<p><code>immer</code> 用法举例： <code>const nextState = produce(state, (draft) =&gt; {});</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>执行结果：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> defineProperty vs Proxy</h3>\n<p>这个没特别的深入，</p>\n<ol>\n<li><code>defineProperty</code> 无法监听数组变化 比如 <code>arr[1] = 2</code>; 如果需要监听</li>\n<li><code>defineProperty</code> 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。</li>\n<li><code>Proxy</code> 可以直接监听对象而非属性,<code>Proxy</code> 的劣势就是兼容性问题,而且无法用 <code>polyfill</code> 磨平</li>\n</ol>\n",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "react"
      ]
    },
    {
      "title": "使用 react-query 让状态管理更加高效优雅",
      "url": "https://www.h7ml.cn/posts/react/reactQuery.html",
      "id": "https://www.h7ml.cn/posts/react/reactQuery.html",
      "summary": "本文介绍了如何使用 React Query 让前端项目的状态管理变得更加高效优雅，详细解析了 React Query 的用法和特性。",
      "content_html": "<h1> 使用 react-query 让状态管理更加高效优雅</h1>\n<h2> 什么是 react-query</h2>\n<p>React Query 是一个基于 React 的轻量级数据获取和状态管理库，其主要关注点在于客户端如何更好地管理服务器端状态。与传统的状态管理库（如 Redux 和 MobX）相比，它专注于处理服务器状态，简化了与后端数据交互的逻辑。</p>\n<p>React Query 通过提供 useQuery、useMutation 等 hooks，使得开发者能够轻松地获取、更新、删除服务器端数据。此外，它还内置了数据缓存、自动更新、重试等功能，进一步优化了客户端与服务器端状态同步的体验。</p>\n<p>因此，React Query 的核心价值在于帮助开发者更优雅地管理客户端与服务器端状态的交互，提升前端开发效率。</p>\n<h2> 客户端应用状态</h2>\n<ol>\n<li>\n<p>客户端状态 Client State:多数用于控制客户端的 UI 展示，储存在于客户端。</p>\n</li>\n<li>\n<p>服务端状态 Server State:客户端通过异步请求获得的数据，储存在于服务端.</p>\n</li>\n</ol>\n<h2> 服务端状态有以下特点</h2>\n<ol>\n<li>\n<p>存储在远端</p>\n</li>\n<li>\n<p>需要异步 API 来查询和更新</p>\n</li>\n<li>\n<p>数据不同步</p>\n</li>\n</ol>\n<h3> React Query 还针对下列常见需求给出了自己的解决方案</h3>\n<h4> 1. 缓存</h4>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 2. 将对同一数据的多个请求简化为一个请求</h4>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3. 在后台更新”过期”数据</h4>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 4. 知道数据何时”过期”</h4>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 5. 尽可能快地反映数据的更新</h4>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 6. 性能优化，如分页和懒加载数据</h4>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 7. 管理内存</h4>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 8. 共享数据</h4>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 使用 react-query</h2>\n<h3> 1. 首先，需要安装 React Query：</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>安装完成后，在项目的根组件中引入 <code>QueryClient</code> 和 <code>QueryClientProvider</code>：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2. 使用 useQuery 获取数据</h3>\n<p>React Query 提供了一个名为 <code>useQuery</code> 的 hook，可以用于获取远程数据。这是一个简单的示例：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3. 优雅地处理错误和重试</h3>\n<p>React Query 默认会在请求失败时尝试重试 3 次。你还可以自定义重试次数和重试间隔，例如：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 4. 缓存和自动更新</h3>\n<p>React Query 默认会缓存数据，减少不必要的请求。当组件卸载后，数据仍然保留在缓存中。当再次使用相同的 key 查询时，React Query 会直接使用缓存中的数据。同时，React Query 还可以在后台自动更新数据，例如：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 5. 使用 useMutation 发送数据</h3>\n<p>React Query 还提供了 <code>useMutation</code> hook，用于处理数据的更改（如添加、修改、删除）。这是一个简单的示例：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在上面的示例中，<code>useMutation</code> hook 用于处理添加用户的操作。当添加成功时，会显示成功提示；如果添加失败，则显示失败提示。</p>\n<h3> 6. 使用 QueryClient 无缝整合</h3>\n<p>使用 <code>QueryClient</code> 可以让你更好地控制 React Query 的行为。例如，你可以在添加用户成功后，使用户列表的缓存失效，以便立即获取更新后的数据：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>总结 React Query 是一个强大且灵活的状态管理库，可以让你的项目状态管理变得更加高效优雅。通过使用 React Query 提供的 <code>useQuery</code> 和 <code>useMutation</code> 等 hooks，可以轻松地处理服务器状态，同时享受缓存、重试和自动更新等功能。如果你在寻找一个简单易用且功能强大的状态管理库，React Query 是一个值得尝试的选择。</p>\n<h2> QueryClient</h2>\n<p>`QueryClient 是 React Query 的核心类，它负责管理查询和突变的缓存、配置以及其他内部状态。你可以将其视为一个全局对象，它在整个应用程序中存储并管理所有查询和突变的状态。</p>\n<p>创建一个 QueryClient 实例的方法如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在创建 QueryClient 时，你还可以传入配置选项来自定义其行为。例如：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> QueryClientProvider</h2>\n<p><code>QueryClientProvider</code> 是一个 React 组件，它的作用是将创建好的 QueryClient 实例传递给应用程序中的其他组件。你可以将它视为 React Query 的上下文提供者，它使得 React Query 可以在整个应用程序范围内工作。使用 QueryClientProvider 的方法如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在项目的根组件中引入 QueryClientProvider 并传入 QueryClient 实例，这样你就可以在应用的任何地方使用 React Query 提供的 hooks，例如 useQuery 和 useMutation 等。</p>\n<p>QueryClient 负责管理和配置 React Query 的内部状态，而 QueryClientProvider 则负责将 QueryClient 实例传递给整个应用程序，使得其他组件可以方便地使用 React Query 的功能。在使用 React Query 时，这两个组件是不可或缺的。</p>\n<h2> useMutation 里 如何将实时状态传递出去</h2>\n<p><code>useMutation</code> 提供了一个名为 <code>onMutate</code> 的配置选项，可以在 mutation 开始之前执行。你可以使用此选项捕获 mutation 的实时状态，并将其传递给外部组件。例如，我们在添加用户的示例中增加一个实时状态传递功能。首先，在 <code>CreateUser</code> 组件中定义一个名为 <code>onStatusChange</code> 的回调函数，然后将此回调函数作为 prop 传递给子组件：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后，在父组件中接收 <code>onStatusChange</code> 回调并处理状态变化：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>现在，当添加用户的 mutation 进行中，父组件会接收到实时状态并显示相应的提示信息。</p>\n<p>useMutation 是 react-query 提供的一个自定义 hook，用于执行数据修改操作（create/update/delete），并处理相关的状态变化。下面列举出 useMutation 提供的所有方法：</p>\n<ol>\n<li>mutate(data, options?): 用于手动触发 mutation 函数执行，并更新相关的状态变量。</li>\n</ol>\n<p>● data: 要传递给 mutation 函数的数据。 ● options: 可选对象，包含以下属性： ○ onMutate: 在 mutation 函数执行之前调用的回调函数。 ○ onSuccess: 在 mutation 函数成功执行后调用的回调函数。 ○ onError: 在 mutation 函数执行出错后调用的回调函数。 ○ onSettled: 在 mutation 函数执行结束后调用的回调函数。 ○ variables: 要覆盖默认 mutationKey 的参数对象。 ○ update: 更新缓存的函数，用于手动更新缓存中的数据。 ○ optimisticUpdate: 在 mutation 函数执行期间进行乐观更新的函数。 ○ throwOnError: 是否在 mutation 函数执行出错时抛出异常。 ○ retry: 是否自动重试 mutation 函数，或者提供一个重试配置对象。</p>\n<ol start=\"2\">\n<li>mutateAsync(data, options?): 与 mutate 方法类似，但使用 async/await 语法来执行 mutation 函数，并返回一个 Promise 对象。不会触发 isLoading 和 isError 等状态变量的更新，需要手动处理结果。</li>\n<li>返回值：一个包含以下属性的对象：</li>\n</ol>\n<p>● mutate: 用于触发 mutation 函数执行的方法。 ● mutateAsync: 使用 async/await 语法来执行 mutation 函数，并返回一个 Promise 对象。不会触发 isLoading 和 isError 等状态变量的更新，需要手动处理结果。 ● reset: 重置 mutation 函数的状态，清除缓存中的数据并重新加载数据。 ● isLoading: 表示 mutation 函数是否在执行的布尔值。 ● isError: 表示 mutation 函数执行期间是否出错的布尔值。 ● error: 如果 mutation 函数执行出错，则为错误对象。 ● data: 如果 mutation 函数执行成功，则为返回的数据。</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2024-04-13T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "react",
        "react query"
      ]
    },
    {
      "title": "requestIdleCallback",
      "url": "https://www.h7ml.cn/posts/react/requestIdleCallback.html",
      "id": "https://www.h7ml.cn/posts/react/requestIdleCallback.html",
      "summary": "实现 requestIdleCallback 浏览器一帧 当前大多数的屏幕刷新率都是 60hz，也就是每秒屏幕刷新 60 次，低于 60hz 人眼就会感知卡顿掉帧等情况，同样我们前端浏览器所说的 FPS（frame per second）是浏览器每秒刷新的次数，理论上 FPS 越高人眼觉得界面越流畅，在两次屏幕硬件刷新之间，浏览器正好进行一次刷新（重绘），网页也会很流畅，当然这种是理想模式， 如果两次硬件刷新之间浏览器重绘多次是没意义的，只会消耗资源，如果浏览器重绘一次的时间是硬件多次刷新的时间，那么人眼将感知卡顿掉帧等， 所以浏览器对一次重绘的渲染工作需要在 16ms（1000ms/60）之内完成，也就是说每一次重绘小于 16ms 才不会卡顿掉帧。",
      "content_html": "<h2> 实现 requestIdleCallback</h2>\n<h3> 浏览器一帧</h3>\n<p>当前大多数的屏幕刷新率都是 <code>60hz</code>，也就是每秒屏幕刷新 <code>60</code> 次，低于 <code>60hz</code> 人眼就会感知卡顿掉帧等情况，同样我们前端浏览器所说的 <code>FPS（frame per second）</code>是浏览器每秒刷新的次数，理论上 <code>FPS</code> 越高人眼觉得界面越流畅，在两次屏幕硬件刷新之间，浏览器正好进行一次刷新（重绘），网页也会很流畅，当然这种是理想模式， 如果两次硬件刷新之间浏览器重绘多次是没意义的，只会消耗资源，如果浏览器重绘一次的时间是硬件多次刷新的时间，那么人眼将感知卡顿掉帧等， 所以浏览器对一次重绘的渲染工作需要在 <code>16ms（1000ms/60）</code>之内完成，也就是说每一次重绘小于 16ms 才不会卡顿掉帧。</p>\n<p><strong>浏览器的一帧说的就是一次完整的重绘。</strong></p>\n<p>一次重绘浏览器需要做哪些事情？</p>\n<figure><img src=\"https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/browser-frame.awebp\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 认识 requestIdleCallback</h3>\n<p>在执行优先级较低的任务时，可以考虑使用 <code>window.requestIdleCallback()</code>，意为交予任务给浏览器，浏览器有空闲的时候执行而不是立即执行这些任务。</p>\n<p>这样这些优先级较低的任务就不阻碍主线程的任务，以达到性能优化的效果。</p>\n<figure><img src=\"https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/browser-frame2.webp\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li><code>callback</code>: 一个在事件循环空闲时即将被调用的函数的引用。函数会接收到一个名为 <code>IdleDeadline</code> 的参数，这个参数可以获取当前空闲时间以及回调是否在超时时间前已经执行的状态。其中 <code>IdleDeadline</code> 对象包含：\n<ul>\n<li><code>didTimeout</code>，布尔值，表示任务是否超时，结合 <code>timeRemaining</code> 使用。</li>\n<li><code>timeRemaining()</code>，表示当前帧剩余的时间，也可理解为留给任务的时间还有多少。</li>\n</ul>\n</li>\n<li><code>timeout</code>: 表示超过这个时间后，如果任务还没执行，则强制执行，不必等待空闲。尚未通过超时毫秒数调用回调，那么回调会在下一次空闲时期被强制执行。如果明确在某段时间内执行回调，可以设置 <code>timeout</code> <code>值。在浏览器繁忙的时候，requestIdleCallback</code> 超时执行就和 <code>setTimeout</code> 效果一样。</li>\n</ul>\n<h3> 浏览器什么时候有空闲时段</h3>\n<h5> 场景一</h5>\n<p>当浏览器一帧渲染所用时间小于屏幕刷新率（对于具有 60Hz 的设备，一帧间隔应该小于 16ms）时间，到下一帧渲染渲染开始时出现的空闲时间，如图 idle period，</p>\n<figure><img src=\"https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/browser-frame2.webp\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h5> 场景二</h5>\n<p>当浏览器没有可渲染的任务，主线程一直处于空闲状态，事件队列为空。为了避免在不可预测的任务（例如用户输入的处理）中引起用户可察觉的延迟，这些空闲周期的长度应限制为最大值 <code>50ms</code>，也就是 <code>timeRemaining</code> 最大不超过 50（也就是 20fps，这也是 <code>react polyfill</code> 的原因之一），当空闲时段结束时，可以调度另一个空闲时段，如果它保持空闲，那么空闲时段将更长，后台任务可以在更长时间段内发生。如图:</p>\n<figure><img src=\"https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/browser-frame3.awebp\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> react 如何实现 requestIdleCallback</h3>\n<p>前面提到 <code>requestIdleCallback</code> 工作只有 <code>20FPS</code>，一般对用户来感觉来说，需要到 <code>60FPS</code> 才是流畅的, 即一帧时间为 <code>16.7 ms</code>，所以这也是 react 团队自己实现 <code>requestIdleCallback</code> 的原因。</p>\n<p><strong>实现大致思路是在 requestAnimationFrame 获取一桢的开始时间，触发一个 postMessage，在空闲的时候调用 idleTick 来完成异步任务。</strong></p>\n\n<h3> 总结</h3>\n<p><code>requestIdleCallback</code> 需要注意的：</p>\n<ul>\n<li><code>requestIdleCallback</code> 是屏幕渲染之后执行的。</li>\n<li>一些低优先级的任务可使用 <code>requestIdleCallback</code> 等浏览器不忙的时候来执行，同时因为时间有限，它所执行的任务应该尽量是能够量化，细分的微任务（micro task）比较适合 <code>requestIdleCallback</code>。</li>\n<li><code>requestIdleCallback</code> 不会和帧对齐，所以涉及到 DOM 的操作和动画最好放在 <code>requestAnimationFrame</code> 中执行，<code>requestAnimationFrame</code> 在重新渲染屏幕之前执行。</li>\n<li><code>Promise</code> 也不建议在这里面进行，因为 <code>Promise</code> 的回调属性 <code>Event loop</code> 中优先级较高的一种微任务，会在 <code>requestIdleCallback</code> 结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms。</li>\n</ul>\n",
      "image": "https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/browser-frame.awebp",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "react"
      ]
    },
    {
      "title": "setState",
      "url": "https://www.h7ml.cn/posts/react/setState.html",
      "id": "https://www.h7ml.cn/posts/react/setState.html",
      "summary": "setState 是同步还是异步的？ trigger = (isBatchedUpdate: boolean) =&gt; { const runSetState = () =&gt; { this.setState({ count: this.state.count + 1 }, () =&gt; console.log(this.state.count)); }; if (isBatchedUpdate) { runSetState(); } else { setTimeout(runSetState, 0); } }; &lt;button onClick={() =&gt; this.trigger(true)}&gt;触发合成事件&lt;/button&gt;; &lt;button onClick={() =&gt; this.trigger(false)}&gt;触发 setTimeout 事件&lt;/button&gt;;",
      "content_html": "<h2> setState 是同步还是异步的？</h2>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以发现两个执行的时机不一样，<code>console.log</code> 的结果也不一样。一个是同步，一个则是异步。</p>\n<h3> 分析</h3>\n<p>我们来看看 react 部分源码</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码可以简单描述这个过程，主要是判断了 <code>executionContext</code> 是否等于 <code>NoContext</code> 来确定当前更新流程是否在 React 事件流中。</p>\n<p>所有的事件在触发的时候，都会先调用 <code>batchedEventUpdates$1</code> 这个方法，在这里就会修改 <code>executionContext</code> 的值，React 就知道此时的 <code>setState</code> 在自己的掌控中。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/setState.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>所以，不管是直接调用 flushSyncCallbackQueue ，还是推迟调用，这里本质上都是同步的，只是有个先后顺序的问题。</p>\n<h3> 结论</h3>\n<p><strong>同步情况</strong></p>\n<ol>\n<li>当前是 <code>Legacy 模式</code></li>\n<li>在非合成事件中执行 <code>setState</code>，比如 <code>setTimeout</code>, <code>Promise</code>, <code>MessageChannel</code> 等</li>\n</ol>\n<p><strong>异步情况</strong></p>\n<ol>\n<li>如果是合成事件中的回调, <code>executionContext |= EventContext</code>, 所以不会进入, 最终表现出异步</li>\n<li>concurrent 模式下都为异步</li>\n</ol>\n<h3> 批处理</h3>\n<p>在<strong>React 合成事件</strong>中执行多次 setState 后，react 会合并进行一次更新，这样就可以提高性能，这就是<strong>批处理</strong>的概念。</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>即使是 async 函数，isBatchedUpdate 为 false，那多次 setState 实际上也会 render 多次。～～</p>\n<h3> 给张图</h3>\n<figure><img src=\"https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/setState-async.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n",
      "image": "https://alvin-cdn.oss-cn-shenzhen.aliyuncs.com/images/setState.png",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "react"
      ]
    },
    {
      "title": "synthetic-event",
      "url": "https://www.h7ml.cn/posts/react/synthetic-event.html",
      "id": "https://www.h7ml.cn/posts/react/synthetic-event.html",
      "summary": "React 合成事件 概览 从v17.0.0开始, React 不会再将事件处理添加到 document 上, 而是将事件处理添加到渲染 React 树的根 DOM 容器中. 引入官方提供的图片:",
      "content_html": "<h2> React 合成事件</h2>\n<h3> 概览</h3>\n<p>从<code>v17.0.0</code>开始, React 不会再将事件处理添加到 <code>document</code> 上, 而是将事件处理添加到渲染 React 树的根 DOM 容器中.</p>\n<p>引入官方提供的图片:</p>\n<figure><img src=\"https://zh-hans.reactjs.org/static/bb4b10114882a50090b8ff61b3c4d0fd/1e088/react_17_delegation.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>图中清晰的展示了<code>v17.0.0</code>的改动, 无论是在<code>document</code>还是<code>根 DOM 容器</code>上监听事件, 都可以归为<code>事件委托(代理)</code>(<a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events\" target=\"_blank\" rel=\"noopener noreferrer\">mdn</a>).</p>\n<p>注意: <code>react</code>的事件体系, 不是全部都通过<code>事件委托</code>来实现的. 有一些<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/client/ReactDOMComponent.js#L530-L616\" target=\"_blank\" rel=\"noopener noreferrer\">特殊情况</a>, 是直接绑定到对应 DOM 元素上的(如:<code>scroll</code>, <code>load</code>), 它们都通过<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/DOMPluginEventSystem.js#L295-L314\" target=\"_blank\" rel=\"noopener noreferrer\">listenToNonDelegatedEvent</a>函数进行绑定.</p>\n<p>上述特殊事件最大的不同是监听的 DOM 元素不同, 除此之外, 其他地方的实现与正常事件大体一致.</p>\n<p>本节讨论的是可以被<code>根 DOM 容器</code>代理的正常事件.</p>\n<h3> 事件绑定</h3>\n<p>在前文 React 应用的启动过程中介绍了<code>React</code>在启动时会创建全局对象, 其中在创建 fiberRoot 对象时, 调用<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/client/ReactDOMRoot.js#L120-L169\" target=\"_blank\" rel=\"noopener noreferrer\">createRootImpl</a>:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/DOMPluginEventSystem.js#L316-L349\" target=\"_blank\" rel=\"noopener noreferrer\">listenToAllSupportedEvents</a>函数, 实际上完成了事件代理:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>核心逻辑:</p>\n<ol>\n<li>节流优化, 保证全局注册只被调用一次.</li>\n<li>遍历<code>allNativeEvents</code>, 调用<code>listenToNativeEvent</code>监听冒泡和捕获阶段的事件.\n<ul>\n<li><code>allNativeEvents</code>包括了大量的原生事件名称, 它是在<code>DOMPluginEventSystem.js</code>中<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/DOMPluginEventSystem.js#L89-L93\" target=\"_blank\" rel=\"noopener noreferrer\">被初始化</a></li>\n</ul>\n</li>\n</ol>\n<p><a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/DOMPluginEventSystem.js#L351-L412\" target=\"_blank\" rel=\"noopener noreferrer\">listenToNativeEvent</a>:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/DOMPluginEventSystem.js#L468-L560\" target=\"_blank\" rel=\"noopener noreferrer\">addTrappedEventListener</a>:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从<code>listenToAllSupportedEvents</code>开始, 调用链路比较长, 最后调用<code>addEventBubbleListener</code>和<code>addEventCaptureListener</code>监听了原生事件.</p>\n<h4> 原生 listener</h4>\n<p>在注册原生事件的过程中, 需要重点关注一下监听函数, 即<code>listener</code>函数. 它实现了把原生事件派发到<code>react</code>体系之内, 非常关键.</p>\n<blockquote>\n<p>比如点击 DOM 触发原生事件, 原生事件最后会被派发到<code>react</code>内部的<code>onClick</code>函数. <code>listener</code>函数就是这个<code>由外至内</code>的关键环节.</p>\n</blockquote>\n<p><code>listener</code>是通过<code>createEventListenerWrapperWithPriority</code>函数产生:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到, 不同的<code>domEventName</code>调用<code>getEventPriorityForPluginSystem</code>后返回不同的优先级, 最终会有 3 种情况:</p>\n<ol>\n<li><code>DiscreteEvent</code>: 优先级最高, 包括<code>click, keyDown, input</code>等事件, <a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/DOMEventProperties.js#L45-L80\" target=\"_blank\" rel=\"noopener noreferrer\">源码</a>\n<ul>\n<li>对应的<code>listener</code>是<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/ReactDOMEventListener.js#L121-L142\" target=\"_blank\" rel=\"noopener noreferrer\">dispatchDiscreteEvent</a></li>\n</ul>\n</li>\n<li><code>UserBlockingEvent</code>: 优先级适中, 包括<code>drag, scroll</code>等事件, <a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/DOMEventProperties.js#L100-L116\" target=\"_blank\" rel=\"noopener noreferrer\">源码</a>\n<ul>\n<li>对应的<code>listener</code>是<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/ReactDOMEventListener.js#L144-L180\" target=\"_blank\" rel=\"noopener noreferrer\">dispatchUserBlockingUpdate</a></li>\n</ul>\n</li>\n<li><code>ContinuousEvent</code>: 优先级最低,包括<code>animation, load</code>等事件, <a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/DOMEventProperties.js#L119-L145\" target=\"_blank\" rel=\"noopener noreferrer\">源码</a>\n<ul>\n<li>对应的<code>listener</code>是<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/ReactDOMEventListener.js#L182-L271\" target=\"_blank\" rel=\"noopener noreferrer\">dispatchEvent</a></li>\n</ul>\n</li>\n</ol>\n<p>这 3 种<code>listener</code>实际上都是对<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/ReactDOMEventListener.js#L182-L271\" target=\"_blank\" rel=\"noopener noreferrer\">dispatchEvent</a>的包装:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 事件触发</h3>\n<p>当原生事件触发之后, 首先会进入到<code>dispatchEvent</code>这个回调函数. 而<code>dispatchEvent</code>函数是<code>react</code>事件体系中最关键的函数, 其调用链路较长, 核心步骤如图所示:</p>\n<p><img src=\"https://7kms.github.io/react-illustration-series/static/dispatch-event.4c0afc05.png\" alt=\"\" loading=\"lazy\"> 重点关注其中 3 个核心环节:</p>\n<ol>\n<li><code>attemptToDispatchEvent</code></li>\n<li><code>SimpleEventPlugin.extractEvents</code></li>\n<li><code>processDispatchQueue</code></li>\n</ol>\n<h4> 关联 fiber</h4>\n<p><a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/ReactDOMEventListener.js#L274-L331\" target=\"_blank\" rel=\"noopener noreferrer\">attemptToDispatchEvent</a>把原生事件和<code>fiber树</code>关联起来.</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>核心逻辑:</p>\n<ol>\n<li>定位原生 DOM 节点: 调用<code>getEventTarget</code></li>\n<li>获取与 DOM 节点对应的 fiber 节点: 调用<code>getClosestInstanceFromNode</code></li>\n<li>通过插件系统, 派发事件: 调用 <code>dispatchEventForPluginEventSystem</code></li>\n</ol>\n<h4> 收集 fiber 上的 listener</h4>\n<p><code>dispatchEvent</code>函数的调用链路中, 通过不同的插件, 处理不同的事件. 其中最常见的事件都会由<code>SimpleEventPlugin.extractEvents</code>进行处理:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>核心逻辑:</p>\n<ol>\n<li>\n<p>收集所有<code>listener</code>回调</p>\n<ul>\n<li>\n<p>这里的是<code>fiber.memoizedProps.onClick/onClickCapture</code>等绑定在<code>fiber</code>节点上的回调函数</p>\n</li>\n<li>\n<p>具体逻辑在<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/DOMPluginEventSystem.js#L712-L803\" target=\"_blank\" rel=\"noopener noreferrer\">accumulateSinglePhaseListeners</a>:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n</ul>\n</li>\n<li>\n<p>构造合成事件(<code>SyntheticEvent</code>), 添加到派发队列(<code>dispatchQueue</code>)</p>\n</li>\n</ol>\n<h4> 构造合成事件</h4>\n<p><a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/SyntheticEvent.js#L152\" target=\"_blank\" rel=\"noopener noreferrer\">SyntheticEvent</a>, 是<code>react</code>内部创建的一个对象, 是原生事件的跨浏览器包装器, 拥有和浏览器原生事件相同的接口(<code>stopPropagation</code>,<code>preventDefault</code>), 抹平不同浏览器 api 的差异, 兼容性好.</p>\n<p>具体的构造过程并不复杂, 可以直接<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/SyntheticEvent.js#L28-L136\" target=\"_blank\" rel=\"noopener noreferrer\">查看源码</a>.</p>\n<p>此处我们需要知道, 在<code>Plugin.extractEvents</code>过程中, 遍历<code>fiber树</code>找到<code>listener</code>之后, 就会创建<code>SyntheticEvent</code>, 加入到<code>dispatchQueue</code>中, 等待派发.</p>\n<h4> 执行派发</h4>\n<p><code>extractEvents</code>完成之后, 逻辑来到<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/DOMPluginEventSystem.js#L260-L272\" target=\"_blank\" rel=\"noopener noreferrer\">processDispatchQueue</a>, 终于要真正执行派发了.</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/DOMPluginEventSystem.js#L233-L258\" target=\"_blank\" rel=\"noopener noreferrer\">processDispatchQueueItemsInOrder</a>遍历<code>dispatchListeners</code>数组, 执行<a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/DOMPluginEventSystem.js#L222-L231\" target=\"_blank\" rel=\"noopener noreferrer\">executeDispatch</a>派发事件, 在<code>fiber</code>节点上绑定的<code>listener</code>函数被执行.</p>\n<p>在<code>processDispatchQueueItemsInOrder</code>函数中, 根据<code>捕获(capture)</code>或<code>冒泡(bubble)</code>的不同, 采取了不同的遍历方式:</p>\n<ol>\n<li><code>capture</code>事件: <code>从上至下</code>调用<code>fiber树</code>中绑定的回调函数, 所以<code>倒序</code>遍历<code>dispatchListeners</code>.</li>\n<li><code>bubble</code>事件: <code>从下至上</code>调用<code>fiber树</code>中绑定的回调函数, 所以<code>顺序</code>遍历<code>dispatchListeners</code>.</li>\n</ol>\n<h3> 总结</h3>\n<p>从架构上来讲, <a href=\"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/events/SyntheticEvent.js#L152\" target=\"_blank\" rel=\"noopener noreferrer\">SyntheticEvent</a>打通了从外部<code>原生事件</code>到内部<code>fiber树</code>的交互渠道, 使得<code>react</code>能够感知到浏览器提供的<code>原生事件</code>, 进而做出不同的响应, 修改<code>fiber树</code>, 变更视图等.</p>\n<p>从实现上讲, 主要分为 3 步:</p>\n<ol>\n<li>监听原生事件: 对齐<code>DOM元素</code>和<code>fiber元素</code></li>\n<li>收集<code>listeners</code>: 遍历<code>fiber树</code>, 收集所有监听本事件的<code>listener</code>函数.</li>\n<li>派发合成事件: 构造合成事件, 遍历<code>listeners</code>进行派发.</li>\n</ol>\n",
      "image": "https://zh-hans.reactjs.org/static/bb4b10114882a50090b8ff61b3c4d0fd/1e088/react_17_delegation.png",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "react"
      ]
    },
    {
      "title": "redis",
      "url": "https://www.h7ml.cn/posts/redis/",
      "id": "https://www.h7ml.cn/posts/redis/",
      "summary": "何谓主从复制 redis 的主从复制就是我们设置一个 master 服务器，然后设置多个 slave 从服务器，主服务器存储着最新的数据，每次主服务器的数据出现变化的时候，都会将对应的命令传输到各个 slave 服务器，这样，我们就可以实现主服务器和从服务器的数据的同步了。 为什么需要？在企业的开发中，主从复制可以避免单机故障导致的数据和服务的丢失，保障了数据安全和服务的稳定运行。 一个 master 可以有多个 slave，一个 slave 也可以有多个 slave，这样，最终可以构成一棵树的结构。",
      "content_html": "<h2> 何谓主从复制</h2>\n<ol>\n<li>redis 的主从复制就是我们设置一个 master 服务器，然后设置多个 slave 从服务器，主服务器存储着最新的数据，每次主服务器的数据出现变化的时候，都会将对应的命令传输到各个 slave 服务器，这样，我们就可以实现主服务器和从服务器的数据的同步了。</li>\n<li>为什么需要？在企业的开发中，主从复制可以避免单机故障导致的数据和服务的丢失，保障了数据安全和服务的稳定运行。</li>\n<li>一个 master 可以有多个 slave，一个 slave 也可以有多个 slave，这样，最终可以构成一棵树的结构。</li>\n</ol>\n<h2> 基本原理</h2>\n<ol>\n<li>Redis 的复制分为同步和命令传播阶段。同步操作作用于从服务器将从服务器的数据状态更新为主服务器的数据状态。</li>\n<li>命令传播则相反，他的命令主要是在主数据库发生数据变化的时候，导致主从服务器的数据不一致的时候，让主从回到一致的过程</li>\n</ol>\n<h2> 同步</h2>\n<ol>\n<li>客户端先向从服务器发送 slaveof 命令，判断是否是第一次复制，如果是第一次复制一般都是刚开始组建主从关系</li>\n<li>如果是第一次复制，从服务器会向主服务器发送 PSYNC 命令，请求主服务器会执行完整的重同步操作。</li>\n<li>主服务器接到完整的请求之后，将在后台执行 BGSAVE 命令，后台生成一个 RDB 文件，同时会有一个积压缓冲区记录从现在开始执行的所有的写命令。</li>\n<li>BGSAVE 命令执行之后，从服务器会接受到主服务器发送的 RDB 文件，同时主服务器还会向从服务器返回一个偏移量。</li>\n<li>如果不是第一次复制，那么说明从服务器可能是断线的，导致了主从数据库状态不一样，需要同步主服务器的数据。这个时候从服务器就会向主服务器发送一个之前记录得到的偏移量，这样主服务器就会知道最后一次同步的是在哪个地方，从这个地方开始进行同步即可。</li>\n<li>由于之前从服务器可能出现断线的情况，所以主服务器需要发送 CONNECT 命令，表示将和从服务器执行同步部分数据的操作。但是，假如从服务器将偏移量丢失了呢？那么主服务器将会发起一个全量同步的操作</li>\n<li>主服务器接到 CONNECT 命令之后，会将积压缓冲区中的命令全部执行，然后将偏移量发送给从服务器，从服务器接到偏移量之后，就会开始执行同步操作。</li>\n</ol>\n<h2> 命令传播阶段</h2>\n<ol>\n<li>执行完同步之后，主从并不会一直保持着这个状态，加入主服务器执行了写的命令，那么就会将命令传输给从服务器，从服务器拿到了命令之后就会执行对应的操作。最后保持主从一致的状态。</li>\n<li>在命令传播阶段，从服务器会以每秒一次的频率，向从服务器发送命令。作用主要是检测主从服务器的网络状态，辅助实现 min-slaves，检测命令丢失。</li>\n</ol>\n",
      "date_published": "2019-07-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "redis"
      ]
    },
    {
      "title": "redis实现分布式可重入锁",
      "url": "https://www.h7ml.cn/posts/redis/redis-lock.html",
      "id": "https://www.h7ml.cn/posts/redis/redis-lock.html",
      "summary": "不可重入锁 即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到而阻塞，直到当前线程释放锁后才能获取。 可重入锁 可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。 就是同一个线程再次进入同样代码时，可以再次拿到该锁。 可重入锁作用 防止在同一线程中多次获取锁而导致死锁发生 在 java 的编程中 synchronized 和 ReentrantLock 都是可重入锁",
      "content_html": "<h2> 不可重入锁</h2>\n<p>即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到而阻塞，直到当前线程释放锁后才能获取。</p>\n<h2> 可重入锁</h2>\n<p>可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。 就是同一个线程再次进入同样代码时，可以再次拿到该锁。</p>\n<h3> 可重入锁作用</h3>\n<p>防止在同一线程中多次获取锁而导致死锁发生</p>\n<blockquote>\n<p>在 java 的编程中 synchronized 和 ReentrantLock 都是可重入锁</p>\n</blockquote>\n<p>用一段 Java 代码解释可重入：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>假设 X 线程在 lockA 方法获取锁之后，继续执行 lockB 方法，如果此时不可重入，线程就必须等待锁释放，再次争抢锁。</p>\n<p>锁明明是被 X 线程拥有，却还需要等待自己释放锁，然后再去抢锁，这看起来就很奇怪，我释放我自己~</p>\n<h2> ReentrantLock 可重入锁源码思路</h2>\n<h3> 加锁</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 解锁</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 分布式重入锁（redisson 依然实现，但此处注重原理实现）</h2>\n<p>基于 ReentrantLock 的源码我们知道，它是加锁成功了，记录了当前持有锁的线程，并通过一个 int 类型的数字，来记录了加锁次数。我们知道 ReentrantLock 的实现原理了，那么 redis 只要下面两个问题解决，就能实现重入锁了：</p>\n<h3> 1.如何保存现有的线程</h3>\n<p>ReentrantLock 使用的是当前线程内存地址进行对比，那么我们就可以使用线程的 ID 进行比较一样可以的。但是在分布式环境下，这个 ID 就可能会存在重复，此时，我们需要增加一个全局的唯一 ID + 线程 ID 来做一个分布式线程比较。</p>\n<h3> 2.加锁次数（重入了多少次），怎么记录维护</h3>\n<p>他能记录下来加锁次数吗？如果 valus 值存的格式是：系进程 id+线程 id+加锁次数，那可以实现存没问题了，但是重入次数要怎么维护了， 它肯定要保证原子性的，能解决吗？好像用 java 代码或者 lua 脚本都没法解决，因为都是实现都需要两步来维护这个重入次数的</p>\n<ul>\n<li>第一步：先获取到 valus 值，把取到加锁次数+1</li>\n<li>第二步：把新的值再设置进去在执行第二步操作之前，如果这个 key 失效了（设置持有锁超时了），如果还能再设置进去，就会有并发问题了</li>\n</ul>\n<h2> Redisson 是如何实现的</h2>\n<p>我们跟一下 lock.lock()的代码，发现它最终调用的是 org.redisson.RedissonLock#tryLockInnerAsync 的方法,具体如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 分析一下 redis 命令</h3>\n<ol>\n<li>exists 查询一个 key 是否存在</li>\n<li>hincrby ：将 hash 中指定域的值增加给定的数字</li>\n<li>pexpire：设置 key 的有效时间以毫秒为单位</li>\n<li>hexists：判断 field 是否存在于 hash 中</li>\n<li>pttl：获取 key 的有效毫秒数</li>\n<li>KEYS[1] = key 的值</li>\n<li>ARGV[1]) = 持有锁的时间</li>\n<li>ARGV[2] = getLockName(threadId) 下面 id 就算系统在启动的时候会全局生成的 uuid 来作为当前进程的 id，加上线程 id 就是 getLockName(threadId)了，可以理解为：进程 ID+系统 ID = ARGV[2] 主要也是使用了 lua 脚本来保证多个命令执行的原子性，使用了 hash 来实现了分布式锁</li>\n</ol>\n<h3> lua 脚本的加锁流程</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/redis-lua.png\" alt=\"redis-lua.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>redis-lua.png</figcaption></figure>\n<h4> 1、第一个 if 判断</h4>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 2、下面来看第二个 if 判断</h4>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：分布式锁有过期时间，默认-1 的时候是需要自动续期的（redisson 有看门狗自动续期），当服务 down 机后自然自动释放解锁过程和 Reentrantlock 的解锁逻辑也基本相同没啥好说的了</p>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/redis-lua.png",
      "date_published": "2019-08-05T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "redis"
      ]
    },
    {
      "title": "rxjava",
      "url": "https://www.h7ml.cn/posts/rxjava/",
      "id": "https://www.h7ml.cn/posts/rxjava/",
      "summary": "依赖 优势 线程调度",
      "content_html": "<ul>\n<li>\n<p><a href=\"/posts/rxjava/note.html\" target=\"blank\">依赖</a></p>\n</li>\n<li>\n<p><a href=\"/posts/rxjava/superiority.html\" target=\"blank\">优势</a></p>\n</li>\n<li>\n<p><a href=\"/posts/rxjava/thread-scheduling.html\" target=\"blank\">线程调度</a></p>\n</li>\n</ul>\n",
      "date_published": "2019-03-21T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "rxjava"
      ]
    },
    {
      "title": "依赖",
      "url": "https://www.h7ml.cn/posts/rxjava/note.html",
      "id": "https://www.h7ml.cn/posts/rxjava/note.html",
      "summary": "添加依赖 compile 'io.reactivex.rxjava2:rxandroid:2.0.1' compile 'io.reactivex.rxjava2:rxjava:2.0.1'",
      "content_html": "<h2> 添加依赖</h2>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 创建数据源（被观察者/可观察者）</h2>\n<p>返回一个可观察对象，该对象发出给定(常量引用)项的信号，然后完成</p>\n<h3> just 方法</h3>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> fromArray 方法</h3>\n<p>fromArray 和 Just 几乎是一样的效果，只不过 Just 限制 10 个以内，而 fromArray 并没有限制，查看得知 单个参数 Just 是自行创建 ObservableJust，而多个参数 Just 最终还是回调了 fromArray，这里不再过多演示</p>\n<h3> create 方法</h3>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> range 方法</h3>\n<p>使用范围数据，指定输出数据的范围（1-40 的数值）</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> interval 方法</h3>\n<p>指定某一时刻进行数据发送</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 创建事件的接收者（观察者|订阅者），onNext 方法中的数据类型必须被观察者指定的泛型</h2>\n<p>表示观察者不对被观察者发送的事件作出任何响应（但被观察者还是可以继续发送事件）</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>表示观察者只对被观察者发送的 Next 事件作出响应</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>表示观察者只对被观察者发送的 Next 事件 &amp; Error 事件作出响应</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>表示观察者只对被观察者发送的 Next 事件、Error 事件 &amp; Complete 事件作出响应</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>表示观察者只对被观察者发送的 Next 事件、Error 事件 、Complete 事件 &amp; onSubscribe 事件作出响应</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>表示观察者对被观察者所有的事件做出响应</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> Observer 类用法</h2>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>观察者</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Consumer 类用法</h2>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 订阅</h2>\n<p>订阅事件，被观察者必须指定了事件的接收者（观察者），整个事件流程才可以被启动</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 是否被订阅</h2>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 取消订阅</h2>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 使用步骤</h2>\n<div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 创建数据源（被观察者/可观察者），泛型必须是 Object 的子类</h2>\n<div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>订阅者是观察者的子类，区别在于订阅者可以取消订阅（在程序销毁后）</p>\n<div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p><a href=\"/posts/rxjava/thread-scheduling.html\" target=\"blank\">Rxjava 的线程调度</a></p>\n</li>\n<li>\n<p><a href=\"/posts/rxjava/superiority.html\" target=\"blank\">RxJava 的优势</a></p>\n</li>\n</ul>\n",
      "date_published": "2019-03-21T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "android"
      ]
    },
    {
      "title": "RxJava的优势",
      "url": "https://www.h7ml.cn/posts/rxjava/superiority.html",
      "id": "https://www.h7ml.cn/posts/rxjava/superiority.html",
      "summary": "public class MainActivity extends AppCompatActivity { private ImageView mImageView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mImageView = (ImageView) findViewById(R.id.image); } // 给图片加水印的方法 private Bitmap createWatermark(Bitmap bitmap, String mark) { int w = bitmap.getWidth(); int h = bitmap.getHeight(); Bitmap bmp = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bmp); Paint p = new Paint(); // 水印颜色 p.setColor(Color.parseColor(\"#C5FF0000\")); // 水印字体大小 p.setTextSize(150); //抗锯齿 p.setAntiAlias(true); //绘制图像 canvas.drawBitmap(bitmap, 0, 0, p); //绘制文字 canvas.drawText(mark, 0, h / 2, p); canvas.save(Canvas.ALL_SAVE_FLAG); canvas.restore(); return bmp; } }",
      "content_html": "<div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 没用 RxJava 之前</h3>\n<div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 使用 RxJava 之后</h3>\n<div class=\"language-android line-numbers-mode\" data-ext=\"android\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> RxJava 优势</h3>\n<ul>\n<li>\n<p>实现优雅：链式调用，一点到底</p>\n</li>\n<li>\n<p>逻辑简洁：代码可读性高，解耦</p>\n</li>\n<li>\n<p>使用简单：支持线程调度和各种操作符</p>\n</li>\n<li>\n<p>扩展维护：随着程序逻辑的复杂性提高，它依然能够保持简洁和优雅</p>\n</li>\n<li>\n<p>扩展维护：随着程序逻辑的复杂性提高，它依然能够保持简洁和优雅</p>\n</li>\n</ul>\n",
      "date_published": "2019-03-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "android"
      ]
    },
    {
      "title": "Rxjava的线程调度",
      "url": "https://www.h7ml.cn/posts/rxjava/thread-scheduling.html",
      "id": "https://www.h7ml.cn/posts/rxjava/thread-scheduling.html",
      "summary": "调度器 用于线程调度 使用案例 Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { System.out.println(\"正在进行耗时操作\"); subscriber.onNext(\"执行耗时操作后的结果\"); subscriber.onCompleted(); } }) .subscribeOn(Schedulers.io()) //让被观察者执行在IO线程 .observeOn(AndroidSchedulers.mainThread()) //让观察者执行在主线程 .subscribe(...);",
      "content_html": "<h3> 调度器</h3>\n<p>用于线程调度</p>\n<h4> 使用案例</h4>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 调度类型</h4>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2019-03-29T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "android"
      ]
    },
    {
      "title": "vite",
      "url": "https://www.h7ml.cn/posts/vite/",
      "id": "https://www.h7ml.cn/posts/vite/",
      "summary": "Vite 自动化注册全局组件 vite 别名配置注意事项",
      "content_html": "<p><a href=\"/posts/vite/automatic-registration-global-components.html\" target=\"blank\">Vite 自动化注册全局组件</a></p>\n<p><a href=\"/posts/vite/alias.html\" target=\"blank\">vite 别名配置注意事项</a></p>\n",
      "date_published": "2021-05-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vite"
      ]
    },
    {
      "title": "vite 别名配置注意事项",
      "url": "https://www.h7ml.cn/posts/vite/alias.html",
      "id": "https://www.h7ml.cn/posts/vite/alias.html",
      "summary": "vite 别名配置注意事项 Vite config image-20220411165325332 import { defineConfig } from 'vite'; import react from '@vitejs/plugin-react'; import * as path from 'path'; // https://vitejs.dev/config/ export default defineConfig({ plugins: [react()], resolve: { alias: { '@': path.resolve(__dirname, './src'), }, }, server: { port: 3000, proxy: { '/api': { target: 'http://xuanyuan.jinuo.fun:8080/', changeOrigin: true, rewrite: (path) =&gt; path.replace(/^\\/api/, ''), }, }, }, });",
      "content_html": "<h2> vite 别名配置注意事项</h2>\n<ol>\n<li>Vite config</li>\n</ol>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/vite/e6c9d24ely1h15vt7vddmj20hc0er0tj.jpg\" alt=\"image-20220411165325332\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20220411165325332</figcaption></figure>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"2\">\n<li>Tsconfig.json</li>\n</ol>\n<p>​ <img src=\"https://static.h7ml.cn/vitepress/assets/images/vite/e6c9d24ely1h15vv3ksz3j20fj0i4q3r.jpg\" alt=\"image-20220411165514379\" loading=\"lazy\"></p>\n<p>告诉 TS 解析如何解析某些路径</p>\n<p>注意<code>./src/* 后边这个*</code>一定要加</p>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/vite/e6c9d24ely1h15vt7vddmj20hc0er0tj.jpg",
      "date_published": "2021-05-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vite"
      ]
    },
    {
      "title": "vue2与vue3全局组件注册",
      "url": "https://www.h7ml.cn/posts/vite/automatic-registration-global-components.html",
      "id": "https://www.h7ml.cn/posts/vite/automatic-registration-global-components.html",
      "summary": "dgiot-dashboard 最佳实践 vue2 import Vue from 'vue'; const requireComponent = require.context('./components', true, /[A-Z]\\w+\\.(vue|js)$/);",
      "content_html": "<p><a href=\"https://gitee.com/dgiiot/dgiot-dashboard/blob/a5d46efd3787f5be3e3e68774f00e1b1850faee5/src/dgiot/index.js#L38\" target=\"_blank\" rel=\"noopener noreferrer\">dgiot-dashboard 最佳实践</a></p>\n<h2> vue2</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 获取组件配置</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 全局注册组件</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> Vite 注册全局组件的方式</h2>\n<h3> import.meta.glob()</h3>\n<h3> import.meta.globEager()</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 在 main.js 文件中 import 并 use</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>因为在 Vite 中不能使用 webpack 的 require.context()方式来读取文,所以之前使用 webpack 注册全局组件的方式就不能使用了。</p>\n",
      "date_published": "2021-05-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vite"
      ]
    },
    {
      "title": "Object.defineproperty 核心代码 自定义实现",
      "url": "https://www.h7ml.cn/posts/vue/Object.defineproperty.html",
      "id": "https://www.h7ml.cn/posts/vue/Object.defineproperty.html",
      "summary": "Object.defineproperty 核心代码 自定义实现 // 触发更新视图 function updateView() { console.log('视图更新'); } // 重新定义数组原型 const oldArrayProperty = Array.prototype; // 创建新对象，原型指向 oldArrayProperty ，再扩展新的方法不会影响原型 const arrProto = Object.create(oldArrayProperty); ['push', 'pop', 'shift', 'unshift', 'splice'].forEach((methodName) =&gt; { arrProto[methodName] = function () { updateView(); // 触发视图更新 oldArrayProperty[methodName].call(this, ...arguments); // Array.prototype.push.call(this, ...arguments) }; }); // 重新定义属性，监听起来 function defineReactive(target, key, value) { // 深度监听 observer(value); // 核心 API Object.defineProperty(target, key, { get() { return value; }, set(newValue) { if (newValue !== value) { // 深度监听 observer(newValue); // 设置新值 // 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值 value = newValue; // 触发更新视图 updateView(); } }, }); } // 监听对象属性 function observer(target) { if (typeof target !== 'object' || target === null) { // 不是对象或数组 return target; } // 污染全局的 Array 原型 // Array.prototype.push = function () { // updateView() // ... // } if (Array.isArray(target)) { target.__proto__ = arrProto; } // 重新定义各个属性（for in 也可以遍历数组） for (let key in target) { defineReactive(target, key, target[key]); } } // 准备数据 const data = { name: 'zhangsan', age: 20, info: { address: '北京', // 需要深度监听 }, nums: [10, 20, 30], }; // 监听数据 observer(data); // 测试 // data.name = 'lisi' // data.age = 21 // // console.log('age', data.age) // data.x = '100' // 新增属性，监听不到 —— 所以有 Vue.set // delete data.name // 删除属性，监听不到 —— 所有已 Vue.delete // data.info.address = '上海' // 深度监听 data.nums.push(4); // 监听数组",
      "content_html": "<h1> Object.defineproperty 核心代码 自定义实现</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2021-06-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "Proxy 核心代码 自定义实现",
      "url": "https://www.h7ml.cn/posts/vue/Proxy.html",
      "id": "https://www.h7ml.cn/posts/vue/Proxy.html",
      "summary": "Proxy 核心代码 自定义实现 // const data = { // name: 'zhangsan', // age: 20, // } const data = ['a', 'b', 'c']; const proxyData = new Proxy(data, { get(target, key, receiver) { // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target); if (ownKeys.includes(key)) { console.log('get', key); // 监听 } const result = Reflect.get(target, key, receiver); return result; // 返回结果 }, set(target, key, val, receiver) { // 重复的数据，不处理 if (val === target[key]) { return true; } const result = Reflect.set(target, key, val, receiver); console.log('set', key, val); // console.log('result', result) // true return result; // 是否设置成功 }, deleteProperty(target, key) { const result = Reflect.deleteProperty(target, key); console.log('delete property', key); // console.log('result', result) // true return result; // 是否删除成功 }, });",
      "content_html": "<h1> Proxy 核心代码 自定义实现</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2021-06-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "vue",
      "url": "https://www.h7ml.cn/posts/vue/",
      "id": "https://www.h7ml.cn/posts/vue/",
      "summary": "vue 源码分析 核心 Vue 响应式的核心是利用 Object.defineProperty()这个方法进行数据劫持和观察者模式进行数据响应式的。Object.defineProperty()这个方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。具体用法如下： ​ 它有三个参数，第一个是 object，它代表要定义属性的对象。；第二个是 prop，它代表目标对象的属性值；第三个参数是 descriptor，它代表要定义或修改的属性描述符。 ​ 响应式用法：",
      "content_html": "<h2> vue 源码分析</h2>\n<h3> <strong>核心</strong></h3>\n<p>Vue 响应式的核心是利用 Object.defineProperty()这个方法进行数据劫持和观察者模式进行数据响应式的。Object.defineProperty()这个方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。具体用法如下：</p>\n<p>​ 它有三个参数，第一个是 object，它代表要定义属性的对象。；第二个是 prop，它代表目标对象的属性值；第三个参数是 descriptor，它代表要定义或修改的属性描述符。</p>\n<p>​ 响应式用法：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> <strong>观察者模式</strong></h3>\n<p>什么是观察者模式？它分为<strong>注册环节跟发布环节</strong>。</p>\n<p>比如我去买芝士蛋糕，但是店家还没有做出来。这时候我又不想在店外面傻傻等，我就需要隔一段时间来回来问问蛋糕做好没，对于我来说是很麻烦的事情，说不定我就懒得买了。</p>\n<p>店家肯定想要做生意，不想流失我这个吃货客户。于是，在蛋糕没有做好的这段时间，有客户来，他们就让客户把自己的电话留下，这就是观察者模式中的<strong>注册环节</strong>。然后蛋糕做好之后，一次性通知所有记录了的客户，这就是观察者的<strong>发布环节</strong>。</p>\n<p>一个简单的观察者模式类：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> <strong>初始化</strong></h3>\n<p>vue 在初始化执行 initState 的时候，会对<code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 和 <code>wathcer</code> 等属性做初始化操作。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在初始化 data 的时候，一共做了两件事，一件是利用 proxy 将数据代理到整个 vue 实例上，另一件就是将 data 中的所有对象属性 reactive 化，变成响应式对象，为对象添加 getter 和 setter。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的这段代码，它将对象的所有属性进行遍历执行 defineReactive()方法进行响应式化</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在执行这个方法的过程中，会 new 一个 dep 实例，记得注意，后面会用到</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码中的 Dep 类就是一个观察者类，每个对象属性都一个 dep 实例对象，在执行 get 的时候进行触发 depend 方法，触发 sit 的时候执行 notify 方法。</p>\n<h3> <strong>mount 阶段</strong></h3>\n<p>在 vue 实例挂载阶段，会创建一个 Watcher 类的实例对象，这个 Watcher 实际上是连接 Vue 组件与 Dep（也就是视图更新环节）的桥梁。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 rende()方法将模板渲染成虚拟 Vnode 的过程中会访问 data，从而触发属性的 getter，然后每个对象属性又有一个 dep 实例对象（上面提到的），然后再 getter 的逻辑中又会调用该 dep 的 depend 方法，将 watcher 实例 add 到 sub（存在 Dep 类中的存储 watcher 的数组）里面。在 depend 方法里面，Dep.target 就是 watcher 本身，在 Wacher 类中的构造函数会执行（上面代码有）。以上过程就叫<strong>依赖收集</strong>。</p>\n<h3> <strong>派发更新</strong></h3>\n<p>在对象属性的数据改变之后，会触发 sitter，从而执行 sitter 函数的逻辑，从而调用 dep 实例的 notify 方法，从而进行遍历调用 sub 中所有 watcher 的 upadte 方法进行视图更新。</p>\n<h3> <strong>总结</strong></h3>\n<p>**第一步：**组件初始化的时候，先给每一个 Data 属性都注册 getter，setter，也就是 reactive 化。然后再 new 一个自己的 Watcher 对象，此时 watcher 会立即调用组件的 render 函数去生成虚拟 DOM。在调用 render 的时候，就会需要用到 data 的属性值，此时会触发 getter 函数，将当前的 Watcher 函数注册进 sub 里。</p>\n<p>**第二步：**当 data 属性发生改变之后，会触发 sitter，遍历 sub 里所有的 watcher 对象，通知它们去重新渲染组件。</p>\n<p>注意：vue 对数组响应式是通过变异方法完成的，而且如果要对响应式对象添加新的属性，必须要用$set 方法才能完成</p>\n<p>参考文章：</p>\n<p><a href=\"https://ustbhuangyi.github.io/vue-analysis/v2/reactive/\" target=\"_blank\" rel=\"noopener noreferrer\">vue 技术揭秘</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/88648401\" target=\"_blank\" rel=\"noopener noreferrer\">最简化 VUE 的响应式原理</a></p>\n",
      "date_published": "2021-06-27T00:00:00.000Z",
      "date_modified": "2023-07-01T19:12:58.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "Computed 和 Watch",
      "url": "https://www.h7ml.cn/posts/vue/computed_and_watch.html",
      "id": "https://www.h7ml.cn/posts/vue/computed_and_watch.html",
      "summary": "Computed 和 Watch Computed本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。 Watch没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开deep：true选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用unWatch手动注销哦。",
      "content_html": "<h2> Computed 和 Watch</h2>\n<p><code>Computed</code>本质是一个具备缓存的<code>watcher</code>，依赖的属性发生变化就会更新视图。适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。</p>\n<p><code>Watch</code>没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开<code>deep：true</code>选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用<code>unWatch</code>手动注销哦。</p>\n<ul>\n<li>功能上：<code>computed</code>是计算属性，也就是依赖其它的属性计算所得出最后的值。<code>watch</code>是去监听一个值的变化，然后执行相对应的函数</li>\n<li>使用上：<code>computed</code>中的函数必须要用<code>return</code>返回；<code>watch</code>的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作，不是必须要用<code>return</code></li>\n<li>性能上：<code>computed</code>中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而<code>watch</code>在每次监听的值发生变化的时候都会执行回调</li>\n<li>场景上\n<ul>\n<li>computed：当一个属性受多个属性影响的时候，例子：购物车商品结算；</li>\n<li>watch：当一条数据影响多条数据的时候，例子：搜索框</li>\n</ul>\n</li>\n</ul>\n<h3> Watch</h3>\n<p>侦听属性的初始化也是发生在 Vue 的实例初始化阶段的 <code>initState</code> 函数中，在 <code>computed</code> 初始化之后，执行了：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里的逻辑也很简单，首先对 <code>hanlder</code> 的类型做判断，拿到它最终的回调函数，最后调用 <code>vm.$watch(keyOrFn, handler, options)</code> 函数，<code>$watch</code> 是 <code>Vue</code> 原型上的方法，它是在执行 <code>stateMixin</code> 的时候定义的：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>虽然<code>watch</code>内部是使用<code>this.$watch</code>，但是我们也是可以手动调用<code>this.$watch</code>来创建监听属性的，所以第二个参数<code>cb</code>会出现是对象的情况。接下来设置一个标记位<code>options.user</code>为<code>true</code>，表明这是一个<code>user-watcher</code>。</p>\n<p>再给<code>watch</code>设置了<code>immediate</code>属性后，会将实例化后得到的值传入回调，并立即执行一次回调函数，这也是<code>immediate</code>的实现原理。最后的返回值是一个方法，执行后可以取消对该监听属性的监听。接下来我们看看<code>user-watcher</code>是如何定义的：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当是<code>user-watcher</code>时，<code>Watcher</code>内部是以上方式实例化的，通常情况下我们是使用字符串的形式创建监听属性，所以首先来看下<code>parsePath</code>方法是干什么的：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>parsePath</code>方法最终返回一个闭包方法，此时<code>Watcher</code>类中的<code>this.getter</code>就是一个函数了，再执行<code>this.get()</code>方法时会将<code>this.vm</code>传入到闭包内，补全<code>Watcher</code>其他的逻辑：</p>\n<h3> 总结</h3>\n<ul>\n<li><a href=\"https://ustbhuangyi.github.io/vue-analysis/v2/reactive/computed-watcher.html\" target=\"_blank\" rel=\"noopener noreferrer\">计算属性 VS 侦听属性</a></li>\n<li><a href=\"https://juejin.im/post/5d629380518825121f661973\" target=\"_blank\" rel=\"noopener noreferrer\">搞懂 computed 和 watch 原理，减少使用场景思考时间</a></li>\n<li><a href=\"https://juejin.im/post/5b98c4da6fb9a05d353c5fd7\" target=\"_blank\" rel=\"noopener noreferrer\">浅谈 Vue 中 computed 实现原理</a></li>\n</ul>\n",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "diff",
      "url": "https://www.h7ml.cn/posts/vue/diff.html",
      "id": "https://www.h7ml.cn/posts/vue/diff.html",
      "summary": "Diff 算法 Diff算法的核心就是针对具有相同父节点的同层新旧子节点进行比较，而不是使用逐层搜索递归遍历的方式。时间复杂度为O(n)。 如何理解？ 说白点，就是当新旧VNode树在同一层具有相同的VNode节点时，才会继续对其子节点进行比较。一旦旧VNode树同层中的节点在新VNode树中不存在或者是多余的，都会在新的真实DOM中进行添加或者删除。",
      "content_html": "<h2> Diff 算法</h2>\n<p><code>Diff</code>算法的核心就是<strong>针对具有相同父节点的同层新旧子节点进行比较，而不是使用逐层搜索递归遍历的方式。时间复杂度为<code>O(n)</code></strong>。</p>\n<p>如何理解？</p>\n<p>说白点，就是<strong>当新旧<code>VNode</code>树在同一层具有相同的<code>VNode</code>节点时，才会继续对其子节点进行比较</strong>。一旦旧<code>VNode</code>树同层中的节点在新<code>VNode</code>树中不存在或者是多余的，都会在新的真实<code>DOM</code>中进行添加或者删除。</p>\n<p>下面就拿一副图进行解释。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/diff1.jpg\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从上面的示例图可以看到，<code>Diff</code>算法中只会对同一层的元素进行比较，并且必须拥有相同节点元素，才会对其子节点进行比较，其他多余的同层节点都会一律做删除或添加操作。</p>\n<p>接下来，我们就从源码角度来看看这过程到底是如何发生的。🤔</p>\n<h3> diff 流程图</h3>\n<p>当数据发生改变时，set 方法会让调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，订阅者就会调用<code>patch</code>给真实的 DOM 打补丁，更新相应的视图。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/diff8.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 从源码角度进行探究</h3>\n<p>我们依然是从<code>_update</code>方法入手，看看到底是如何操作的。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>每一次更新模板时，都会先将渲染好的新<code>VNode</code>树保存到实例的<code>_vnode</code>属性上，这样做的目的是为了下一次更新时，能获取到旧<code>VNode</code>树进行比较。</p>\n<p>针对是否拥有旧的<code>VNode</code>树，使用<code>__patch__</code>方法执行相应逻辑，也即执行了<code>patch</code>过程。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，<strong>只有在浏览器的环境下才能进行<code>patch</code>过程</strong>，而实现<code>patch</code>的，就是<code>createPatchFunction</code>方法，我们接着看下去。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>好啦，对于<code>patch</code>比较过程，你也应该有了一个大概了解。现在就来简单总结一下上述代码。</p>\n<ul>\n<li>当旧<code>VNode</code>树不存在时，直接根据新<code>VNode</code>树创建相应的真实<code>DOM</code>。</li>\n<li>当旧<code>VNode</code>树存在时，则会调用<code>sameVnode</code>方法比较当前新旧节点是否相同。\n<ul>\n<li>当新旧节点是相同时，会调用<code>patchVnode</code>方法比较新旧节点（过程就是继续比较其子节点，递归下去～）。</li>\n<li>当新旧节点是不同时，则会先按照新<code>VNode</code>节点创建新的真实<code>DOM</code>节点，再根据旧<code>VNode</code>节点将相应的真实<code>DOM</code>节点进行删除。</li>\n</ul>\n</li>\n</ul>\n<p>是不是很简单 🤔...那么问题来了，不是说<code>patch过</code>程是使用<code>Diff</code>算法进行比较的吗？怎么还看不到，甭急，下面我会讲到哈。</p>\n<p>在上面的总结中，我们是可以看到两个方法，分别是<code>sameVnode</code>方法和<code>patchVnode</code>方法。接下来我们就来探讨一下这两个方法。</p>\n<h3> sameVnode</h3>\n<p>判断两个节点间是否相同</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>比较两个新旧节点间是很简单的，主要是按照下面几个属性进行判断。</p>\n<ul>\n<li><code>VNode</code>节点唯一标识<code>key</code>。</li>\n<li>是否同为注释<code>isComment</code>。</li>\n<li>数据属性是否为空<code>isDef</code>。</li>\n<li>是否为相同的<code>input</code>类型<code>sameInputType</code>。</li>\n</ul>\n<h3> patchVnode</h3>\n<p>好啦，接着就到我们的主角<code>patchVnode</code>方法了，这个才是<code>Diff</code>相关方法，我们先来看看源码是如何实现的。🤔</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>patchVnode</code>方法做的事情不多，最主要就是按照一下场景做了处理;</p>\n<p><code>diff</code>过程中又分了好几种情况，<code>oldCh</code> 为 <code>oldVnode</code>的子节点，<code>ch</code> 为 <code>Vnode</code>的子节点：</p>\n<ul>\n<li>首先进行文本节点的判断，若 <code>oldVnode.text !== vnode.text</code>，那么就会直接进行文本节点的替换；</li>\n<li><code>在vnode</code>没有文本节点的情况下，进入子节点的 <code>diff</code>；</li>\n<li>当 <code>oldCh</code> 和 <code>ch</code> 都存在且不相同的情况下，调用 <code>updateChildren</code> 对子节点进行 <code>diff</code>；</li>\n<li>若 <code>oldCh</code>不存在，<code>ch</code> 存在，首先清空 <code>oldVnode</code> 的文本节点，同时调用 <code>addVnodes</code> 方法将 <code>ch</code> 添加到<code>elm</code>真实 dom 节点当中；</li>\n<li>若 <code>oldCh</code>存在，<code>ch</code>不存在，则删除 <code>elm</code> 真实节点下的 <code>oldCh</code> 子节点；</li>\n<li>若 <code>oldVnode</code> 有文本节点，而 <code>vnode</code> 没有，那么就清空这个文本节点。</li>\n</ul>\n<p>接下来才是最重点呀。。😅 在上面中留下了<code>updateChildren</code>方法，那么这个方法又是干啥？</p>\n<p>不瞒你说，<code>updateChildren</code>方法在根据场景<code>Diff</code>后，将<code>oldVNode</code>树作出相应的改动。在没有看源码之前，我会先阐述一下。</p>\n<p><code>Diff算法</code>过程中，在将<code>oldVNode</code>树改动时，优先考虑相同位置的相同节点，再考虑需要移动的相同节点，最后才考虑创建或删除节点。</p>\n<h3> updateChildren</h3>\n<p>有了上面的简单理解，我们就来继续探究啦 😄。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 具体的 diff 分析</h3>\n<p>我们可以假设有旧的 Vnode 数组和新的 Vnode 数组这两个数组,而且有四个变量充当指针分别指到两个数组的头尾.</p>\n<p>重复下面的对比过程，直到两个数组中任一数组的头指针超过尾指针，循环结束 :</p>\n<ul>\n<li>头头对比: 对比两个数组的头部，如果找到，把新节点 patch 到旧节点，头指针后移</li>\n<li>尾尾对比: 对比两个数组的尾部，如果找到，把新节点 patch 到旧节点，尾指针前移</li>\n<li>旧尾新头对比: 交叉对比，旧尾新头，如果找到，把新节点 patch 到旧节点，旧尾指针前移，新头指针后移</li>\n<li>旧头新尾对比: 交叉对比，旧头新尾，如果找到，把新节点 patch 到旧节点，新尾指针前移，旧头指针后移</li>\n<li>利用 key 对比: 用新指针对应节点的 key 去旧数组寻找对应的节点,这里分三种情况,当没有对应的 key，那么创建新的节点,如果有 key 并且是相同的节点，把新节点 patch 到旧节点,如果有 key 但是不是相同的节点，则创建新节点</li>\n</ul>\n<p>我们假设有新旧两个数组:</p>\n<ul>\n<li>旧数组: <code>[1, 2, 3, 4, 5]</code></li>\n<li>新数组: <code>[1, 4, 6, 1000, 100, 5]</code></li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/diff2.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>首先我们进行头头对比,新旧数组的头部都是<code>1</code>,因此将双方的头部指针后移.</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/diff3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>我们继续头头对比,但是<code>2 !== 4</code>导致对比失败,我进入尾尾对比,<code>5 === 5</code>,那么尾部指针则可前移.</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/diff4.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>现在进入新的循环,头头对比<code>2 !== 4</code>,尾尾对比<code>4 !== 100</code>,此时进入交叉对比,先进行旧尾新头对比,即<code>4 === 4</code>,旧尾前移且新头后移.</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/diff5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>接着再进入一个轮新的循环,头头对比<code>2 !== 6</code>,尾尾对比<code>3 !== 100</code>,交叉对比<code>2 != 100 3 != 6</code>,四种对比方式全部不符合,如果这个时候需要通过<code>key</code>去对比,然后将新头指针后移</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/diff6.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>继续重复上述对比的循环方式直至任一数组的头指针超过尾指针，循环结束.</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/diff7.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在上述循环结束后,两个数组中可能存在未遍历完的情况: 循环结束后，</p>\n<ul>\n<li>先对比旧数组的头尾指针，如果旧数组遍历完了（可能新数组没遍历完，有漏添加的问题），添加新数组中漏掉的节点</li>\n<li>再对比新数组的头尾指针，如果新数组遍历完了（可能旧数组没遍历完，有漏删除的问题），删除旧数组中漏掉的节点</li>\n</ul>\n<h3> 参考</h3>\n<ul>\n<li><a href=\"https://juejin.im/post/5d36cc575188257aea108a74\" target=\"_blank\" rel=\"noopener noreferrer\">Vue 核心之虚拟 DOM</a></li>\n<li><a href=\"https://github.com/aooy/blog/issues/2\" target=\"_blank\" rel=\"noopener noreferrer\">解析 vue2.0 的 diff 算法</a></li>\n<li><a href=\"https://juejin.im/post/5affd01551882542c83301da\" target=\"_blank\" rel=\"noopener noreferrer\">详解 vue 的 diff 算法</a></li>\n<li><a href=\"https://juejin.im/post/5d3f3bf36fb9a06af824b3e2#heading-5\" target=\"_blank\" rel=\"noopener noreferrer\">面试官: 你对虚拟 DOM 原理的理解?</a></li>\n<li><a href=\"https://github.com/Andraw-lin/about-Vue/blob/master/docs/%E3%80%90%20Vue%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20%E3%80%91%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9B%B4%E6%96%B0%20Patch%20%E4%B8%AD%E8%BF%9B%E8%A1%8C%20Diff.md\" target=\"_blank\" rel=\"noopener noreferrer\">【 Vue 源码分析 】如何在更新 Patch 中进行 Diff.md</a></li>\n</ul>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/diff1.jpg",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "keep-alive",
      "url": "https://www.h7ml.cn/posts/vue/keep-alive.html",
      "id": "https://www.h7ml.cn/posts/vue/keep-alive.html",
      "summary": "keep-alive keep-alive是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。 activated和deactivated两个生命周期, 将会在&lt;keep-alive&gt;树内的所有嵌套组件中触发, 用来得知当前组件是否处于活跃状态。 include - 字符串或正则表达式。只有名称匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。 max - 数字。最多可以缓存多少组件实例。",
      "content_html": "<h2> keep-alive</h2>\n<p><code>keep-alive</code>是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p>\n<p><code>activated</code>和<code>deactivated</code>两个生命周期, 将会在<code>&lt;keep-alive&gt;</code>树内的所有嵌套组件中触发, 用来得知当前组件是否处于活跃状态。</p>\n<ul>\n<li>include - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>\n<li>exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>\n<li>max - 数字。最多可以缓存多少组件实例。</li>\n</ul>\n<p>实现原理：</p>\n<ul>\n<li><a href=\"https://ustbhuangyi.github.io/vue-analysis/v2/extend/keep-alive.html\" target=\"_blank\" rel=\"noopener noreferrer\">keep-alive</a></li>\n<li><a href=\"https://github.com/answershuto/learnVue/blob/master/docs/%E8%81%8A%E8%81%8Akeep-alive%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.MarkDown\" target=\"_blank\" rel=\"noopener noreferrer\">聊聊 keep-alive 组件的使用及其实现原理</a></li>\n</ul>\n<h2> 组件中 data 为什么是一个函数</h2>\n<p>为什么组件中的 <code>data</code> 必须是一个函数，然后 return 一个对象，而 <code>new Vue</code> 实例里，<code>data</code> 可以直接是一个对象？</p>\n<p>因为组件是用来复用的，且 JS 里<strong>对象是引用关系</strong>，如果组件中 <code>data</code> 是一个对象，那么这样作用域没有隔离，子组件中的 <code>data</code> 属性值会相互影响，如果组件中 <code>data</code> 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 <code>data</code> 属性值不会互相影响；而 <code>new Vue</code> 的实例，是不会被复用的，因此不存在引用对象的问题。</p>\n<h2> 父子组件钩子函数执行顺序</h2>\n<p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>\n<ul>\n<li>加载渲染过程</li>\n</ul>\n<p>父 <code>beforeCreate</code> -&gt; 父 <code>created</code> -&gt; 父 <code>beforeMount</code> -&gt; 子 <code>beforeCreate</code> -&gt; 子 <code>created</code> -&gt; 子 <code>beforeMount</code> -&gt; 子 <code>mounted</code> -&gt; 父 <code>mounted</code></p>\n<ul>\n<li>子组件更新过程</li>\n</ul>\n<p>父 <code>beforeUpdate</code> -&gt; 子 <code>beforeUpdate</code> -&gt; 子 <code>updated</code> -&gt; 父 <code>updated</code></p>\n<ul>\n<li>父组件更新过程</li>\n</ul>\n<p>父 <code>beforeUpdate</code> -&gt; 父 <code>updated</code></p>\n<ul>\n<li>销毁过程</li>\n</ul>\n<p>父 <code>beforeDestroy</code> -&gt; 子 <code>beforeDestroy</code> -&gt; 子 <code>destroyed</code> -&gt; 父 <code>destroyed</code></p>\n<h2> 父组件监听子组件的生命周期</h2>\n<p>比如有父组件 <code>Parent</code> 和子组件 <code>Child</code>，如果父组件监听到子组件挂载 <code>mounted</code> 就做一些逻辑处理，可以通过以下写法实现：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上需要手动通过 <code>$emit</code> 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 <code>@hook</code> 来监听即可，如下所示：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当然 <code>@hook</code> 方法不仅仅是可以监听 <code>mounted</code>，其它的生命周期事件，例如：<code>created</code>，<code>updated</code> 等都可以监听。</p>\n",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "vue生命周期",
      "url": "https://www.h7ml.cn/posts/vue/life-cycle.html",
      "id": "https://www.h7ml.cn/posts/vue/life-cycle.html",
      "summary": "vue 生命周期 Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 Dom、渲染 → 更新 → 渲染、销毁等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。 每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。 img",
      "content_html": "<h1> vue 生命周期</h1>\n<p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 Dom、渲染 → 更新 → 渲染、销毁等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。</p>\n<p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/life-cycle.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>在我们实际项目开发过程中，会非常频繁地和 Vue 组件的生命周期打交道，接下来我们就从源码的角度来看一下这些生命周期的钩子函数是如何被执行的。</p>\n<p>源码中最终执行生命周期的函数都是调用 <code>callHook</code> 方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>callHook</code>函数的逻辑很简单，根据传入的字符串 hook，去拿到 <code>vm.$options[hook]</code> 对应的回调函数数组，然后遍历执行，执行的时候把 <code>vm</code> 作为函数执行的上下文。</p>\n<h2> beforeCreate &amp; created</h2>\n<p><code>beforeCreate</code> 和 <code>created</code>函数都是在实例化 Vue 的阶段，在<code>_init</code>方法中执行的, 也就是初始化实例的时候</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>beforeCreate</code> 和 <code>created</code> 的钩子调用是在 <code>initState</code> 的前后，<code>initState</code> 的作用是初始化 <code>props</code>、<code>data</code>、<code>methods</code>、<code>watch</code>、<code>computed</code> 等属性，之后我们会详细分析。那么显然 <code>beforeCreate</code> 的钩子函数中就不能获取到 <code>props</code>、<code>data</code> 中定义的值，也不能调用 <code>methods</code> 中定义的函数。</p>\n<h2> beforeMount &amp; mounted</h2>\n<p>顾名思义，<code>beforeMount</code> 钩子函数发生在 <code>mount</code>，也就是 DOM 挂载之前，它的调用时机是在 <code>mountComponent</code> 函数中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在执行 <code>vm._render()</code> 函数渲染<code>VNode</code>之前，执行了 <code>beforeMount</code> 钩子函数，在执行完 <code>vm._update()</code> 把 <code>VNode patch</code>到真实 DOM 后，执行 <code>mounted</code>钩子。注意，这里对 <code>mounted</code>钩子函数执行有一个判断逻辑，<code>vm.$vnode</code> 如果为 <code>null</code>，则表明这不是一次组件的初始化过程，而是我们通过外部<code>new Vue</code>初始化过程。那么对于组件，它的 <code>mounted</code>时机在哪儿呢？组件的 <code>VNode</code> <code>patch</code> 到 DOM 后，会执行 <code>invokeInsertHook</code> 函数，把 <code>insertedVnodeQueue</code>里保存的钩子函数依次执行一遍</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>该函数会执行 <code>insert</code> 这个钩子函数，对于组件而言，<code>insert</code> 钩子函数的定义在 <code>src/core/vdom/create-component.js</code> 中的 <a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/create-component.js#L67\" target=\"_blank\" rel=\"noopener noreferrer\">componentVNodeHooks</a> 中：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，每个子组件都是在这个钩子函数中执行 <code>mounted</code> 钩子函数，并且我们之前分析过，<code>insertedVnodeQueue</code> 的添加顺序是先子后父，所以对于同步渲染的子组件而言，<code>mounted</code> 钩子函数的执行顺序也是先子后父。</p>\n<h2> beforeUpdate &amp; updated</h2>\n<p>顾名思义，<code>beforeUpdate</code> 和 <code>updated</code> 的钩子函数执行时机都应该是在数据更新的时候，到目前为止，还没有分析 Vue 的数据双向绑定、更新相关。 <code>beforeUpdate</code> 的执行时机是在渲染 <code>Watcher</code> 的 <code>before</code> 函数中：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意这里有个判断，也就是在组件已经 <code>mounted</code> 之后，才会去调用这个钩子函数。 <code>update</code> 的执行时机是在 <code>flushSchedulerQueue</code> 函数调用的时候，它的定义在 <a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/observer/scheduler.js\" target=\"_blank\" rel=\"noopener noreferrer\">src/core/observer/scheduler.js</a> 中：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>flushSchedulerQueue</code> <code>updatedQueue</code> 是更新了的 <code>wathcer</code> 数组，那么在 <code>callUpdatedHooks</code> 函数中，它对这些数组做遍历，只有满足当前 <code>watcher</code> 为 <code>vm.\\_watcher</code> 以及组件已经 <code>mounted</code> 这两个条件，才会执行 <code>updated</code> 钩子函数。在组件 <code>mount</code> 的过程中，会实例化一个渲染的 <code>Watche</code>r 去监听 <code>vm</code> 上的数据变化重新渲染，这段逻辑发生在 <a href=\"https://github.com/vuejs/vue/blob/e0b26c483a1ba407a818b1fcba1a439df24e84a8/src/core/instance/lifecycle.ts#L146\" target=\"_blank\" rel=\"noopener noreferrer\">mountComponent</a> 函数执行的时候：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>那么在实例化 <code>Watcher</code> 的过程中，在它的构造函数里会判断 <code>isRenderWatcher</code>，接着把当前 <code>watcher</code> 的实例赋值给 <code>vm.\\_watcher</code>，定义在 <a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/observer/watcher.js#L27\" target=\"_blank\" rel=\"noopener noreferrer\">src/core/observer/watcher.js</a> 中：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同时，还把当前 <code>wathcer</code> 实例 <code>push</code> 到 <code>vm.\\_watchers</code> 中，<code>vm.\\_watcher</code> 是专门用来监听 <code>vm</code> 上数据变化然后重新渲染的，所以它是一个渲染相关的 <code>watcher</code>，因此在 <code>callUpdatedHooks</code> 函数中，只有 <code>vm.\\_watcher</code> 的回调执行完毕后，才会执行 <code>updated</code> 钩子函数。</p>\n<h2> beforeDestroy &amp; destroyed</h2>\n<p>顾名思义，<code>beforeDestroy</code> 和 <code>destroyed</code> 钩子函数的执行时机在组件销毁的阶段，组件的销毁过程之后会详细介绍，最终会调用 <code>$destroy</code> 方法，它的定义在 <a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/instance/lifecycle.js#L97\" target=\"_blank\" rel=\"noopener noreferrer\">src/core/instance/lifecycle.js</a>中：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>beforeDestroy</code> 钩子函数的执行时机是在 <code>$destroy</code> 函数执行最开始的地方，接着执行了一系列的销毁动作，包括从 <code>parent</code> 的 <code>$children</code> 中删掉自身，删除 <code>watcher</code>，当前渲染的 <code>VNode</code> 执行销毁钩子函数等，执行完毕后再调用 <code>destroy</code> 钩子函数。在 <code>$destroy</code> 的执行过程中，它又会执行 <code>vm.**patch**(vm.\\_vnode, null)</code> 触发它子组件的销毁钩子函数，这样一层层的递归调用，所以 <code>destroy</code> 钩子函数执行顺序是先子后父，和 <code>mounted</code> 过程一样。</p>\n<h2> activated &amp; deactivated</h2>\n<p><code>activated</code> 和 <code>deactivated</code>钩子函数是专门为<code>keep-alive</code> 组件定制的钩子.</p>\n<h2> 总结</h2>\n<p>Vue 生命周期中各个钩子函数的执行时机以及顺序，在 <code>created</code> 钩子函数中可以访问到数据，在 <code>mounted</code> 钩子函数中可以访问到 DOM，在 <code>destroy</code> 钩子函数中可以做一些定时器销毁工作，了解它们有利于我们在合适的生命周期去做不同的事情。</p>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/life-cycle.png",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "nextTick",
      "url": "https://www.h7ml.cn/posts/vue/nextTick.html",
      "id": "https://www.h7ml.cn/posts/vue/nextTick.html",
      "summary": "nextTick 在做项目的时候，我们经常会用到nextTick，简单的理解就是它就是一个setTimeout函数，将函数放到异步后去处理；将它替换成setTimeout好像也能跑起来，但它仅仅这么简单吗？那为什么我们不直接用setTimeout呢？让我们深入剖析一下。 先看一个例子 &lt;template&gt; &lt;div&gt; &lt;div ref=\"message\"&gt;{{ message }}&lt;/div&gt; &lt;button @click=\"handleClick\"&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { message: 'begin' }; }, methods () { handleClick () { this.message = 'end'; console.log(this.$refs.message.innerText); //打印“begin” } } } &lt;/script&gt;",
      "content_html": "<h2> nextTick</h2>\n<p>在做项目的时候，我们经常会用到<code>nextTick</code>，简单的理解就是它就是一个<code>setTimeout</code>函数，将函数放到异步后去处理；将它替换成<code>setTimeout</code>好像也能跑起来，但它仅仅这么简单吗？那为什么我们不直接用<code>setTimeout</code>呢？让我们深入剖析一下。</p>\n<h3> 先看一个例子</h3>\n<div class=\"language-vue line-numbers-mode\" data-ext=\"vue\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>打印出来的结果是<code>begin</code>，我们在点击事件里明明将<code>message</code>赋值为<code>end</code>，而获取真实 DOM 节点的 innerHTML 却没有得到预期中的<code>begin</code>，为什么？</p>\n<p>同样的情况也发生在给子组件传参上；我们给子组件传参数后，在子组件中调用函数查看参数。</p>\n<h3> 再看一个例子</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>虽然页面上展示了子组件的 name，但是打印出来却是空值：</p>\n<h3> 异步更新</h3>\n<p>我们发现上述两个问题的发生，不管子组件还是父组件，都是在给 data 中赋值后立马去查看数据导致的。由于<code>查看数据</code>这个动作是同步操作的，而且都是在赋值之后；因此我们猜测一下，给数据赋值操作是一个异步操作，并没有马上执行，Vue 官网对数据操作是这么描述的：</p>\n<blockquote>\n<p>可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个<code>watcher</code>被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p>\n</blockquote>\n<p>也就是说我们在设置<code>this.msg = 'some thing'</code>的时候，Vue 并没有马上去更新 DOM 数据，而是将这个操作放进一个队列中；如果我们重复执行的话，队列还会进行去重操作；等待同一事件循环中的所有数据变化完成之后，会将队列中的事件拿出来处理。</p>\n<p>这样做主要是为了提升性能，因为如果在主线程中更新 DOM，循环 100 次就要更新 100 次 DOM；但是如果等事件循环完成之后更新 DOM，只需要更新 1 次。</p>\n<p>为了在数据更新操作之后操作 DOM，我们可以在数据变化之后立即使用<code>Vue.nextTick(callback)</code>；这样回调函数会在 DOM 更新完成后被调用，就可以拿到最新的 DOM 元素了。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 事件轮询</h3>\n<p>Vue.js 在修改数据的时候，不会立马修改数据，而是要等同一事件轮询的数据都更新完之后，再统一进行视图更新。 知乎上的例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nextTick.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> nextTick 源码分析</h3>\n<p>了解了<code>nextTick</code>的用法和原理之后，我们就来看一下 Vue 是怎么来实现这波“操作”的。</p>\n<p>Vue 把<code>nextTick</code>的源码单独抽到一个文件中，<code>/src/core/util/next-tick.js</code>，删掉注释也就大概六七十行的样子，让我们逐段来分析。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中<code>Promise</code>和<code>setTimeout</code>很好理解，是一个异步任务，会在同步任务以及更新 DOM 的异步任务之后回调具体函数。</p>\n<p>下面着重介绍一下<code>MutationObserver</code></p>\n<p><code>MutationObserver</code>是 HTML5 中的新 API，是个用来<strong>监视 DOM 变动的接口</strong>。他能监听一个 DOM 对象上发生的子节点删除、属性修改、文本内容修改等等。</p>\n<p>调用过程很简单，但是有点不太寻常：你需要先给他绑回调：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>通过给<code>MutationObserver</code>的构造函数传入一个回调，能得到一个<code>MutationObserver</code>实例，这个回调就会在<code>MutationObserver</code>实例监听到变动时触发。</p>\n<p>这个时候你只是给 MutationObserver 实例绑定好了回调，他具体监听哪个 DOM、监听节点删除还是监听属性修改，还没有设置。而调用他的 observer 方法就可以完成这一步:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/nextTick2.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在<code>nextTick</code>中<code>MutationObserver</code>的作用就如上图所示。在监听到 DOM 更新后，调用回调函数。</p>\n<p>其实使用<code>MutationObserver</code>的原因就是<code>nextTick</code>想要一个异步 API，用来在当前的同步代码执行完毕后，执行我想执行的异步回调，包括<code>Promise</code>和<code>setTimeout</code>都是基于这个原因。</p>\n<h3> 实现一个简易的 nextTick</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，在简易版的 nextTick 中，通过 nextTick 接收回调函数，通过 setTimeout 来异步执行回调函数。通过这种方式，可以实现在下一个 tick 中执行回调函数，即在 UI 重新渲染后执行回调函数。</p>\n<h3> 总结</h3>\n<p>到这里，整体 nextTick 的代码都分析完毕了，总结一下它的流程就是：</p>\n<ol>\n<li>把回调函数放入 callbacks 等待执行</li>\n<li>将执行函数放到微任务或者宏任务中</li>\n<li>事件循环到了微任务或者宏任务，执行函数依次执行 callbacks 中的回调</li>\n</ol>\n<ul>\n<li><a href=\"https://juejin.im/post/5eb095b05188256d7674a257#heading-0\" target=\"_blank\" rel=\"noopener noreferrer\">Vue 中$nextTick 源码解析</a></li>\n<li><a href=\"https://juejin.im/post/5b85b3326fb9a019fc76ecee#heading-4\" target=\"_blank\" rel=\"noopener noreferrer\">Vue.js 异步更新及 nextTick</a></li>\n<li><a href=\"https://juejin.im/post/5c03500e6fb9a049d37ed754#heading-0\" target=\"_blank\" rel=\"noopener noreferrer\">Vue 源码解析之 nextTick</a></li>\n<li><a href=\"https://www.jianshu.com/p/a7550c0e164f\" target=\"_blank\" rel=\"noopener noreferrer\">简单理解 Vue 中的 nextTick</a></li>\n</ul>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/nextTick.png",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "props",
      "url": "https://www.h7ml.cn/posts/vue/props.html",
      "id": "https://www.h7ml.cn/posts/vue/props.html",
      "summary": "props 这一次，通过源码阅读，主要探索的方面包括如何初始化 Props、以及如何进行更新。 初始化 initState(vm); function initState(vm) { vm._watchers = []; var opts = vm.$options; if (opts.props) { initProps(vm, opts.props); } // ... } function initProps(vm, propsOptions) { var propsData = vm.$options.propsData || {}; // 获取Vue实例选项上的Props var props = (vm._props = {}); // 获取挂载Vue实例上的_props var keys = (vm.$options._propKeys = []); // Props的Key值组成的数组 // ... for (var key in propsOptions) loop(key); // 循环遍历 vue 实例选项中Props，并且执行响应式处理以及挂载在对应实例上 // ... }",
      "content_html": "<h2> props</h2>\n<p>这一次，通过源码阅读，主要探索的方面包括如何初始化 Props、以及如何进行更新。</p>\n<h3> 初始化</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>初始化 Props 的关键点就在于 loop 函数，让我们接着该函数做了什么事情。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>理解上应该不会有太大的问题，loop 函数中主要做了以下几件事：</p>\n<ul>\n<li>defineReactive</li>\n</ul>\n<p>相信对这个函数应该都不会陌生，其实就是对 Vue 实例上的<code>_props</code>对象中每一个属性都配置成响应式的，这样一来，当父组件中传递进来的 <code>Props</code> 变化时，则会通知相应的子组件中更新函数进行更新；</p>\n<ul>\n<li>对相应的子组件配置 Props 属性的 Setter 警告函数</li>\n</ul>\n<p>用过 Vue 的童鞋们应该都会遇到直接更改一个 <code>Props</code> 中的属性时，会抛出一个警告。而这个警告就是在 Vue 遍历 <code>_props</code> 对象中的值时，都会默认配置一个警告 <code>Setter</code> 函数；</p>\n<ul>\n<li>proxy</li>\n</ul>\n<p>在遍历的过程中，一旦发现有新的属性时，都会将新属性重新挂载到 Vue 实例的 <code>_props</code> 中。这里有一个很重要的知识点，<strong>当我们直接访问一个 Props 中的属性时，即上面栗子中<code>this.name</code>，其实是直接访问了 Vue 实例的 <code>_props</code> 对象中值而已。</strong></p>\n<p>至此，我们也知道 Vue 源码是如何实现初始化 Props 的了，那么，究竟是父组件是如何通知更新 Props 的呢？我们接着看下去。</p>\n<h3> 更新</h3>\n<p>由于父组件在更新的过程中，会通知子组件也进行更新，这时候就会调取一个方法<code>updateChildComponent</code>，而这个方法里就会对 <code>Props</code> 进行更新。我们就来看看是如何处理的：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>一开始看到这里代码时，我是懵逼状态的，因为很容易绕不出来 😂。。在这里面会有几个问题，分别是：</p>\n<ul>\n<li>validateProp 作用究竟是什么？</li>\n</ul>\n<p>相信用过 Props 的同学都清楚，在传递给子组件时，子组件中是有权限决定传递的值类型的，大大提高传递的规范，举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>代码很好理解，就是规定 <code>name</code> 属性的类型以及是否必传。而方法<code>validateProp</code>作用就是校验父组件传递给子组件的值是否按要求传递，若正确传递则直接赋值给 <code>_props</code> 对象上相应的属性。</p>\n<ul>\n<li>校验通过后，直接赋值给 <code>_props</code> 对象上相应的属性的用意何在？</li>\n</ul>\n<p>上面提到过，<code>_props</code> 对象上的每一个属性都会使用 <code>proxy</code> 方法进行响应式挂载。那么当我直接赋值到 <code>_props</code> 对象上相应的属性时，就会触发到其 <code>Setter</code> 函数进行相应的依赖更新。因此，当父组件更新一个传递到子组件的属性时，首先会触发其 <code>Setter</code> 函数通知父组件进行更新，然后通过渲染函数传递到子组件后，更新子组件中的 <code>Props</code>。这时候，由于此时的 <code>Props</code> 对象中的属性收集到了子组件的依赖，更改后会通知相应的依赖进行更新。</p>\n<ul>\n<li>toggleObserving 究竟是干嘛用的？</li>\n</ul>\n<p>首先它是一个递归遍历方法，<strong><code>Props</code> 在通知子组件依赖更新时，必须搞清楚的一点，就是是整个值的变化来进行通知</strong>。如何理解？</p>\n<p>简单滴说，对于属性值为基本数据类型的，当值改变时，是可以直接通知子组件进行更新的，而对于复杂数据类型来说，在更新时，会递归遍历其对象内部的属性来通知相应的依赖进行更新。</p>\n<p>那么当调用方法<code>toggleObserving</code>为 false 时，对于基础数据类型来说，当其值变化时则直接通知子组件更新，而对于其复杂数据类型来说，则不会递归下去，而只会监听整个复杂数据类型替换时，才会去通知子组件进行更新。因此在 <code>Props</code> 中所有属性通知完后，又会重新调用方法 toggleObserving 为 true 来打开递归开关。（真的不得不服尤大大啊，这么好的优化思路都能想出来，牛人 👍）</p>\n<p>至此，你大概也知道整个更新流程了，但是我当时还是存在疑惑的，既然基础数据类型值更改或复杂数据类型整个值更改，可以直接通知到子组件进行更新，那么是否会有一种情况就是，复杂数据类型中属性更改时，又是如何通知子组件更新的呢？？🤔</p>\n<p>首先，我们一开始已经忽略一个方法，那就是 defineReactive$$1，这个方法真的用的秒，可以看看上面的代码，在初始化 Props 时候，会对 Props 每一项的属性进行使用该方法进行响应式的处理，包括了复杂数据类型的中属性，此时该属性不但收集了父组件依赖，还收集了子组件的依赖，这样一来，当复杂数据类型中属性变化时，会先通知父组件更新，再通知子组件进行更新。（这时候我真的不得不服到五体投地。。。）</p>\n<h3> 总结</h3>\n<ul>\n<li>当 Props 中属性为基础数据类型值更改或复杂数据类型替换时，会通过 Setter 函数通知父组件进行更新，然后通过渲染函数，传递到子组件中更新其 Props 中对象相应的值，这时候就会触发到相应值的 Setter 来通知子组件进行更新；</li>\n<li>当 Props 中属性为复杂数据类型的属性更改时，由于使用 defineReactive$$1 方法收集到了父组件依赖以及子组件的依赖，这时候会先通知父组件进行更新，再通知子组件进行更新；</li>\n</ul>\n<p>参考:</p>\n<ul>\n<li><a href=\"https://ustbhuangyi.github.io/vue-analysis/v2/reactive/props.html\" target=\"_blank\" rel=\"noopener noreferrer\">Vue.js 技术揭秘 props</a></li>\n<li><a href=\"https://github.com/Andraw-lin/about-Vue/blob/master/docs/%E3%80%90%20Vue%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20%E3%80%91%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B9%8B%20Props.md\" target=\"_blank\" rel=\"noopener noreferrer\">【 Vue 源码分析 】运行机制之 Props</a></li>\n</ul>\n",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "proxy-observe 核心代码 自定义实现",
      "url": "https://www.h7ml.cn/posts/vue/proxy-observe.html",
      "id": "https://www.h7ml.cn/posts/vue/proxy-observe.html",
      "summary": "proxy-observe 核心代码 自定义实现 // 创建响应式 function reactive(target = {}) { if (typeof target !== 'object' || target == null) { // 不是对象或数组，则返回 return target; } // 代理配置 const proxyConf = { get(target, key, receiver) { // 只处理本身（非原型的）属性 const ownKeys = Reflect.ownKeys(target); if (ownKeys.includes(key)) { console.log('get', key); // 监听 } const result = Reflect.get(target, key, receiver); // 深度监听 // 性能如何提升的？ return reactive(result); }, set(target, key, val, receiver) { // 重复的数据，不处理 if (val === target[key]) { return true; } const ownKeys = Reflect.ownKeys(target); if (ownKeys.includes(key)) { console.log('已有的 key', key); } else { console.log('新增的 key', key); } const result = Reflect.set(target, key, val, receiver); console.log('set', key, val); // console.log('result', result) // true return result; // 是否设置成功 }, deleteProperty(target, key) { const result = Reflect.deleteProperty(target, key); console.log('delete property', key); // console.log('result', result) // true return result; // 是否删除成功 }, }; // 生成代理对象 const observed = new Proxy(target, proxyConf); return observed; } // 测试数据 const data = { name: 'zhangsan', age: 20, info: { city: 'beijing', a: { b: { c: { d: { e: 100, }, }, }, }, }, }; const proxyData = reactive(data);",
      "content_html": "<h1> proxy-observe 核心代码 自定义实现</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2021-06-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "set",
      "url": "https://www.h7ml.cn/posts/vue/set.html",
      "id": "https://www.h7ml.cn/posts/vue/set.html",
      "summary": "$set() 实时更新 对象添加属性 对于使用 Object.defineProperty 实现响应式的对象，当我们去给这个对象添加一个新的属性的时候，是不能够触发它的 setter 的，比如： var vm = new Vue({ data: { a: 1, }, }); // vm.b 是非响应的 vm.b = 2;",
      "content_html": "<h2> $set() 实时更新</h2>\n<h3> 对象添加属性</h3>\n<p>对于使用 <code>Object.defineProperty</code> 实现响应式的对象，当我们去给这个对象添加一个新的属性的时候，是不能够触发它的 <code>setter</code> 的，比如：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但是添加新属性的场景我们在平时开发中会经常遇到，那么 <code>Vue</code> 为了解决这个问题，定义了一个全局 <code>API Vue.set</code> 方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>set</code> 方法接收 3 个参数，</p>\n<ul>\n<li><code>target</code> 可能是数组或者是普通对象</li>\n<li><code>key</code> 代表的是数组的下标或者是对象的键值</li>\n<li><code>val</code> 代表添加的值</li>\n</ul>\n<p>首先判断如果 <code>target</code> 是数组且 <code>key</code> 是一个合法的下标，则之前通过 <code>splice</code> 去添加进数组然后返回，这里的 <code>splice</code> 其实已经不仅仅是原生数组的 <code>splice</code> 了，稍后我会详细介绍数组的逻辑。</p>\n<p>接着又判断 <code>key</code> 已经存在于 <code>target</code> 中，则直接赋值返回，因为这样的变化是可以观测到了。</p>\n<p>接着再获取到 <code>target.__ob__</code> 并赋值给 <code>ob</code>，之前分析过它是在 <code>Observer</code> 的构造函数执行的时候初始化的，表示 <code>Observer</code> 的一个实例，如果它不存在，则说明 <code>target</code> 不是一个响应式的对象，则直接赋值并返回。</p>\n<p>最后通过 <code>defineReactive(ob.value, key, val)</code> 把新添加的属性变成响应式对象，然后再通过 <code>ob.dep.notify()</code> 手动的触发依赖通知，还记得我们在给对象添加 <code>getter</code> 的时候有这么一段逻辑：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 <code>getter</code> 过程中判断了 <code>childOb</code>，并调用了 <code>childOb.dep.depend()</code> 收集了依赖，这就是为什么执行 <code>Vue.set</code> 的时候通过 <code>ob.dep.notify()</code> 能够通知到 <code>watcher</code>，从而让添加新的属性到对象也可以检测到变化。这里如果 <code>value</code> 是个数组，那么就通过 <code>dependArray</code> 把数组每个元素也去做依赖收集。</p>\n<h3> 数组</h3>\n<p>接着说一下数组的情况，<code>Vue</code> 也是不能检测到以下变动的数组：</p>\n<p>1.当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></p>\n<p>2.当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></p>\n<p>对于第一种情况，可以使用：<code>Vue.set(example1.items, indexOfItem, newValue)</code>；而对于第二种情况，可以使用 <code>vm.items.splice(newLength)</code>。</p>\n<p>我们刚才也分析到，对于 <code>Vue.set</code> 的实现，当 <code>target</code> 是数组的时候，也是通过 <code>target.splice(key, 1, val)</code> 来添加的，那么这里的 <code>splice</code> 到底有什么黑魔法，能让添加的对象变成响应式的呢。</p>\n<p>其实之前我们也分析过，在通过 <code>observe</code> 方法去观察对象的时候会实例化 <code>Observer</code>，在它的构造函数中是专门对数组做了处理。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里我们只需要关注 <code>value</code> 是 <code>Array</code> 的情况，首先获取 <code>augment</code>，这里的 <code>hasProto</code> 实际上就是判断对象中是否存在 <code>__proto__</code>，如果存在则 <code>augment</code> 指向 <code>protoAugment</code>， 否则指向 <code>copyAugment</code>，来看一下这两个函数的定义：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>protoAugment</code> 方法是直接把 <code>target.__proto__</code> 原型直接修改为 <code>src</code>，而 <code>copyAugment</code> 方法是遍历 <code>keys</code>，通过 <code>def</code>，也就是 <code>Object.defineProperty</code> 去定义它自身的属性值。对于大部分现代浏览器都会走到 <code>protoAugment</code>，那么它实际上就把 <code>value</code> 的原型指向了 <code>arrayMethods</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，<code>arrayMethods</code> 首先继承了 <code>Array</code>，然后对数组中所有能改变数组自身的方法，如 <code>push、pop</code> 等这些方法进行重写。</p>\n<p>重写后的方法会先执行它们本身原有的逻辑，并对能增加数组长度的 3 个方法 <code>push、unshift、splice</code> 方法做了判断，获取到插入的值，然后把新添加的值变成一个响应式对象，并且再调用 <code>ob.dep.notify()</code> 手动触发依赖通知，这就很好地解释了之前的示例中调用 <code>vm.items.splice(newLength)</code> 方法可以检测到变化。</p>\n",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "vue核心概念",
      "url": "https://www.h7ml.cn/posts/vue/theory.html",
      "id": "https://www.h7ml.cn/posts/vue/theory.html",
      "summary": "在父组件中监听子组件的生命周期钩子 &lt;template&gt; &lt;child @hook:mounted=\"onChildMounted\"&gt;&lt;/child&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { onChildMounted() {}, }, }; &lt;/script&gt;",
      "content_html": "<h2> 在父组件中监听子组件的生命周期钩子</h2>\n<div class=\"language-vue line-numbers-mode\" data-ext=\"vue\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><a href=\"https://github.com/vuejs/vue/blob/dev/src/core/instance/lifecycle.js#L347\" target=\"_blank\" rel=\"noopener noreferrer\">相关源码</a></p>\n<h2> 在 methods 中使用 debounce / throttle</h2>\n<div class=\"language-vue line-numbers-mode\" data-ext=\"vue\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><a href=\"https://cn.vuejs.org/v2/guide/migration.html#%E5%B8%A6%E6%9C%89-debounce-%E7%9A%84-v-model%E7%A7%BB%E9%99%A4\" target=\"_blank\" rel=\"noopener noreferrer\">官网例子</a></p>\n<h2> 1、组件化</h2>\n<h3> 组件化基础</h3>\n<ul>\n<li>\n<p>MVVM 模型</p>\n<ul>\n<li>模型-视图-视图模型。</li>\n<li>模型（Model）指的是后端传递的数据。视图(View)指的是所看到的页面。视图模型(ViewModel)是 mvvm 模式的核心，它是连接 view 和 model 的桥梁。它有两个方向：一是将模型（Model）转化成视图(View)，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将视图(View)转化成模型(Model)，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。</li>\n</ul>\n</li>\n<li>\n<p>MVC</p>\n<ul>\n<li>模型-视图-控制器。</li>\n<li>M 和 V 指的意思和 MVVM 中的 M 和 V 意思一样。 C 即 Controller 指的是页面业务逻辑。使用 MVC 的目的就是将 M 和 V 的代码分离。 MVC 是单向通信。也就是 View 跟 Model，必须通过 Controller 来承上启下。 MVC 和 MVVM 的区别并不是 VM 完全取代了 C，只是在 MVC 的基础上增加了一层 VM，只不过是弱化了 C 的概念，ViewModel 存在目的在于抽离 Controller 中展示的业务逻辑，而不是替代 Controller，其它视图操作业务等还是应该放在 Controller 中实现。也就是说 MVVM 实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。</li>\n</ul>\n</li>\n</ul>\n<h3> 数据驱动视图</h3>\n<ul>\n<li>传统组件，只是静态渲染，更新还要依赖操作 DOM</li>\n<li>数据驱动视图 - Vue MVVM</li>\n<li>数据驱动视图 - React setState</li>\n</ul>\n<h2> 2、响应式</h2>\n<ul>\n<li>核心 api Object.defineproperty\n<ul>\n<li>vue 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的， 也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；</li>\n<li><a href=\"/posts/vue/Object.defineproperty.html\" target=\"blank\">Object.defineproperty 核心代码 自定义实现</a></li>\n</ul>\n</li>\n<li>监听对象（深度），监听数组</li>\n<li>Object.defineproperty 的缺点（vue3 用 Proxy）\n<ul>\n<li>深度监听，需要递归到底，一次性计算量大</li>\n<li>无法监听新增属性/删除属性（Vue.set Vue.delete）</li>\n<li><a href=\"/posts/vue/Proxy.html\" target=\"blank\">Proxy 核心代码 自定义实现</a></li>\n<li><a href=\"/posts/vue/proxy-observe.html\" target=\"blank\">proxy-observe 核心代码 自定义实现</a></li>\n</ul>\n</li>\n</ul>\n<p>Object.defineproperty.html</p>\n<h2> 3、vdom 和 diff</h2>\n<ul>\n<li>应用背景\n<ul>\n<li>vdom 是实现 vue 和 react 的重要基石</li>\n<li>diff 算法是 vdom 中最核心、最关键的部分</li>\n<li>vdom 是一个热门话题，也是面试中的热门问题</li>\n<li>DOM 操作非常耗费性能</li>\n<li>以前用 jQuery，可以自行控制 DOM 操作的时机，手动调整</li>\n<li>Vue 和 React 是数据驱动视图，如何有效控制 DOM 操作</li>\n</ul>\n</li>\n<li>解决方案 - vdom\n<ul>\n<li>有了一定复杂度，想减少计算次数比较难</li>\n<li>能不能吧计算，更多的转移为 JS 计算？因为 JS 执行速度很快</li>\n<li>vdom - 用 JS 模拟 DOM 结构，计算出最小的变更，操作 DOM</li>\n</ul>\n</li>\n<li>vnode 结构</li>\n<li>snabbdom 使用：vnode h patch</li>\n</ul>\n<h3> diff 算法</h3>\n<ul>\n<li>diff 算法是 vdom 中最核心、最关键的部分</li>\n<li>diff 算法能在日常使用 vue React 中体现出来（如 key）</li>\n<li>diff 算法是前端热门话题</li>\n</ul>\n<h4> diff 算法概述</h4>\n<ul>\n<li>diff 即对比，是一个广泛的概念，如 linux diff 命令、git diff 等</li>\n<li>两个 js 对象也可以做 diff，如<a href=\"https://gethub.com/cujojs/jiff\" target=\"_blank\" rel=\"noopener noreferrer\">https://gethub.com/cujojs/jiff</a></li>\n</ul>\n<h2> 4、模版编译</h2>\n<ul>\n<li>with 语法</li>\n<li>模版编译为 render 函数</li>\n<li>执行 render 函数生成 vdom</li>\n</ul>\n<h2> 5、渲染过程</h2>\n<ul>\n<li>初次渲染过程</li>\n<li>更新过程</li>\n<li>异步渲染</li>\n</ul>\n<h2> 6、前端路由</h2>\n<ul>\n<li>hash</li>\n<li>h5 history</li>\n<li>两者对比</li>\n</ul>\n<h2> 7、vue 面试真题演练</h2>\n<h3> 1、v-show 和 v-if 的区别</h3>\n<ul>\n<li>v-show 通过 css display 控制显示和隐藏</li>\n<li>v-if 组件真正的渲染和销毁， 而不是显示和隐藏</li>\n<li>频繁切换显示状态用 v-show， 否则用 v-if</li>\n</ul>\n<h3> 为何在 v-for 中使用 key</h3>\n<ul>\n<li>必须用 key， 且不能是 index 和 random</li>\n<li>diff 算法中通过 tag 和 key 来判断， 是否是 sameNode</li>\n<li>减少渲染次数，提升渲染性能</li>\n</ul>\n<h3> 描述 Vue 组件生命周期（父子组件）</h3>\n<ul>\n<li>单组件生命周期</li>\n<li>父子组件生命周期关系</li>\n</ul>\n<h3> Vue 组件如何通讯（常见）</h3>\n<ul>\n<li>父子组件 props 和 this.$emit</li>\n<li>自定义事件 event.off event.emit</li>\n<li>vuex</li>\n</ul>\n<h3> 描述组件渲染和更新的过程</h3>\n<ul>\n<li>响应式（监听属性变化）</li>\n<li>模版渲染</li>\n<li>vdom</li>\n</ul>\n<h3> 双向数据绑定 v-model 的实现原理</h3>\n<ul>\n<li>input 元素的 value = <a href=\"http://this.name\" target=\"_blank\" rel=\"noopener noreferrer\">this.name</a></li>\n<li>绑定 input 事件 <a href=\"http://this.name\" target=\"_blank\" rel=\"noopener noreferrer\">this.name</a> = $event.target.value</li>\n<li>data 更新触发 re-render</li>\n</ul>\n<h3> 对于 MVVM 的理解</h3>\n<ul>\n<li>Model、viewModel、view</li>\n</ul>\n<h3> computed 有何特点</h3>\n<ul>\n<li>缓存，不变不会重新计算</li>\n<li>提高性能</li>\n</ul>\n<h3> 为何组件 data 必须是一个函数？</h3>\n<ul>\n<li>data 必须是一个函数（为了不同的实例不冲突）</li>\n<li>vue 是一个 class</li>\n</ul>\n<h3> ajax 请求应该放在哪个生命周期</h3>\n<ul>\n<li>mounted</li>\n<li>js 是单线程的， ajax 异步获取数据</li>\n<li>放在 mounted 之前没有什么用，只会让逻辑变得更混乱</li>\n</ul>\n<h3> 如何将组件所有 props 传递给子组件？</h3>\n<ul>\n<li>$props</li>\n<li><code>&lt;User v-bind=\"$props\"&gt;</code></li>\n<li>细节知识点，优先级不高</li>\n</ul>\n<h3> 如何自己实现 v-model</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 多个组件有相同的逻辑，如何抽离？</h3>\n<ul>\n<li>mixin</li>\n<li>以及 mixin 的一些缺点</li>\n</ul>\n<h3> 为何要使用异步组件？</h3>\n<ul>\n<li>加载大组件</li>\n<li>路由异步加载</li>\n</ul>\n<h3> 何时使用 keep-alive？</h3>\n<ul>\n<li>缓存组件，不需要重复渲染</li>\n<li>如多个静态 tab 页的切换</li>\n<li>优化性能</li>\n</ul>\n<h3> 何时需要使用 beforeDestory</h3>\n<ul>\n<li>解绑自定义事件 event.$off</li>\n<li>清除定时器</li>\n<li>解绑自定义的 DOM 事件，如 window scroll 等</li>\n</ul>\n<h3> 什么是作用域插槽</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> vuex 中 action 和 mutation 有何区别</h3>\n<ul>\n<li>action 中处理异步，mutation 不可以</li>\n<li>mutaion 做原子操作</li>\n<li>action 可以整合多个 mutation</li>\n</ul>\n<h3> vue-router 常用的路由模式</h3>\n<ul>\n<li>hash 默认</li>\n<li>H5 history（需要服务支持）</li>\n<li>两者比较</li>\n</ul>\n<h3> 如何配置 vue-router 异步加载</h3>\n<ul>\n<li>path 和 component</li>\n<li>component: ()=&gt; import('..///')</li>\n</ul>\n<h3> 请用 vnode 描述一个 DOM 结构</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 监听 data 变化的核心 API 是什么</h3>\n<ul>\n<li>Object.defineProperty</li>\n<li>以及深度监听、监听数组</li>\n<li>有何缺点</li>\n</ul>\n<h3> Vue 如何监听数组变化</h3>\n<ul>\n<li>Object.defineProperty 不能监听数组变化</li>\n<li>重新定义原型，重写 push pop 等方法，实现监听</li>\n<li>proxy 可以原生支持监听数组变化</li>\n</ul>\n<h3> 请描述响应式原理</h3>\n<ul>\n<li>监听 data 变化</li>\n<li>组件渲染和更新的流程</li>\n</ul>\n<h3> diff 算法的时间复杂度</h3>\n<ul>\n<li>O(n)</li>\n<li>在 O(n^3)基础上做了一些调整</li>\n</ul>\n<h3> 简述 diff 算法过程</h3>\n<ul>\n<li>patch(elem, vnode)和 path(vnode, newVode)</li>\n<li>pathVnode 和 addVnodes 和 removeVnodes</li>\n<li>updataChildren（key 的重要性）</li>\n</ul>\n<h3> vue 为何是异步渲染， $nextTick 何用</h3>\n<ul>\n<li>异步渲染（以合并 data 修改），以提高渲染性能</li>\n<li>$nextTick 在 DOM 更新完后，触发回调</li>\n</ul>\n<h3> Vue 常见性能优化方式</h3>\n<ul>\n<li>合理使用 v-show 和 v-if</li>\n<li>合理使用 computed</li>\n<li>v-for 时加 key， 以及避免和 v-if 同时使用</li>\n<li>（v-for 优先级高， 每次 v-for 会重新计算一遍 v-if）</li>\n<li>自定义事件、DOM 事件及时销毁</li>\n<li>合理使用异步组件</li>\n<li>合理使用 keep-alive</li>\n<li>data 层级不要太深</li>\n<li>使用 vue-loader 在开发环境做模版编译（预编译）</li>\n<li>webpack 层面的优化</li>\n<li>前端通用的性能优化，如图片懒加载</li>\n<li>使用 SSR</li>\n</ul>\n<h2> hash 和 history 路由实现原理</h2>\n<p>location.hash 的值实际就是 URL 中#后面的东西。</p>\n<p>history 实际采用了 HTML5 中提供的 API 来实现，主要有 history.pushState()和 history.replaceState()。</p>\n",
      "date_published": "2021-06-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "Virtual DOM",
      "url": "https://www.h7ml.cn/posts/vue/virtual-dom.html",
      "id": "https://www.h7ml.cn/posts/vue/virtual-dom.html",
      "summary": "Virtual DOM 要知道渲染真实DOM的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实 dom 上会引起整个 dom 树的重绘和重排，有没有可能我们只更新我们修改的那一小块 dom 而不要更新整个 dom 呢？ diff算法能够帮助我们。 我们先根据真实 DOM 生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的 DOM 上，然后使oldVnode的值为Vnode。",
      "content_html": "<h2> Virtual DOM</h2>\n<p>要知道渲染<code>真实DOM</code>的开销是很大的，比如有时候我们修改了某个数据，<strong>如果直接渲染到真实 dom 上会引起整个 dom 树的重绘和重排</strong>，有没有可能我们只更新我们修改的那一小块 dom 而不要更新整个 dom 呢？</p>\n<p><code>diff算法</code>能够帮助我们。</p>\n<p>我们先根据真实 DOM 生成一颗<code>virtual DOM</code>，当<code>virtual DOM</code>某个节点的数据改变后会生成一个新的<code>Vnode</code>，然后<code>Vnode</code>和<code>oldVnode</code>作对比，发现有不一样的地方就直接修改在真实的 DOM 上，然后使<code>oldVnode</code>的值为<code>Vnode</code>。</p>\n<p><code>diff</code>的过程就是调用名为<code>patch</code>的函数，比较新旧节点，一边比较一边给<strong>真实的 DOM</strong>打补丁。</p>\n<h3> virtual DOM 和真实 DOM 的区别</h3>\n<p><code>virtual DOM</code>是将真实的 DOM 的数据抽取出来，以对象的形式模拟树形结构。比如 dom 是这样的：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对应的 virtual DOM（伪代码）：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>（温馨提示：<code>VNode</code>和<code>oldVNode</code>都是对象，一定要记住）</p>\n<ul>\n<li>\n<p>用 JavaScript 对象模拟 DOM</p>\n</li>\n<li>\n<p>把此虚拟 DOM 转成真实 DOM 并插入页面中</p>\n</li>\n<li>\n<p>如果有事件发生修改了虚拟 DOM</p>\n</li>\n<li>\n<p>比较两棵虚拟 DOM 树的差异，得到差异对象</p>\n</li>\n<li>\n<p>把差异对象应用到真正的 DOM 树上</p>\n</li>\n</ul>\n<h3> VNode</h3>\n<p>对于 <code>VNode</code>，相信大家一点都不陌生，用于表示虚拟节点，是实现<code>Virtual DOM</code>的一种方式。那么它究竟是怎样的呢？我们就去 Vue 源码里探讨一下。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里千万不要因为 <code>VNode</code> 的这么属性而被吓到，或者咬紧牙去摸清楚每个属性的意义，其实，我们主要了解其几个核心的关键属性就差不多了，例如：</p>\n<ul>\n<li><code>tag</code> 属性即这个<code>vnode</code>的标签属性</li>\n<li><code>data</code> 属性包含了最后渲染成真实 dom 节点后，节点上的<code>class</code>，<code>attribute</code>，<code>style</code>以及绑定的事件</li>\n<li><code>children</code> 属性是<code>vnode</code>的子节点</li>\n<li><code>text</code> 属性是文本属性</li>\n<li><code>elm</code> 属性为这个<code>vnode</code>对应的真实 dom 节点</li>\n<li><code>key</code> 属性是<code>vnode</code>的标记，在<code>diff</code>过程中可以提高<code>diff</code>的效率</li>\n</ul>\n<p><code>Virtual DOM</code> 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 <code>VNode</code> 的 create、diff、patch 等过程。</p>\n",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "vueuse实用方法",
      "url": "https://www.h7ml.cn/posts/vue/vssue.html",
      "id": "https://www.h7ml.cn/posts/vue/vssue.html",
      "summary": "浏览器 使用屏幕断点 import { useBreakpoints } from '@vueuse/core'; /** * 浏览器屏幕断点 */ export const handleBreakpoints = () =&gt; { const breakpoints = useBreakpoints({ xs: 0, sm: 768, md: 992, lg: 1200, xl: 1920, xxl: 2560, }); const xs = breakpoints.between('xs', 'sm'); const sm = breakpoints.between('sm', 'md'); const md = breakpoints.between('md', 'lg'); const lg = breakpoints.between('lg', 'xl'); const xl = breakpoints.between('xl', 'xxl'); return { xs, sm, md, lg, xl }; };",
      "content_html": "<h2> 浏览器</h2>\n<h3> 使用屏幕断点</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 复制文字</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 事件监听</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 取色器</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 网站图标</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 全屏元素</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 异步加载图片</h3>\n<div class=\"language-vue line-numbers-mode\" data-ext=\"vue\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 加载 script 标签</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 加载 css 字符串</h3>\n<ul>\n<li>输入</li>\n</ul>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>输出</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 网站标题</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> url 查询参数</h3>\n<ul>\n<li>history</li>\n</ul>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>hash</li>\n</ul>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 系统通知</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 传感器</h2>\n<h3> 键盘事件</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 长按</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>使用指令</li>\n</ul>\n<div class=\"language-vue line-numbers-mode\" data-ext=\"vue\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 设备列表</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 屏幕共享</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 鼠标悬停</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>指令</li>\n</ul>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 焦点</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 地理位置</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 跟踪用户空闲</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 无限滚动</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>指令</li>\n</ul>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 鼠标位置</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 网络状态</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 网络在线</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 页面离开</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 文本选中</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "new Vue 发生了什么",
      "url": "https://www.h7ml.cn/posts/vue/what_happened_to_new_Vue.html",
      "id": "https://www.h7ml.cn/posts/vue/what_happened_to_new_Vue.html",
      "summary": "new Vue 发生了什么 写在前面：本文基于vue2.6进行源码分析 初始化 vue 我们在实例化一个 vue 实例，也即 new Vue() 时，实际上是执行 src/core/instance/index.js 中定义的 Function 函数。",
      "content_html": "<h1> new Vue 发生了什么</h1>\n<p>写在前面：本文基于<a href=\"https://github.com/vuejs/vue/tree/2.6\" target=\"_blank\" rel=\"noopener noreferrer\">vue2.6</a>进行源码分析</p>\n<h2> 初始化 vue</h2>\n<p>我们在实例化一个 <code>vue</code> 实例，也即 <code>new Vue()</code> 时，实际上是执行 <a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/instance/index.js#L8\" target=\"_blank\" rel=\"noopener noreferrer\">src/core/instance/index.js</a> 中定义的 <code>Function</code> 函数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过查看 <code>Vue</code> 的 <code>function</code>，我们知道 <code>Vue</code> 只能通过 <code>new</code> 关键字初始化，然后调用 <code>this._init</code> 方法，该方法在 <a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/instance/init.js#L16\" target=\"_blank\" rel=\"noopener noreferrer\">src/core/instance/init.js</a> 中定义。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 <code>data、props、computed、watcher</code> 等等。</p>\n<h2> Vue 实例挂载</h2>\n<p>Vue 中是通过 <code>$mount</code> 实例方法去挂载 <code>dom</code> 的，下面我们通过分析 <code>compiler</code> 版本的 <code>mount</code> 实现，相关源码在目录 <a href=\"https://github.com/vuejs/vue/blob/2.6/src/platforms/web/entry-runtime-with-compiler.js#L17\" target=\"_blank\" rel=\"noopener noreferrer\">src/platforms/web/entry-runtime-with-compiler.js</a> 文件中定义：。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们发现最终还是调用用原先原型上的 <code>$mount</code> 方法挂载 ，原先原型上的 <code>$mount</code> 方法在 <a href=\"https://github.com/vuejs/vue/blob/2.6/src/platforms/web/runtime/index.js#L37\" target=\"_blank\" rel=\"noopener noreferrer\">src/platforms/web/runtime/index.js</a> 中定义 。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们发现<code>$mount</code> 方法实际上会去调用 <code>mountComponent</code> 方法，这个方法定义在 <a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/instance/lifecycle.js#L141\" target=\"_blank\" rel=\"noopener noreferrer\">src/core/instance/lifecycle.js</a> 文件中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面的代码可以看到，<code>mountComponent</code>核心就是先实例化一个渲染<code>Watcher</code>，在它的回调函数中会调用 <code>updateComponent</code>方法，在此方法中调用 <code>vm._render</code>方法先生成虚拟 <code>Node</code>，最终调用 <code>vm._update</code>更新 DOM。</p>\n<h2> 创建虚拟 Node</h2>\n<p>Vue 的 <code>_render</code> 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟<code>Node</code>。它的定义在 <a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/instance/render.js#L69\" target=\"_blank\" rel=\"noopener noreferrer\">src/core/instance/render.js</a> 文件中：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>vm._render</code> 最终是通过执行 <code>createElement</code> 方法并返回的是 <code>vnode</code>，它是一个虚拟 Node</p>\n<p><a href=\"https://github.com/vuejs/vue/blob/2.6\" target=\"_blank\" rel=\"noopener noreferrer\">Vue.js</a> 利用 <code>_createElement</code> 方法创建 <code>VNode</code>，它定义在 <a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/vdom/create-element.js#L47\" target=\"_blank\" rel=\"noopener noreferrer\">src/core/vdom/create-elemenet.js</a> 中：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>_createElement 方法有</code> 5 个参数，<code>context</code>表示 <code>VNode</code> 的上下文环境，它是 <code>Component</code>类型；<code>tag</code>表示标签，它可以是一个字符串，也可以是一个 <code>Component</code>；<code>data</code>表示 <code>VNode</code> 的数据，它是一个 <code>VNodeData</code>类型，可以在 flow/vnode.js 中找到它的定义；<code>children</code>表示当前 <code>VNode</code> 的子节点，它是任意类型的，需要被规范为标准的 <code>VNode</code> 数组；</p>\n<h2> 更新视图</h2>\n<p>完成视图的更新工作事实上就是调用了<code>vm._update</code>方法，这个方法接收的第一个参数是刚生成的<code>Vnode</code>，调用的<code>vm._update</code>方法定义在 <a href=\"https://github.com/vuejs/vue/blob/2.6/src/core/instance/lifecycle.js#L59\" target=\"_blank\" rel=\"noopener noreferrer\">src/core/instance/lifecycle.js</a> 中。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 总结</h2>\n<p>下图更直观地看到从初始化 Vue 到最终渲染的整个过程。</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/vue.png\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n",
      "image": "https://static.h7ml.cn/vitepress/assets/images/vue.png",
      "date_published": "2021-07-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "JavaScript ajax 封装",
      "url": "https://www.h7ml.cn/posts/html/ajax/ajax%E5%B0%81%E8%A3%85.html",
      "id": "https://www.h7ml.cn/posts/html/ajax/ajax%E5%B0%81%E8%A3%85.html",
      "summary": "JavaScript ajax 封装 function ajax(setting) { var ajax = new XMLHttpRequest(); // 默认 get if (!setting.method) setting.method = 'get'; // 组合data查询数据 if (setting.data) { setting.data = getSearch(setting.data); } else { setting.data = ''; } if (setting.method.toLowerCase() == 'get') { ajax.open('get', setting.url + '?' + setting.data, true); ajax.send(); } else if (setting.method.toLowerCase() == 'post') { ajax.open('post', setting.url, true); ajax.setRequestHeader('Content-type', 'appliction/x-www-form-urlencoded'); ajax.send(setting.data); } ajax.onreadystatechange = function () { if (ajax.readyState == 4) { if (ajax.status == 200) { setting.success(ajax.responseText); } else { console.log('Error:' + ajax.status); } } }; } // 拼接字符串 function getSearch(obj) { var str = ''; for (var key in obj) { str += key + '=' + obj[key] + '&amp;'; } return str.slice(0, str.length - 1); }",
      "content_html": "<h1> JavaScript ajax 封装</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript ajax 状态码、json 对象、http 状态码",
      "url": "https://www.h7ml.cn/posts/html/ajax/ajax%E7%8A%B6%E6%80%81.html",
      "id": "https://www.h7ml.cn/posts/html/ajax/ajax%E7%8A%B6%E6%80%81.html",
      "summary": "JavaScript ajax 状态码、json 对象、http 状态码 readyState open：之前是 0 send：发送请求之后是 1 send：方法完成，已经接受到所有的响应内容 2 正在解析下载到的数据 3 解析完成 4 State HTTP 常见状态码 200：交易成功 301：永久重定向 302：临时重定向 304：使用缓存文件 400：错误请求，如语法错误 404：没有发现文件、查询或 URl 405：请求方式错误 500：后端错误 1**：请求收到，继续处理 2**：操作成功收到，分析、接受 3**：完成此请求必须进一步处理 4**：请求包含一个错误语法或不能完成 5**：服务器执行一个完全有效请求失败",
      "content_html": "<h1> JavaScript ajax 状态码、json 对象、http 状态码</h1>\n<h2> readyState</h2>\n<ul>\n<li>open：之前是 0</li>\n<li>send：发送请求之后是 1</li>\n<li>send：方法完成，已经接受到所有的响应内容 2</li>\n<li>正在解析下载到的数据 3</li>\n<li>解析完成 4</li>\n</ul>\n<h2> State HTTP 常见状态码</h2>\n<ul>\n<li>200：交易成功</li>\n<li>301：永久重定向</li>\n<li>302：临时重定向</li>\n<li>304：使用缓存文件</li>\n<li>400：错误请求，如语法错误</li>\n<li>404：没有发现文件、查询或 URl</li>\n<li>405：请求方式错误</li>\n<li>500：后端错误</li>\n<li>1**：请求收到，继续处理</li>\n<li>2**：操作成功收到，分析、接受</li>\n<li>3**：完成此请求必须进一步处理</li>\n<li>4**：请求包含一个错误语法或不能完成</li>\n<li>5**：服务器执行一个完全有效请求失败</li>\n</ul>\n<h2> json 对象</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 数组深拷贝</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript 面向对象-原型继承",
      "url": "https://www.h7ml.cn/posts/html/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF.html",
      "id": "https://www.h7ml.cn/posts/html/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF.html",
      "summary": "JavaScript 面向对象-原型继承 JavaScript原型 JavaScript原型链 原型链继承 function Person(name) { this.name = name; } Person.prototype.fn = function () { console.log('parent'); }; function Child() {} Child.prototype = new Person('name'); // new 之后 只是实例化的对象，下面有 __proto__ Child.prototype.constructor = Child; // 手动修改回来 var child = new Child(); // 在原型上继承，子类不能修改和传参进去",
      "content_html": "<h1> JavaScript 面向对象-原型继承</h1>\n<figure><figcaption>JavaScript原型</figcaption></figure>\n<figure><figcaption>JavaScript原型链</figcaption></figure>\n<h2> 原型链继承</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 对象冒充继承（借用构造函数</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 组合继承</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 寄生式组合继承</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> for...in 继承</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Object.create()继承</h2>\n<p>create 创建新对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript 检查来自实例还是原型",
      "url": "https://www.h7ml.cn/posts/html/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%A3%80%E6%9F%A5%E6%9D%A5%E8%87%AA%E5%AE%9E%E4%BE%8B%E8%BF%98%E6%98%AF%E5%8E%9F%E5%9E%8B.html",
      "id": "https://www.h7ml.cn/posts/html/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%A3%80%E6%9F%A5%E6%9D%A5%E8%87%AA%E5%AE%9E%E4%BE%8B%E8%BF%98%E6%98%AF%E5%8E%9F%E5%9E%8B.html",
      "summary": "JavaScript 检查来自实例还是原型 方法 fn1 instanceof Fun; // fn1 是由构造函数 Fun 构造出来的吗？返回 Boolean Object.getPrototypeOf(Person); // 返回 Person 构造函数的原型 Object.getPrototypeOf(Person) == Person.prototype; // true",
      "content_html": "<h1> JavaScript 检查来自实例还是原型</h1>\n<h2> 方法</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检查来自实例还是原型</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 返回实例或原型</h3>\n<p>将实例保存为数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "== 和 ===区别，分别在什么情况使用",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/%20____.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/%20____.html",
      "summary": "前端物语|面试物语-== 和 ===区别，分别在什么情况使用",
      "content_html": "<h1> == 和 ===区别，分别在什么情况使用</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/51b208f0-68df-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、等于操作符</h2>\n<p>等于操作符用两个等于号（ == ）表示，如果操作数相等，则会返回 <code>true</code></p>\n<p>前面文章，我们提到在<code>JavaScript</code>中存在隐式转换。等于操作符（==）在比较中会先进行类型转换，再确定操作数是否相等</p>\n<p>遵循以下规则：</p>\n<p>如果任一操作数是布尔值，则将其转换为数值再比较是否相等</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果一个操作数是对象，另一个操作数不是，则调用对象的 <code>valueOf()</code>方法取得其原始值，再根据前面的规则进行比较</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>null</code>和<code>undefined</code>相等</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果有任一操作数是 <code>NaN</code> ，则相等操作符返回 <code>false</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回<code>true</code></p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面进一步做个小结：</p>\n<ul>\n<li>\n<p>两个都为简单类型，字符串和布尔值都会转换成数值，再比较</p>\n</li>\n<li>\n<p>简单类型与引用类型比较，对象转化成其原始类型的值，再比较</p>\n</li>\n<li>\n<p>两个都为引用类型，则比较它们是否指向同一个对象</p>\n</li>\n<li>\n<p>null 和 undefined 相等</p>\n</li>\n<li>\n<p>存在 NaN 则返回 false</p>\n</li>\n</ul>\n<h2> 二、全等操作符</h2>\n<p>全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 <code>true</code>。即类型相同，值也需相同</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>undefined</code> 和 <code>null</code> 与自身严格相等</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、区别</h2>\n<p>相等操作符（==）会做类型转换，再进行值的比较，全等运算符不会做类型转换</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>null</code> 和 <code>undefined</code> 比较，相等操作符（==）为<code>true</code>，全等为<code>false</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 小结</h3>\n<p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但在比较<code>null</code>的情况的时候，我们一般使用相等操作符<code>==</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>等同于下面写法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用相等操作符（==）的写法明显更加简洁了</p>\n<p>所以，除了在比较对象属性为<code>null</code>或者<code>undefined</code>的情况下，我们可以使用相等操作符（<mark>），其他情况建议一律使用全等操作符（</mark>=）</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "前端物语|面试物语-JavaScript",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/",
      "summary": "[ == 和 =区别，分别在什么情况使用](https://www.h7ml.cn/posts/interview/JavaScript/== _=) 说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？ DOM 常见的操作有哪些？ ajax 原理是什么？如何实现？ 数组的常用方法有哪些？ bind、call、apply 区别？如何实现一个 bind? Javascript 本地存储的方式有哪些？区别及应用场景？ 说说你对闭包的理解？闭包使用场景 JavaScript 中执行上下文和执行栈是什么？ 大文件上传如何做断点续传？ 深拷贝浅拷贝的区别？如何实现一个深拷贝？ 说说 JavaScript 中的数据类型？存储上的差别？ 什么是防抖和节流？有什么区别？如何实现？ 说说 JavaScript 中的事件模型 解释下什么是事件代理？应用场景？ 说说你对事件循环的理解 Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？ 说说你对函数式编程的理解？优缺点？ Javascript 如何实现继承？ 说说你了解的 js 数据结构？ 说说 Javascript 数字精度丢失的问题，如何解决？ 说说 JavaScript 中内存泄漏的几种情况？ 说说 new 操作符具体干了什么？ JavaScript 原型，原型链 ? 有什么特点？ 如何实现上拉加载，下拉刷新？ 说说你对正则表达式的理解？应用场景？ 说说你对作用域链的理解 web 常见的攻击方式有哪些？如何防御？ 什么是单点登录？如何实现？ JavaScript 字符串的常用方法有哪些？ 举例说明你对尾递归的理解，有哪些应用场景 谈谈 this 对象的理解 谈谈 JavaScript 中的类型转换机制 typeof 与 instanceof 区别 如何判断一个元素是否在可视区域中？",
      "content_html": "<ul>\n<li>[ == 和 =<mark>区别，分别在什么情况使用](<a href=\"https://www.h7ml.cn/posts/interview/JavaScript/==\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/posts/interview/JavaScript/==</a> _</mark>=)</li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/BOM\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/Dom\" target=\"_blank\" rel=\"noopener noreferrer\"> DOM 常见的操作有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/ajax\" target=\"_blank\" rel=\"noopener noreferrer\"> ajax 原理是什么？如何实现？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/array_api\" target=\"_blank\" rel=\"noopener noreferrer\"> 数组的常用方法有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/bind_call_apply\" target=\"_blank\" rel=\"noopener noreferrer\"> bind、call、apply 区别？如何实现一个 bind?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/cache\" target=\"_blank\" rel=\"noopener noreferrer\"> Javascript 本地存储的方式有哪些？区别及应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/closure\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对闭包的理解？闭包使用场景</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/context_stack\" target=\"_blank\" rel=\"noopener noreferrer\"> JavaScript 中执行上下文和执行栈是什么？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/continue_to_upload\" target=\"_blank\" rel=\"noopener noreferrer\"> 大文件上传如何做断点续传？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/copy\" target=\"_blank\" rel=\"noopener noreferrer\"> 深拷贝浅拷贝的区别？如何实现一个深拷贝？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/data_type\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 JavaScript 中的数据类型？存储上的差别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/debounce_throttle\" target=\"_blank\" rel=\"noopener noreferrer\"> 什么是防抖和节流？有什么区别？如何实现？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/event_Model\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 JavaScript 中的事件模型</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/event_agent\" target=\"_blank\" rel=\"noopener noreferrer\"> 解释下什么是事件代理？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/event_loop\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对事件循环的理解</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/function_cache\" target=\"_blank\" rel=\"noopener noreferrer\"> Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/functional_programming\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对函数式编程的理解？优缺点？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/inherit\" target=\"_blank\" rel=\"noopener noreferrer\"> Javascript 如何实现继承？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/js_data_structure\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你了解的 js 数据结构？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/loss_accuracy\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 Javascript 数字精度丢失的问题，如何解决？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/memory_leak\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 JavaScript 中内存泄漏的几种情况？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/new\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 new 操作符具体干了什么？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/prototype\" target=\"_blank\" rel=\"noopener noreferrer\"> JavaScript 原型，原型链 ? 有什么特点？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/pull_up_loading_pull_down_refresh\" target=\"_blank\" rel=\"noopener noreferrer\"> 如何实现上拉加载，下拉刷新？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/regexp\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对正则表达式的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/scope\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对作用域链的理解</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/security\" target=\"_blank\" rel=\"noopener noreferrer\"> web 常见的攻击方式有哪些？如何防御？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/single_sign\" target=\"_blank\" rel=\"noopener noreferrer\"> 什么是单点登录？如何实现？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/string_api\" target=\"_blank\" rel=\"noopener noreferrer\"> JavaScript 字符串的常用方法有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/tail_recursion\" target=\"_blank\" rel=\"noopener noreferrer\"> 举例说明你对尾递归的理解，有哪些应用场景</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/this\" target=\"_blank\" rel=\"noopener noreferrer\"> 谈谈 this 对象的理解</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/type_conversion\" target=\"_blank\" rel=\"noopener noreferrer\"> 谈谈 JavaScript 中的类型转换机制</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/typeof_instanceof\" target=\"_blank\" rel=\"noopener noreferrer\"> typeof 与 instanceof 区别</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/JavaScript/visible\" target=\"_blank\" rel=\"noopener noreferrer\"> 如何判断一个元素是否在可视区域中？</a></li>\n</ul>\n",
      "date_published": "2023-05-26T00:00:00.000Z",
      "date_modified": "2023-05-26T10:13:08.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "JavaScript"
      ]
    },
    {
      "title": "ajax 原理是什么？如何实现？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/ajax.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/ajax.html",
      "summary": "前端物语|面试物语-ajax 原理是什么？如何实现？",
      "content_html": "<h1> ajax 原理是什么？如何实现？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a35a2950-7b2a-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>AJAX</code>全称(Async Javascript and XML)</p>\n<p>即异步的<code>JavaScript</code> 和<code>XML</code>，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页</p>\n<p><code>Ajax</code>的原理简单来说通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>JavaScript</code>来操作<code>DOM</code>而更新页面</p>\n<p>流程图如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/af42de10-7b2a-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>下面举个例子：</p>\n<p>领导想找小李汇报一下工作，就委托秘书去叫小李，自己就接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作</p>\n<p><code>Ajax</code>请求数据流程与“领导想找小李汇报一下工作”类似，上述秘书就相当于<code>XMLHttpRequest</code>对象，领导相当于浏览器，响应数据相当于小李</p>\n<p>浏览器可以发送<code>HTTP</code>请求后，接着做其他事情，等收到<code>XHR</code>返回来的数据再进行操作</p>\n<h2> 二、实现过程</h2>\n<p>实现 <code>Ajax</code>异步交互需要服务器逻辑进行配合，需要完成以下步骤：</p>\n<ul>\n<li>\n<p>创建 <code>Ajax</code>的核心对象 <code>XMLHttpRequest</code>对象</p>\n</li>\n<li>\n<p>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务端建立连接</p>\n</li>\n<li>\n<p>构建请求所需的数据内容，并通过<code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法发送给服务器端</p>\n</li>\n<li>\n<p>通过 <code>XMLHttpRequest</code> 对象提供的 <code>onreadystatechange</code> 事件监听服务器端你的通信状态</p>\n</li>\n<li>\n<p>接受并处理服务端向客户端响应的数据结果</p>\n</li>\n<li>\n<p>将处理结果更新到 <code>HTML</code>页面中</p>\n</li>\n</ul>\n<h3> 创建 XMLHttpRequest 对象</h3>\n<p>通过<code>XMLHttpRequest()</code> 构造函数用于初始化一个 <code>XMLHttpRequest</code> 实例对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 与服务器建立连接</h3>\n<p>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务器建立连接</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>参数说明：</p>\n<ul>\n<li>\n<p><code>method</code>：表示当前的请求方式，常见的有<code>GET</code>、<code>POST</code></p>\n</li>\n<li>\n<p><code>url</code>：服务端地址</p>\n</li>\n<li>\n<p><code>async</code>：布尔值，表示是否异步执行操作，默认为<code>true</code></p>\n</li>\n<li>\n<p><code>user</code>: 可选的用户名用于认证用途；默认为`null</p>\n</li>\n<li>\n<p><code>password</code>: 可选的密码用于认证用途，默认为`null</p>\n</li>\n</ul>\n<h3> 给服务端发送数据</h3>\n<p>通过 <code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法，将客户端页面的数据发送给服务端</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>body</code>: 在 <code>XHR</code> 请求中要发送的数据体，如果不传递数据则为 <code>null</code></p>\n<p>如果使用<code>GET</code>请求发送数据的时候，需要注意如下：</p>\n<ul>\n<li>将请求数据添加到<code>open()</code>方法中的<code>url</code>地址中</li>\n<li>发送请求数据中的<code>send()</code>方法中参数设置为<code>null</code></li>\n</ul>\n<h3> 绑定 onreadystatechange 事件</h3>\n<p><code>onreadystatechange</code> 事件用于监听服务器端的通信状态，主要监听的属性为<code>XMLHttpRequest.readyState</code> ,</p>\n<p>关于<code>XMLHttpRequest.readyState</code>属性有五个状态，如下图显示</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9782fc90-7b31-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>只要 <code>readyState</code>属性值一变化，就会触发一次 <code>readystatechange</code> 事件</p>\n<p><code>XMLHttpRequest.responseText</code>属性用于接收服务器端的响应结果</p>\n<p>举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、封装</h2>\n<p>通过上面对<code>XMLHttpRequest</code>对象的了解，下面来封装一个简单的<code>ajax</code>请求</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用方式如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-19T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "数组的常用方法有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/array_api.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/array_api.html",
      "summary": "前端物语|面试物语-数组的常用方法有哪些？",
      "content_html": "<h1> 数组的常用方法有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5842e560-67b6-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、操作方法</h2>\n<p>数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生影响，哪些方法不会</p>\n<p>下面对数组常用的操作方法做一个归纳</p>\n<h3> 增</h3>\n<p>下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响</p>\n<ul>\n<li>push()</li>\n<li>unshift()</li>\n<li>splice()</li>\n<li>concat()</li>\n</ul>\n<h4> push()</h4>\n<p><code>push()</code>方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> unshift()</h4>\n<p>unshift()在数组开头添加任意多个值，然后返回新的数组长度</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> splice</h4>\n<p>传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> concat()</h4>\n<p>首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 删</h3>\n<p>下面三种都会影响原数组，最后一项不影响原数组：</p>\n<ul>\n<li>pop()</li>\n<li>shift()</li>\n<li>splice()</li>\n<li>slice()</li>\n</ul>\n<h4> pop()</h4>\n<p><code>pop()</code> 方法用于删除数组的最后一项，同时减少数组的<code>length</code> 值，返回被删除的项</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> shift()</h4>\n<p><code>shift()</code>方法用于删除数组的第一项，同时减少数组的<code>length</code> 值，返回被删除的项</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> splice()</h4>\n<p>传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> slice()</h3>\n<p>slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 改</h4>\n<p>即修改原来数组的内容，常用<code>splice</code></p>\n<h4> splice()</h4>\n<p>传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 查</h4>\n<p>即查找元素，返回元素坐标或者元素值</p>\n<ul>\n<li>indexOf()</li>\n<li>includes()</li>\n<li>find()</li>\n</ul>\n<h4> indexOf()</h4>\n<p>返回要查找的元素在数组中的位置，如果没找到则返回 -1</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> includes()</h4>\n<p>返回要查找的元素在数组中的位置，找到返回<code>true</code>，否则<code>false</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> find()</h4>\n<p>返回第一个匹配的元素</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、排序方法</h2>\n<p>数组有两个方法可以用来对元素重新排序：</p>\n<ul>\n<li>reverse()</li>\n<li>sort()</li>\n</ul>\n<h3> reverse()</h3>\n<p>顾名思义，将数组元素方向反转</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> sort()</h3>\n<p>sort()方法接受一个比较函数，用于判断哪个值应该排在前面</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、转换方法</h2>\n<p>常见的转换方法有：</p>\n<h3> join()</h3>\n<p>join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 四、迭代方法</h2>\n<p>常用来迭代数组的方法（都不改变原数组）有如下：</p>\n<ul>\n<li>some()</li>\n<li>every()</li>\n<li>forEach()</li>\n<li>filter()</li>\n<li>map()</li>\n</ul>\n<h3> some()</h3>\n<p>对数组每一项都运行传入的测试函数，如果至少有 1 个元素返回 true ，则这个方法返回 true</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> every()</h3>\n<p>对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> forEach()</h3>\n<p>对数组每一项都运行传入的函数，没有返回值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> filter()</h3>\n<p>对数组每一项都运行传入的函数，函数返回 <code>true</code> 的项会组成数组之后返回</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> map()</h3>\n<p>对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "bind、call、apply 区别？如何实现一个 bind?",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/bind_call_apply.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/bind_call_apply.html",
      "summary": "前端物语|面试物语-bind、call、apply 区别？如何实现一个 bind?",
      "content_html": "<h1> bind、call、apply 区别？如何实现一个 bind?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a900e460-7be4-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、作用</h2>\n<p><code>call</code>、<code>apply</code>、<code>bind</code>作用是改变函数执行时的上下文，简而言之就是改变函数运行时的<code>this</code>指向</p>\n<p>那么什么情况下需要改变<code>this</code>的指向呢？下面举个例子</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面可以看到，正常情况<code>say</code>方法输出<code>martin</code></p>\n<p>但是我们把<code>say</code>放在<code>setTimeout</code>方法中，在定时器中是作为回调函数来执行的，因此回到主栈执行时是在全局执行上下文的环境中执行的，这时候<code>this</code>指向<code>window</code>，所以输出<code>lucy</code></p>\n<p>我们实际需要的是<code>this</code>指向<code>obj</code>对象，这时候就需要该改变<code>this</code>指向了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 二、区别</h2>\n<p>下面再来看看<code>apply</code>、<code>call</code>、<code>bind</code>的使用</p>\n<h3> apply</h3>\n<p><code>apply</code>接受两个参数，第一个参数是<code>this</code>的指向，第二个参数是函数接受的参数，以数组的形式传入</p>\n<p>改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当第一个参数为<code>null</code>、<code>undefined</code>的时候，默认指向<code>window</code>(在浏览器中)</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> call</h3>\n<p><code>call</code>方法的第一个参数也是<code>this</code>的指向，后面传入的是一个参数列表</p>\n<p>跟<code>apply</code>一样，改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同样的，当第一个参数为<code>null</code>、<code>undefined</code>的时候，默认指向<code>window</code>(在浏览器中)</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> bind</h3>\n<p>bind 方法和 call 很相似，第一参数也是<code>this</code>的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)</p>\n<p>改变<code>this</code>指向后不会立即执行，而是返回一个永久改变<code>this</code>指向的函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 小结</h3>\n<p>从上面可以看到，<code>apply</code>、<code>call</code>、<code>bind</code>三者的区别在于：</p>\n<ul>\n<li>三者都可以改变函数的<code>this</code>对象指向</li>\n<li>三者第一个参数都是<code>this</code>要指向的对象，如果如果没有这个参数或参数为<code>undefined</code>或<code>null</code>，则默认指向全局<code>window</code></li>\n<li>三者都可以传参，但是<code>apply</code>是数组，而<code>call</code>是参数列表，且<code>apply</code>和<code>call</code>是一次性传入参数，而<code>bind</code>可以分为多次传入</li>\n<li><code>bind</code>是返回绑定 this 之后的函数，<code>apply</code>、<code>call</code> 则是立即执行</li>\n</ul>\n<h2> 三、实现</h2>\n<p>实现<code>bind</code>的步骤，我们可以分解成为三部分：</p>\n<ul>\n<li>修改<code>this</code>指向</li>\n<li>动态传递参数</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>兼容<code>new</code>关键字</li>\n</ul>\n<p>整体实现代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-18T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "Javascript 本地存储的方式有哪些？区别及应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/cache.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/cache.html",
      "summary": "前端物语|面试物语-Javascript 本地存储的方式有哪些？区别及应用场景？",
      "content_html": "<h1> Javascript 本地存储的方式有哪些？区别及应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/68dccf20-849f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、方式</h2>\n<p><code>javaScript</code>本地缓存的方法我们主要讲述以下四种：</p>\n<ul>\n<li>cookie</li>\n<li>sessionStorage</li>\n<li>localStorage</li>\n<li>indexedDB</li>\n</ul>\n<h3> cookie</h3>\n<p><code>Cookie</code>，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 <code>HTTP</code>无状态导致的问题</p>\n<p>作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 <code>cookie</code>有效期、安全性、使用范围的可选属性组成</p>\n<p>但是<code>cookie</code>在每次请求中都会被发送，如果不使用 <code>HTTPS</code>并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 <code>cookie</code>保持登录态的网站上，如果 <code>cookie</code>被窃取，他人很容易利用你的 <code>cookie</code>来假扮成你登录网站</p>\n<p>关于<code>cookie</code>常用的属性如下：</p>\n<ul>\n<li>Expires 用于设置 Cookie 的过期时间</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>Max-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比<code>Expires</code>高）</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li><code>Domain</code>指定了 <code>Cookie</code> 可以送达的主机名</li>\n<li><code>Path</code>指定了一个 <code>URL</code>路径，这个路径必须出现在要请求的资源的路径中才可以发送 <code>Cookie</code> 首部</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>标记为 <code>Secure</code>的 <code>Cookie</code>只应通过被<code>HTTPS</code>协议加密过的请求发送给服务端</li>\n</ul>\n<p>通过上述，我们可以看到<code>cookie</code>又开始的作用并不是为了缓存而设计出来，只是借用了<code>cookie</code>的特性实现缓存</p>\n<p>关于<code>cookie</code>的使用如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>关于<code>cookie</code>的修改，首先要确定<code>domain</code>和<code>path</code>属性都是相同的才可以，其中有一个不同得时候都会创建出一个新的<code>cookie</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最后<code>cookie</code>的删除，最常用的方法就是给<code>cookie</code>设置一个过期的事件，这样<code>cookie</code>过期后会被浏览器删除</p>\n<h3> localStorage</h3>\n<p><code>HTML5</code>新方法，IE8 及以上浏览器都兼容</p>\n<h3> 特点</h3>\n<ul>\n<li>生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</li>\n<li>存储的信息在同一域中是共享的</li>\n<li>当本页操作（新增、修改、删除）了<code>localStorage</code>的时候，本页面不会触发<code>storage</code>事件,但是别的页面会触发<code>storage</code>事件。</li>\n<li>大小：5M（跟浏览器厂商有关系）</li>\n<li><code>localStorage</code>本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li>\n<li>受同源策略的限制</li>\n</ul>\n<p>下面再看看关于<code>localStorage</code>的使用</p>\n<p>设置</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>获取</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>获取键名</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>删除</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>一次性清除所有存储</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>localStorage</code> 也不是完美的，它有两个缺点：</p>\n<ul>\n<li>无法像<code>Cookie</code>一样设置过期时间</li>\n<li>只能存入字符串，无法直接存对象</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> sessionStorage</h3>\n<p><code>sessionStorage</code>和 <code>localStorage</code>使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，<code>sessionStorage</code> 将会删除数据</p>\n<h3> 扩展的前端存储方式</h3>\n<p><code>indexedDB</code>是一种低级 API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该 API 使用索引来实现对该数据的高性能搜索</p>\n<p>虽然 <code>Web Storage</code>对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。<code>IndexedDB</code>提供了一个解决方案</p>\n<h4> 优点</h4>\n<ul>\n<li>储存量理论上没有上限</li>\n<li>所有操作都是异步的，相比 <code>LocalStorage</code> 同步操作性能更高，尤其是数据量较大时</li>\n<li>原生支持储存<code>JS</code>的对象</li>\n<li>是个正经的数据库，意味着数据库能干的事它都能干</li>\n</ul>\n<h4> 缺点</h4>\n<ul>\n<li>操作非常繁琐</li>\n<li>本身有一定门槛</li>\n</ul>\n<p>关于<code>indexedDB</code>的使用基本使用步骤如下：</p>\n<ul>\n<li>\n<p>打开数据库并且开始一个事务</p>\n</li>\n<li>\n<p>创建一个 <code>object store</code></p>\n</li>\n<li>\n<p>构建一个请求来执行一些数据库操作，像增加或提取数据等。</p>\n</li>\n<li>\n<p>通过监听正确类型的 <code>DOM</code> 事件以等待操作完成。</p>\n</li>\n<li>\n<p>在操作结果上进行一些操作（可以在 <code>request</code>对象中找到）</p>\n</li>\n</ul>\n<p>关于使用<code>indexdb</code>的使用会比较繁琐，大家可以通过使用<code>Godb.js</code>库进行缓存，最大化的降低操作难度</p>\n<h2> 二、区别</h2>\n<p>关于<code>cookie</code>、<code>sessionStorage</code>、<code>localStorage</code>三者的区别主要如下：</p>\n<ul>\n<li>\n<p>存储大小：<code>cookie</code>数据大小不能超过<code>4k</code>，<code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到 5M 或更大</p>\n</li>\n<li>\n<p>有效时间：<code>localStorage</code>存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； <code>sessionStorage</code>数据在当前浏览器窗口关闭后自动删除；<code>cookie</code>设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</p>\n</li>\n<li>\n<p>数据与服务器之间的交互方式，<code>cookie</code>的数据会自动的传递到服务器，服务器端也可以写<code>cookie</code>到客户端； <code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</p>\n</li>\n</ul>\n<h2> 三、应用场景</h2>\n<p>在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择：</p>\n<ul>\n<li>标记用户与跟踪用户行为的情况，推荐使用<code>cookie</code></li>\n<li>适合长期保存在本地的数据（令牌），推荐使用<code>localStorage</code></li>\n<li>敏感账号一次性登录，推荐使用<code>sessionStorage</code></li>\n<li>存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用<code>indexedDB</code></li>\n</ul>\n<h2> 相关连接</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/mROjtpoXarN--UDfEMqwhQ\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/mROjtpoXarN--UDfEMqwhQ</a></li>\n<li><a href=\"https://github.com/chenstarx/GoDB.js\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/chenstarx/GoDB.js</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-14T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说你对闭包的理解？闭包使用场景",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/closure.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/closure.html",
      "summary": "前端物语|面试物语-说说你对闭包的理解？闭包使用场景",
      "content_html": "<h1> 说说你对闭包的理解？闭包使用场景</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c141a030-6a7a-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</p>\n<p>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域</p>\n<p>在 <code>JavaScript</code>中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁</p>\n<p>下面给出一个简单的例子</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>displayName()</code> 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量</p>\n<h2> 二、使用场景</h2>\n<p>任何闭包的使用场景都离不开这两点：</p>\n<ul>\n<li>创建私有变量</li>\n<li>延长变量的生命周期</li>\n</ul>\n<blockquote>\n<p>一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的</p>\n</blockquote>\n<p>下面举个例子：</p>\n<p>在页面上添加一些可以调整字号的按钮</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 柯里化函数</h3>\n<p>柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 使用闭包模拟私有方法</h3>\n<p>在<code>JavaScript</code>中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法</p>\n<p>下面举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式</p>\n<p>两个计数器 <code>Counter1</code> 和 <code>Counter2</code> 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量</p>\n<h3> 其他</h3>\n<p>例如计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期</p>\n<h2> 三、注意事项</h2>\n<p>如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响</p>\n<p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。</p>\n<p>原因在于每个对象的创建，方法都会被重新赋值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-04T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "JavaScript 中执行上下文和执行栈是什么？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/context_stack.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/context_stack.html",
      "summary": "前端物语|面试物语-JavaScript 中执行上下文和执行栈是什么？",
      "content_html": "<h1> JavaScript 中执行上下文和执行栈是什么？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8652b710-74c1-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、执行上下文</h2>\n<p>简单的来说，执行上下文是一种对<code>Javascript</code>代码执行环境的抽象概念，也就是说只要有<code>Javascript</code>代码运行，那么它就一定是运行在执行上下文中</p>\n<p>执行上下文的类型分为三种：</p>\n<ul>\n<li>全局执行上下文：只有一个，浏览器中的全局对象就是 <code>window</code>对象，<code>this</code> 指向这个全局对象</li>\n<li>函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文</li>\n<li>Eval 函数执行上下文： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用</li>\n</ul>\n<p>下面给出全局上下文和函数上下文的例子：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/90dd3b60-74c1-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>紫色框住的部分为全局上下文，蓝色和橘色框起来的是不同的函数上下文。只有全局上下文（的变量）能被其他任何上下文访问</p>\n<p>可以有任意多个函数上下文，每次调用函数创建一个新的上下文，会创建一个私有作用域，函数内部声明的任何变量都不能在当前函数作用域外部直接访问</p>\n<h2> 二、生命周期</h2>\n<p>执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段</p>\n<h3> 创建阶段</h3>\n<p>创建阶段即当函数被调用，但未执行任何其内部代码之前</p>\n<p>创建阶段做了三件事：</p>\n<ul>\n<li>确定 this 的值，也被称为 <code>This Binding</code></li>\n<li>LexicalEnvironment（词法环境） 组件被创建</li>\n<li>VariableEnvironment（变量环境） 组件被创建</li>\n</ul>\n<p>伪代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> This Binding</h4>\n<p>确定<code>this</code>的值我们前面讲到，<code>this</code>的值是在执行的时候才能确认，定义的时候不能确认</p>\n<h4> 词法环境</h4>\n<p>词法环境有两个组成部分：</p>\n<ul>\n<li>\n<p>全局环境：是一个没有外部环境的词法环境，其外部环境引用为<code>null</code>，有一个全局对象，<code>this</code> 的值指向这个全局对象</p>\n</li>\n<li>\n<p>函数环境：用户在函数中定义的变量被存储在环境记录中，包含了<code>arguments</code> 对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境</p>\n</li>\n</ul>\n<p>伪代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 变量环境</h4>\n<p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性</p>\n<p>在 ES6 中，词法环境和变量环境的区别在于前者用于存储函数声明和变量（ <code>let</code> 和 <code>const</code> ）绑定，而后者仅用于存储变量（ <code>var</code> ）绑定</p>\n<p>举个例子</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>执行上下文如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>留意上面的代码，<code>let</code>和<code>const</code>定义的变量<code>a</code>和<code>b</code>在创建阶段没有被赋值，但<code>var</code>声明的变量从在创建阶段被赋值为<code>undefined</code></p>\n<p>这是因为，创建阶段，会在代码中扫描变量和函数声明，然后将函数声明存储在环境中</p>\n<p>但变量会被初始化为<code>undefined</code>(<code>var</code>声明的情况下)和保持<code>uninitialized</code>(未初始化状态)(使用<code>let</code>和<code>const</code>声明的情况下)</p>\n<p>这就是变量提升的实际原因</p>\n<h3> 执行阶段</h3>\n<p>在这阶段，执行变量赋值、代码执行</p>\n<p>如果 <code>Javascript</code> 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 <code>undefined</code> 值</p>\n<h3> 回收阶段</h3>\n<p>执行上下文出栈等待虚拟机回收执行上下文</p>\n<h2> 二、执行栈</h2>\n<p>执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9eda0310-74c1-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>当<code>Javascript</code>引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中</p>\n<p>每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中</p>\n<p>引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文</p>\n<p>举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>转化成图的形式</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ac11a600-74c1-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>简单分析一下流程：</p>\n<ul>\n<li>创建全局上下文请压入执行栈</li>\n<li><code>first</code>函数被调用，创建函数执行上下文并压入栈</li>\n<li>执行<code>first</code>函数过程遇到<code>second</code>函数，再创建一个函数执行上下文并压入栈</li>\n<li><code>second</code>函数执行完毕，对应的函数执行上下文被推出执行栈，执行下一个执行上下文<code>first</code>函数</li>\n<li><code>first</code>函数执行完毕，对应的函数执行上下文也被推出栈中，然后执行全局上下文</li>\n<li>所有代码执行完毕，全局上下文也会被推出栈中，程序结束</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/107552264\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/107552264</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-05T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "大文件上传如何做断点续传？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/continue_to_upload.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/continue_to_upload.html",
      "summary": "前端物语|面试物语-大文件上传如何做断点续传？",
      "content_html": "<h1> 大文件上传如何做断点续传？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3ccb0e90-8ba4-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>不管怎样简单的需求，在量级达到一定层次时，都会变得异常复杂</p>\n<p>文件上传简单，文件变大就复杂</p>\n<p>上传大文件时，以下几个变量会影响我们的用户体验</p>\n<ul>\n<li>服务器处理数据的能力</li>\n<li>请求超时</li>\n<li>网络波动</li>\n</ul>\n<p>上传时间会变长，高频次文件上传失败，失败后又需要重新上传等等</p>\n<p>为了解决上述问题，我们需要对大文件上传单独处理</p>\n<p>这里涉及到分片上传及断点续传两个概念</p>\n<h4> 分片上传</h4>\n<p>分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传</p>\n<p>如下图</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/21db7520-8ba4-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件</p>\n<p>大致流程如下：</p>\n<ol>\n<li>将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；</li>\n<li>初始化一个分片上传任务，返回本次分片上传唯一标识；</li>\n<li>按照一定的策略（串行或并行）发送各个分片数据块；</li>\n<li>发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件</li>\n</ol>\n<h4> 断点续传</h4>\n<p>断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分</p>\n<p>每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度</p>\n<p>一般实现方式有两种：</p>\n<ul>\n<li>服务器端返回，告知从哪开始</li>\n<li>浏览器端自行处理</li>\n</ul>\n<p>上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可</p>\n<p>如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可</p>\n<h2> 二、实现思路</h2>\n<p>整体思路比较简单，拿到文件，保存文件唯一性标识，切割文件，分段上传，每次上传一段，根据唯一性标识判断文件上传进度，直到文件的全部片段上传完毕</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/465d2920-8ba4-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>下面的内容都是伪代码</p>\n<p>读取文件内容：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以使用<code>md5</code>实现文件的唯一性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>然后开始对文件进行分割</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>h5 上传一个（一片）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里给出常见的图片和视频的文件类型判断</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>调用方法如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面上传文件的一步，可以改成：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>有了切割上传后，也就有了文件唯一标识信息，断点续传变成了后台的一个小小的逻辑判断</p>\n<p>后端主要做的内容为：根据前端传给后台的<code>md5</code>值，到服务器磁盘查找是否有之前未完成的文件合并信息（也就是未完成的半成品文件切片），取到之后根据上传切片的数量，返回数据告诉前端开始从第几节上传</p>\n<p>如果想要暂停切片的上传，可以使用<code>XMLHttpRequest</code>的 <code>abort</code>方法</p>\n<h2> 三、使用场景</h2>\n<ul>\n<li>大文件加速上传：当文件大小超过预期大小时，使用分片上传可实现并行上传多个 Part， 以加快上传速度</li>\n<li>网络环境较差：建议使用分片上传。当出现上传失败的时候，仅需重传失败的 Part</li>\n<li>流式上传：可以在需要上传的文件大小还不确定的情况下开始上传。这种场景在视频监控等行业应用中比较常见</li>\n</ul>\n<h2> 小结</h2>\n<p>当前的伪代码，只是提供一个简单的思路，想要把事情做到极致，我们还需要考虑到更多场景，比如</p>\n<ul>\n<li>切片上传失败怎么办</li>\n<li>上传过程中刷新页面怎么办</li>\n<li>如何进行并行上传</li>\n<li>切片什么时候按数量切，什么时候按大小切</li>\n<li>如何结合 Web Worker 处理大文件上传</li>\n<li>如何实现秒传</li>\n</ul>\n<p>人生又何尝不是如此，极致的人生体验有无限可能，越是后面才发现越是精彩 <sub>_</sub></p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000009448892\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000009448892</a></li>\n<li><a href=\"https://baike.baidu.com/\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-11T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "深拷贝浅拷贝的区别？如何实现一个深拷贝？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/copy.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/copy.html",
      "summary": "前端物语|面试物语-深拷贝浅拷贝的区别？如何实现一个深拷贝？",
      "content_html": "<h1> 深拷贝浅拷贝的区别？如何实现一个深拷贝？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/cdf952e0-69b8-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、数据类型存储</h2>\n<p>前面文章我们讲到，<code>JavaScript</code>中存在两大数据类型：</p>\n<ul>\n<li>基本类型</li>\n<li>引用类型</li>\n</ul>\n<p>基本类型数据保存在在栈内存中</p>\n<p>引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中</p>\n<h2> 二、浅拷贝</h2>\n<p>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p>\n<p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址</p>\n<p>即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址</p>\n<p>下面简单实现一个浅拷贝</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在<code>JavaScript</code>中，存在浅拷贝的现象有：</p>\n<ul>\n<li><code>Object.assign</code></li>\n<li><code>Array.prototype.slice()</code>, <code>Array.prototype.concat()</code></li>\n<li>使用拓展运算符实现的复制</li>\n</ul>\n<h3> Object.assign</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> slice()</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> concat()</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 拓展运算符</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、深拷贝</h2>\n<p>深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p>\n<p>常见的深拷贝方式有：</p>\n<ul>\n<li>\n<p>_.cloneDeep()</p>\n</li>\n<li>\n<p>jQuery.extend()</p>\n</li>\n<li>\n<p>JSON.stringify()</p>\n</li>\n<li>\n<p>手写循环递归</p>\n</li>\n</ul>\n<h3> _.cloneDeep()</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> jQuery.extend()</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> JSON.stringify()</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>但是这种方式存在弊端，会忽略<code>undefined</code>、<code>symbol</code>和<code>函数</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 循环递归</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 四、区别</h2>\n<p>下面首先借助两张图，可以更加清晰看到浅拷贝与深拷贝的区别</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d9862c00-69b8-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从上图发现，浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样</p>\n<p>浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 小结</h3>\n<p>前提为拷贝类型为引用类型的情况下：</p>\n<ul>\n<li>\n<p>浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址</p>\n</li>\n<li>\n<p>深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址</p>\n</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-26T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说 JavaScript 中的数据类型？存储上的差别？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/data_type.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/data_type.html",
      "summary": "前端物语|面试物语-说说 JavaScript 中的数据类型？存储上的差别？",
      "content_html": "<h1> 说说 JavaScript 中的数据类型？存储上的差别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6d133f90-6463-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 前言</h2>\n<p>在<code>JavaScript</code>中，我们可以分成两种类型：</p>\n<ul>\n<li>基本类型</li>\n<li>复杂类型</li>\n</ul>\n<p>两种类型的区别是：存储位置不同</p>\n<h2> 一、基本类型</h2>\n<p>基本类型主要为以下 6 种：</p>\n<ul>\n<li>Number</li>\n<li>String</li>\n<li>Boolean</li>\n<li>Undefined</li>\n<li>null</li>\n<li>symbol</li>\n</ul>\n<h3> Number</h3>\n<p>数值最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x 开头）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>浮点类型则在数值汇总必须包含小数点，还可通过科学计数法表示</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在数值类型中，存在一个特殊数值<code>NaN</code>，意为“不是数值”，用于表示本来要返回数值的操作失败了（而不是抛出错误）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Undefined</h3>\n<p><code>Undefined</code> 类型只有一个值，就是特殊值 <code>undefined</code>。当使用 <code>var</code>或 <code>let</code>声明了变量但没有初始化时，就相当于给变量赋予了 <code>undefined</code>值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>包含<code>undefined</code> 值的变量跟未定义变量是有区别的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> String</h3>\n<p>字符串可以使用双引号（\"）、单引号（'）或反引号（`）标示</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>字符串是不可变的，意思是一旦创建，它们的值就不能变了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Null</h3>\n<p><code>Null</code>类型同样只有一个值，即特殊值 <code>null</code></p>\n<p>逻辑上讲， null 值表示一个空对象指针，这也是给<code>typeof</code>传一个 <code>null</code> 会返回 <code>\"object\"</code> 的原因</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>undefined</code> 值是由 <code>null</code>值派生而来</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>只要变量要保存对象，而当时又没有那个对象可保存，就可用 <code>null</code>来填充该变量</p>\n<h3> Boolean</h3>\n<p><code>Boolean</code>（布尔值）类型有两个字面值： <code>true</code> 和<code>false</code></p>\n<p>通过<code>Boolean</code>可以将其他类型的数据转化成布尔值</p>\n<p>规则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Symbol</h3>\n<p>Symbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、引用类型</h2>\n<p>复杂类型统称为<code>Object</code>，我们这里主要讲述下面三种：</p>\n<ul>\n<li>Object</li>\n<li>Array</li>\n<li>Function</li>\n</ul>\n<h3> Object</h3>\n<p>创建<code>object</code>常用方式为对象字面量表示法，属性名可以是字符串或数值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Array</h3>\n<p><code>JavaScript</code>数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。并且，数组也是动态大小的，会随着数据添加而自动增长</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Function</h3>\n<p>函数实际上是对象，每个函数都是 <code>Function</code>类型的实例，而 <code>Function</code>也有属性和方法，跟其他引用类型一样</p>\n<p>函数存在三种常见的表达方式：</p>\n<ul>\n<li>函数声明</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>函数表达式</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>箭头函数</li>\n</ul>\n<p>函数声明和函数表达式两种方式</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 其他引用类型</h3>\n<p>除了上述说的三种之外，还包括<code>Date</code>、<code>RegExp</code>、<code>Map</code>、<code>Set</code>等......</p>\n<h2> 三、存储区别</h2>\n<p>基本数据类型和引用数据类型存储在内存中的位置不同：</p>\n<ul>\n<li>\n<p>基本数据类型存储在栈中</p>\n</li>\n<li>\n<p>引用类型的对象存储于堆中</p>\n</li>\n</ul>\n<p>当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值</p>\n<p>下面来举个例子</p>\n<h3> 基本类型</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>a</code>的值为一个基本类型，是存储在栈中，将<code>a</code>的值赋给<code>b</code>，虽然两个变量的值相等，但是两个变量保存了两个不同的内存地址</p>\n<p>下图演示了基本类型赋值的过程：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/906ffb90-6463-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 引用类型</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>引用类型数据存放在堆中，每个堆内存对象都有对应的引用地址指向它，引用地址存放在栈中。</p>\n<p><code>obj1</code>是一个引用类型，在赋值操作过程汇总，实际是将堆内存对象在栈内存的引用地址复制了一份给了<code>obj2</code>，实际上他们共同指向了同一个堆内存对象，所以更改<code>obj2</code>会对<code>obj1</code>产生影响</p>\n<p>下图演示这个引用类型赋值过程</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a34bdd10-6463-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 小结</h3>\n<ul>\n<li>声明变量时不同的内存地址分配：\n<ul>\n<li>简单类型的值存放在栈中，在栈中存放的是对应的值</li>\n<li>引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址</li>\n</ul>\n</li>\n<li>不同的类型数据导致赋值变量时的不同：\n<ul>\n<li>简单类型赋值，是生成相同的值，两个对象对应不同的地址</li>\n<li>复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象</li>\n</ul>\n</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-19T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说 JavaScript 中的事件模型",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/event_Model.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/event_Model.html",
      "summary": "前端物语|面试物语-说说 JavaScript 中的事件模型",
      "content_html": "<h1> 说说 JavaScript 中的事件模型</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/32a182f0-74cf-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、事件与事件流</h2>\n<p><code>javascript</code>中的事件，可以理解就是在<code>HTML</code>文档或者浏览器中发生的一种交互操作，使得网页具备互动性， 常见的有加载事件、鼠标事件、自定义事件等</p>\n<p>由于<code>DOM</code>是一个树结构，如果在父子节点绑定事件时候，当触发子节点的时候，就存在一个顺序问题，这就涉及到了事件流的概念</p>\n<p>事件流都会经历三个阶段：</p>\n<ul>\n<li>事件捕获阶段(capture phase)</li>\n<li>处于目标阶段(target phase)</li>\n<li>事件冒泡阶段(bubbling phase)</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3e9a6450-74cf-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>事件冒泡是一种从下往上的传播方式，由最具体的元素（触发节点）然后逐渐向上传播到最不具体的那个节点，也就是<code>DOM</code>中最高层的父节点</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后，我们给<code>button</code>和它的父元素，加入点击事件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>点击按钮，输出如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>点击事件首先在<code>button</code>元素上发生，然后逐级向上传播</p>\n<p>事件捕获与事件冒泡相反，事件最开始由不太具体的节点最早接受事件, 而最具体的节点（触发节点）最后接受事件</p>\n<h2> 二、事件模型</h2>\n<p>事件模型可以分为三种：</p>\n<ul>\n<li>原始事件模型（DOM0 级）</li>\n<li>标准事件模型（DOM2 级）</li>\n<li>IE 事件模型（基本不用）</li>\n</ul>\n<h3> 原始事件模型</h3>\n<p>事件绑定监听函数比较简单, 有两种方式：</p>\n<ul>\n<li>HTML 代码中直接绑定</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>通过<code>JS</code>代码绑定</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 特性</h4>\n<ul>\n<li>绑定速度快</li>\n</ul>\n<p><code>DOM0</code>级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行</p>\n<ul>\n<li>\n<p>只支持冒泡，不支持捕获</p>\n</li>\n<li>\n<p>同一个类型的事件只能绑定一次</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如上，当希望为同一个元素绑定多个同类型事件的时候（上面的这个<code>btn</code>元素绑定 2 个点击事件），是不被允许的，后绑定的事件会覆盖之前的事件</p>\n<p>删除 <code>DOM0</code> 级事件处理程序只要将对应事件属性置为<code>null</code>即可</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 标准事件模型</h3>\n<p>在该事件模型中，一次事件共有三个过程:</p>\n<ul>\n<li>事件捕获阶段：事件从<code>document</code>一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>\n<li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数</li>\n<li>事件冒泡阶段：事件从目标元素冒泡到<code>document</code>, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>\n</ul>\n<p>事件绑定监听函数的方式如下:</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>事件移除监听函数的方式如下:</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>参数如下：</p>\n<ul>\n<li><code>eventType</code>指定事件类型(不要加 on)</li>\n<li><code>handler</code>是事件处理函数</li>\n<li><code>useCapture</code>是一个<code>boolean</code>用于指定是否在捕获阶段进行处理，一般设置为<code>false</code>与 IE 浏览器保持一致</li>\n</ul>\n<p>举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 特性</h4>\n<ul>\n<li>可以在一个<code>DOM</code>元素上绑定多个事件处理器，各自并不会冲突</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>执行时机</li>\n</ul>\n<p>当第三个参数(<code>useCapture</code>)设置为<code>true</code>就在捕获过程中执行，反之在冒泡过程中执行处理函数</p>\n<p>下面举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>设置点击事件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述使用了<code>eventPhase</code>，返回一个代表当前执行阶段的整数值。1 为捕获阶段、2 为事件对象触发阶段、3 为冒泡阶段</p>\n<p>点击<code>Click Me!</code>，输出如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，<code>p</code>和<code>div</code>都是在冒泡阶段响应了事件，由于冒泡的特性，裹在里层的<code>p</code>率先做出响应</p>\n<p>如果把第三个参数都改为<code>true</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>两者都是在捕获阶段响应事件，所以<code>div</code>比<code>p</code>标签先做出响应</p>\n<h3> IE 事件模型</h3>\n<p>IE 事件模型共有两个过程:</p>\n<ul>\n<li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。</li>\n<li>事件冒泡阶段：事件从目标元素冒泡到<code>document</code>, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>\n</ul>\n<p>事件绑定监听函数的方式如下:</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>事件移除监听函数的方式如下:</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-19T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "解释下什么是事件代理？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/event_agent.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/event_agent.html",
      "summary": "前端物语|面试物语-解释下什么是事件代理？应用场景？",
      "content_html": "<h1> 解释下什么是事件代理？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a33f0ab0-797e-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>事件代理，俗地来讲，就是把一个元素响应事件（<code>click</code>、<code>keydown</code>......）的函数委托到另一个元素</p>\n<p>前面讲到，事件流的都会经过三个阶段： 捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段，而事件委托就是在冒泡阶段完成</p>\n<p>事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素</p>\n<p>当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数</p>\n<p>下面举个例子：</p>\n<p>比如一个宿舍的同学同时快递到了，一种笨方法就是他们一个个去领取</p>\n<p>较优方法就是把这件事情委托给宿舍长，让一个人出去拿好所有快递，然后再根据收件人一一分发给每个同学</p>\n<p>在这里，取快递就是一个事件，每个同学指的是需要响应事件的 <code>DOM</code>元素，而出去统一领取快递的宿舍长就是代理的元素</p>\n<p>所以真正绑定事件的是这个元素，按照收件人分发快递的过程就是在事件执行中，需要判断当前响应的事件应该匹配到被代理元素中的哪一个或者哪几个</p>\n<h2> 二、应用场景</h2>\n<p>如果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这时候就可以事件委托，把点击事件绑定在父级元素<code>ul</code>上面，然后执行事件的时候再去匹配目标元素</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>还有一种场景是上述列表项并不多，我们给每个列表项都绑定了事件</p>\n<p>但是如果用户能够随时动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件</p>\n<p>如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的</p>\n<p>举个例子：</p>\n<p>下面<code>html</code>结构中，点击<code>input</code>可以动态添加元素</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用事件委托</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，使用事件委托，在动态绑定事件的情况下是可以减少很多重复工作的</p>\n<h2> 三、总结</h2>\n<p>适合事件委托的事件有：<code>click</code>，<code>mousedown</code>，<code>mouseup</code>，<code>keydown</code>，<code>keyup</code>，<code>keypress</code></p>\n<p>从上面应用场景中，我们就可以看到使用事件委托存在两大优点：</p>\n<ul>\n<li>减少整个页面所需的内存，提升整体性能</li>\n<li>动态绑定，减少重复工作</li>\n</ul>\n<p>但是使用事件委托也是存在局限性：</p>\n<ul>\n<li>\n<p><code>focus</code>、<code>blur</code>这些事件没有事件冒泡机制，所以无法进行委托绑定事件</p>\n</li>\n<li>\n<p><code>mousemove</code>、<code>mouseout</code>这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的</p>\n</li>\n</ul>\n<p>如果把所有事件都用事件代理，可能会出现事件误判，即本不该被触发的事件被绑定上了事件</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说你对事件循环的理解",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/event_loop.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/event_loop.html",
      "summary": "前端物语|面试物语-说说你对事件循环的理解",
      "content_html": "<h1> 说说你对事件循环的理解</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/50f062d0-7cb8-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>首先，<code>JavaScript</code>是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环</p>\n<p>在<code>JavaScript</code>中，所有的任务都可以分为</p>\n<ul>\n<li>\n<p>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</p>\n</li>\n<li>\n<p>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等</p>\n</li>\n</ul>\n<p>同步任务与异步任务的运行流程图如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/61efbc20-7cb8-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就事件循环</p>\n<h2> 二、宏任务与微任务</h2>\n<p>如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果按照上面流程图来分析代码，我们会得到下面的执行步骤：</p>\n<ul>\n<li><code>console.log(1)</code>，同步任务，主线程中执行</li>\n<li><code>setTimeout()</code> ，异步任务，放到 <code>Event Table</code>，0 毫秒后<code>console.log(2)</code>回调推入 <code>Event Queue</code> 中</li>\n<li><code>new Promise</code> ，同步任务，主线程直接执行</li>\n<li><code>.then</code> ，异步任务，放到 <code>Event Table</code></li>\n<li><code>console.log(3)</code>，同步任务，主线程执行</li>\n</ul>\n<p>所以按照分析，它的结果应该是 <code>1</code> =&gt; <code>'new Promise'</code> =&gt; <code>3</code> =&gt; <code>2</code> =&gt; <code>'then'</code></p>\n<p>但是实际结果是：<code>1</code>=&gt;<code>'new Promise'</code>=&gt; <code>3</code> =&gt; <code>'then'</code> =&gt; <code>2</code></p>\n<p>出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取</p>\n<p>例子中 <code>setTimeout</code>回调事件是先进入队列中的，按理说应该先于 <code>.then</code> 中的执行，但是结果却偏偏相反</p>\n<p>原因在于异步任务还可以细分为微任务与宏任务</p>\n<h3> 微任务</h3>\n<p>一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前</p>\n<p>常见的微任务有：</p>\n<ul>\n<li>\n<p>Promise.then</p>\n</li>\n<li>\n<p>MutaionObserver</p>\n</li>\n<li>\n<p>Object.observe（已废弃；Proxy 对象替代）</p>\n</li>\n<li>\n<p>process.nextTick（Node.js）</p>\n</li>\n</ul>\n<h3> 宏任务</h3>\n<p>宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合</p>\n<p>常见的宏任务有：</p>\n<ul>\n<li>script (可以理解为外层同步代码)</li>\n<li>setTimeout/setInterval</li>\n<li>UI rendering/UI 事件</li>\n<li>postMessage、MessageChannel</li>\n<li>setImmediate、I/O（Node.js）</li>\n</ul>\n<p>这时候，事件循环，宏任务，微任务的关系如图所示</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6e80e5e0-7cb8-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>按照这个流程，它的执行机制是：</p>\n<ul>\n<li>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中</li>\n<li>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完</li>\n</ul>\n<p>回到上面的题目</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>流程如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、async 与 await</h2>\n<p><code>async</code> 是异步的意思，<code>await</code>则可以理解为 <code>async wait</code>。所以可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await</code>是用来等待异步方法执行</p>\n<h3> async</h3>\n<p><code>async</code>函数返回一个<code>promise</code>对象，下面两种方法是等效的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> await</h3>\n<p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code>对象，返回该对象的结果。如果不是 <code>Promise</code>对象，就直接返回对应的值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的例子中，<code>await</code> 会阻塞下面的代码（即加入微任务队列），先执行 <code>async</code>外面的同步代码，同步代码执行完，再回到 <code>async</code> 函数中，再执行之前阻塞的代码</p>\n<p>所以上述输出结果为：<code>1</code>，<code>fn2</code>，<code>3</code>，<code>2</code></p>\n<h2> 四、流程分析</h2>\n<p>通过对上面的了解，我们对<code>JavaScript</code>对各种场景的执行顺序有了大致的了解</p>\n<p>这里直接上代码：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>分析过程：</p>\n<ol>\n<li>执行整段代码，遇到 <code>console.log('script start')</code> 直接打印结果，输出 <code>script start</code></li>\n<li>遇到定时器了，它是宏任务，先放着不执行</li>\n<li>遇到 <code>async1()</code>，执行 <code>async1</code> 函数，先打印 <code>async1 start</code>，下面遇到<code>await</code>怎么办？先执行 <code>async2</code>，打印 <code>async2</code>，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码</li>\n<li>跳到 <code>new Promise</code> 这里，直接执行，打印 <code>promise1</code>，下面遇到 <code>.then()</code>，它是微任务，放到微任务列表等待执行</li>\n<li>最后一行直接打印 <code>script end</code>，现在同步代码执行完了，开始执行微任务，即 <code>await</code>下面的代码，打印 <code>async1 end</code></li>\n<li>继续执行下一个微任务，即执行 <code>then</code> 的回调，打印 <code>promise2</code></li>\n<li>上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 <code>settimeout</code></li>\n</ol>\n<p>所以最后的结果是：<code>script start</code>、<code>async1 start</code>、<code>async2</code>、<code>promise1</code>、<code>script end</code>、<code>async1 end</code>、<code>promise2</code>、<code>settimeout</code></p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-25T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/function_cache.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/function_cache.html",
      "summary": "前端物语|面试物语-Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？",
      "content_html": "<h1> Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2ae9dda0-85fa-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>函数缓存，就是将函数运算过的结果进行缓存</p>\n<p>本质上就是用空间（缓存存储）换时间（计算过程）</p>\n<p>常用于缓存数据计算结果和缓存对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>缓存只是一个临时的数据存储，它保存数据，以便将来对该数据的请求能够更快地得到处理</p>\n<h2> 二、如何实现</h2>\n<p>实现函数缓存主要依靠闭包、柯里化、高阶函数，这里再简单复习下：</p>\n<h3> 闭包</h3>\n<p>闭包可以理解成，函数 + 函数体内可访问的变量总和</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>add</code>函数本身，以及其内部可访问的变量，即 <code>a = 1</code>，这两个组合在⼀起就形成了闭包</p>\n<h3> 柯里化</h3>\n<p>把接受多个参数的函数转换成接受一个单一参数的函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>将一个二元函数拆分成两个一元函数</p>\n<h3> 高阶函数</h3>\n<p>通过接收其他函数作为参数或返回其他函数的函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>函数 <code>foo</code> 如何返回另一个函数 <code>bar</code>，<code>baz</code> 现在持有对 <code>foo</code> 中定义的<code>bar</code> 函数的引用。由于闭包特性，<code>a</code>的值能够得到</p>\n<p>下面再看看如何实现函数缓存，实现原理也很简单，把参数和对应的结果数据存在一个对象中，调用时判断参数对应的数据是否存在，存在就返回对应的结果数据，否则就返回计算结果</p>\n<p>如下所示</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>调用方式也很简单</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>过程分析：</p>\n<ul>\n<li>在当前函数作用域定义了一个空对象，用于缓存运行结果</li>\n<li>运用柯里化返回一个函数，返回的函数由于闭包特性，可以访问到<code>cache</code></li>\n<li>然后判断输入参数是不是在<code>cache</code>的中。如果已经存在，直接返回<code>cache</code>的内容，如果没有存在，使用函数<code>func</code>对输入参数求值，然后把结果存储在<code>cache</code>中</li>\n</ul>\n<h2> 三、应用场景</h2>\n<p>虽然使用缓存效率是非常高的，但并不是所有场景都适用，因此千万不要极端的将所有函数都添加缓存</p>\n<p>以下几种情况下，适合使用缓存：</p>\n<ul>\n<li>对于昂贵的函数调用，执行复杂计算的函数</li>\n<li>对于具有有限且高度重复输入范围的函数</li>\n<li>对于具有重复输入值的递归函数</li>\n<li>对于纯函数，即每次使用特定输入调用时返回相同输出的函数</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/112505577\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/112505577</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-19T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "Javascript 如何实现继承？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/inherit.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/inherit.html",
      "summary": "前端物语|面试物语-Javascript 如何实现继承？",
      "content_html": "<h1> Javascript 如何实现继承？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5d9c4450-72a3-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>继承（inheritance）是面向对象软件技术当中的一个概念。</p>\n<p>如果一个类别 B“继承自”另一个类别 A，就把这个 B 称为“A 的子类”，而把 A 称为“B 的父类别”也可以称“A 是 B 的超类”</p>\n<ul>\n<li>继承的优点</li>\n</ul>\n<p>继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码</p>\n<p>在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能</p>\n<p>虽然<code>JavaScript</code>并不是真正的面向对象语言，但它天生的灵活性，使应用场景更加丰富</p>\n<p>关于继承，我们举个形象的例子：</p>\n<p>定义一个类（Class）叫汽车，汽车的属性包括颜色、轮胎、品牌、速度、排气量等</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>由汽车这个类可以派生出“轿车”和“货车”两个类，在汽车的基础属性上，为轿车添加一个后备厢、给货车添加一个大货箱</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样轿车和货车就是不一样的，但是二者都属于汽车这个类，汽车、轿车继承了汽车的属性，而不需要再次在“轿车”中定义汽车已经有的属性</p>\n<p>在“轿车”继承“汽车”的同时，也可以重新定义汽车的某些属性，并重写或覆盖某些属性和方法，使其获得与“汽车”这个父类不同的属性和方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从这个例子中就能详细说明汽车、轿车以及卡车之间的继承关系</p>\n<h2> 二、实现方式</h2>\n<p>下面给出<code>JavaScripy</code>常见的继承方式：</p>\n<ul>\n<li>\n<p>原型链继承</p>\n</li>\n<li>\n<p>构造函数继承（借助 call）</p>\n</li>\n<li>\n<p>组合继承</p>\n</li>\n<li>\n<p>原型式继承</p>\n</li>\n<li>\n<p>寄生式继承</p>\n</li>\n<li>\n<p>寄生组合式继承</p>\n</li>\n</ul>\n<h3> 原型链继承</h3>\n<p>原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针</p>\n<p>举个例子</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码看似没问题，实际存在潜在问题</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>改变<code>s1</code>的<code>play</code>属性，会发现<code>s2</code>也跟着发生变化了，这是因为两个实例使用的是同一个原型对象，内存空间是共享的</p>\n<h3> 构造函数继承</h3>\n<p>借助 <code>call</code>调用<code>Parent</code>函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法</p>\n<p>相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法</p>\n<h3> 组合继承</h3>\n<p>前面我们讲到两种继承方式，各有优缺点。组合继承则将前两种方式继承起来</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种方式看起来就没什么问题，方式一和方式二的问题都解决了，但是从上面代码我们也可以看到<code>Parent3</code> 执行了两次，造成了多构造一次的性能开销</p>\n<h3> 原型式继承</h3>\n<p>这里主要借助<code>Object.create</code>方法实现普通对象的继承</p>\n<p>同样举个例子</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种继承方式的缺点也很明显，因为<code>Object.create</code>方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能</p>\n<h3> 寄生式继承</h3>\n<p>寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其优缺点也很明显，跟上面讲的原型式继承一样</p>\n<h3> 寄生组合式继承</h3>\n<p>寄生组合式继承，借助解决普通对象的继承问题的<code>Object.create</code> 方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题</p>\n<p>文章一开头，我们是使用<code>ES6</code> 中的<code>extends</code>关键字直接实现 <code>JavaScript</code>的继承</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>利用<code>babel</code>工具进行转换，我们会发现<code>extends</code>实际采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式</p>\n<h2> 三、总结</h2>\n<p>下面以一张图作为总结：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/0df74700-731c-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>通过<code>Object.create</code> 来划分不同的继承方式，最后的寄生式组合继承方式是通过组合继承改造之后的最优继承方式，而 <code>extends</code> 的语法糖和寄生组合继承的方式基本类似</p>\n<h2> 相关链接</h2>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/继承</a></p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-05-21T00:00:00.000Z",
      "date_modified": "2023-05-21T15:11:12.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说你了解的 js 数据结构？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/js_data_structure.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/js_data_structure.html",
      "summary": "前端物语|面试物语-说说你了解的 js 数据结构？",
      "content_html": "<h1> 说说你了解的 js 数据结构？</h1>\n<h2> 什么是数据结构？</h2>\n<p>数据结构是计算机存储、组织数据的方式。数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。</p>\n<p>我们每天的编码中都会用到数据结构数组是最简单的内存数据结构下面是常见的数据结构：</p>\n<ol>\n<li>数组（Array）</li>\n<li>栈（Stack）</li>\n<li>队列（Queue）</li>\n<li>链表（Linked List）</li>\n<li>字典</li>\n<li>散列表（Hash table）</li>\n<li>树（Tree）</li>\n<li>图（Graph）</li>\n<li>堆（Heap）</li>\n</ol>\n<h2> 数组（Array）</h2>\n<p>数组是最最基本的数据结构，很多语言都内置支持数组。数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的。</p>\n<p>在日常生活中，人们经常使用列表：待办事项列表、购物清单等。</p>\n<p>而计算机程序也在使用列表，在下面的条件下，选择列表作为数据结构就显得尤为有用：数据结构较为简单不需要在一个长序列中查找元素，或者对其进行排序反之，如果数据结构非常复杂，列表的作用就没有那么大了。</p>\n<h2> 栈（Stack）</h2>\n<p>栈是一种遵循后进先出（LIFO）原则的有序集合在栈里，新元素都接近栈顶，旧元素都接近栈底。每次加入新的元素和拿走元素都在顶部操作 <img src=\"https://upload-images.jianshu.io/upload_images/13253432-ddcb884374470d2c?imageMogr2/auto-orient/strip|imageView2/2/format/webp\" alt=\"\" loading=\"lazy\"></p>\n<h2> 队列（Queue）</h2>\n<p>队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项队列在尾部添加新元素，并从顶部移除元素最新添加的元素必须排在队列的末尾 <img src=\"https://upload-images.jianshu.io/upload_images/13253432-55ad7c7db40d3796?imageMogr2/auto-orient/strip|imageView2/2/format/webp\" alt=\"\" loading=\"lazy\"></p>\n<h2> 链表（Linked List）</h2>\n<p>链表也是一种列表，已经设计了数组，为什么还需要链表呢？ JavaScript 中数组的主要问题时，它们被实现成了对象，与其他语言（比如 C++和 Java）的数组相对，效率很低。如果你发现数组在实际使用时很慢，就可以考虑使用链表来代替它。</p>\n<p>使用条件：链表几乎可以用在任何可以使用一维数组的情况中。如果需要随机访问，数组仍然是更好的选择。 <img src=\"https://raw.githubusercontent.com/zoro-web/blog/master/img/lian.jpg\" alt=\"\" loading=\"lazy\"></p>\n<h2> 字典</h2>\n<p>字典是一种以键-值对存储数据的数据结构，js 中的 Object 类就是以字典的形式设计的。JavaScript 可以通过实现字典类，让这种字典类型的对象使用起来更加简单，字典可以实现对象拥有的常见功能，并相应拓展自己想要的功能，而对象在 JavaScript 编写中随处可见，所以字典的作用也异常明显了。</p>\n<h2> 散列表</h2>\n<p>也称为哈希表，特点是在散列表上插入、删除和取用数据都非常快。为什么要设计这种数据结构呢？用数组或链表存储数据，如果想要找到其中一个数据，需要从头进行遍历，因为不知道这个数据存储到了数组的哪个位置。</p>\n<p>散列表在 JavaScript 中可以基础数组去进行设计。数组的长度是预先设定的，所有元素根据和该元素对应的键，保存在数组的特定位置，这里的键和对象的键是类型的概念。使用散列表存储数组时，通过一个散列函数将键映射为一个数字，这个数字的范围是 0 到散列表的长度。</p>\n<p>即使使用一个高效的散列函数，依然存在将两个键映射为同一个值得可能，这种现象叫做碰撞。常见碰撞的处理方法有：开链法和线性探测法（具体概念有兴趣的可以网上自信了解）使用条件：可以用于数据的插入、删除和取用，不适用于查找数据 <img src=\"https://raw.githubusercontent.com/zoro-web/blog/master/img/微信图片_20170820211406.png\" alt=\"\" loading=\"lazy\"></p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-23T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说 Javascript 数字精度丢失的问题，如何解决？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/loss_accuracy.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/loss_accuracy.html",
      "summary": "前端物语|面试物语-说说 Javascript 数字精度丢失的问题，如何解决？",
      "content_html": "<h1> 说说 Javascript 数字精度丢失的问题，如何解决？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/09646a10-86f4-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、场景复现</h2>\n<p>一个经典的面试题</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>为什么是<code>false</code>呢?</p>\n<p>先看下面这个比喻</p>\n<p>比如一个数 1÷3=0.33333333......</p>\n<p>3 会一直无限循环，数学可以表示，但是计算机要存储，方便下次取出来再使用，但 0.333333...... 这个数无限循环，再大的内存它也存不下，所以不能存储一个相对于数学来说的值，只能存储一个近似值，当计算机存储后再取出时就会出现精度丢失问题</p>\n<h2> 二、浮点数</h2>\n<p>“浮点数”是一种表示数字的标准，整数也可以用浮点数的格式来存储</p>\n<p>我们也可以理解成，浮点数就是小数</p>\n<p>在<code>JavaScript</code>中，现在主流的数值类型是<code>Number</code>，而<code>Number</code>采用的是<code>IEEE754</code>规范中 64 位双精度浮点数编码</p>\n<p>这样的存储结构优点是可以归一化处理整数和小数，节省存储空间</p>\n<p>对于一个整数，可以很轻易转化成十进制或者二进制。但是对于一个浮点数来说，因为小数点的存在，小数点的位置不是固定的。解决思路就是使用科学计数法，这样小数点位置就固定了</p>\n<p>而计算机只能用二进制（0 或 1）表示，二进制转换为科学记数法的公式如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1b4b1620-86f4-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>其中，<code>a</code>的值为 0 或者 1，e 为小数点移动的位置</p>\n<p>举个例子：</p>\n<p>27.0 转化成二进制为 11011.0 ，科学计数法表示为：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/37007090-86f4-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>前面讲到，<code>javaScript</code>存储方式是双精度浮点数，其长度为 8 个字节，即 64 位比特</p>\n<p>64 位比特又可分为三个部分：</p>\n<ul>\n<li>符号位 S：第 1 位是正负数符号位（sign），0 代表正数，1 代表负数</li>\n<li>指数位 E：中间的 11 位存储指数（exponent），用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为 1023</li>\n<li>尾数位 M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零</li>\n</ul>\n<p>如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/430d0100-86f4-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>举个例子：</p>\n<p>27.5 转换为二进制 11011.1</p>\n<p>11011.1 转换为科学记数法 <img src=\"https://www.zhihu.com/equation?tex=1.10111*2^4\" alt=\"[公式]\" loading=\"lazy\"></p>\n<p>符号位为 1(正数)，指数位为 4+，1023+4，即 1027</p>\n<p>因为它是十进制的需要转换为二进制，即 <code>10000000011</code>，小数部分为<code>10111</code>，补够 52 位即： 1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000`</p>\n<p>所以 27.5 存储为计算机的二进制标准形式（符号位+指数位+小数部分 (阶数)），既下面所示</p>\n<p>0+10000000011+011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000`</p>\n<h2> 二、问题分析</h2>\n<p>再回到问题上</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>通过上面的学习，我们知道，在<code>javascript</code>语言中，0.1 和 0.2 都转化成二进制后再进行运算</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>所以输出<code>false</code></p>\n<p>再来一个问题，那么为什么<code>x=0.1</code>得到<code>0.1</code>？</p>\n<p>主要是存储二进制时小数点的偏移量最大为 52 位，最多可以表达的位数是<code>2^53=9007199254740992</code>，对应科学计数尾数是 <code>9.007199254740992</code>，这也是 JS 最多能表示的精度</p>\n<p>它的长度是 16，所以可以使用 <code>toPrecision(16)</code> 来做精度运算，超过的精度会自动做凑整处理</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但看到的 <code>0.1</code> 实际上并不是 <code>0.1</code>。不信你可用更高的精度试试：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果整数大于 <code>9007199254740992</code> 会出现什么情况呢？</p>\n<p>由于指数位最大值是 1023，所以最大可以表示的整数是 <code>2^1024 - 1</code>，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 <code>2^1024</code> 开始就变成了 <code>Infinity</code></p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>那么对于 <code>(2^53, 2^63)</code> 之间的数会出现什么情况呢？</p>\n<ul>\n<li><code>(2^53, 2^54)</code> 之间的数会两个选一个，只能精确表示偶数</li>\n<li><code>(2^54, 2^55)</code> 之间的数会四个选一个，只能精确表示 4 个倍数</li>\n<li>... 依次跳过更多 2 的倍数</li>\n</ul>\n<p>要想解决大数的问题你可以引用第三方库 <code>bignumber.js</code>，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生差很多</p>\n<h3> 小结</h3>\n<p>计算机存储双精度浮点数需要先把十进制数转换为二进制的科学记数法的形式，然后计算机以自己的规则{符号位+(指数位+指数偏移量的二进制)+小数部分}存储二进制的科学记数法</p>\n<p>因为存储时有位数限制（64 位），并且某些十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0 舍 1 入)，当再转换为十进制时就造成了计算误差</p>\n<h2> 三、解决方案</h2>\n<p>理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果</p>\n<p>当你拿到 <code>1.4000000000000001</code> 这样的数据要展示时，建议使用 <code>toPrecision</code> 凑整并 <code>parseFloat</code> 转成数字后再显示，如下：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>封装成方法就是：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对于运算类操作，如 <code>+-*/</code>，就不能使用 <code>toPrecision</code> 了。正确的做法是把小数转成整数后再运算。以加法为例：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最后还可以使用第三方库，如<code>Math.js</code>、<code>BigDecimal.js</code></p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/100353781\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/100353781</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-19T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说 JavaScript 中内存泄漏的几种情况？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/memory_leak.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/memory_leak.html",
      "summary": "前端物语|面试物语-说说 JavaScript 中内存泄漏的几种情况？",
      "content_html": "<h1> 说说 JavaScript 中内存泄漏的几种情况？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/19f76b30-824d-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存</p>\n<p>并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费</p>\n<p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存</p>\n<p>对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/56d4bd90-821c-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在<code>C</code>语言中，因为是手动管理内存，内存泄露是经常出现的事情。</p>\n<div class=\"language-clang line-numbers-mode\" data-ext=\"clang\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面是 C 语言代码，<code>malloc</code>方法用来申请内存，使用完毕之后，必须自己用<code>free</code>方法释放内存。</p>\n<p>这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为\"垃圾回收机制\"</p>\n<h2> 二、垃圾回收机制</h2>\n<p>Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存</p>\n<p>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存</p>\n<p>通常情况下有两种实现方式：</p>\n<ul>\n<li>标记清除</li>\n<li>引用计数</li>\n</ul>\n<h3> 标记清除</h3>\n<p><code>JavaScript</code>最常用的垃圾收回机制</p>\n<p>当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“</p>\n<p>垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉</p>\n<p>在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了</p>\n<p>随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存</p>\n<p>举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 引用计数</h3>\n<p>语言引擎有一张\"引用表\"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是<code>0</code>，就表示这个值不再用到了，因此可以将这块内存释放</p>\n<p>如果一个值不再需要了，引用数却不为<code>0</code>，垃圾回收机制无法释放这块内存，从而导致内存泄漏</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中，数组<code>[1, 2, 3, 4]</code>是一个值，会占用内存。变量<code>arr</code>是仅有的对这个值的引用，因此引用次数为<code>1</code>。尽管后面的代码没有用到<code>arr</code>，它还是会持续占用内存</p>\n<p>如果需要这块内存被垃圾回收机制释放，只需要设置如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>通过设置<code>arr</code>为<code>null</code>，就解除了对数组<code>[1,2,3,4]</code>的引用，引用次数变为 0，就被垃圾回收了</p>\n<h3> 小结</h3>\n<p>有了垃圾回收机制，不代表不用关注内存泄露。那些很占空间的值，一旦不再用到，需要检查是否还存在对它们的引用。如果是的话，就必须手动解除引用</p>\n<h2> 三、常见内存泄露情况</h2>\n<p>意外的全局变量</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另一种意外的全局变量可能由 <code>this</code> 创建：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述使用严格模式，可以避免意外的全局变量</p>\n<p>定时器也常会造成内存泄露</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果<code>id</code>为 Node 的元素从<code>DOM</code>中移除，该定时器仍会存在，同时，因为回调函数中包含对<code>someResource</code>的引用，定时器外面的<code>someResource</code>也不会被释放</p>\n<p>包括我们之前所说的闭包，维持函数内局部变量，使其得不到释放</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>没有清理对<code>DOM</code>元素的引用同样造成内存泄露</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>包括使用事件监听<code>addEventListener</code>监听的时候，在不监听的情况下使用<code>removeEventListener</code>取消对事件监听</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/04/memory-leak.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.ruanyifeng.com/blog/2017/04/memory-leak.html</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-05T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "如何实现上拉加载，下拉刷新？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/pull_up_loading_pull_down_refresh.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/pull_up_loading_pull_down_refresh.html",
      "summary": "前端物语|面试物语-如何实现上拉加载，下拉刷新？",
      "content_html": "<h1> 如何实现上拉加载，下拉刷新？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/89cd1850-8adc-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、前言</h2>\n<p>下拉刷新和上拉加载这两种交互方式通常出现在移动端中</p>\n<p>本质上等同于 PC 网页中的分页，只是交互形式不同</p>\n<p>开源社区也有很多优秀的解决方案，如<code>iscroll</code>、<code>better-scroll</code>、<code>pulltorefresh.js</code>库等等</p>\n<p>这些第三方库使用起来非常便捷</p>\n<p>我们通过原生的方式实现一次上拉加载，下拉刷新，有助于对第三方库有更好的理解与使用</p>\n<h2> 二、实现原理</h2>\n<p>上拉加载及下拉刷新都依赖于用户交互</p>\n<p>最重要的是要理解在什么场景，什么时机下触发交互动作</p>\n<h3> 上拉加载</h3>\n<p>首先可以看一张图</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/df498a00-8ae3-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>上拉加载的本质是页面触底，或者快要触底时的动作</p>\n<p>判断页面触底我们需要先了解一下下面几个属性</p>\n<ul>\n<li>\n<p><code>scrollTop</code>：滚动视窗的高度距离<code>window</code>顶部的距离，它会随着往上滚动而不断增加，初始值是 0，它是一个变化的值</p>\n</li>\n<li>\n<p><code>clientHeight</code>:它是一个定值，表示屏幕可视区域的高度；</p>\n</li>\n<li>\n<p><code>scrollHeight</code>：页面不能滚动时也是存在的,此时 scrollHeight 等于 clientHeight。scrollHeight 表示<code>body</code>所有元素的总长度(包括 body 元素自身的 padding)</p>\n</li>\n</ul>\n<p>综上我们得出一个触底公式：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>简单实现</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 下拉刷新</h3>\n<p>下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作</p>\n<p>关于下拉刷新的原生实现，主要分成三步：</p>\n<ul>\n<li>监听原生<code>touchstart</code>事件，记录其初始位置的值，<code>e.touches[0].pageY</code>；</li>\n<li>监听原生<code>touchmove</code>事件，记录并计算当前滑动的位置值与初始位置值的差值，大于<code>0</code>表示向下拉动，并借助 CSS3 的<code>translateY</code>属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；</li>\n<li>监听原生<code>touchend</code>事件，若此时元素滑动达到最大值，则触发<code>callback</code>，同时将<code>translateY</code>重设为<code>0</code>，元素回到初始位置</li>\n</ul>\n<p>举个例子：</p>\n<p><code>Html</code>结构如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>监听<code>touchstart</code>事件，记录初始的值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>监听<code>touchmove</code>移动事件，记录滑动差值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最后，就是监听<code>touchend</code>离开的事件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面可以看到，在下拉到松手的过程中，经历了三个阶段：</p>\n<ul>\n<li>当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作</li>\n<li>下拉到一定值时，显示松手释放后的操作提示</li>\n<li>下拉到达设定最大值松手时，执行回调，提示正在进行更新操作</li>\n</ul>\n<h2> 三、案例</h2>\n<p>在实际开发中，我们更多的是使用第三方库，下面以<code>better-scroll</code>进行举例：</p>\n<p>HTML 结构</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实例化上拉下拉插件，通过<code>use</code>来注册插件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实例化<code>BetterScroll</code>，并传入相关的参数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意点：</p>\n<p>使用<code>better-scroll</code>实现下拉刷新、上拉加载时要注意以下几点：</p>\n<ul>\n<li><code>wrapper</code>里必须只有一个子元素</li>\n<li>子元素的高度要比<code>wrapper</code>要高</li>\n<li>使用的时候，要确定<code>DOM</code>元素是否已经生成，必须要等到<code>DOM</code>渲染完成后，再<code>new BScroll()</code></li>\n<li>滚动区域的<code>DOM</code>元素结构有变化后，需要执行刷新 <code>refresh()</code></li>\n<li>上拉或者下拉，结束后，需要执行<code>finishPullUp()</code>或者<code>finishPullDown()</code>，否则将不会执行下次操作</li>\n<li><code>better-scroll</code>，默认会阻止浏览器的原生<code>click</code>事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置<code>click:true</code></li>\n</ul>\n<h3> 小结</h3>\n<p>下拉刷新、上拉加载原理本身都很简单，真正复杂的是封装过程中，要考虑的兼容性、易用性、性能等诸多细节</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000014423308\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000014423308</a></li>\n<li><a href=\"https://github.com/ustbhuangyi/better-scroll\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/ustbhuangyi/better-scroll</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说你对正则表达式的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/regexp.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/regexp.html",
      "summary": "前端物语|面试物语-说说你对正则表达式的理解？应用场景？",
      "content_html": "<h1> 说说你对正则表达式的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/55388a40-7f1d-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>正则表达式是一种用来匹配字符串的强有力的武器</p>\n<p>它的设计思想是用一种描述性的语言定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的</p>\n<p>在 <code>JavaScript</code>中，正则表达式也是对象，构建正则表达式有两种方式：</p>\n<ol>\n<li>字面量创建，其由包含在斜杠之间的模式组成</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol start=\"2\">\n<li>调用<code>RegExp</code>对象的构造函数</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用构建函数创建，第一个参数可以是一个变量，遇到特殊字符<code>\\</code>需要使用<code>\\\\</code>进行转义</p>\n<h2> 二、匹配规则</h2>\n<p>常见的校验规则如下：</p>\n<table>\n<thead>\n<tr>\n<th>规则</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\</td>\n<td>转义</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配输入的开始</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配输入的结束</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配前一个表达式 0 次或多次</td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配前面一个表达式 1 次或者多次。等价于 <code>{1,}</code></td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配前面一个表达式 0 次或者 1 次。等价于<code>{0,1}</code></td>\n</tr>\n<tr>\n<td>.</td>\n<td>默认匹配除换行符之外的任何单个字符</td>\n</tr>\n<tr>\n<td>x(?=y)</td>\n<td>匹配'x'仅仅当'x'后面跟着'y'。这种叫做先行断言</td>\n</tr>\n<tr>\n<td>(?&lt;=y)x</td>\n<td>匹配'x'仅当'x'前面是'y'.这种叫做后行断言</td>\n</tr>\n<tr>\n<td>x(?!y)</td>\n<td>仅仅当'x'后面不跟着'y'时匹配'x'，这被称为正向否定查找</td>\n</tr>\n<tr>\n<td>(?&lt;!<em>y</em>)<em>x</em></td>\n<td>仅仅当'x'前面不是'y'时匹配'x'，这被称为反向否定查找</td>\n</tr>\n<tr>\n<td>x|y</td>\n<td>匹配‘x’或者‘y’</td>\n</tr>\n<tr>\n<td n=\"\"></td>\n<td>n 是一个正整数，匹配了前面一个字符刚好出现了 n 次</td>\n</tr>\n<tr>\n<td n,=\"\"></td>\n<td>n 是一个正整数，匹配前一个字符至少出现了 n 次</td>\n</tr>\n<tr>\n<td n,m=\"\"></td>\n<td>n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次</td>\n</tr>\n<tr>\n<td>[xyz]</td>\n<td>一个字符集合。匹配方括号中的任意字符</td>\n</tr>\n<tr>\n<td>[^xyz]</td>\n<td>匹配任何没有包含在方括号中的字符</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配一个词的边界，例如在字母和空格之间</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配一个非单词边界</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配一个数字</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配一个非数字字符</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>匹配一个换页符</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>匹配一个换行符</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>匹配一个回车符</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配一个空白字符，包括空格、制表符、换页符和换行符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配一个非空白字符</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配一个单字字符（字母、数字或者下划线）</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配一个非单字字符</td>\n</tr>\n</tbody>\n</table>\n<h3> 正则表达式标记</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">标志</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>g</code></td>\n<td style=\"text-align:left\">全局搜索。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>i</code></td>\n<td style=\"text-align:left\">不区分大小写搜索。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>m</code></td>\n<td style=\"text-align:left\">多行搜索。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>s</code></td>\n<td style=\"text-align:left\">允许 <code>.</code> 匹配换行符。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>u</code></td>\n<td style=\"text-align:left\">使用<code>unicode</code>码的模式进行匹配。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>y</code></td>\n<td style=\"text-align:left\">执行“粘性(<code>sticky</code>)”搜索,匹配从目标字符串的当前位置开始。</td>\n</tr>\n</tbody>\n</table>\n<p>使用方法如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在了解下正则表达式基本的之外，还可以掌握几个正则表达式的特性：</p>\n<h3> 贪婪模式</h3>\n<p>在了解贪婪模式前，首先举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在匹配过程中，尝试可能的顺序是从多往少的方向去尝试。首先会尝试<code>bbb</code>，然后再看整个正则是否能匹配。不能匹配时，吐出一个<code>b</code>，即在<code>bb</code>的基础上，再继续尝试，以此重复</p>\n<p>如果多个贪婪量词挨着，则深度优先搜索</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中，前面的<code>\\d{1,3}</code>匹配的是\"123\"，后面的<code>\\d{1,3}</code>匹配的是\"45\"</p>\n<h3> 懒惰模式</h3>\n<p>惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中<code>\\d{1,3}?</code>只匹配到一个字符\"1\"，而后面的<code>\\d{1,3}</code>匹配了\"234\"</p>\n<h3> 分组</h3>\n<p>分组主要是用过<code>()</code>进行实现，比如<code>beyond{3}</code>，是匹配<code>d</code>字母 3 次。而<code>(beyond){3}</code>是匹配<code>beyond</code>三次</p>\n<p>在<code>()</code>内使用<code>|</code>达到或的效果，如<code>(abc | xxx)</code>可以匹配<code>abc</code>或者<code>xxx</code></p>\n<p>反向引用，巧用<code>$</code>分组捕获</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、匹配方法</h2>\n<p>正则表达式常被用于某些方法，我们可以分成两类：</p>\n<ul>\n<li>字符串（str）方法：<code>match</code>、<code>matchAll</code>、<code>search</code>、<code>replace</code>、<code>split</code></li>\n<li>正则对象下（regexp）的方法：<code>test</code>、<code>exec</code></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">exec</td>\n<td style=\"text-align:left\">一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">test</td>\n<td style=\"text-align:left\">一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">match</td>\n<td style=\"text-align:left\">一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">matchAll</td>\n<td style=\"text-align:left\">一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">search</td>\n<td style=\"text-align:left\">一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">replace</td>\n<td style=\"text-align:left\">一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">split</td>\n<td style=\"text-align:left\">一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 <code>String</code> 方法。</td>\n</tr>\n</tbody>\n</table>\n<h3> str.match(regexp)</h3>\n<p><code>str.match(regexp)</code> 方法在字符串 <code>str</code> 中找到匹配 <code>regexp</code> 的字符</p>\n<p>如果 <code>regexp</code> 不带有 <code>g</code> 标记，则它以数组的形式返回第一个匹配项，其中包含分组和属性 <code>index</code>（匹配项的位置）、<code>input</code>（输入字符串，等于 <code>str</code>）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果 <code>regexp</code> 带有 <code>g</code> 标记，则它将所有匹配项的数组作为字符串返回，而不包含分组和其他详细信息</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果没有匹配项，则无论是否带有标记 <code>g</code> ，都将返回 <code>null</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> str.matchAll(regexp)</h3>\n<p>返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> str.search(regexp)</h3>\n<p>返回第一个匹配项的位置，如果未找到，则返回 <code>-1</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里需要注意的是，<code>search</code> 仅查找第一个匹配项</p>\n<h2> str.replace(regexp)</h2>\n<p>替换与正则表达式匹配的子串，并返回替换后的字符串。在不设置全局匹配<code>g</code>的时候，只替换第一个匹配成功的字符串片段</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> str.split(regexp)</h3>\n<p>使用正则表达式（或子字符串）作为分隔符来分割字符串</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> regexp.exec(str)</h3>\n<p><code>regexp.exec(str)</code> 方法返回字符串 <code>str</code> 中的 <code>regexp</code> 匹配项，与以前的方法不同，它是在正则表达式而不是字符串上调用的</p>\n<p>根据正则表达式是否带有标志 <code>g</code>，它的行为有所不同</p>\n<p>如果没有 <code>g</code>，那么 <code>regexp.exec(str)</code> 返回的第一个匹配与 <code>str.match(regexp)</code> 完全相同</p>\n<p>如果有标记 <code>g</code>，调用 <code>regexp.exec(str)</code> 会返回第一个匹配项，并将紧随其后的位置保存在属性<code>regexp.lastIndex</code> 中。 下一次同样的调用会从位置 <code>regexp.lastIndex</code> 开始搜索，返回下一个匹配项，并将其后的位置保存在 <code>regexp.lastIndex</code> 中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> regexp.test(str)</h3>\n<p>查找匹配项，然后返回 <code>true/false</code> 表示是否存在</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 四、应用场景</h2>\n<p>通过上面的学习，我们对正则表达式有了一定的了解</p>\n<p>下面再来看看正则表达式一些案例场景：</p>\n<p>验证 QQ 合法性（5~15 位、全是数字、不以 0 开头）：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>校验用户账号合法性（只能输入 5-20 个以字母开头、可带数字、“_”、“.”的字串）：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>将<code>url</code>参数解析为对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再将上面的<code>search</code>和<code>hash</code>进行解析</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-19T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说你对作用域链的理解",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/scope.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/scope.html",
      "summary": "前端物语|面试物语-说说你对作用域链的理解",
      "content_html": "<h1> 说说你对作用域链的理解</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/16f614a0-718f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、作用域</h2>\n<p>作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合</p>\n<p>换句话说，作用域决定了代码区块中变量和其他资源的可见性</p>\n<p>举个例子</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述例子中，函数<code>myFunction</code>内部创建一个<code>inVariable</code>变量，当我们在全局访问这个变量的时候，系统会报错</p>\n<p>这就说明我们在全局是无法获取到（闭包除外）函数内部的变量</p>\n<p>我们一般将作用域分成：</p>\n<ul>\n<li>\n<p>全局作用域</p>\n</li>\n<li>\n<p>函数作用域</p>\n</li>\n<li>\n<p>块级作用域</p>\n</li>\n</ul>\n<h3> 全局作用域</h3>\n<p>任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 函数作用域</h3>\n<p>函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可见上述代码中在函数内部声明的变量或函数，在函数外部是无法访问的，这说明在函数内部定义的变量或者方法只是函数作用域</p>\n<h3> 块级作用域</h3>\n<p>ES6 引入了<code>let</code>和<code>const</code>关键字,和<code>var</code>关键字不同，在大括号中使用<code>let</code>和<code>const</code>声明的变量存在于块级作用域中。在大括号之外不能访问这些变量</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、词法作用域</h2>\n<p>词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，<code>JavaScript</code> 遵循的就是词法作用域</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码改变成一张图</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/29fab3d0-718f-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>由于<code>JavaScript</code>遵循词法作用域，相同层级的 <code>foo</code> 和 <code>bar</code> 就没有办法访问到彼此块作用域中的变量，所以输出 2</p>\n<h2> 三、作用域链</h2>\n<p>当在<code>Javascript</code>中使用一个变量的时候，首先<code>Javascript</code>引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域</p>\n<p>如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错</p>\n<p>这里拿《你不知道的 Javascript(上)》中的一张图解释：</p>\n<p>把作用域比喻成一个建筑，这份建筑代表程序中的嵌套作用域链，第一层代表当前的执行作用域，顶层代表全局作用域</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/33f9c100-718f-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>变量的引用会顺着当前楼层进行查找，如果找不到，则会往上一层找，一旦到达顶层，查找的过程都会停止</p>\n<p>下面代码演示下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码主要主要做了以下工作：</p>\n<ul>\n<li><code>student</code>函数内部属于最内层作用域，找不到<code>name</code>，向上一层作用域<code>person</code>函数内部找，找到了输出“张三”</li>\n<li><code>student</code>内部输出<code>sex</code>时找不到，向上一层作用域<code>person</code>函数找，还找不到继续向上一层找，即全局作用域，找到了输出“男”</li>\n<li>在<code>person</code>函数内部输出<code>age</code>时找不到，向上一层作用域找，即全局作用域，还是找不到则报错</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "web 常见的攻击方式有哪些？如何防御？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/security.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/security.html",
      "summary": "前端物语|面试物语-web 常见的攻击方式有哪些？如何防御？",
      "content_html": "<h1> web 常见的攻击方式有哪些？如何防御？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d0892930-8d1d-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>Web 攻击（WebAttack）是针对用户上网行为或网站服务器等设备进行攻击的行为</p>\n<p>如植入恶意代码，修改网站权限，获取网站用户隐私信息等等</p>\n<p>Web 应用程序的安全性是任何基于 Web 业务的重要组成部分</p>\n<p>确保 Web 应用程序安全十分重要，即使是代码中很小的 bug 也有可能导致隐私信息被泄露</p>\n<p>站点安全就是为保护站点不受未授权的访问、使用、修改和破坏而采取的行为或实践</p>\n<p>我们常见的 Web 攻击方式有</p>\n<ul>\n<li>XSS (Cross Site Scripting) 跨站脚本攻击</li>\n<li>CSRF（Cross-site request forgery）跨站请求伪造</li>\n<li>SQL 注入攻击</li>\n</ul>\n<h2> 二、XSS</h2>\n<p>XSS，跨站脚本攻击，允许攻击者将恶意代码植入到提供给其它用户使用的页面中</p>\n<p><code>XSS</code>涉及到三方，即攻击者、客户端与<code>Web</code>应用</p>\n<p><code>XSS</code>的攻击目标是为了盗取存储在客户端的<code>cookie</code>或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互</p>\n<p>举个例子：</p>\n<p>一个搜索页面，根据<code>url</code>参数决定关键词的内容</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里看似并没有问题，但是如果不按套路出牌呢？</p>\n<p>用户输入<code>\"&gt;&lt;script&gt;alert('XSS');&lt;/script&gt;</code>，拼接到 HTML 中返回给浏览器。形成了如下的 HTML：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>浏览器无法分辨出 <code>&lt;script&gt;alert('XSS');&lt;/script&gt;</code> 是恶意代码，因而将其执行，试想一下，如果是获取<code>cookie</code>发送对黑客服务器呢？</p>\n<p>根据攻击的来源，<code>XSS</code>攻击可以分成：</p>\n<ul>\n<li>存储型</li>\n<li>反射型</li>\n<li>DOM 型</li>\n</ul>\n<h3> 存储型</h3>\n<p>存储型 XSS 的攻击步骤：</p>\n<ol>\n<li>攻击者将恶意代码提交到目标网站的数据库中</li>\n<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器</li>\n<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>\n</ol>\n<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等</p>\n<h3> 反射型 XSS</h3>\n<p>反射型 XSS 的攻击步骤：</p>\n<ol>\n<li>攻击者构造出特殊的 URL，其中包含恶意代码</li>\n<li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器</li>\n<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>\n</ol>\n<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p>\n<p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</p>\n<p>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p>\n<p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见</p>\n<h3> DOM 型 XSS</h3>\n<p>DOM 型 XSS 的攻击步骤：</p>\n<ol>\n<li>攻击者构造出特殊的 URL，其中包含恶意代码</li>\n<li>用户打开带有恶意代码的 URL</li>\n<li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>\n</ol>\n<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞</p>\n<h3> XSS 的预防</h3>\n<p>通过前面介绍，看到<code>XSS</code>攻击的两大要素：</p>\n<ul>\n<li>攻击者提交而恶意代码</li>\n<li>浏览器执行恶意代码</li>\n</ul>\n<p>针对第一个要素，我们在用户输入的过程中，过滤掉用户输入的恶劣代码，然后提交给后端，但是如果攻击者绕开前端请求，直接构造请求就不能预防了</p>\n<p>而如果在后端写入数据库前，对输入进行过滤，然后把内容给前端，但是这个内容在不同地方就会有不同显示</p>\n<p>例如：</p>\n<p>一个正常的用户输入了 <code>5 &lt; 7</code> 这个内容，在写入数据库前，被转义，变成了 <code>5 &lt; 7</code></p>\n<p>在客户端中，一旦经过了 <code>escapeHTML()</code>，客户端显示的内容就变成了乱码( <code>5 &lt; 7</code> )</p>\n<p>在前端中，不同的位置所需的编码也不同。</p>\n<ul>\n<li>当 <code>5 &lt; 7</code> 作为 HTML 拼接页面时，可以正常显示：</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>当 <code>5 &lt; 7</code> 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等</li>\n</ul>\n<p>可以看到，过滤并非可靠的，下面就要通过防止浏览器执行恶意代码：</p>\n<p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等</p>\n<p>如果用 <code>Vue/React</code> 技术栈，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能，就在前端 <code>render</code> 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患</p>\n<p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、CSRF</h2>\n<p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求</p>\n<p>利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目</p>\n<p>一个典型的 CSRF 攻击有着如下的流程：</p>\n<ul>\n<li>受害者登录 <a href=\"http://a.com\" target=\"_blank\" rel=\"noopener noreferrer\">a.com</a>，并保留了登录凭证（Cookie）</li>\n<li>攻击者引诱受害者访问了 <a href=\"http://b.com\" target=\"_blank\" rel=\"noopener noreferrer\">b.com</a></li>\n<li><a href=\"http://b.com\" target=\"_blank\" rel=\"noopener noreferrer\">b.com</a> 向 <a href=\"http://a.com\" target=\"_blank\" rel=\"noopener noreferrer\">a.com</a> 发送了一个请求：<a href=\"http://a.com/act=xx%E3%80%82%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E9%BB%98%E8%AE%A4%E6%90%BA%E5%B8%A6\" target=\"_blank\" rel=\"noopener noreferrer\">a.com/act=xx。浏览器会默认携带</a> <a href=\"http://a.com\" target=\"_blank\" rel=\"noopener noreferrer\">a.com</a> 的 Cookie</li>\n<li><a href=\"http://a.com\" target=\"_blank\" rel=\"noopener noreferrer\">a.com</a> 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</li>\n<li><a href=\"http://a.com\" target=\"_blank\" rel=\"noopener noreferrer\">a.com</a> 以受害者的名义执行了 act=xx</li>\n<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 <a href=\"http://a.com\" target=\"_blank\" rel=\"noopener noreferrer\">a.com</a> 执行了自己定义的操作</li>\n</ul>\n<p><code>csrf</code>可以通过<code>get</code>请求，即通过访问<code>img</code>的页面后，浏览器自动访问目标地址，发送请求</p>\n<p>同样，也可以设置一个自动提交的表单发送<code>post</code>请求，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次<code>POST</code>操作</p>\n<p>还有一种为使用<code>a</code>标签的，需要用户点击链接才会触发</p>\n<p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> CSRF 的特点</h3>\n<ul>\n<li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生</li>\n<li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据</li>\n<li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”</li>\n<li>跨站请求可以用各种方式：图片 URL、超链接、CORS、Form 提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪</li>\n</ul>\n<h3> CSRF 的预防</h3>\n<p>CSRF 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 CSRF 的防护能力来提升安全性</p>\n<p>防止<code>csrf</code>常用方案如下：</p>\n<ul>\n<li>阻止不明外域的访问\n<ul>\n<li>同源检测</li>\n<li>Samesite Cookie</li>\n</ul>\n</li>\n<li>提交时要求附加本域才能获取的信息\n<ul>\n<li>CSRF Token</li>\n<li>双重 Cookie 验证</li>\n</ul>\n</li>\n</ul>\n<p>这里主要讲讲<code>token</code>这种形式，流程如下：</p>\n<ul>\n<li>用户打开页面的时候，服务器需要给这个用户生成一个 Token</li>\n<li>对于 GET 请求，Token 将附在请求地址之后。对于 POST 请求来说，要在 form 的最后加上</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>当用户从客户端得到了 Token，再次提交给服务器的时候，服务器需要判断 Token 的有效性</li>\n</ul>\n<h2> 四、SQL 注入</h2>\n<p>Sql 注入攻击，是通过将恶意的 <code>Sql</code>查询或添加语句插入到应用的输入参数中，再在后台 <code>Sql</code>服务器上解析执行进行的攻击</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ead52fa0-8d1d-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>流程如下所示：</p>\n<ul>\n<li>\n<p>找出 SQL 漏洞的注入点</p>\n</li>\n<li>\n<p>判断数据库的类型以及版本</p>\n</li>\n<li>\n<p>猜解用户名和密码</p>\n</li>\n<li>\n<p>利用工具查找 Web 后台管理入口</p>\n</li>\n<li>\n<p>入侵和破坏</p>\n</li>\n</ul>\n<p>预防方式如下：</p>\n<ul>\n<li>严格检查输入变量的类型和格式</li>\n<li>过滤和转义特殊字符</li>\n<li>对访问数据库的 Web 应用程序采用 Web 应用防火墙</li>\n</ul>\n<p>上述只是列举了常见的<code>web</code>攻击方式，实际开发过程中还会遇到很多安全问题，对于这些问题， 切记不可忽视</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://tech.meituan.com/2018/09/27/fe-security.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://tech.meituan.com/2018/09/27/fe-security.html</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/learn/Server-side/First_steps/Website_security\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/learn/Server-side/First_steps/Website_security</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-28T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "JavaScript 字符串的常用方法有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/string_api.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/string_api.html",
      "summary": "前端物语|面试物语-JavaScript 字符串的常用方法有哪些？",
      "content_html": "<h1> JavaScript 字符串的常用方法有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ceb6ebc0-65c1-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、操作方法</h2>\n<p>我们也可将字符串常用的操作方法归纳为增、删、改、查，需要知道字符串的特点是一旦创建了，就不可变</p>\n<h3> 增</h3>\n<p>这里增的意思并不是说直接增添内容，而是创建字符串的一个副本，再进行操作</p>\n<p>除了常用<code>+</code>以及<code>${}</code>进行字符串拼接之外，还可通过<code>concat</code></p>\n<h4> concat</h4>\n<p>用于将一个或多个字符串拼接成一个新字符串</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 删</h3>\n<p>这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作</p>\n<p>常见的有：</p>\n<ul>\n<li>slice()</li>\n<li>substr()</li>\n<li>substring()</li>\n</ul>\n<p>这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 改</h3>\n<p>这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作</p>\n<p>常见的有：</p>\n<ul>\n<li>\n<p>trim()、trimLeft()、trimRight()</p>\n</li>\n<li>\n<p>repeat()</p>\n</li>\n<li>\n<p>padStart()、padEnd()</p>\n</li>\n<li>\n<p>toLowerCase()、 toUpperCase()</p>\n</li>\n</ul>\n<h4> trim()、trimLeft()、trimRight()</h4>\n<p>删除前、后或前后所有空格符，再返回新的字符串</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> repeat()</h4>\n<p>接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> padEnd()</h4>\n<p>复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> toLowerCase()、 toUpperCase()</h3>\n<p>大小写转化</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 查</h3>\n<p>除了通过索引的方式获取字符串的值，还可通过：</p>\n<ul>\n<li>\n<p>chatAt()</p>\n</li>\n<li>\n<p>indexOf()</p>\n</li>\n<li>\n<p>startWith()</p>\n</li>\n<li>\n<p>includes()</p>\n</li>\n</ul>\n<h4> charAt()</h4>\n<p>返回给定索引位置的字符，由传给方法的整数参数指定</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> indexOf()</h4>\n<p>从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> startWith()、includes()</h4>\n<p>从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、转换方法</h2>\n<h3> split</h3>\n<p>把字符串按照指定的分割符，拆分成数组中的每一项</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、模板匹配方法</h2>\n<p>针对正则表达式，字符串设计了几个方法：</p>\n<ul>\n<li>match()</li>\n<li>search()</li>\n<li>replace()</li>\n</ul>\n<h3> match()</h3>\n<p>接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code>对象，返回数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> search()</h3>\n<p>接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code>对象，找到则返回匹配索引，否则返回 -1</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> replace()</h3>\n<p>接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "谈谈 JavaScript 中的类型转换机制",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/type_conversion.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/type_conversion.html",
      "summary": "前端物语|面试物语-谈谈 JavaScript 中的类型转换机制",
      "content_html": "<h1> 谈谈 JavaScript 中的类型转换机制</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2abd00a0-6692-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、概述</h2>\n<p>前面我们讲到，<code>JS</code>中有六种简单数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>string</code>、<code>number</code>、<code>symbol</code>，以及引用类型：<code>object</code></p>\n<p>但是我们在声明的时候只有一种数据类型，只有到运行期间才会确定当前类型</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>上面代码中，<code>x</code>的值在编译阶段是无法获取的，只有等到程序运行时才能知道</p>\n<p>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制</p>\n<p>常见的类型转换有：</p>\n<ul>\n<li>强制转换（显示转换）</li>\n<li>自动转换（隐式转换）</li>\n</ul>\n<h2> 二、显示转换</h2>\n<p>显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：</p>\n<ul>\n<li>Number()</li>\n<li>parseInt()</li>\n<li>String()</li>\n<li>Boolean()</li>\n</ul>\n<h3> Number()</h3>\n<p>将任意类型的值转化为数值</p>\n<p>先给出类型转换规则：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/915b7300-6692-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>实践一下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面可以看到，<code>Number</code>转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code></p>\n<h3> parseInt()</h3>\n<p><code>parseInt</code>相比<code>Number</code>，就没那么严格了，<code>parseInt</code>函数逐个解析字符，遇到不能转换的字符就停下来</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> String()</h3>\n<p>可以将任意类型的值转化成字符串</p>\n<p>给出转换规则图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/48dd8eb0-6692-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>实践一下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Boolean()</h3>\n<p>可以将任意类型的值转为布尔值，转换规则如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/53bdad10-6692-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>实践一下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、隐式转换</h2>\n<p>在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？</p>\n<p>我们这里可以归纳为两种情况发生隐式转换的场景：</p>\n<ul>\n<li>比较运算（<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>）、<code>if</code>、<code>while</code>需要布尔值地方</li>\n<li>算术运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）</li>\n</ul>\n<p>除了上面的场景，还要求运算符两边的操作数不是同一类型</p>\n<h3> 自动转换为布尔值</h3>\n<p>在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用<code>Boolean</code>函数</p>\n<p>可以得出个小结：</p>\n<ul>\n<li>undefined</li>\n<li>null</li>\n<li>false</li>\n<li>+0</li>\n<li>-0</li>\n<li>NaN</li>\n<li>\"\"</li>\n</ul>\n<p>除了上面几种会被转化成<code>false</code>，其他都换被转化成<code>true</code></p>\n<h3> 自动转换成字符串</h3>\n<p>遇到预期为字符串的地方，就会将非字符串的值自动转为字符串</p>\n<p>具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串</p>\n<p>常发生在<code>+</code>运算中，一旦存在字符串，则会进行字符串拼接操作</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 自动转换成数值</h3>\n<p>除了<code>+</code>有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>null</code>转为数值时，值为<code>0</code> 。<code>undefined</code>转为数值时，值为<code>NaN</code></p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "如何判断一个元素是否在可视区域中？",
      "url": "https://www.h7ml.cn/posts/interview/JavaScript/visible.html",
      "id": "https://www.h7ml.cn/posts/interview/JavaScript/visible.html",
      "summary": "前端物语|面试物语-如何判断一个元素是否在可视区域中？",
      "content_html": "<h1> 如何判断一个元素是否在可视区域中？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d848c790-8a05-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、用途</h2>\n<p>可视区域即我们浏览网页的设备肉眼可见的区域，如下图</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9c5bbb10-8a56-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：</p>\n<ul>\n<li>图片的懒加载</li>\n<li>列表的无限滚动</li>\n<li>计算广告元素的曝光情况</li>\n<li>可点击链接的预加载</li>\n</ul>\n<h2> 二、实现方式</h2>\n<p>判断一个元素是否在可视区域，我们常用的有三种办法：</p>\n<ul>\n<li>\n<p>offsetTop、scrollTop</p>\n</li>\n<li>\n<p>getBoundingClientRect</p>\n</li>\n<li>\n<p>Intersection Observer</p>\n</li>\n</ul>\n<h3> offsetTop、scrollTop</h3>\n<p><code>offsetTop</code>，元素的上外边框至包含元素的上内边框之间的像素距离，其他<code>offset</code>属性如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b4b63ca0-8a54-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>下面再来了解下<code>clientWidth</code>、<code>clientHeight</code>：</p>\n<ul>\n<li><code>clientWidth</code>：元素内容区宽度加上左右内边距宽度，即<code>clientWidth = content + padding</code></li>\n<li><code>clientHeight</code>：元素内容区高度加上上下内边距高度，即<code>clientHeight = content + padding</code></li>\n</ul>\n<p>这里可以看到<code>client</code>元素都不包括外边距</p>\n<p>最后，关于<code>scroll</code>系列的属性如下：</p>\n<ul>\n<li>\n<p><code>scrollWidth</code> 和 <code>scrollHeight</code> 主要用于确定元素内容的实际大小</p>\n</li>\n<li>\n<p><code>scrollLeft</code> 和 <code>scrollTop</code> 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置</p>\n<ul>\n<li>\n<ul>\n<li>垂直滚动 <code>scrollTop &gt; 0</code></li>\n</ul>\n</li>\n<li>水平滚动 <code>scrollLeft &gt; 0</code></li>\n</ul>\n</li>\n<li>\n<p>将元素的 <code>scrollLeft</code> 和 <code>scrollTop</code> 设置为 0，可以重置元素的滚动位置</p>\n</li>\n</ul>\n<h4> 注意</h4>\n<ul>\n<li>上述属性都是只读的，每次访问都要重新开始</li>\n</ul>\n<p>下面再看看如何实现判断：</p>\n<p>公式如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>代码实现：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> getBoundingClientRect</h3>\n<p>返回值是一个 <code>DOMRect</code>对象，拥有<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>, <code>x</code>, <code>y</code>, <code>width</code>, 和 <code>height</code>属性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>属性对应的关系图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e34ac5d0-8a05-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>当页面发生滚动的时候，<code>top</code>与<code>left</code>属性值都会随之改变</p>\n<p>如果一个元素在视窗之内的话，那么它一定满足下面四个条件：</p>\n<ul>\n<li>top 大于等于 0</li>\n<li>left 大于等于 0</li>\n<li>bottom 小于等于视窗高度</li>\n<li>right 小于等于视窗宽度</li>\n</ul>\n<p>实现代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Intersection Observer</h3>\n<p><code>Intersection Observer</code> 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比<code>getBoundingClientRect</code>会好很多</p>\n<p>使用步骤主要分为两步：创建观察者和传入被观察者</p>\n<h4> 创建观察者</h4>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过<code>new IntersectionObserver</code>创建了观察者 <code>observer</code>，传入的参数 <code>callback</code> 在重叠比例超过 <code>threshold</code> 时会被执行`</p>\n<p>关于<code>callback</code>回调函数常用属性如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 传入被观察者</h4>\n<p>通过 <code>observer.observe(target)</code> 这一行代码即可简单的注册被观察者</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 三、案例分析</h3>\n<p>实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色</p>\n<p><code>Html</code>结构如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>css</code>样式如下：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>往<code>container</code>插入 1000 个元素</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里，首先使用<code>getBoundingClientRect</code>方法进行判断元素是否在可视区域</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后开始监听<code>scroll</code>事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为<code>yellow</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了<code>scroll</code>事件，<code>scroll</code>事件伴随了大量的计算，会造成资源方面的浪费</p>\n<p>下面通过<code>Intersection Observer</code>的形式同样实现相同的功能</p>\n<p>首先创建一个观察者</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>getYellow</code>回调函数实现对背景颜色改变，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最后传入观察者，即<code>.target</code>元素</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到功能同样完成，并且页面不会出现卡顿的情况</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-22T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "JavaScript"
      ]
    },
    {
      "title": "说说对 Node 中的 Buffer 的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/Buffer.html",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/Buffer.html",
      "summary": "前端物语|面试物语-说说对 Node 中的 Buffer 的理解？应用场景？",
      "content_html": "<h1> 说说对 Node 中的 Buffer 的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/176d02b0-c69c-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在<code>Node</code>应用中，需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，要处理大量二进制数据，而<code>Buffer</code>就是在内存中开辟一片区域（初次初始化为 8KB），用来存放二进制数据</p>\n<p>在上述操作中都会存在数据流动，每个数据流动的过程中，都会有一个最小或最大数据量</p>\n<p>如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的数据到达之后才能被处理</p>\n<p>这里的等待区就指的缓冲区（Buffer），它是计算机中的一个小物理单位，通常位于计算机的 <code>RAM</code> 中</p>\n<p>简单来讲，<code>Nodejs</code>不能控制数据传输的速度和到达时间，只能决定何时发送数据，如果还没到发送时间，则将数据放在<code>Buffer</code>中，即在<code>RAM</code>中，直至将它们发送完毕</p>\n<p>上面讲到了<code>Buffer</code>是用来存储二进制数据，其的形式可以理解成一个数组，数组中的每一项，都可以保存 8 位二进制：<code>00000000</code>，也就是一个字节</p>\n<p>例如：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>其存储过程如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/20371250-c69c-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、使用方法</h2>\n<p><code>Buffer</code> 类在全局作用域中，无须<code>require</code>导入</p>\n<p>创建<code>Buffer</code>的方法有很多种，我们讲讲下面的两种常见的形式：</p>\n<ul>\n<li>\n<p>Buffer.from()</p>\n</li>\n<li>\n<p>Buffer.alloc()</p>\n</li>\n</ul>\n<h3> Buffer.from()</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Buffer.alloc()</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在上面创建<code>buffer</code>后，则能够<code>toString</code>的形式进行交互，默认情况下采取<code>utf8</code>字符编码形式，如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果编码与解码不是相同的格式则会出现乱码的情况，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当设定的范围导致字符串被截断的时候，也会存在乱码情况，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>所支持的字符集有如下：</p>\n<ul>\n<li>ascii：仅支持 7 位 ASCII 数据，如果设置去掉高位的话，这种编码是非常快的</li>\n<li>utf8：多字节编码的 Unicode 字符，许多网页和其他文档格式都使用 UTF-8</li>\n<li>utf16le：2 或 4 个字节，小字节序编码的 Unicode 字符，支持代理对（U+10000 至 U+10FFFF）</li>\n<li>ucs2，utf16le 的别名</li>\n<li>base64：Base64 编码</li>\n<li>latin：一种把 Buffer 编码成一字节编码的字符串的方式</li>\n<li>binary：latin1 的别名，</li>\n<li>hex：将每个字节编码为两个十六进制字符</li>\n</ul>\n<h2> 三、应用场景</h2>\n<p><code>Buffer</code>的应用场景常常与流的概念联系在一起，例如有如下：</p>\n<ul>\n<li>I/O 操作</li>\n<li>加密解密</li>\n<li>zlib.js</li>\n</ul>\n<h3> I/O 操作</h3>\n<p>通过流的形式，将一个文件的内容读取到另外一个文件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 加解密</h3>\n<p>在一些加解密算法中会遇到使用 <code>Buffer</code>，例如 <code>crypto.createCipheriv</code> 的第二个参数 <code>key</code> 为 <code>string</code> 或 <code>Buffer</code> 类型</p>\n<h3> zlib.js</h3>\n<p><code>zlib.js</code> 为 <code>Node.js</code> 的核心库之一，其利用了缓冲区（<code>Buffer</code>）的功能来操作二进制数据流，提供了压缩或解压功能</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"http://nodejs.cn/api/buffer.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://nodejs.cn/api/buffer.html</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000019894714\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000019894714</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-05T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "NodeJS"
      ]
    },
    {
      "title": "说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter?",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/EventEmitter.html",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/EventEmitter.html",
      "summary": "前端物语|面试物语-说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter?",
      "content_html": "<h1> 说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/16b10390-c83a-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>我们了解到，<code>Node</code>采用了事件驱动机制，而<code>EventEmitter</code>就是<code>Node</code>实现事件驱动的基础</p>\n<p>在<code>EventEmitter</code>的基础上，<code>Node</code>几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定／触发监听器，实现了异步操作</p>\n<p><code>Node.js</code> 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件</p>\n<p>这些产生事件的对象都是 events.EventEmitter 的实例，这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上</p>\n<h2> 二、使用方法</h2>\n<p><code>Node</code>的<code>events</code>模块只提供了一个<code>EventEmitter</code>类，这个类实现了<code>Node</code>异步事件驱动架构的基本模式——观察者模式</p>\n<p>在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们</p>\n<p>基本代码如下所示：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过实例对象的<code>on</code>方法注册一个名为<code>event</code>的事件，通过<code>emit</code>方法触发该事件，而<code>removeListener</code>用于取消事件的监听</p>\n<p>关于其常见的方法如下：</p>\n<ul>\n<li>emitter.addListener/on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部</li>\n<li>emitter.prependListener(eventName, listener)：添加类型为 eventName 的监听事件到事件数组头部</li>\n<li>emitter.emit(eventName[, ...args])：触发类型为 eventName 的监听事件</li>\n<li>emitter.removeListener/off(eventName, listener)：移除类型为 eventName 的监听事件</li>\n<li>emitter.once(eventName, listener)：添加类型为 eventName 的监听事件，以后只能执行一次并删除</li>\n<li>emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件</li>\n</ul>\n<h2> 三、实现过程</h2>\n<p>通过上面的方法了解，<code>EventEmitter</code>是一个构造函数，内部存在一个包含所有事件的对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中<code>events</code>存放的监听事件的函数的结构如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后开始一步步实现实例方法，首先是<code>emit</code>，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当实现了<code>emit</code>方法之后，然后实现<code>on</code>、<code>addListener</code>、<code>prependListener</code>这三个实例方法，都是添加事件监听触发函数，实现也是大同小异</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>紧接着就是实现事件监听的方法<code>removeListener/on</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最后再来实现<code>once</code>方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过<code>fired</code>属性值判断事件函数是否执行过</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>完整代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>测试代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"http://nodejs.cn/api/events.html#events_class_eventemitter\" target=\"_blank\" rel=\"noopener noreferrer\">http://nodejs.cn/api/events.html#events_class_eventemitter</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015762318\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000015762318</a></li>\n<li><a href=\"https://juejin.cn/post/6844903781230968845\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903781230968845</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "NodeJS"
      ]
    },
    {
      "title": "前端物语|面试物语-NodeJS",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/",
      "summary": "说说对 Node 中的 Buffer 的理解？应用场景？ 说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter? 说说对 Node 中的 Stream 的理解？应用场景？ 说说对 Nodejs 中的事件循环机制理解? 如何实现文件上传？说说你的思路 说说对 Node 中的 fs 模块的理解? 有哪些常用方法 说说 Node. js 有哪些全局对象？ 如何实现 jwt 鉴权机制？说说你的思路 说说对中间件概念的理解，如何封装 node 中间件？ 说说你对 Node.js 的理解？优缺点？应用场景？ 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互? Node 性能如何进行监控以及优化？ 说说对 Node 中的 process 的理解？有哪些常用方法？ 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/Buffer\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 Node 中的 Buffer 的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/EventEmitter\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/Stream\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 Node 中的 Stream 的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/event_loop\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 Nodejs 中的事件循环机制理解?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/file_upload\" target=\"_blank\" rel=\"noopener noreferrer\"> 如何实现文件上传？说说你的思路</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/fs\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 Node 中的 fs 模块的理解? 有哪些常用方法</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/global\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 Node. js 有哪些全局对象？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/jwt\" target=\"_blank\" rel=\"noopener noreferrer\"> 如何实现 jwt 鉴权机制？说说你的思路</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/middleware\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对中间件概念的理解，如何封装 node 中间件？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/nodejs\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对 Node.js 的理解？优缺点？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/paging\" target=\"_blank\" rel=\"noopener noreferrer\"> 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/performance\" target=\"_blank\" rel=\"noopener noreferrer\"> Node 性能如何进行监控以及优化？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/process\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 Node 中的 process 的理解？有哪些常用方法？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/NodeJS/require_order\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?</a></li>\n</ul>\n",
      "date_published": "2023-04-08T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "NodeJS"
      ]
    },
    {
      "title": "说说对 Node 中的 Stream 的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/Stream.html",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/Stream.html",
      "summary": "前端物语|面试物语-说说对 Node 中的 Stream 的理解？应用场景？",
      "content_html": "<h1> 说说对 Node 中的 Stream 的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a5df3c60-c76f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>流（Stream），是一个数据传输手段，是端到端信息交换的一种方式，而且是有顺序的,是逐块读取数据、处理内容，用于顺序读取输入或写入输出</p>\n<p><code>Node.js</code>中很多对象都实现了流，总之它是会冒数据（以 <code>Buffer</code> 为单位）</p>\n<p>它的独特之处在于，它不像传统的程序那样一次将一个文件读入内存，而是逐块读取数据、处理其内容，而不是将其全部保存在内存中</p>\n<p>流可以分成三部分：<code>source</code>、<code>dest</code>、<code>pipe</code></p>\n<p>在<code>source</code>和<code>dest</code>之间有一个连接的管道<code>pipe</code>,它的基本语法是<code>source.pipe(dest)</code>，<code>source</code>和<code>dest</code>就是通过 pipe 连接，让数据从<code>source</code>流向了<code>dest</code>，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/aec05670-c76f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、种类</h2>\n<p>在<code>NodeJS</code>，几乎所有的地方都使用到了流的概念，分成四个种类：</p>\n<ul>\n<li>\n<p>可写流：可写入数据的流。例如 fs.createWriteStream() 可以使用流将数据写入文件</p>\n</li>\n<li>\n<p>可读流： 可读取数据的流。例如 fs.createReadStream() 可以从文件读取内容</p>\n</li>\n<li>\n<p>双工流： 既可读又可写的流。例如 net.Socket</p>\n</li>\n<li>\n<p>转换流： 可以在数据写入和读取时修改或转换数据的流。例如，在文件压缩操作中，可以向文件写入压缩数据，并从文件中读取解压数据</p>\n</li>\n</ul>\n<p>在<code>NodeJS</code>中<code>HTTP</code>服务器模块中，<code>request</code> 是可读流，<code>response</code> 是可写流。还有<code>fs</code> 模块，能同时处理可读和可写文件流</p>\n<p>可读流和可写流都是单向的，比较容易理解，而另外两个是双向的</p>\n<h3> 双工流</h3>\n<p>之前了解过<code>websocket</code>通信，是一个全双工通信，发送方和接受方都是各自独立的方法，发送和接收都没有任何关系</p>\n<p>如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b7ac6d00-c76f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>基本代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 双工流</h3>\n<p>双工流的演示图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c02883b0-c76f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>除了上述压缩包的例子，还比如一个 <code>babel</code>，把<code>es6</code>转换为，我们在左边写入 <code>es6</code>，从右边读取 <code>es5</code></p>\n<p>基本代码如下所示：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、应用场景</h2>\n<p><code>stream</code>的应用场景主要就是处理<code>IO</code>操作，而<code>http</code>请求和文件操作都属于<code>IO</code>操作</p>\n<p>试想一下，如果一次<code>IO</code>操作过大，硬件的开销就过大，而将此次大的<code>IO</code>操作进行分段操作，让数据像水管一样流动，直到流动完成</p>\n<p>常见的场景有：</p>\n<ul>\n<li>get 请求返回文件给客户端</li>\n<li>文件操作</li>\n<li>一些打包工具的底层操作</li>\n</ul>\n<h3> get 请求返回文件给客户端</h3>\n<p>使用<code>stream</code>流返回文件，<code>res</code>也是一个<code>stream</code>对象，通过<code>pipe</code>管道将文件数据返回</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 文件操作</h3>\n<p>创建一个可读数据流<code>readStream</code>，一个可写数据流<code>writeStream</code>，通过<code>pipe</code>管道把数据流转过去</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 一些打包工具的底层操作</h3>\n<p>目前一些比较火的前端打包构建工具，都是通过<code>node.js</code>编写的，打包和构建的过程肯定是文件频繁操作的过程，离不来<code>stream</code>，如<code>gulp</code></p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://xie.infoq.cn/article/1a9695020828460eb3c4ff1fa\" target=\"_blank\" rel=\"noopener noreferrer\">https://xie.infoq.cn/article/1a9695020828460eb3c4ff1fa</a></li>\n<li><a href=\"https://juejin.cn/post/6844903891083984910\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903891083984910</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "NodeJS"
      ]
    },
    {
      "title": "说说对 Nodejs 中的事件循环机制理解?",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/event_loop.html",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/event_loop.html",
      "summary": "前端物语|面试物语-说说对 Nodejs 中的事件循环机制理解?",
      "content_html": "<h1> 说说对 Nodejs 中的事件循环机制理解?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e0faf3c0-c90e-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在<a href=\"https://github.com/febobo/web-interview/issues/73\" target=\"_blank\" rel=\"noopener noreferrer\">浏览器事件循环</a>中，我们了解到<code>javascript</code>在浏览器中的事件循环机制，其是根据<code>HTML5</code>定义的规范来实现</p>\n<p>而在<code>NodeJS</code>中，事件循环是基于<code>libuv</code>实现，<code>libuv</code>是一个多平台的专注于异步 IO 的库，如下图最右侧所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ea690b90-c90e-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>上图<code>EVENT_QUEUE</code> 给人看起来只有一个队列，但<code>EventLoop</code>存在 6 个阶段，每个阶段都有对应的一个先进先出的回调队列</p>\n<h2> 二、流程</h2>\n<p>上节讲到事件循环分成了六个阶段，对应如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f2e34d80-c90e-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>timers 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调</li>\n<li>定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数</li>\n<li>I/O 事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些 I/O 回调</li>\n<li>闲置阶段(idle, prepare)：仅系统内部使用</li>\n<li>轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞</li>\n<li>检查阶段(check)：setImmediate() 回调函数在这里执行</li>\n<li>关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)</li>\n</ul>\n<p>每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段</p>\n<p>除了上述 6 个阶段，还存在<code>process.nextTick</code>，其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡, 即本阶段执行结束, 进入下一个阶段前, 所要执行的回调，类似插队</p>\n<p>流程图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fbe731d0-c90e-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在<code>Node</code>中，同样存在宏任务和微任务，与浏览器中的事件循环相似</p>\n<p>微任务对应有：</p>\n<ul>\n<li>next tick queue：process.nextTick</li>\n<li>other queue：Promise 的 then 回调、queueMicrotask</li>\n</ul>\n<p>宏任务对应有：</p>\n<ul>\n<li>timer queue：setTimeout、setInterval</li>\n<li>poll queue：IO 事件</li>\n<li>check queue：setImmediate</li>\n<li>close queue：close 事件</li>\n</ul>\n<p>其执行顺序为：</p>\n<ul>\n<li>next tick microtask queue</li>\n<li>other microtask queue</li>\n<li>timer queue</li>\n<li>poll queue</li>\n<li>check queue</li>\n<li>close queue</li>\n</ul>\n<h2> 三、题目</h2>\n<p>通过上面的学习，下面开始看看题目</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>分析过程：</p>\n<ul>\n<li>\n<p>先找到同步任务，输出 script start</p>\n</li>\n<li>\n<p>遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中</p>\n</li>\n<li>\n<p>遇到第二个 setTimeout，300ms 后将里面的回调函数放到 timer 队列中</p>\n</li>\n<li>\n<p>遇到第一个 setImmediate，将里面的回调函数放到 check 队列中</p>\n</li>\n<li>\n<p>遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行</p>\n</li>\n<li>\n<p>执行 async1 函数，输出 async1 start</p>\n</li>\n<li>\n<p>执行 async2 函数，输出 async2，async2 后面的输出 async1 end 进入微任务，等待下一轮的事件循环</p>\n</li>\n<li>\n<p>遇到第二个，将其里面的回调函数放到本轮同步任务执行完毕后执行</p>\n</li>\n<li>\n<p>遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2</p>\n</li>\n<li>\n<p>then 里面的回调函数进入微任务队列</p>\n</li>\n<li>\n<p>遇到同步任务，输出 script end</p>\n</li>\n<li>\n<p>执行下一轮回到函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2</p>\n</li>\n<li>\n<p>然后执行微任务队列，依次输出 async1 end、promise3</p>\n</li>\n<li>\n<p>执行 timer 队列，依次输出 setTimeout0</p>\n</li>\n<li>\n<p>接着执行 check 队列，依次输出 setImmediate</p>\n</li>\n<li>\n<p>300ms 后，timer 队列存在任务，执行输出 setTimeout2</p>\n</li>\n</ul>\n<p>执行结果如下：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最后有一道是关于<code>setTimeout</code>与<code>setImmediate</code>的输出顺序</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出情况如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>分析下流程：</p>\n<ul>\n<li>外层同步代码一次性全部执行完，遇到异步 API 就塞到对应的阶段</li>\n<li>遇到<code>setTimeout</code>，虽然设置的是 0 毫秒触发，但实际上会被强制改成 1ms，时间到了然后塞入<code>times</code>阶段</li>\n<li>遇到<code>setImmediate</code>塞入<code>check</code>阶段</li>\n<li>同步代码执行完毕，进入 Event Loop</li>\n<li>先进入<code>times</code>阶段，检查当前时间过去了 1 毫秒没有，如果过了 1 毫秒，满足<code>setTimeout</code>条件，执行回调，如果没过 1 毫秒，跳过</li>\n<li>跳过空的阶段，进入 check 阶段，执行<code>setImmediate</code>回调</li>\n</ul>\n<p>这里的关键在于这 1ms，如果同步代码执行时间较长，进入<code>Event Loop</code>的时候 1 毫秒已经过了，<code>setTimeout</code>先执行，如果 1 毫秒还没到，就先执行了<code>setImmediate</code></p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000012258592\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000012258592</a></li>\n<li><a href=\"https://juejin.cn/post/6844904100195205133\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904100195205133</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "NodeJS"
      ]
    },
    {
      "title": "如何实现文件上传？说说你的思路",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/file_upload.html",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/file_upload.html",
      "summary": "前端物语|面试物语-如何实现文件上传？说说你的思路",
      "content_html": "<h1> 如何实现文件上传？说说你的思路</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/248a5580-ce60-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>文件上传在日常开发中应用很广泛，我们发微博、发微信朋友圈都会用到了图片上传功能</p>\n<p>因为浏览器限制，浏览器不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主动授权发起来访问文件动作，然后读取文件内容进指定内存里，最后执行提交请求操作，将内存里的文件内容数据上传到服务端，服务端解析前端传来的数据信息后存入文件里</p>\n<p>对于文件上传，我们需要设置请求头为<code>content-type:multipart/form-data</code></p>\n<blockquote>\n<p>multipart 互联网上的混合资源，就是资源由多种元素组成，form-data 表示可以使用 HTML Forms 和 POST 方法上传文件</p>\n</blockquote>\n<p>结构如下：</p>\n<div class=\"language-http line-numbers-mode\" data-ext=\"http\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>boundary</code>表示分隔符，如果要上传多个表单项，就要使用<code>boundary</code>分割，每个表单项由<code>———XXX</code>开始，以<code>———XXX</code>结尾</p>\n<p>而<code>xxx</code>是即时生成的字符串，用以确保整个分隔符不会在文件或表单项的内容中出现</p>\n<p>每个表单项必须包含一个 <code>Content-Disposition</code> 头，其他的头信息则为可选项， 比如 <code>Content-Type</code></p>\n<p><code>Content-Disposition</code> 包含了 <code>type</code>和 一个名字为<code>name</code>的 <code>parameter</code>，<code>type</code> 是 <code>form-data</code>，<code>name</code>参数的值则为表单控件（也即 field）的名字，如果是文件，那么还有一个 <code>filename</code>参数，值就是文件名</p>\n<div class=\"language-kotlin line-numbers-mode\" data-ext=\"kt\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>至于使用<code>multipart/form-data</code>，是因为文件是以二进制的形式存在，其作用是专门用于传输大型二进制数据，效率高</p>\n<h3> 二、如何实现</h3>\n<p>关于文件的上传的上传，我们可以分成两步骤：</p>\n<ul>\n<li>文件的上传</li>\n<li>文件的解析</li>\n</ul>\n<h3> 文件上传</h3>\n<p>传统前端文件上传的表单结构如下：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>action</code> 就是我们的提交到的接口，<code>enctype=\"multipart/form-data\"</code> 就是指定上传文件格式，<code>input</code> 的 <code>name</code> 属性一定要等于<code>file</code></p>\n<h3> 文件解析</h3>\n<p>在服务器中，这里采用<code>koa2</code>中间件的形式解析上传的文件数据，分别有下面两种形式：</p>\n<ul>\n<li>koa-body</li>\n<li>koa-multer</li>\n</ul>\n<h4> koa-body</h4>\n<p>安装依赖</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>引入<code>koa-body</code>中间件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>获取上传的文件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>获取文件数据后，可以通过<code>fs</code>模块将文件保存到指定目录</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> koa-multer</h4>\n<p>安装依赖：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>使用 <code>multer</code> 中间件实现文件上传</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000037411957\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000037411957</a></li>\n<li><a href=\"https://www.jianshu.com/p/29e38bcc8a1d\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/29e38bcc8a1d</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-10T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "NodeJS"
      ]
    },
    {
      "title": "说说对 Node 中的 fs 模块的理解? 有哪些常用方法",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/fs.html",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/fs.html",
      "summary": "前端物语|面试物语-说说对 Node 中的 fs 模块的理解? 有哪些常用方法",
      "content_html": "<h1> 说说对 Node 中的 fs 模块的理解? 有哪些常用方法</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a141e5c0-c46a-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>fs（filesystem），该模块提供本地文件的读写能力，基本上是<code>POSIX</code>文件操作命令的简单包装</p>\n<p>可以说，所有与文件的操作都是通过<code>fs</code>核心模块实现</p>\n<p>导入模块如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这个模块对所有文件系统操作提供异步（不具有<code>sync</code> 后缀）和同步（具有 <code>sync</code> 后缀）两种操作方式，而供开发者选择</p>\n<h3> 二、文件知识</h3>\n<p>在计算机中有关于文件的知识：</p>\n<ul>\n<li>权限位 mode</li>\n<li>标识位 flag</li>\n<li>文件描述为 fd</li>\n</ul>\n<h3> 权限位 mode</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/4f4d41a0-c46b-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>针对文件所有者、文件所属组、其他用户进行权限分配，其中类型又分成读、写和执行，具备权限位 4、2、1，不具备权限为 0</p>\n<p>如在<code>linux</code>查看文件权限位：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在开头前十位中，<code>d</code>为文件夹，<code>-</code>为文件，后九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），- 代表没有当前位对应的权限</p>\n<h3> 标识位</h3>\n<p>标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>r</td>\n<td>读取文件，如果文件不存在则抛出异常。</td>\n</tr>\n<tr>\n<td>r+</td>\n<td>读取并写入文件，如果文件不存在则抛出异常。</td>\n</tr>\n<tr>\n<td>rs</td>\n<td>读取并写入文件，指示操作系统绕开本地文件系统缓存。</td>\n</tr>\n<tr>\n<td>w</td>\n<td>写入文件，文件不存在会被创建，存在则清空后写入。</td>\n</tr>\n<tr>\n<td>wx</td>\n<td>写入文件，排它方式打开。</td>\n</tr>\n<tr>\n<td>w+</td>\n<td>读取并写入文件，文件不存在则创建文件，存在则清空后写入。</td>\n</tr>\n<tr>\n<td>wx+</td>\n<td>和 w+ 类似，排他方式打开。</td>\n</tr>\n<tr>\n<td>a</td>\n<td>追加写入，文件不存在则创建文件。</td>\n</tr>\n<tr>\n<td>ax</td>\n<td>与 a 类似，排他方式打开。</td>\n</tr>\n<tr>\n<td>a+</td>\n<td>读取并追加写入，不存在则创建。</td>\n</tr>\n<tr>\n<td>ax+</td>\n<td>与 a+ 类似，排他方式打开。</td>\n</tr>\n</tbody>\n</table>\n<h3> 文件描述为 fd</h3>\n<p>操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件</p>\n<p><code>Window</code>系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，<code>NodeJS</code>抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符</p>\n<p>在 <code>NodeJS</code>中，每操作一个文件，文件描述符是递增的，文件描述符一般从 <code>3</code> 开始，因为前面有 <code>0</code>、<code>1</code>、<code>2</code>三个比较特殊的描述符，分别代表 <code>process.stdin</code>（标准输入）、<code>process.stdout</code>（标准输出）和 <code>process.stderr</code>（错误输出）</p>\n<h2> 三、方法</h2>\n<p>下面针对<code>fs</code>模块常用的方法进行展开：</p>\n<ul>\n<li>文件读取</li>\n<li>文件写入</li>\n<li>文件追加写入</li>\n<li>文件拷贝</li>\n<li>创建目录</li>\n</ul>\n<h3> 文件读取</h3>\n<h4> fs.readFileSync</h4>\n<p>同步读取，参数如下：</p>\n<ul>\n<li>第一个参数为读取文件的路径或文件描述符</li>\n<li>第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding</li>\n</ul>\n<p>结果为返回文件的内容</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> fs.readFile</h4>\n<p>异步读取方法 <code>readFile</code> 与 <code>readFileSync</code> 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 <code>err</code>（错误）和 <code>data</code>（数据），该方法没有返回值，回调函数在读取文件成功后执行</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 文件写入</h3>\n<h4> writeFileSync</h4>\n<p>同步写入，有三个参数：</p>\n<ul>\n<li>\n<p>第一个参数为写入文件的路径或文件描述符</p>\n</li>\n<li>\n<p>第二个参数为写入的数据，类型为 String 或 Buffer</p>\n</li>\n<li>\n<p>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> writeFile</h4>\n<p>异步写入，<code>writeFile</code> 与 <code>writeFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件写入数据成功后执行</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 文件追加写入</h3>\n<h4> appendFileSync</h4>\n<p>参数如下：</p>\n<ul>\n<li>第一个参数为写入文件的路径或文件描述符</li>\n<li>第二个参数为写入的数据，类型为 String 或 Buffer</li>\n<li>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> appendFile</h4>\n<p>异步追加写入方法 <code>appendFile</code> 与 <code>appendFileSync</code> 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数 <code>err</code>（错误），回调函数在文件追加写入数据成功后执行</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 文件拷贝</h3>\n<h4> copyFileSync</h4>\n<p>同步拷贝</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> copyFile</h4>\n<p>异步拷贝</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 创建目录</h3>\n<h4> mkdirSync</h4>\n<p>同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> mkdir</h4>\n<p>异步创建，第二个参数为回调函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li>\n<p><a href=\"http://nodejs.cn/api/fs.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://nodejs.cn/api/fs.html</a></p>\n</li>\n<li>\n<p><a href=\"https://segmentfault.com/a/1190000019913303\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000019913303</a></p>\n</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "NodeJS"
      ]
    },
    {
      "title": "说说 Node. js 有哪些全局对象？",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/global.html",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/global.html",
      "summary": "前端物语|面试物语-说说 Node. js 有哪些全局对象？",
      "content_html": "<h1> 说说 Node. js 有哪些全局对象？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/79c7b100-c2a3-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在浏览器 <code>JavaScript</code> 中，通常<code>window</code> 是全局对象， 而 <code>Nodejs</code>中的全局对象是 <code>global</code></p>\n<p>在<code>NodeJS</code>里，是不可能在最外层定义一个变量，因为所有的用户代码都是当前模块的，只在当前模块里可用，但可以通过<code>exports</code>对象的使用将其传递给模块外部</p>\n<p>所以，在<code>NodeJS</code>中，用<code>var</code>声明的变量并不属于全局的变量，只在当前模块生效</p>\n<p>像上述的<code>global</code>全局对象则在全局作用域中，任何全局变量、函数、对象都是该对象的一个属性值</p>\n<h2> 二、有哪些</h2>\n<p>将全局对象分成两类：</p>\n<ul>\n<li>\n<p>真正的全局对象</p>\n</li>\n<li>\n<p>模块级别的全局变量</p>\n</li>\n</ul>\n<h3> 真正的全局对象</h3>\n<p>下面给出一些常见的全局对象：</p>\n<ul>\n<li>\n<p>Class:Buffer</p>\n</li>\n<li>\n<p>process</p>\n</li>\n<li>\n<p>console</p>\n</li>\n<li>\n<p>clearInterval、setInterval</p>\n</li>\n<li>\n<p>clearTimeout、setTimeout</p>\n</li>\n<li>\n<p>global</p>\n</li>\n</ul>\n<h4> Class:Buffer</h4>\n<p>可以处理二进制以及非<code>Unicode</code>编码的数据</p>\n<p>在<code>Buffer</code>类实例化中存储了原始数据。<code>Buffer</code>类似于一个整数数组，在 V8 堆原始存储空间给它分配了内存</p>\n<p>一旦创建了<code>Buffer</code>实例，则无法改变大小</p>\n<h4> process</h4>\n<p>进程对象，提供有关当前进程的信息和控制</p>\n<p>包括在执行<code>node</code>程序进程时，如果需要传递参数，我们想要获取这个参数需要在<code>process</code>内置对象中</p>\n<p>启动进程：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>index.js 文件如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>除此之外，还包括一些其他信息如版本、操作系统等</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/85f473a0-c2a3-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h4> console</h4>\n<p>用来打印<code>stdout</code>和<code>stderr</code></p>\n<p>最常用的输入内容的方式：console.log</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>清空控制台：console.clear</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>打印函数的调用栈：console.trace</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/91b6dbb0-c2a3-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h4> clearInterval、setInterval</h4>\n<p>设置定时器与清除定时器</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>callback</code>每<code>delay</code>毫秒重复执行一次</p>\n<p><code>clearInterval</code>则为对应发取消定时器的方法</p>\n<h4> clearTimeout、setTimeout</h4>\n<p>设置延时器与清除延时器</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>callback</code>在<code>delay</code>毫秒后执行一次</p>\n<p><code>clearTimeout</code>则为对应取消延时器的方法</p>\n<h4> global</h4>\n<p>全局命名空间对象，墙面讲到的<code>process</code>、<code>console</code>、<code>setTimeout</code>等都有放到<code>global</code>中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 模块级别的全局对象</h3>\n<p>这些全局对象是模块中的变量，只是每个模块都有，看起来就像全局变量，像在命令交互中是不可以使用，包括：</p>\n<ul>\n<li>__dirname</li>\n<li>__filename</li>\n<li>exports</li>\n<li>module</li>\n<li>require</li>\n</ul>\n<h4> __dirname</h4>\n<p>获取当前文件所在的路径，不包括后面的文件名</p>\n<p>从 <code>/Users/mjr</code> 运行 <code>node example.js</code>：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> __filename</h4>\n<p>获取当前文件所在的路径和文件名称，包括后面的文件名称</p>\n<p>从 <code>/Users/mjr</code> 运行 <code>node example.js</code>：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> exports</h4>\n<p><code>module.exports</code> 用于指定一个模块所导出的内容，即可以通过 <code>require()</code> 访问的内容</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> module</h4>\n<p>对当前模块的引用，通过<code>module.exports</code> 用于指定一个模块所导出的内容，即可以通过 <code>require()</code> 访问的内容</p>\n<h4> require</h4>\n<p>用于引入模块、 <code>JSON</code>、或本地文件。 可以从 <code>node_modules</code> 引入模块。</p>\n<p>可以使用相对路径引入本地模块或<code>JSON</code>文件，路径会根据<code>__dirname</code>定义的目录名或当前工作目录进行处理</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"http://nodejs.cn/api/globals.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://nodejs.cn/api/globals.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-05T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "NodeJS"
      ]
    },
    {
      "title": "如何实现 jwt 鉴权机制？说说你的思路",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/jwt.html",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/jwt.html",
      "summary": "前端物语|面试物语-如何实现 jwt 鉴权机制？说说你的思路",
      "content_html": "<h1> 如何实现 jwt 鉴权机制？说说你的思路</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/efff62b0-cd88-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>JWT（JSON Web Token），本质就是一个字符串书写规范，如下图，作用是用来在用户和服务器之间传递安全可靠的信息</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/052904c0-cd89-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在目前前后端分离的开发过程中，使用<code>token</code>鉴权机制用于身份验证是最常见的方案，流程如下：</p>\n<ul>\n<li>服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证</li>\n<li>后续访问会根据这个令牌判断用户时候有权限进行访问</li>\n</ul>\n<p><code>Token</code>，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以<code>.</code>进行拼接。其中头部和载荷都是以<code>JSON</code>格式存放数据，只是进行了编码</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1175f990-cd89-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> header</h3>\n<p>每个 JWT 都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为<code>alg</code>，同时还有一个<code>typ</code>的字段，默认<code>JWT</code>即可。以下示例中算法为 HS256</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>因为 JWT 是字符串，所以我们还需要对以上内容进行 Base64 编码，编码后字符串如下：</p>\n<div class=\"language-tex line-numbers-mode\" data-ext=\"tex\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> payload</h3>\n<p>载荷即消息体，这里会存放实际的内容，也就是<code>Token</code>的数据声明，例如用户的<code>id</code>和<code>name</code>，默认情况下也会携带令牌的签发时间<code>iat</code>，通过还可以设置过期时间，如下：</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同样进行 Base64 编码后，字符串如下：</p>\n<div class=\"language-tex line-numbers-mode\" data-ext=\"tex\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> Signature</h3>\n<p>签名是对头部和载荷内容进行签名，一般情况，设置一个<code>secretKey</code>，对前两个的结果进行<code>HMACSHA25</code>算法，公式如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致</p>\n<h2> 二、如何实现</h2>\n<p><code>Token</code>的使用分成了两部分：</p>\n<ul>\n<li>生成 token：登录成功的时候，颁发 token</li>\n<li>验证 token：访问某些资源或者接口时，验证 token</li>\n</ul>\n<h3> 生成 token</h3>\n<p>借助第三方库<code>jsonwebtoken</code>，通过<code>jsonwebtoken</code> 的 <code>sign</code> 方法生成一个 <code>token</code>：</p>\n<ul>\n<li>\n<p>第一个参数指的是 Payload</p>\n</li>\n<li>\n<p>第二个是秘钥，服务端特有</p>\n</li>\n<li>\n<p>第三个参数是 option，可以定义 token 过期时间</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在前端接收到<code>token</code>后，一般情况会通过<code>localStorage</code>进行缓存，然后将<code>token</code>放到<code>HTTP</code>请求头<code>Authorization</code> 中，关于<code>Authorization</code> 的设置，前面要加上 Bearer ，注意后面带有空格</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 校验 token</h3>\n<p>使用 <code>koa-jwt</code> 中间件进行验证，方式比较简单</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>secret 必须和 sign 时候保持一致</li>\n<li>可以通过 unless 配置接口白名单，也就是哪些 URL 可以不用经过校验，像登陆/注册都可以不用校验</li>\n<li>校验的中间件需要放在需要校验的路由前面，无法对前面的 URL 进行校验</li>\n</ul>\n<p>获取<code>token</code>用户的信息方法如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：上述的<code>HMA256</code>加密算法为单秘钥的形式，一旦泄露后果非常的危险</p>\n<p>在分布式系统中，每个子系统都要获取到秘钥，那么这个子系统根据该秘钥可以发布和验证令牌，但有些服务器只需要验证令牌</p>\n<p>这时候可以采用非对称加密，利用私钥发布令牌，公钥验证令牌，加密算法可以选择<code>RS256</code></p>\n<h2> 三、优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>json 具有通用性，所以可以跨语言</li>\n<li>组成简单，字节占用小，便于传输</li>\n<li>服务端无需保存会话信息，很容易进行水平扩展</li>\n<li>一处生成，多处使用，可以在分布式系统中，解决单点登录问题</li>\n<li>可防护 CSRF 攻击</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>payload 部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息</li>\n<li>需要保护好加密密钥，一旦泄露后果不堪设想</li>\n<li>为避免 token 被劫持，最好使用 https 协议</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></li>\n<li><a href=\"https://blog.wangjunfeng.com/post/golang-jwt/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.wangjunfeng.com/post/golang-jwt/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "NodeJS"
      ]
    },
    {
      "title": "说说对中间件概念的理解，如何封装 node 中间件？",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/middleware.html",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/middleware.html",
      "summary": "前端物语|面试物语-说说对中间件概念的理解，如何封装 node 中间件？",
      "content_html": "<h1> 说说对中间件概念的理解，如何封装 node 中间件？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/614ae480-cce4-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的</p>\n<p>在<code>NodeJS</code>中，中间件主要是指封装<code>http</code>请求细节处理的方法</p>\n<p>例如在<code>express</code>、<code>koa</code>等<code>web</code>框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6a6ed3f0-cce4-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作</p>\n<h2> 二、封装</h2>\n<p><code>koa</code>是基于<code>NodeJS</code>当前比较流行的<code>web</code>框架，本身支持的功能并不多，功能都可以通过中间件拓展实现。通过添加不同的中间件，实现不同的需求，从而构建一个 <code>Koa</code> 应用</p>\n<p><code>Koa</code> 中间件采用的是洋葱圈模型，每次执行下一个中间件传入两个参数：</p>\n<ul>\n<li>ctx ：封装了 request 和 response 的变量</li>\n<li>next ：进入下一个要执行的中间件的函数</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7507b020-cce4-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>下面就针对<code>koa</code>进行中间件的封装：</p>\n<p><code>Koa</code>的中间件就是函数，可以是<code>async</code> 函数，或是普通函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面则通过中间件封装<code>http</code>请求过程中几个常用的功能：</p>\n<h3> token 校验</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 日志模块</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Koa</code>存在很多第三方的中间件，如<code>koa-bodyparser</code>、<code>koa-static</code>等</p>\n<p>下面再来看看它们的大体的简单实现：</p>\n<h3> koa-bodyparser</h3>\n<p><code>koa-bodyparser</code> 中间件是将我们的 <code>post</code> 请求和表单提交的查询字符串转换成对象，并挂在 <code>ctx.request.body</code> 上，方便我们在其他中间件或接口处取值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> koa-static</h3>\n<p><code>koa-static</code> 中间件的作用是在服务器接到请求时，帮我们处理静态文件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、总结</h2>\n<p>在实现中间件时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据</p>\n<p><code>koa</code>本身比较简洁，但是通过中间件的机制能够实现各种所需要的功能，使得<code>web</code>应用具备良好的可拓展性和组合性</p>\n<p>通过将公共逻辑的处理编写在中间件中，可以不用在每一个接口回调中做相同的代码编写，减少了冗杂代码，过程就如装饰者模式</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000017897279\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000017897279</a></li>\n<li><a href=\"https://www.jianshu.com/p/81b6ebc0dd85\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/81b6ebc0dd85</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/中间件</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "NodeJS"
      ]
    },
    {
      "title": "说说你对 Node.js 的理解？优缺点？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/nodejs.html",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/nodejs.html",
      "summary": "前端物语|面试物语-说说你对 Node.js 的理解？优缺点？应用场景？",
      "content_html": "<h1> 说说你对 Node.js 的理解？优缺点？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b565d240-c1e6-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>Node.js</code> 是一个开源与跨平台的 <code>JavaScript</code> 运行时环境</p>\n<p>在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核），利用事件驱动、非阻塞和异步输入输出模型等技术提高性能</p>\n<p>可以理解为 <code>Node.js</code> 就是一个服务器端的、非阻塞式 I/O 的、事件驱动的<code>JavaScript</code>运行环境</p>\n<h3> 非阻塞异步</h3>\n<p><code>Nodejs</code>采用了非阻塞型<code>I/O</code>机制，在做<code>I/O</code>操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作</p>\n<p>例如在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率</p>\n<h3> 事件驱动</h3>\n<p>事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数</p>\n<p>比如读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a7729590-c1e8-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>处理高并发场景性能更佳</li>\n<li>适合 I/O 密集型应用，值的是应用在运行极限时，CPU 占用率仍然比较低，大部分时间是在做 I/O 硬盘内存读写操作</li>\n</ul>\n<p>因为<code>Nodejs</code>是单线程，带来的缺点有：</p>\n<ul>\n<li>不适合 CPU 密集型应用</li>\n<li>只支持单核 CPU，不能充分利用 CPU</li>\n<li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li>\n</ul>\n<h2> 三、应用场景</h2>\n<p>借助<code>Nodejs</code>的特点和弊端，其应用场景分类如下：</p>\n<ul>\n<li>善于<code>I/O</code>，不善于计算。因为 Nodejs 是一个单线程，如果计算（同步）太多，则会阻塞这个线程</li>\n<li>大量并发的 I/O，应用程序内部并不需要进行非常复杂的处理</li>\n<li>与 websocket 配合，开发长连接的实时交互应用程序</li>\n</ul>\n<p>具体场景可以表现为如下：</p>\n<ul>\n<li>第一大类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的 web 应用程序</li>\n<li>第二大类：基于 web、canvas 等多人联网游戏</li>\n<li>第三大类：基于 web 的多人实时聊天客户端、聊天室、图文直播</li>\n<li>第四大类：单页面浏览器应用程序</li>\n<li>第五大类：操作数据库、为前端和移动端提供基于<code>json</code>的 API</li>\n</ul>\n<p>其实，<code>Nodejs</code>能实现几乎一切的应用，只考虑适不适合使用它</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"noopener noreferrer\">http://nodejs.cn/</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000019854308\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000019854308</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000005173218\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000005173218</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "NodeJS"
      ]
    },
    {
      "title": "如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/paging.html",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/paging.html",
      "summary": "前端物语|面试物语-如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?",
      "content_html": "<h1> 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/54b0a390-cf14-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在我们做数据查询的时候，如果数据量很大，比如几万条数据，放在一个页面显示的话显然不友好，这时候就需要采用分页显示的形式，如每次只显示 10 条数据</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6070e8c0-cf14-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>要实现分页功能，实际上就是从结果集中显示第 1~10 条记录作为第 1 页，显示第 11~20 条记录作为第 2 页，以此类推</p>\n<p>因此，分页实际上就是从结果集中截取出第 M~N 条记录</p>\n<h2> 二、如何实现</h2>\n<p>前端实现分页功能，需要后端返回必要的数据，如总的页数，总的数据量，当前页，当前的数据</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>后端采用<code>mysql</code>作为数据的持久性存储</p>\n<p>前端向后端发送目标的页码<code>page</code>以及每页显示数据的数量<code>pageSize</code>，默认情况每次取 10 条数据，则每一条数据的起始位置<code>start</code>为：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>当确定了<code>limit</code>和<code>start</code>的值后，就能够确定<code>SQL</code>语句：</p>\n<div class=\"language-JS line-numbers-mode\" data-ext=\"JS\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>上诉<code>SQL</code>语句表达的意思为：截取从<code>start</code>到<code>start</code>+<code>pageSize</code>之间（左闭右开）的数据</p>\n<p>关于查询数据总数的<code>SQL</code>语句为，<code>record</code>为表名：</p>\n<div class=\"language-mysql line-numbers-mode\" data-ext=\"mysql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>因此后端的处理逻辑为：</p>\n<ul>\n<li>获取用户参数页码数 page 和每页显示的数目 pageSize ，其中 page 是必须传递的参数，pageSize 为可选参数，默认为 10</li>\n<li>编写 SQL 语句，利用 limit 和 OFFSET 关键字进行分页查询</li>\n<li>查询数据库，返回总数据量、总页数、当前页、当前页数据给前端</li>\n</ul>\n<p>代码如下所示：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、总结</h2>\n<p>通过上面的分析，可以看到分页查询的关键在于，要首先确定每页显示的数量<code>pageSize</code>，然后根据当前页的索引<code>pageIndex</code>（从 1 开始），确定<code>LIMIT</code>和<code>OFFSET</code>应该设定的值：</p>\n<ul>\n<li>LIMIT 总是设定为 pageSize</li>\n<li>OFFSET 计算公式为 pageSize * (pageIndex - 1)</li>\n</ul>\n<p>确定了这两个值，就能查询出第 <code>N</code>页的数据</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1177760294764384/1217864791925600\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.liaoxuefeng.com/wiki/1177760294764384/1217864791925600</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-22T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "NodeJS"
      ]
    },
    {
      "title": "Node 性能如何进行监控以及优化？",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/performance.html",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/performance.html",
      "summary": "前端物语|面试物语-Node 性能如何进行监控以及优化？",
      "content_html": "<h1> Node 性能如何进行监控以及优化？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bb37dae0-d179-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、 是什么</h2>\n<p><code>Node</code>作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下：</p>\n<ul>\n<li>CPU</li>\n<li>内存</li>\n<li>I/O</li>\n<li>网络</li>\n</ul>\n<h3> CPU</h3>\n<p>主要分成了两部分：</p>\n<ul>\n<li>CPU 负载：在某个时间段内，占用以及等待 CPU 的进程总数</li>\n<li>CPU 使用率：CPU 时间占用状况，等于 1 - 空闲 CPU 时间(idle time) / CPU 总时间</li>\n</ul>\n<p>这两个指标都是用来评估系统当前 CPU 的繁忙程度的量化指标</p>\n<p><code>Node</code>应用一般不会消耗很多的<code>CPU</code>，如果<code>CPU</code>占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞</p>\n<h3> 内存指标</h3>\n<p>内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于 Node 来说，内部内存堆栈的使用状态也是一个可以量化的指标</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>rss：表示 node 进程占用的内存总量。</li>\n<li>heapTotal：表示堆内存的总量。</li>\n<li>heapUsed：实际堆内存的使用量。</li>\n<li>external ：外部程序的内存使用量，包含 Node 核心的 C++程序的内存使用量</li>\n</ul>\n<p>在<code>Node</code>中，一个进程的最大内存容量为 1.5GB。因此我们需要减少内存泄露</p>\n<h3> 磁盘 I/O</h3>\n<p>硬盘的<code>IO</code> 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍</p>\n<p>内存 <code>IO</code>比磁盘<code>IO</code> 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 <code>redis</code>、<code>memcached</code>等</p>\n<p>并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决</p>\n<h2> 二、如何监控</h2>\n<p>关于性能方面的监控，一般情况都需要借助工具来实现</p>\n<p>这里采用<code>Easy-Monitor 2.0</code>，其是轻量级的 <code>Node.js</code> 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 <code>require</code> 一次，无需改动任何业务代码即可开启内核级别的性能监控分析</p>\n<p>使用方法如下：</p>\n<p>在你的项目入口文件中按照如下方式引入，当然请传入你的项目名称：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>打开你的浏览器，访问 <code>http://localhost:12333</code> ，即可看到进程界面</p>\n<p>关于定制化开发、通用配置项以及如何动态更新配置项详见官方文档</p>\n<h2> 三、如何优化</h2>\n<p>关于<code>Node</code>的性能优化的方式有：</p>\n<ul>\n<li>使用最新版本 Node.js</li>\n<li>正确使用流 Stream</li>\n<li>代码层面优化</li>\n<li>内存管理优化</li>\n</ul>\n<h3> 使用最新版本 Node.js</h3>\n<p>每个版本的性能提升主要来自于两个方面：</p>\n<ul>\n<li>V8 的版本更新</li>\n<li>Node.js 内部代码的更新优化</li>\n</ul>\n<h3> 正确使用流 Stream</h3>\n<p>在<code>Node</code>中，很多对象都实现了流，对于一个大文件可以通过流的形式发送，不需要将其完全读入内存</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 代码层面优化</h3>\n<p>合并查询，将多次查询合并一次，减少数据库的查询次数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 内存管理优化</h3>\n<p>在 V8 中，主要将内存分为新生代和老生代两代：</p>\n<ul>\n<li>新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象</li>\n<li>老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象</li>\n</ul>\n<p>若新生代内存空间不够，直接分配到老生代</p>\n<p>通过减少内存占用，可以提高服务器的性能。如果有内存泄露，也会导致大量的对象存储到老生代中，服务器性能会大大降低</p>\n<p>如下面情况：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>leak</code>的内存非常大，造成内存泄露，应当避免这样的操作，通过减少内存使用，是提高服务性能的手段之一</p>\n<p>而节省内存最好的方式是使用池，其将频用、可复用对象存储起来，减少创建和销毁操作</p>\n<p>例如有个图片请求接口，每次请求，都需要用到类。若每次都需要重新 new 这些类，并不是很合适，在大量请求时，频繁创建和销毁这些类，造成内存抖动</p>\n<p>使用对象池的机制，对这种频繁需要创建和销毁的对象保存在一个对象池中。每次用到该对象时，就取对象池空闲的对象，并对它进行初始化操作，从而提高框架的性能</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000039327565\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000039327565</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/50055740\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/50055740</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000010231628\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000010231628</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-21T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "NodeJS"
      ]
    },
    {
      "title": "说说对 Node 中的 process 的理解？有哪些常用方法？",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/process.html",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/process.html",
      "summary": "前端物语|面试物语-说说对 Node 中的 process 的理解？有哪些常用方法？",
      "content_html": "<h1> 说说对 Node 中的 process 的理解？有哪些常用方法？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/4f7866b0-c2b2-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>process</code> 对象是一个全局变量，提供了有关当前 <code>Node.js</code>进程的信息并对其进行控制，作为一个全局变量</p>\n<p>我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器</p>\n<p>当我们启动一个<code>js</code>文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享</p>\n<p>由于<code>JavaScript</code>是一个单线程语言，所以通过<code>node xxx</code>启动一个文件后，只有一条主线程</p>\n<h2> 二、属性与方法</h2>\n<p>关于<code>process</code>常见的属性有如下：</p>\n<ul>\n<li>process.env：环境变量，例如通过 `process.env.NODE_ENV 获取不同环境项目配置信息</li>\n<li>process.nextTick：这个在谈及 <code>EventLoop</code> 时经常为会提到</li>\n<li>process.pid：获取当前进程 id</li>\n<li>process.ppid：当前进程对应的父进程</li>\n<li>process.cwd()：获取当前进程工作目录，</li>\n<li>process.platform：获取当前进程运行的操作系统平台</li>\n<li>process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值</li>\n<li>进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听</li>\n<li>三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出</li>\n<li>process.title 指定进程名称，有的时候需要给进程指定一个名称</li>\n</ul>\n<p>下面再稍微介绍下某些方法的使用：</p>\n<h3> process.cwd()</h3>\n<p>返回当前 <code>Node</code>进程执行的目录</p>\n<p>一个<code>Node</code> 模块 <code>A</code> 通过 NPM 发布，项目 <code>B</code> 中使用了模块 <code>A</code>。在 <code>A</code> 中需要操作 <code>B</code> 项目下的文件时，就可以用 <code>process.cwd()</code> 来获取 <code>B</code> 项目的路径</p>\n<h3> process.argv</h3>\n<p>在终端通过 Node 执行命令的时候，通过 <code>process.argv</code> 可以获取传入的命令行参数，返回值是一个数组：</p>\n<ul>\n<li>0: Node 路径（一般用不到，直接忽略）</li>\n<li>1: 被执行的 JS 文件路径（一般用不到，直接忽略）</li>\n<li>2~n: 真实传入命令的参数</li>\n</ul>\n<p>所以，我们只要从 <code>process.argv[2]</code> 开始获取就好了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> process.env</h3>\n<p>返回一个对象，存储当前环境相关的所有信息，一般很少直接用到。</p>\n<p>一般我们会在 <code>process.env</code> 上挂载一些变量标识当前的环境。比如最常见的用 <code>process.env.NODE_ENV</code> 区分 <code>development</code> 和 <code>production</code></p>\n<p>在 <code>vue-cli</code> 的源码中也经常会看到 <code>process.env.VUE_CLI_DEBUG</code> 标识当前是不是 <code>DEBUG</code> 模式</p>\n<h3> process.nextTick()</h3>\n<p>我们知道<code>NodeJs</code>是基于事件轮询，在这个过程中，同一时间只会处理一件事情</p>\n<p>在这种处理模式下，<code>process.nextTick()</code>就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行</p>\n<p>例如下面例子将一个<code>foo</code>函数在下一个时间点调用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果为<code>bar</code>、<code>foo</code></p>\n<p>虽然下述方式也能实现同样效果：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>两者区别在于：</p>\n<ul>\n<li>process.nextTick()会在这一次 event loop 的 call stack 清空后（下一次 event loop 开始前）再调用 callback</li>\n<li>setTimeout()是并不知道什么时候 call stack 清空的，所以何时调用 callback 函数是不确定的</li>\n</ul>\n<h3> 参考文献</h3>\n<ul>\n<li><a href=\"http://nodejs.cn/api/process.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://nodejs.cn/api/process.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-16T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "NodeJS"
      ]
    },
    {
      "title": "说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?",
      "url": "https://www.h7ml.cn/posts/interview/NodeJS/require_order.html",
      "id": "https://www.h7ml.cn/posts/interview/NodeJS/require_order.html",
      "summary": "前端物语|面试物语-说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?",
      "content_html": "<h1> 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/15913530-c9ba-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、模块规范</h2>\n<p><code>NodeJS</code>对<code>CommonJS</code>进行了支持和实现，让我们在开发<code>node</code>的过程中可以方便的进行模块化开发：</p>\n<ul>\n<li>在 Node 中每一个 js 文件都是一个单独的模块</li>\n<li>模块中包括 CommonJS 规范的核心变量：exports、module.exports、require</li>\n<li>通过上述变量进行模块化开发</li>\n</ul>\n<p>而模块化的核心是导出与导入，在<code>Node</code>中通过<code>exports</code>与<code>module.exports</code>负责对模块中的内容进行导出，通过<code>require</code>函数导入其他模块（自定义模块、系统模块、第三方库模块）中的内容</p>\n<h2> 二、查找策略</h2>\n<p><code>require</code>方法接收一下几种参数的传递：</p>\n<ul>\n<li>原生模块：http、fs、path 等</li>\n<li>相对路径的文件模块：./mod 或../mod</li>\n<li>绝对路径的文件模块：/pathtomodule/mod</li>\n<li>目录作为模块：./dirname</li>\n<li>非原生模块的文件模块：mod</li>\n</ul>\n<p><code>require</code>参数较为简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/33ae8ef0-c9ba-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从上图可以看见，文件模块存在缓存区，寻找模块路径的时候都会优先从缓存中加载已经存在的模块</p>\n<h3> 原生模块</h3>\n<p>而像原生模块这些，通过<code>require</code>方法在解析文件名之后，优先检查模块是否在原生模块列表中，如果在则从原生模块中加载</p>\n<h3> 绝对路径、相对路径</h3>\n<p>如果<code>require</code>绝对路径的文件，则直接查找对应的路径，速度最快</p>\n<p>相对路径的模块则相对于当前调用<code>require</code>的文件去查找</p>\n<p>如果按确切的文件名没有找到模块，则 <code>NodeJs</code> 会尝试带上 <code>.js</code>、<code>.json</code>或 <code>.node</code>拓展名再加载</p>\n<h3> 目录作为模块</h3>\n<p>默认情况是根据根目录中<code>package.json</code>文件的<code>main</code>来指定目录模块，如：</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果这是在<code>./some-library node_modules</code>目录中，则 <code>require('./some-library')</code> 会试图加载 <code>./some-library/main.js</code></p>\n<p>如果目录里没有 <code>package.json</code>文件，或者 <code>main</code>入口不存在或无法解析，则会试图加载目录下的 <code>index.js</code> 或 <code>index.node</code> 文件</p>\n<h3> 非原生模块</h3>\n<p>在每个文件中都存在<code>module.paths</code>，表示模块的搜索路径，<code>require</code>就是根据其来寻找文件</p>\n<p>在<code>window</code>下输出如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>可以看出<code>module path</code>的生成规则为：从当前文件目录开始查找<code>node_modules</code>目录；然后依次进入父目录，查找父目录下的<code>node_modules</code>目录，依次迭代，直到根目录下的<code>node_modules</code>目录</p>\n<p>当都找不到的时候，则会从系统<code>NODE_PATH</code>环境变量查找</p>\n<h4> 举个例子</h4>\n<p>如果在<code>/home/ry/projects/foo.js</code>文件里调用了 <code>require('bar.js')</code>，则 Node.js 会按以下顺序查找：</p>\n<ul>\n<li>/home/ry/projects/node_modules/bar.js</li>\n<li>/home/ry/node_modules/bar.js</li>\n<li>/home/node_modules/bar.js</li>\n<li>/node_modules/bar.js</li>\n</ul>\n<p>这使得程序本地化它们的依赖，避免它们产生冲突</p>\n<h2> 三、总结</h2>\n<p>通过上面模块的文件查找策略之后，总结下文件查找的优先级：</p>\n<ul>\n<li>\n<p>缓存的模块优先级最高</p>\n</li>\n<li>\n<p>如果是内置模块，则直接返回，优先级仅次缓存的模块</p>\n</li>\n<li>\n<p>如果是绝对路径 / 开头，则从根目录找</p>\n</li>\n<li>\n<p>如果是相对路径 ./开头，则从当前 require 文件相对位置找</p>\n</li>\n<li>\n<p>如果文件没有携带后缀，先从 js、json、node 按顺序查找</p>\n</li>\n<li>\n<p>如果是目录，则根据 package.json 的 main 属性值决定目录下入口文件，默认情况为 index.js</p>\n</li>\n<li>\n<p>如果文件为第三方模块，则会引入 node_modules 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"http://nodejs.cn/api/modules.html#modules_file_modules\" target=\"_blank\" rel=\"noopener noreferrer\">http://nodejs.cn/api/modules.html#modules_file_modules</a></li>\n<li><a href=\"https://blog.csdn.net/qq_36801250/article/details/106352686\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/qq_36801250/article/details/106352686</a></li>\n<li><a href=\"https://www.cnblogs.com/samve/p/10805908.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/samve/p/10805908.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-08T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "NodeJS"
      ]
    },
    {
      "title": "React 事件绑定的方式有哪些？区别？",
      "url": "https://www.h7ml.cn/posts/interview/React/Binding_events.html",
      "id": "https://www.h7ml.cn/posts/interview/React/Binding_events.html",
      "summary": "前端物语|面试物语-React 事件绑定的方式有哪些？区别？",
      "content_html": "<h1> React 事件绑定的方式有哪些？区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e21f5560-d8fa-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在<code>react</code>应用中，事件名都是用小驼峰格式进行书写，例如<code>onclick</code>要改写成<code>onClick</code></p>\n<p>最简单的事件绑定如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面可以看到，事件绑定的方法需要使用<code>{}</code>包住</p>\n<p>上述的代码看似没有问题，但是当将处理函数输出代码换成<code>console.log(this)</code>的时候，点击按钮，则会发现控制台输出<code>undefined</code></p>\n<h2> 二、如何绑定</h2>\n<p>为了解决上面正确输出<code>this</code>的问题，常见的绑定方式有如下：</p>\n<ul>\n<li>render 方法中使用 bind</li>\n<li>render 方法中使用箭头函数</li>\n<li>constructor 中 bind</li>\n<li>定义阶段使用箭头函数绑定</li>\n</ul>\n<h3> render 方法中使用 bind</h3>\n<p>如果使用一个类组件，在其中给某个组件/元素一个<code>onClick</code>属性，它现在并会自定绑定其<code>this</code>到当前组件，解决这个问题的方法是在事件函数后使用<code>.bind(this)</code>将<code>this</code>绑定到当前组件中</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种方式在组件每次<code>render</code>渲染的时候，都会重新进行<code>bind</code>的操作，影响性能</p>\n<h3> render 方法中使用箭头函数</h3>\n<p>通过<code>ES6</code>的上下文来将<code>this</code>的指向绑定给当前组件，同样再每一次<code>render</code>的时候都会生成新的方法，影响性能</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> constructor 中 bind</h2>\n<p>在<code>constructor</code>中预先<code>bind</code>当前组件，可以避免在<code>render</code>操作中重复绑定</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 定义阶段使用箭头函数绑定</h3>\n<p>跟上述方式三一样，能够避免在<code>render</code>操作中重复绑定，实现也非常的简单，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、区别</h2>\n<p>上述四种方法的方式，区别主要如下：</p>\n<ul>\n<li>编写方面：方式一、方式二写法简单，方式三的编写过于冗杂</li>\n<li>性能方面：方式一和方式二在每次组件 render 的时候都会生成新的方法实例，性能问题欠缺。若该函数作为属性值传给子组件的时候，都会导致额外的渲染。而方式三、方式四只会生成一个方法实例</li>\n</ul>\n<p>综合上述，方式四是最优的事件绑定方式</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000011317515\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000011317515</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-04T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "React 构建组件的方式有哪些？区别？",
      "url": "https://www.h7ml.cn/posts/interview/React/Building_components.html",
      "id": "https://www.h7ml.cn/posts/interview/React/Building_components.html",
      "summary": "前端物语|面试物语-React 构建组件的方式有哪些？区别？",
      "content_html": "<h1> React 构建组件的方式有哪些？区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/04355cb0-da10-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式</p>\n<p>在<code>React</code>中，一个类、一个函数都可以视为一个组件</p>\n<p>在<a href=\"https://mp.weixin.qq.com/s/Wi0r38LBopsyQ9HesMID0g\" target=\"_blank\" rel=\"noopener noreferrer\">之前文章</a>中，我们了解到组件所存在的优势：</p>\n<ul>\n<li>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</li>\n<li>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</li>\n<li>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</li>\n</ul>\n<h2> 二、如何构建</h2>\n<p>在<code>React</code>目前来讲，组件的创建主要分成了三种方式：</p>\n<ul>\n<li>函数式创建</li>\n<li>通过 React.createClass 方法创建</li>\n<li>继承 React.Component 创建</li>\n</ul>\n<h3> 函数式创建</h3>\n<p>在<code>React Hooks</code>出来之前，函数式组件可以视为无状态组件，只负责根据传入的<code>props</code>来展示视图，不涉及对<code>state</code>状态的操作</p>\n<p>大多数组件可以写为无状态组件，通过简单组合构建其他组件</p>\n<p>在<code>React</code>中，通过函数简单创建组件的示例如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 通过 React.createClass 方法创建</h3>\n<p><code>React.createClass</code>是 react 刚开始推荐的创建组件的方式，目前这种创建方式已经不怎么用了</p>\n<p>像上述通过函数式创建的组件的方式，最终会通过<code>babel</code>转化成<code>React.createClass</code>这种形式，转化成如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>由于上述的编写方式过于冗杂，目前基本上不使用上</p>\n<h3> 继承 React.Component 创建</h3>\n<p>同样在<code>react hooks</code>出来之前，有状态的组件只能通过继承<code>React.Component</code>这种形式进行创建</p>\n<p>有状态的组件也就是组件内部存在维护的数据，在类创建的方式中通过<code>this.state</code>进行访问</p>\n<p>当调用<code>this.setState</code>修改组件的状态时，组价会再次会调用<code>render()</code>方法进行重新渲染</p>\n<p>通过继承<code>React.Component</code>创建一个时钟示例如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、区别</h2>\n<p>由于<code>React.createClass</code>创建的方式过于冗杂，并不建议使用</p>\n<p>而像函数式创建和类组件创建的区别主要在于需要创建的组件是否需要为有状态组件：</p>\n<ul>\n<li>\n<p>对于一些无状态的组件创建，建议使用函数式创建的方式</p>\n</li>\n<li>\n<p>由于<code>react hooks</code>的出现，函数式组件创建的组件通过使用<code>hooks</code>方法也能使之成为有状态组件，再加上目前推崇函数式编程，所以这里建议都使用函数式的方式来创建组件</p>\n</li>\n</ul>\n<p>在考虑组件的选择原则上，能用无状态组件则用无状态组件</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://react.docschina.org/\" target=\"_blank\" rel=\"noopener noreferrer\">https://react.docschina.org/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-28T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说对 Fiber 架构的理解？解决了什么问题？",
      "url": "https://www.h7ml.cn/posts/interview/React/Fiber.html",
      "id": "https://www.h7ml.cn/posts/interview/React/Fiber.html",
      "summary": "前端物语|面试物语-说说对 Fiber 架构的理解？解决了什么问题？",
      "content_html": "<h1> 说说对 Fiber 架构的理解？解决了什么问题？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/554da6d0-ed24-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、问题</h2>\n<p><code>JavaScript</code>引擎和页面渲染引擎两个线程是互斥的，当其中一个线程执行时，另一个线程只能挂起等待</p>\n<p>如果 <code>JavaScript</code> 线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待，界面长时间不更新，会导致页面响应度变差，用户可能会感觉到卡顿</p>\n<p>而这也正是 <code>React 15</code> 的 <code>Stack Reconciler</code>所面临的问题，当 <code>React</code>在渲染组件时，从开始到渲染完成整个过程是一气呵成的，无法中断</p>\n<p>如果组件较大，那么<code>js</code>线程会一直执行，然后等到整棵<code>VDOM</code>树计算完成后，才会交给渲染的线程</p>\n<p>这就会导致一些用户交互、动画等任务无法立即得到处理，导致卡顿的情况</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5eb3a850-ed24-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、是什么</h2>\n<p>React Fiber 是 Facebook 花费两年余时间对 React 做出的一个重大改变与优化，是对 React 核心算法的一次重新实现。从 Facebook 在 React Conf 2017 会议上确认，React Fiber 在 React 16 版本发布</p>\n<p>在<code>react</code>中，主要做了以下的操作：</p>\n<ul>\n<li>为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li>\n<li>增加了异步任务，调用 requestIdleCallback api，浏览器空闲的时候执行</li>\n<li>dom diff 树变成了链表，一个 dom 对应两个 fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li>\n</ul>\n<p>从架构角度来看，<code>Fiber</code> 是对 <code>React</code>核心算法（即调和过程）的重写</p>\n<p>从编码角度来看，<code>Fiber</code>是 <code>React</code>内部所定义的一种数据结构，它是 <code>Fiber</code>树结构的节点单位，也就是 <code>React 16</code> 新架构下的虚拟<code>DOM</code></p>\n<p>一个 <code>fiber</code>就是一个 <code>JavaScript</code>对象，包含了元素的信息、该元素的更新操作队列、类型，其数据结构如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、如何解决</h2>\n<p><code>Fiber</code>把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行</p>\n<p>即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 <code>React Element</code> 对应的 <code>Fiber</code>节点</p>\n<p>实现的上述方式的是<code>requestIdleCallback</code>方法</p>\n<p><code>window.requestIdleCallback()</code>方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应</p>\n<p>首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前 React 未完成的任务，是一种合作式调度。</p>\n<p>该实现过程是基于 <code>Fiber</code>节点实现，作为静态的数据结构来说，每个 <code>Fiber</code> 节点对应一个 <code>React element</code>，保存了该组件的类型（函数组件/类组件/原生组件等等）、对应的 DOM 节点等信息。</p>\n<p>作为动态的工作单元来说，每个 <code>Fiber</code> 节点保存了本次更新中该组件改变的状态、要执行的工作。</p>\n<p>每个 Fiber 节点有个对应的 <code>React element</code>，多个 <code>Fiber</code>节点根据如下三个属性构建一颗树：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过这些属性就能找到下一个执行目标</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6926432527980691470\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6926432527980691470</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/137234573\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/137234573</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说对高阶组件的理解？应用场景?",
      "url": "https://www.h7ml.cn/posts/interview/React/High_order_components.html",
      "id": "https://www.h7ml.cn/posts/interview/React/High_order_components.html",
      "summary": "前端物语|面试物语-说说对高阶组件的理解？应用场景?",
      "content_html": "<h1> 说说对高阶组件的理解？应用场景?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c8901850-e197-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>高阶函数（Higher-order function），至少满足下列一个条件的函数</p>\n<ul>\n<li>接受一个或多个函数作为输入</li>\n<li>输出一个函数</li>\n</ul>\n<p>在<code>React</code>中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>上述代码中，该函数接受一个组件<code>WrappedComponent</code>作为参数，返回加工过的新组件<code>EnhancedComponent</code></p>\n<p>高阶组件的这种实现方式，本质上是一个装饰者设计模式</p>\n<h2> 二、如何编写</h2>\n<p>最基本的高阶组件的编写模板如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过对传入的原始组件 <code>WrappedComponent</code> 做一些你想要的操作（比如操作 props，提取 state，给原始组件包裹其他元素等），从而加工出想要的组件 <code>EnhancedComponent</code></p>\n<p>把通用的逻辑放在高阶组件中，对组件实现一致的处理，从而实现代码的复用</p>\n<p>所以，高阶组件的主要功能是封装并分离组件的通用逻辑，让通用逻辑在组件间更好地被复用</p>\n<p>但在使用高阶组件的同时，一般遵循一些约定，如下：</p>\n<ul>\n<li>props 保持一致</li>\n<li>你不能在函数式（无状态）组件上使用 ref 属性，因为它没有实例</li>\n<li>不要以任何方式改变原始组件 WrappedComponent</li>\n<li>透传不相关 props 属性给被包裹的组件 WrappedComponent</li>\n<li>不要再 render() 方法中使用高阶组件</li>\n<li>使用 compose 组合高阶组件</li>\n<li>包装显示名字以便于调试</li>\n</ul>\n<p>这里需要注意的是，高阶组件可以传递所有的<code>props</code>，但是不能传递<code>ref</code></p>\n<p>如果向一个高阶组件添加<code>refe</code>引用，那么<code>ref</code> 指向的是最外层容器组件实例的，而不是被包裹的组件，如果需要传递<code>refs</code>的话，则使用<code>React.forwardRef</code>，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、应用场景</h2>\n<p>通过上面的了解，高阶组件能够提高代码的复用性和灵活性，在实际应用中，常常用于与核心业务无关但又在多个模块使用的功能，如权限控制、日志记录、数据校验、异常处理、统计上报等</p>\n<p>举个例子，存在一个组件，需要从缓存中获取数据，然后渲染。一般情况，我们会如下编写：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码当然可以实现该功能，但是如果还有其他组件也有类似功能的时候，每个组件都需要重复写<code>componentWillMount</code>中的代码，这明显是冗杂的</p>\n<p>下面就可以通过高价组件来进行改写，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再比如组件渲染性能监控，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh-hans.reactjs.org/docs/higher-order-components.html#gatsby-focus-wrapper\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh-hans.reactjs.org/docs/higher-order-components.html#gatsby-focus-wrapper</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/高阶函数</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000010307650\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000010307650</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/61711492\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/61711492</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-13T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说 React 性能优化的手段有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/React/Improve_performance.html",
      "id": "https://www.h7ml.cn/posts/interview/React/Improve_performance.html",
      "summary": "前端物语|面试物语-说说 React 性能优化的手段有哪些？",
      "content_html": "<h1> 说说 React 性能优化的手段有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a9e83b00-f270-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>React</code>凭借<code>virtual DOM</code>和<code>diff</code>算法拥有高效的性能，但是某些情况下，性能明显可以进一步提高</p>\n<p>在前面文章中，我们了解到类组件通过调用<code>setState</code>方法， 就会导致<code>render</code>，父组件一旦发生<code>render</code>渲染，子组件一定也会执行<code>render</code>渲染</p>\n<p>当我们想要更新一个子组件的时候，如下图绿色部分：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b41f6f30-f270-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>理想状态只调用该路径下的组件<code>render</code>：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bc0f2460-f270-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>但是<code>react</code>的默认做法是调用所有组件的<code>render</code>，再对生成的虚拟<code>DOM</code>进行对比（黄色部分），如不变则不进行更新</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c2f0c4f0-f270-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从上图可见，黄色部分<code>diff</code>算法对比是明显的性能浪费的情况</p>\n<h2> 二、如何做</h2>\n<p>在<a href=\"https://mp.weixin.qq.com/s/h4NX4Plr6TCjoIhlawiJTg\" target=\"_blank\" rel=\"noopener noreferrer\">React 中如何避免不必要的 render</a>中，我们了解到如何避免不必要的<code>render</code>来应付上面的问题，主要手段是通过<code>shouldComponentUpdate</code>、<code>PureComponent</code>、<code>React.memo</code>，这三种形式这里就不再复述</p>\n<p>除此之外， 常见性能优化常见的手段有如下：</p>\n<ul>\n<li>\n<p>避免使用内联函数</p>\n</li>\n<li>\n<p>使用 React Fragments 避免额外标记</p>\n</li>\n<li>\n<p>使用 Immutable</p>\n</li>\n<li>\n<p>懒加载组件</p>\n</li>\n<li>\n<p>事件绑定方式</p>\n</li>\n<li>\n<p>服务端渲染</p>\n</li>\n</ul>\n<h4> 避免使用内联函数</h4>\n<p>如果我们使用内联函数，则每次调用<code>render</code>函数时都会创建一个新的函数实例，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们应该在组件内部创建一个函数，并将事件绑定到该函数本身。这样每次调用 <code>render</code> 时就不会创建单独的函数实例，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 使用 React Fragments 避免额外标记</h4>\n<p>用户创建新组件时，每个组件应具有单个父标签。父级不能有两个标签，所以顶部要有一个公共标签，所以我们经常在组件顶部添加额外标签<code>div</code></p>\n<p>这个额外标签除了充当父标签之外，并没有其他作用，这时候则可以使用<code>fragement</code></p>\n<p>其不会向组件引入任何额外标记，但它可以作为父级标签的作用，如下所示：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 事件绑定方式</h3>\n<p>在<a href=\"https://mp.weixin.qq.com/s/VfQ34ZEPXUXsimzMaJ_41A\" target=\"_blank\" rel=\"noopener noreferrer\">事件绑定方式</a>中，我们了解到四种事假绑定的方式</p>\n<p>从性能方面考虑，在<code>render</code>方法中使用<code>bind</code>和<code>render</code>方法中使用箭头函数这两种形式在每次组件<code>render</code>的时候都会生成新的方法实例，性能欠缺</p>\n<p>而<code>constructor</code>中<code>bind</code>事件与定义阶段使用箭头函数绑定这两种形式只会生成一个方法实例，性能方面会有所改善</p>\n<h3> 使用 Immutable</h3>\n<p>在<a href=\"https://mp.weixin.qq.com/s/laYJ_KNa8M5JNBnIolMDAA\" target=\"_blank\" rel=\"noopener noreferrer\">理解 Immutable 中</a>，我们了解到使用 <code>Immutable</code>可以给 <code>React</code> 应用带来性能的优化，主要体现在减少渲染的次数</p>\n<p>在做<code>react</code>性能优化的时候，为了避免重复渲染，我们会在<code>shouldComponentUpdate()</code>中做对比，当返回<code>true</code>执行<code>render</code>方法</p>\n<p><code>Immutable</code>通过<code>is</code>方法则可以完成对比，而无需像一样通过深度比较的方式比较</p>\n<h3> 懒加载组件</h3>\n<p>从工程方面考虑，<code>webpack</code>存在代码拆分能力，可以为应用创建多个包，并在运行时动态加载，减少初始包的大小</p>\n<p>而在<code>react</code>中使用到了<code>Suspense</code>和 <code>lazy</code>组件实现代码拆分功能，基本使用如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 服务端渲染</h3>\n<p>采用服务端渲染端方式，可以使用户更快的看到渲染完成的页面</p>\n<p>服务端渲染，需要起一个<code>node</code>服务，可以使用<code>express</code>、<code>koa</code>等，调用<code>react</code>的<code>renderToString</code>方法，将根组件渲染成字符串，再输出到响应中</p>\n<p>例如：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>客户端使用 render 方法来生成 HTML</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 其他</h3>\n<p>除此之外，还存在的优化手段有组件拆分、合理使用<code>hooks</code>等性能优化手段...</p>\n<h3> 三、总结</h3>\n<p>通过上面初步学习，我们了解到<code>react</code>常见的性能优化可以分成三个层面：</p>\n<ul>\n<li>代码层面</li>\n<li>工程层面</li>\n<li>框架机制层面</li>\n</ul>\n<p>通过这三个层面的优化结合，能够使基于<code>react</code>项目的性能更上一层楼</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/108666350\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/108666350</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000007811296\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000007811296</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-13T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说 React Jsx 转换成真实 DOM 过程？",
      "url": "https://www.h7ml.cn/posts/interview/React/JSX_to_DOM.html",
      "id": "https://www.h7ml.cn/posts/interview/React/JSX_to_DOM.html",
      "summary": "前端物语|面试物语-说说 React Jsx 转换成真实 DOM 过程？",
      "content_html": "<h1> 说说 React Jsx 转换成真实 DOM 过程？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1d340620-f00a-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>react</code>通过将组件编写的<code>JSX</code>映射到屏幕，以及组件中的状态发生了变化之后 <code>React</code>会将这些「变化」更新到屏幕上</p>\n<p>在前面文章了解中，<code>JSX</code>通过<code>babel</code>最终转化成<code>React.createElement</code>这种形式，例如：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>会被<code>bebel</code>转化成如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在转化过程中，<code>babel</code>在编译时会判断 JSX 中组件的首字母：</p>\n<ul>\n<li>\n<p>当首字母为小写时，其被认定为原生 <code>DOM</code> 标签，<code>createElement</code> 的第一个变量被编译为字符串</p>\n</li>\n<li>\n<p>当首字母为大写时，其被认定为自定义组件，createElement 的第一个变量被编译为对象</p>\n</li>\n</ul>\n<p>最终都会通过<code>RenderDOM.render(...)</code>方法进行挂载，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 二、过程</h2>\n<p>在<code>react</code>中，节点大致可以分成四个类别：</p>\n<ul>\n<li>原生标签节点</li>\n<li>文本节点</li>\n<li>函数组件</li>\n<li>类组件</li>\n</ul>\n<p>如下所示：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这些类别最终都会被转化成<code>React.createElement</code>这种形式</p>\n<p><code>React.createElement</code>其被调用时会传⼊标签类型<code>type</code>，标签属性<code>props</code>及若干子元素<code>children</code>，作用是生成一个虚拟<code>Dom</code>对象，如下所示：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>createElement</code>会根据传入的节点信息进行一个判断：</p>\n<ul>\n<li>如果是原生标签节点， type 是字符串，如 div、span</li>\n<li>如果是文本节点， type 就没有，这里是 TEXT</li>\n<li>如果是函数组件，type 是函数名</li>\n<li>如果是类组件，type 是类名</li>\n</ul>\n<p>虚拟<code>DOM</code>会通过<code>ReactDOM.render</code>进行渲染成真实<code>DOM</code>，使用方法如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>当首次调用时，容器节点里的所有 <code>DOM</code> 元素都会被替换，后续的调用则会使用 <code>React</code> 的 <code>diff</code>算法进行高效的更新</p>\n<p>如果提供了可选的回调函数<code>callback</code>，该回调将在组件被渲染或更新之后被执行</p>\n<p><code>render</code>大致实现方法如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、总结</h2>\n<p>在<code>react</code>源码中，虚拟<code>Dom</code>转化成真实<code>Dom</code>整体流程如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/28824fa0-f00a-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>其渲染流程如下所示：</p>\n<ul>\n<li>使用 React.createElement 或 JSX 编写 React 组件，实际上所有的 JSX 代码最后都会转换成 React.createElement(...) ，Babel 帮助我们完成了这个转换的过程。</li>\n<li>createElement 函数对 key 和 ref 等特殊的 props 进行处理，并获取 defaultProps 对默认 props 进行赋值，并且对传入的孩子节点进行处理，最终构造成一个虚拟 DOM 对象</li>\n<li>ReactDOM.render 将生成好的虚拟 DOM 渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实 DOM</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://bbs.huaweicloud.com/blogs/265503\" target=\"_blank\" rel=\"noopener noreferrer\">https://bbs.huaweicloud.com/blogs/265503</a>)</li>\n<li><a href=\"https://huang-qing.github.io/react/2019/05/29/React-VirDom/\" target=\"_blank\" rel=\"noopener noreferrer\">https://huang-qing.github.io/react/2019/05/29/React-VirDom/</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018891454\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000018891454</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-10T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "前端物语|面试物语-React",
      "url": "https://www.h7ml.cn/posts/interview/React/",
      "id": "https://www.h7ml.cn/posts/interview/React/",
      "summary": "React 事件绑定的方式有哪些？区别？ React 构建组件的方式有哪些？区别？ 说说对 Fiber 架构的理解？解决了什么问题？ 说说对高阶组件的理解？应用场景? 说说 React 性能优化的手段有哪些？ 说说 React Jsx 转换成真实 DOM 过程？ 说说对 React 的理解？有哪些特性？ 说说对 React Hooks 的理解？解决了什么问题？ 说说你对 React Router 的理解？常用的 Router 组件有哪些？ 说说 React Router 有几种模式？实现原理？ 说说对 React refs 的理解？应用场景？ [ 说说 Real DOM 和 Virtual DOM 的区别？优缺点？](https://www.h7ml.cn/posts/interview/React/Real_DOM_Virtual DOM) 说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？ 说说 React 的事件机制？ 在 react 中组件间过渡动画如何实现？ 说说你在 React 项目是如何捕获错误的？ 说说对 React 中类组件和函数组件的理解？有什么区别？ React 中组件之间如何通信？ 说说对受控组件和非受控组件的理解？应用场景？ 说说 React diff 的原理是什么？ 你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？ 说说你对 immutable 的理解？如何应用在 react 项目中？ 说说 react 中引入 css 的方式有哪几种？区别？ 说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？ React 中的 key 有什么作用？ 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？ 说说你对 Redux 的理解？其工作原理？ 说说 React render 方法的原理？在什么时候会被触发？ 说说 React 服务端渲染怎么做？原理是什么？ 说说 React 中的 setState 执行机制 state 和 props 有什么区别？ 说说你在使用 React 过程中遇到的常见问题？如何解决? super() 和 super(props) 有什么区别？",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/Binding_events\" target=\"_blank\" rel=\"noopener noreferrer\"> React 事件绑定的方式有哪些？区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/Building_components\" target=\"_blank\" rel=\"noopener noreferrer\"> React 构建组件的方式有哪些？区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/Fiber\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 Fiber 架构的理解？解决了什么问题？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/High_order_components\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对高阶组件的理解？应用场景?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/Improve_performance\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React 性能优化的手段有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/JSX_to_DOM\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React Jsx 转换成真实 DOM 过程？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/React\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 React 的理解？有哪些特性？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/React_Hooks\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 React Hooks 的理解？解决了什么问题？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/React_Router\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对 React Router 的理解？常用的 Router 组件有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/React_Router_model\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React Router 有几种模式？实现原理？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/React_refs\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 React refs 的理解？应用场景？</a></li>\n<li>[ 说说 Real DOM 和 Virtual DOM 的区别？优缺点？](<a href=\"https://www.h7ml.cn/posts/interview/React/Real_DOM_Virtual\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/posts/interview/React/Real_DOM_Virtual</a> DOM)</li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/Redux_Middleware\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/SyntheticEvent\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React 的事件机制？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/animation\" target=\"_blank\" rel=\"noopener noreferrer\"> 在 react 中组件间过渡动画如何实现？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/capture_error\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你在 React 项目是如何捕获错误的？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/class_function_component\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对 React 中类组件和函数组件的理解？有什么区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/communication\" target=\"_blank\" rel=\"noopener noreferrer\"> React 中组件之间如何通信？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/controlled_Uncontrolled\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说对受控组件和非受控组件的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/diff\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React diff 的原理是什么？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/how_to_use_redux\" target=\"_blank\" rel=\"noopener noreferrer\"> 你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/immutable\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对 immutable 的理解？如何应用在 react 项目中？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/import_css\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 react 中引入 css 的方式有哪几种？区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/improve_render\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/key\" target=\"_blank\" rel=\"noopener noreferrer\"> React 中的 key 有什么作用？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/life_cycle\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/redux\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对 Redux 的理解？其工作原理？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/render\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React render 方法的原理？在什么时候会被触发？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/server_side_rendering\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React 服务端渲染怎么做？原理是什么？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/setState\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说 React 中的 setState 执行机制</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/state_props\" target=\"_blank\" rel=\"noopener noreferrer\"> state 和 props 有什么区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/summary\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你在使用 React 过程中遇到的常见问题？如何解决?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/React/super()_super(props)\" target=\"_blank\" rel=\"noopener noreferrer\"> super() 和 super(props) 有什么区别？</a></li>\n</ul>\n",
      "date_published": "2023-05-23T00:00:00.000Z",
      "date_modified": "2023-05-22T20:12:41.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "React"
      ]
    },
    {
      "title": "说说对 React 的理解？有哪些特性？",
      "url": "https://www.h7ml.cn/posts/interview/React/React.html",
      "id": "https://www.h7ml.cn/posts/interview/React/React.html",
      "summary": "前端物语|面试物语-说说对 React 的理解？有哪些特性？",
      "content_html": "<h1> 说说对 React 的理解？有哪些特性？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/671f5a90-d265-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>React，用于构建用户界面的 JavaScript 库，只提供了 UI 层面的解决方案</p>\n<p>遵循组件设计模式、声明式编程范式和函数式编程概念，以使前端应用程序更高效</p>\n<p>使用虚拟 <code>DOM</code> 来有效地操作 <code>DOM</code>，遵循从高阶组件到低阶组件的单向数据流</p>\n<p>帮助我们将界面成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，构成整体页面</p>\n<p><code>react</code> 类组件使用一个名为 <code>render()</code> 的方法或者函数组件<code>return</code>，接收输入的数据并返回需要展示的内容</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述这种类似 <code>XML</code> 形式就是 <code>JSX</code>，最终会被 <code>babel</code> 编译为合法的 <code>JS</code> 语句调用</p>\n<p>被传入的数据可在组件中通过 <code>this.props</code> 在 <code>render()</code> 访问</p>\n<h2> 二、特性</h2>\n<p><code>React</code> 特性有很多，如：</p>\n<ul>\n<li>JSX 语法</li>\n<li>单向数据绑定</li>\n<li>虚拟 DOM</li>\n<li>声明式编程</li>\n<li>Component</li>\n</ul>\n<p>着重介绍下声明式编程及 Component</p>\n<h3> 声明式编程</h3>\n<p>声明式编程是一种编程范式，它关注的是你要做什么，而不是如何做</p>\n<p>它表达逻辑而不显式地定义步骤。这意味着我们需要根据逻辑的计算来声明要显示的组件</p>\n<p>如实现一个标记的地图：</p>\n<p>通过命令式创建地图、创建标记、以及在地图上添加的标记的步骤如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>而用 <code>React</code> 实现上述功能则如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>声明式编程方式使得 <code>React</code> 组件很容易使用，最终的代码简单易于维护</p>\n<h3> Component</h3>\n<p>在 <code>React</code> 中，一切皆为组件。通常将应用程序的整个逻辑分解为小的单个部分。 我们将每个单独的部分称为组件</p>\n<p>组件可以是一个函数或者是一个类，接受数据输入，处理它并返回在 <code>UI</code> 中呈现的 <code>React</code> 元素</p>\n<p>函数式组件如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>类组件（有状态组件）如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>一个组件该有的特点如下：</p>\n<ul>\n<li>可组合：每个组件易于和其它组件一起使用，或者嵌套在另一个组件内部</li>\n<li>可重用：每个组件都是具有独立功能的，它可以被使用在多个 UI 场景</li>\n<li>可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护</li>\n</ul>\n<h2> 三、优势</h2>\n<p>通过上面的初步了解，可以感受到 <code>React</code> 存在的优势：</p>\n<ul>\n<li>高效灵活</li>\n<li>声明式的设计，简单使用</li>\n<li>组件式开发，提高代码复用率</li>\n<li>单向响应的数据流会比双向绑定的更安全，速度更快</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000015924762\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000015924762</a></li>\n<li><a href=\"https://react.docschina.org/\" target=\"_blank\" rel=\"noopener noreferrer\">https://react.docschina.org/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-10T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说对 React Hooks 的理解？解决了什么问题？",
      "url": "https://www.h7ml.cn/posts/interview/React/React_Hooks.html",
      "id": "https://www.h7ml.cn/posts/interview/React/React_Hooks.html",
      "summary": "前端物语|面试物语-说说对 React Hooks 的理解？解决了什么问题？",
      "content_html": "<h1> 说说对 React Hooks 的理解？解决了什么问题？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8d357c50-e12e-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>Hook</code> 是 React 16.8 的新增特性。它可以让你在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 <code>React</code> 特性</p>\n<p>至于为什么引入<code>hook</code>，官方给出的动机是解决长时间使用和维护<code>react</code>过程中常遇到的问题，例如：</p>\n<ul>\n<li>难以重用和共享组件中的与状态相关的逻辑</li>\n<li>逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面</li>\n<li>类组件中的 this 增加学习成本，类组件在基于现有工具的优化上存在些许问题</li>\n<li>由于业务变动，函数组件不得不改为类组件等等</li>\n</ul>\n<p>在以前，函数组件也被称为无状态的组件，只负责渲染的一些工作</p>\n<p>因此，现在的函数组件也可以是有状态的组件，内部也可以维护自身的状态以及做一些逻辑方面的处理</p>\n<h2> 二、有哪些</h2>\n<p>上面讲到，<code>Hooks</code>让我们的函数组件拥有了类组件的特性，例如组件内的状态、生命周期</p>\n<p>最常见的<code>hooks</code>有如下：</p>\n<ul>\n<li>useState</li>\n<li>useEffect</li>\n<li>其他</li>\n</ul>\n<h3> useState</h3>\n<p>首先给出一个例子，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在函数组件中通过<code>useState</code>实现函数内部维护<code>state</code>，参数为<code>state</code>默认的值，返回值是一个数组，第一个值为当前的<code>state</code>，第二个值为更新<code>state</code>的函数</p>\n<p>该函数组件等价于的类组件如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上述两种代码分析，可以看出两者区别：</p>\n<ul>\n<li>\n<p>state 声明方式：在函数组件中通过 useState 直接获取，类组件通过 constructor 构造函数中设置</p>\n</li>\n<li>\n<p>state 读取方式：在函数组件中直接使用变量，类组件通过<code>this.state.count</code>的方式获取</p>\n</li>\n<li>\n<p>state 更新方式：在函数组件中通过 setCount 更新，类组件通过 this.setState()</p>\n</li>\n</ul>\n<p>总的来讲，useState 使用起来更为简洁，减少了<code>this</code>指向不明确的情况</p>\n<h3> useEffect</h3>\n<p><code>useEffect</code>可以让我们在函数组件中进行一些带有副作用的操作</p>\n<p>同样给出一个计时器示例：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面可以看见，组件在加载和更新阶段都执行同样操作</p>\n<p>而如果使用<code>useEffect</code>后，则能够将相同的逻辑抽离出来，这是类组件不具备的方法</p>\n<p>对应的<code>useEffect</code>示例如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>useEffect</code>第一个参数接受一个回调函数，默认情况下，<code>useEffect</code>会在第一次渲染和更新之后都会执行，相当于在<code>componentDidMount</code>和<code>componentDidUpdate</code>两个生命周期函数中执行回调</p>\n<p>如果某些特定值在两次重渲染之间没有发生变化，你可以跳过对 effect 的调用，这时候只需要传入第二个参数，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述传入第二个参数后，如果 <code>count</code> 的值是 <code>5</code>，而且我们的组件重渲染的时候 <code>count</code> 还是等于 <code>5</code>，React 将对前一次渲染的 <code>[5]</code> 和后一次渲染的 <code>[5]</code> 进行比较，如果是相等则跳过<code>effects</code>执行</p>\n<p>回调函数中可以返回一个清除函数，这是<code>effect</code>可选的清除机制，相当于类组件中<code>componentwillUnmount</code>生命周期函数，可做一些清除副作用的操作，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>所以， <code>useEffect</code>相当于<code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个生命周期函数的组合</p>\n<h3> 其它 hooks</h3>\n<p>在组件通信过程中可以使用<code>useContext</code>，<code>refs</code>学习中我们也用到了<code>useRef</code>获取<code>DOM</code>结构......</p>\n<p>还有很多额外的<code>hooks</code>，如：</p>\n<ul>\n<li>useReducer</li>\n<li>useCallback</li>\n<li>useMemo</li>\n<li>useRef</li>\n</ul>\n<h2> 三、解决什么</h2>\n<p>通过对上面的初步认识，可以看到<code>hooks</code>能够更容易解决状态相关的重用的问题：</p>\n<ul>\n<li>\n<p>每调用 useHook 一次都会生成一份独立的状态</p>\n</li>\n<li>\n<p>通过自定义 hook 能够更好的封装我们的功能</p>\n</li>\n</ul>\n<p>编写<code>hooks</code>为函数式编程，每个功能都包裹在函数中，整体风格更清爽，更优雅</p>\n<p><code>hooks</code>的出现，使函数组件的功能得到了扩充，拥有了类组件相似的功能，在我们日常使用中，使用<code>hooks</code>能够解决大多数问题，并且还拥有代码复用机制，因此优先考虑<code>hooks</code></p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh-hans.reactjs.org/docs/hooks-state.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh-hans.reactjs.org/docs/hooks-state.html</a></li>\n<li><a href=\"https://zh-hans.reactjs.org/docs/hooks-effect.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh-hans.reactjs.org/docs/hooks-effect.html</a></li>\n<li><a href=\"https://www.cnblogs.com/lalalagq/p/9898531.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/lalalagq/p/9898531.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-04T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说你对 React Router 的理解？常用的 Router 组件有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/React/React_Router.html",
      "id": "https://www.h7ml.cn/posts/interview/React/React_Router.html",
      "summary": "前端物语|面试物语-说说你对 React Router 的理解？常用的 Router 组件有哪些？",
      "content_html": "<h1> 说说你对 React Router 的理解？常用的 Router 组件有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c6635670-e8ac-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>react-router</code>等前端路由的原理大致相同，可以实现无刷新的条件下切换显示不同的页面</p>\n<p>路由的本质就是页面的<code>URL</code>发生改变时，页面的显示结果可以根据<code>URL</code>的变化而变化，但是页面不会刷新</p>\n<p>因此，可以通过前端路由可以实现单页(SPA)应用</p>\n<p><code>react-router</code>主要分成了几个不同的包：</p>\n<ul>\n<li>\n<p>react-router: 实现了路由的核心功能</p>\n</li>\n<li>\n<p>react-router-dom： 基于 react-router，加入了在浏览器运行环境下的一些功能</p>\n</li>\n<li>\n<p>react-router-native：基于 react-router，加入了 react-native 运行环境下的一些功能</p>\n</li>\n<li>\n<p>react-router-config: 用于配置静态路由的工具库</p>\n</li>\n</ul>\n<h2> 二、有哪些</h2>\n<p>这里主要讲述的是<code>react-router-dom</code>的常用<code>API</code>，主要是提供了一些组件：</p>\n<ul>\n<li>BrowserRouter、HashRouter</li>\n<li>Route</li>\n<li>Link、NavLink</li>\n<li>switch</li>\n<li>redirect</li>\n</ul>\n<h3> BrowserRouter、HashRouter</h3>\n<p><code>Router</code>中包含了对路径改变的监听，并且会将相应的路径传递给子组件</p>\n<p><code>BrowserRouter</code>是<code>history</code>模式，<code>HashRouter</code>模式</p>\n<p>使用两者作为最顶层组件包裹其他组件</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Route</h3>\n<p><code>Route</code>用于路径的匹配，然后进行组件的渲染，对应的属性如下：</p>\n<ul>\n<li>path 属性：用于设置匹配到的路径</li>\n<li>component 属性：设置匹配到路径后，渲染的组件</li>\n<li>render 属性：设置匹配到路径后，渲染的内容</li>\n<li>exact 属性：开启精准匹配，只有精准匹配到完全一致的路径，才会渲染对应的组件</li>\n</ul>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Link、NavLink</h3>\n<p>通常路径的跳转是使用<code>Link</code>组件，最终会被渲染成<code>a</code>元素，其中属性<code>to</code>代替<code>a</code>标题的<code>href</code>属性</p>\n<p><code>NavLink</code>是在<code>Link</code>基础之上增加了一些样式属性，例如组件被选中时，发生样式变化，则可以设置<code>NavLink</code>的一下属性：</p>\n<ul>\n<li>activeStyle：活跃时（匹配时）的样式</li>\n<li>activeClassName：活跃时添加的 class</li>\n</ul>\n<p>如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果需要实现<code>js</code>实现页面的跳转，那么可以通过下面的形式：</p>\n<p>通过<code>Route</code>作为顶层组件包裹其他组件后,页面组件就可以接收到一些路由相关的东西，比如<code>props.history</code></p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>props</code>中接收到的<code>history</code>对象具有一些方便的方法，如<code>goBack</code>，<code>goForward</code>,<code>push</code></p>\n<h3> redirect</h3>\n<p>用于路由的重定向，当这个组件出现时，就会执行跳转到对应的<code>to</code>路径中，如下例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述组件当接收到的路由参数<code>name</code> 不等于 <code>tom</code> 的时候，将会自动重定向到首页</p>\n<h3> switch</h3>\n<p><code>swich</code>组件的作用适用于当匹配到第一个组件的时候，后面的组件就不应该继续匹配</p>\n<p>如下例子：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果不使用<code>switch</code>组件进行包裹</p>\n<p>除了一些路由相关的组件之外，<code>react-router</code>还提供一些<code>hooks</code>，如下：</p>\n<ul>\n<li>useHistory</li>\n<li>useParams</li>\n<li>useLocation</li>\n</ul>\n<h3> useHistory</h3>\n<p><code>useHistory</code>可以让组件内部直接访问<code>history</code>，无须通过<code>props</code>获取</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> useParams</h3>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> useLocation</h3>\n<p><code>useLocation</code> 会返回当前 <code>URL</code>的 <code>location</code>对象</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、参数传递</h2>\n<p>这些路由传递参数主要分成了三种形式：</p>\n<ul>\n<li>动态路由的方式</li>\n<li>search 传递参数</li>\n<li>to 传入对象</li>\n</ul>\n<h3> 动态路由</h3>\n<p>动态路由的概念指的是路由中的路径并不会固定</p>\n<p>例如将<code>path</code>在<code>Route</code>匹配时写成<code>/detail/:id</code>，那么 <code>/detail/abc</code>、<code>/detail/123</code>都可以匹配到该<code>Route</code></p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>获取参数方式如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> search 传递参数</h3>\n<p>在跳转的路径中添加了一些 query 参数；</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>获取形式如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> to 传入对象</h3>\n<p>传递方式如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>获取参数的形式如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"http://react-guide.github.io/react-router-cn/docs/API.html#route\" target=\"_blank\" rel=\"noopener noreferrer\">http://react-guide.github.io/react-router-cn/docs/API.html#route</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-11T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说 React Router 有几种模式？实现原理？",
      "url": "https://www.h7ml.cn/posts/interview/React/React_Router_model.html",
      "id": "https://www.h7ml.cn/posts/interview/React/React_Router_model.html",
      "summary": "前端物语|面试物语-说说 React Router 有几种模式？实现原理？",
      "content_html": "<h1> 说说 React Router 有几种模式？实现原理？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/065f7a80-e978-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在单页应用中，一个<code>web</code>项目只有一个<code>html</code>页面，一旦页面加载完成之后，就不用因为用户的操作而进行页面的重新加载或者跳转，其特性如下：</p>\n<ul>\n<li>\n<p>改变 url 且不让浏览器像服务器发送请求</p>\n</li>\n<li>\n<p>在不刷新页面的前提下动态改变浏览器地址栏中的 URL 地址</p>\n</li>\n</ul>\n<p>其中主要分成了两种模式：</p>\n<ul>\n<li>hash 模式：在 url 后面加上#，如<a href=\"http://127.0.0.1:5500/home/#/page1\" target=\"_blank\" rel=\"noopener noreferrer\">http://127.0.0.1:5500/home/#/page1</a></li>\n<li>history 模式：允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录</li>\n</ul>\n<h2> 二、使用</h2>\n<p><code>React Router</code>对应的<code>hash</code>模式和<code>history</code>模式对应的组件为：</p>\n<ul>\n<li>HashRouter</li>\n<li>BrowserRouter</li>\n</ul>\n<p>这两个组件的使用都十分的简单，作为最顶层组件包裹其他组件，如下所示</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、实现原理</h2>\n<p>路由描述了 <code>URL</code> 与 <code>UI</code>之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）</p>\n<p>下面以<code>hash</code>模式为例子，改变<code>hash</code>值并不会导致浏览器向服务器发送请求，浏览器不发出请求，也就不会刷新页面</p>\n<p><code>hash</code> 值改变，触发全局 <code>window</code> 对象上的 <code>hashchange</code> 事件。所以 <code>hash</code> 模式路由就是利用 <code>hashchange</code> 事件监听 <code>URL</code> 的变化，从而进行 <code>DOM</code> 操作来模拟页面跳转</p>\n<p><code>react-router</code>也是基于这个特性实现路由的跳转</p>\n<p>下面以<code>HashRouter</code>组件分析进行展开：</p>\n<h2> HashRouter</h2>\n<p><code>HashRouter</code>包裹了整应用，</p>\n<p>通过<code>window.addEventListener('hashChange',callback)</code>监听<code>hash</code>值的变化，并传递给其嵌套的组件</p>\n<p>然后通过<code>context</code>将<code>location</code>数据往后代组件传递，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Router</h3>\n<p><code>Router</code>组件主要做的是通过<code>BrowserRouter</code>传过来的当前值，通过<code>props</code>传进来的<code>path</code>与<code>context</code>传进来的<code>pathname</code>进行匹配，然后决定是否执行渲染组件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li>\n<p><a href=\"https://juejin.cn/post/6870376090297171975#heading-9\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6870376090297171975#heading-9</a></p>\n</li>\n<li>\n<p><a href=\"https://segmentfault.com/a/1190000023560665\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000023560665</a></p>\n</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-01T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说对 React refs 的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/React/React_refs.html",
      "id": "https://www.h7ml.cn/posts/interview/React/React_refs.html",
      "summary": "前端物语|面试物语-说说对 React refs 的理解？应用场景？",
      "content_html": "<h1> 说说对 React refs 的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/25162040-de02-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>Refs</code> 在计算机中称为弹性文件系统（英语：Resilient File System，简称 ReFS）</p>\n<p><code>React</code> 中的 <code>Refs</code>提供了一种方式，允许我们访问 <code>DOM</code>节点或在 <code>render</code>方法中创建的 <code>React</code>元素</p>\n<p>本质为<code>ReactDOM.render()</code>返回的组件实例，如果是渲染组件则返回的是组件实例，如果渲染<code>dom</code>则返回的是具体的<code>dom</code>节点</p>\n<h2> 二、如何使用</h2>\n<p>创建<code>ref</code>的形式有三种：</p>\n<ul>\n<li>传入字符串，使用时通过 this.refs.传入的字符串的格式获取对应的元素</li>\n<li>传入对象，对象是通过 React.createRef() 方式创建出来，使用时获取到创建的对象中存在 current 属性就是对应的元素</li>\n<li>传入函数，该函数会在 DOM 被挂载时进行回调，这个函数会传入一个 元素对象，可以自己保存，使用时，直接拿到之前保存的元素对象即可</li>\n<li>传入 hook，hook 是通过 useRef() 方式创建，使用时通过生成 hook 对象的 current 属性就是对应的元素</li>\n</ul>\n<h3> 传入字符串</h3>\n<p>只需要在对应元素或组件中<code>ref</code>属性</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>访问当前节点的方式如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 传入对象</h3>\n<p><code>refs</code>通过<code>React.createRef()</code>创建，然后将<code>ref</code>属性添加到<code>React</code>元素中，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当 <code>ref</code> 被传递给 <code>render</code> 中的元素时，对该节点的引用可以在 <code>ref</code> 的 <code>current</code> 属性中访问</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 传入函数</h3>\n<p>当<code>ref</code>传入为一个函数的时候，在渲染过程中，回调函数参数会传入一个元素对象，然后通过实例将对象进行保存</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>获取<code>ref</code>对象只需要通过先前存储的对象即可</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 传入 hook</h3>\n<p>通过<code>useRef</code>创建一个<code>ref</code>，整体使用方式与<code>React.createRef</code>一致</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>获取<code>ref</code>属性也是通过<code>hook</code>对象的<code>current</code>属性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>上述三种情况都是<code>ref</code>属性用于原生<code>HTML</code>元素上，如果<code>ref</code>设置的组件为一个类组件的时候，<code>ref</code>对象接收到的是组件的挂载实例</p>\n<p>注意的是，不能在函数组件上使用<code>ref</code>属性，因为他们并没有实例</p>\n<h2> 三、应用场景</h2>\n<p>在某些情况下，我们会通过使用<code>refs</code>来更新组件，但这种方式并不推荐，更多情况我们是通过<code>props</code>与<code>state</code>的方式进行去重新渲染子元素</p>\n<p>过多使用<code>refs</code>，会使组件的实例或者是<code>DOM</code>结构暴露，违反组件封装的原则</p>\n<p>例如，避免在 <code>Dialog</code> 组件里暴露 <code>open()</code> 和 <code>close()</code> 方法，最好传递 <code>isOpen</code> 属性</p>\n<p>但下面的场景使用<code>refs</code>非常有用：</p>\n<ul>\n<li>对 Dom 元素的焦点控制、内容选择、控制</li>\n<li>对 Dom 元素的内容设置及媒体播放</li>\n<li>对 Dom 元素的操作和对组件实例的操作</li>\n<li>集成第三方 DOM 库</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh-hans.reactjs.org/docs/refs-and-the-dom.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh-hans.reactjs.org/docs/refs-and-the-dom.html</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000020842342\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000020842342</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-15T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说 Real DOM 和 Virtual DOM 的区别？优缺点？",
      "url": "https://www.h7ml.cn/posts/interview/React/Real_DOM_Virtual%20DOM.html",
      "id": "https://www.h7ml.cn/posts/interview/React/Real_DOM_Virtual%20DOM.html",
      "summary": "前端物语|面试物语-说说 Real DOM 和 Virtual DOM 的区别？优缺点？",
      "content_html": "<h1> 说说 Real DOM 和 Virtual DOM 的区别？优缺点？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f1d36350-d302-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>Real DOM，真实 <code>DOM</code>，意思为文档对象模型，是一个结构化文本的抽象，在页面渲染出的每一个结点都是一个真实 <code>DOM</code> 结构，如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fc7ba8d0-d302-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p><code>Virtual Dom</code>，本质上是以 <code>JavaScript</code> 对象形式存在的对 <code>DOM</code> 的描述</p>\n<p>创建虚拟 <code>DOM</code> 目的就是为了更好将虚拟的节点渲染到页面视图中，虚拟 <code>DOM</code> 对象的节点与真实 <code>DOM</code> 的属性一一照应</p>\n<p>在 <code>React</code> 中，<code>JSX</code> 是其一大特性，可以让你在 <code>JS</code> 中通过使用 <code>XML</code> 的方式去直接声明界面的 <code>DOM</code> 结构</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述中，<code>ReactDOM.render()</code> 用于将你创建好的虚拟 <code>DOM</code> 节点插入到某个真实节点上，并渲染到页面上</p>\n<p><code>JSX</code> 实际是一种语法糖，在使用过程中会被 <code>babel</code> 进行编译转化成 <code>JS</code> 代码，上述 <code>VDOM</code> 转化为如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，<code>JSX</code> 就是为了简化直接调用 <code>React.createElement()</code> 方法：</p>\n<ul>\n<li>\n<p>第一个参数是标签名，例如 h1、span、table...</p>\n</li>\n<li>\n<p>第二个参数是个对象，里面存着标签的一些属性，例如 id、class 等</p>\n</li>\n<li>\n<p>第三个参数是节点中的文本</p>\n</li>\n</ul>\n<p>通过 <code>console.log(VDOM)</code>，则能够得到虚拟 <code>VDOM</code> 消息</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1716b9a0-d303-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>所以可以得到，<code>JSX</code> 通过 <code>babel</code> 的方式转化成 <code>React.createElement</code> 执行，返回值是一个对象，也就是虚拟 <code>DOM</code></p>\n<h2> 二、区别</h2>\n<p>两者的区别如下：</p>\n<ul>\n<li>虚拟 DOM 不会进行排版与重绘操作，而真实 DOM 会频繁重排与重绘</li>\n<li>虚拟 DOM 的总损耗是“虚拟 DOM 增删改+真实 DOM 差异增删改+排版与重绘”，真实 DOM 的总损耗是“真实 DOM 完全增删改+排版与重绘”</li>\n</ul>\n<p>拿<a href=\"https://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&amp;mid=2247484516&amp;idx=1&amp;sn=965a4ce32bf93adb9ed112922c5cb8f5&amp;chksm=fc10c632cb674f2484fdf914d76fba55afcefca3b5adcbe6cf4b0c7fd36e29d0292e8cefceb5&amp;scene=178&amp;cur_album_id=1711105826272116736#rd\" target=\"_blank\" rel=\"noopener noreferrer\">以前文章</a>举过的例子：</p>\n<p>传统的原生 <code>api</code> 或 <code>jQuery</code> 去操作 <code>DOM</code> 时，浏览器会从构建 <code>DOM</code> 树开始从头到尾执行一遍流程</p>\n<p>当你在一次操作时，需要更新 10 个 <code>DOM</code> 节点，浏览器没这么智能，收到第一个更新 <code>DOM</code> 请求后，并不知道后续还有 9 次更新操作，因此会马上执行流程，最终执行 10 次流程</p>\n<p>而通过 <code>VNode</code>，同样更新 10 个 <code>DOM</code> 节点，虚拟 <code>DOM</code> 不会立即操作 <code>DOM</code>，而是将这 10 次更新的 <code>diff</code> 内容保存到本地的一个 <code>js</code> 对象中，最终将这个 <code>js</code> 对象一次性 <code>attach</code> 到 <code>DOM</code> 树上，避免大量的无谓计算</p>\n<h2> 三、优缺点</h2>\n<p>真实 <code>DOM</code> 的优势：</p>\n<ul>\n<li>易用</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>效率低，解析速度慢，内存占用量过高</li>\n<li>性能差：频繁操作真实 DOM，易于导致重绘与回流</li>\n</ul>\n<p>使用虚拟 <code>DOM</code> 的优势如下：</p>\n<ul>\n<li>\n<p>简单方便：如果使用手动操作真实 <code>DOM</code> 来完成页面，繁琐又容易出错，在大规模应用下维护起来也很困难</p>\n</li>\n<li>\n<p>性能方面：使用 Virtual DOM，能够有效避免真实 DOM 数频繁更新，减少多次引起重绘与回流，提高性能</p>\n</li>\n<li>\n<p>跨平台：React 借助虚拟 DOM，带来了跨平台的能力，一套代码多端运行</p>\n</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化</li>\n<li>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，速度比正常稍慢</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844904052971536391\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904052971536391</a></li>\n<li><a href=\"https://www.html.cn/qa/other/22832.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.html.cn/qa/other/22832.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？",
      "url": "https://www.h7ml.cn/posts/interview/React/Redux_Middleware.html",
      "id": "https://www.h7ml.cn/posts/interview/React/Redux_Middleware.html",
      "summary": "前端物语|面试物语-说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？",
      "content_html": "<h1> 说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/4520bbd0-e699-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的</p>\n<p>在上篇文章中，了解到了<code>Redux</code>整个工作流程，当<code>action</code>发出之后，<code>reducer</code>立即算出<code>state</code>，整个过程是一个同步的操作</p>\n<p>那么如果需要支持异步操作，或者支持错误处理、日志监控，这个过程就可以用上中间件</p>\n<p><code>Redux</code>中，中间件就是放在就是在<code>dispatch</code>过程，在分发<code>action</code>进行拦截处理，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/57edf750-e699-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>其本质上一个函数，对<code>store.dispatch</code>方法进行了改造，在发出 <code>Action</code>和执行 <code>Reducer</code>这两步之间，添加了其他功能</p>\n<h2> 二、常用的中间件</h2>\n<p>有很多优秀的<code>redux</code>中间件，如：</p>\n<ul>\n<li>redux-thunk：用于异步操作</li>\n<li>redux-logger：用于日志记录</li>\n</ul>\n<p>上述的中间件都需要通过<code>applyMiddlewares</code>进行注册，作用是将所有的中间件组成一个数组，依次执行</p>\n<p>然后作为第二个参数传入到<code>createStore</code>中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> redux-thunk</h3>\n<p><code>redux-thunk</code>是官网推荐的异步处理中间件</p>\n<p>默认情况下的<code>dispatch(action)</code>，<code>action</code>需要是一个<code>JavaScript</code>的对象</p>\n<p><code>redux-thunk</code>中间件会判断你当前传进来的数据类型，如果是一个函数，将会给函数传入参数值（dispatch，getState）</p>\n<ul>\n<li>dispatch 函数用于我们之后再次派发 action</li>\n<li>getState 函数考虑到我们之后的一些操作需要依赖原来的状态，用于让我们可以获取之前的一些状态</li>\n</ul>\n<p>所以<code>dispatch</code>可以写成下述函数的形式：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> redux-logger</h3>\n<p>如果想要实现一个日志功能，则可以使用现成的<code>redux-logger</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样我们就能简单通过中间件函数实现日志记录的信息</p>\n<h2> 三、实现原理</h2>\n<p>首先看看<code>applyMiddlewares</code>的源码</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>所有中间件被放进了一个数组<code>chain</code>，然后嵌套执行，最后执行<code>store.dispatch</code>。可以看到，中间件内部（<code>middlewareAPI</code>）可以拿到<code>getState</code>和<code>dispatch</code>这两个方法</p>\n<p>在上面的学习中，我们了解到了<code>redux-thunk</code>的基本使用</p>\n<p>内部会将<code>dispatch</code>进行一个判断，然后执行对应操作，原理如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实现一个日志输出的原理也非常简单，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-09T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说 React 的事件机制？",
      "url": "https://www.h7ml.cn/posts/interview/React/SyntheticEvent.html",
      "id": "https://www.h7ml.cn/posts/interview/React/SyntheticEvent.html",
      "summary": "前端物语|面试物语-说说 React 的事件机制？",
      "content_html": "<h1> 说说 React 的事件机制？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f054f080-d86f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>React</code>基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等</p>\n<p>在<code>React</code>中这套事件机制被称之为合成事件</p>\n<h4> 合成事件（SyntheticEvent）</h4>\n<p>合成事件是 <code>React</code>模拟原生 <code>DOM</code>事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器</p>\n<p>根据 <code>W3C</code>规范来定义合成事件，兼容所有浏览器，拥有与浏览器原生事件相同的接口，例如：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果想要获得原生<code>DOM</code>事件，可以通过<code>e.nativeEvent</code>属性获取</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面可以看到<code>React</code>事件和原生事件也非常的相似，但也有一定的区别：</p>\n<ul>\n<li>事件名称命名方式不同</li>\n</ul>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>事件处理函数书写不同</li>\n</ul>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>虽然<code>onclick</code>看似绑定到<code>DOM</code>元素上，但实际并不会把事件代理函数直接绑定到真实的节点上，而是把所有的事件绑定到结构的最外层，使用一个统一的事件去监听</p>\n<p>这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象</p>\n<p>当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升</p>\n<h2> 二、执行顺序</h2>\n<p>关于<code>React</code>合成事件与原生事件执行顺序，可以看看下面一个例子：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出顺序为：</p>\n<div class=\"language-tex line-numbers-mode\" data-ext=\"tex\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以得出以下结论：</p>\n<ul>\n<li>React 所有事件都挂载在 document 对象上</li>\n<li>当真实 DOM 元素触发事件，会冒泡到 document 对象后，再处理 React 事件</li>\n<li>所以会先执行原生事件，然后处理 React 事件</li>\n<li>最后真正执行 document 上挂载的事件</li>\n</ul>\n<p>对应过程如图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/08e22ff0-d870-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>所以想要阻止不同时间段的冒泡行为，对应使用不同的方法，对应如下：</p>\n<ul>\n<li>\n<p>阻止合成事件间的冒泡，用 e.stopPropagation()</p>\n</li>\n<li>\n<p>阻止合成事件与最外层 document 上的事件间的冒泡，用 e.nativeEvent.stopImmediatePropagation()</p>\n</li>\n<li>\n<p>阻止合成事件与除最外层 document 上的原生事件上的冒泡，通过判断 e.target 来避免</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、总结</h2>\n<p><code>React</code>事件机制总结如下：</p>\n<ul>\n<li>React 上注册的事件最终会绑定在 document 这个 DOM 上，而不是 React 组件对应的 DOM(减少内存开销就是因为所有的事件都绑定在 document 上，其他节点没有绑定事件)</li>\n<li>React 自身实现了一套事件冒泡机制，所以这也就是为什么我们 event.stopPropagation()无效的原因。</li>\n<li>React 通过队列的形式，从触发的组件向父组件回溯，然后调用他们 JSX 中定义的 callback</li>\n<li>React 有一套自己的合成事件 SyntheticEvent</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh-hans.reactjs.org/docs/events.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh-hans.reactjs.org/docs/events.html</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015725214?utm_source=sf-similar-article\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000015725214?utm_source=sf-similar-article</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000038251163\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000038251163</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-26T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说你在 React 项目是如何捕获错误的？",
      "url": "https://www.h7ml.cn/posts/interview/React/capture_error.html",
      "id": "https://www.h7ml.cn/posts/interview/React/capture_error.html",
      "summary": "前端物语|面试物语-说说你在 React 项目是如何捕获错误的？",
      "content_html": "<h1> 说说你在 React 项目是如何捕获错误的？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8db1b5c0-f288-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>错误在我们日常编写代码是非常常见的</p>\n<p>举个例子，在<code>react</code>项目中去编写组件内<code>JavaScript</code>代码错误会导致 <code>React</code> 的内部状态被破坏，导致整个应用崩溃，这是不应该出现的现象</p>\n<p>作为一个框架，<code>react</code>也有自身对于错误的处理的解决方案</p>\n<h2> 二、如何做</h2>\n<p>为了解决出现的错误导致整个应用崩溃的问题，<code>react16</code>引用了<strong>错误边界</strong>新的概念</p>\n<p>错误边界是一种 <code>React</code> 组件，这种组件可以捕获发生在其子组件树任何位置的 <code>JavaScript</code> 错误，并打印这些错误，同时展示降级 <code>UI</code>，而并不会渲染那些发生崩溃的子组件树</p>\n<p>错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误</p>\n<p>形成错误边界组件的两个条件：</p>\n<ul>\n<li>使用了 static getDerivedStateFromError()</li>\n<li>使用了 componentDidCatch()</li>\n</ul>\n<p>抛出错误后，请使用 <code>static getDerivedStateFromError()</code> 渲染备用 UI ，使用 <code>componentDidCatch()</code> 打印错误信息，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后就可以把自身组件的作为错误边界的子组件，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面这些情况无法捕获到异常：</p>\n<ul>\n<li>事件处理</li>\n<li>异步代码</li>\n<li>服务端渲染</li>\n<li>自身抛出来的错误</li>\n</ul>\n<p>在<code>react 16</code>版本之后，会把渲染期间发生的所有错误打印到控制台</p>\n<p>除了错误信息和 JavaScript 栈外，React 16 还提供了组件栈追踪。现在你可以准确地查看发生在组件树内的错误信息：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7b2b51d0-f289-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>可以看到在错误信息下方文字中存在一个组件栈，便于我们追踪错误</p>\n<p>对于错误边界无法捕获的异常，如事件处理过程中发生问题并不会捕获到，是因为其不会在渲染期间触发，并不会导致渲染时候问题</p>\n<p>这种情况可以使用<code>js</code>的<code>try...catch...</code>语法，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>除此之外还可以通过监听<code>onerror</code>事件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh-hans.reactjs.org/docs/error-boundaries.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh-hans.reactjs.org/docs/error-boundaries.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-14T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说对 React 中类组件和函数组件的理解？有什么区别？",
      "url": "https://www.h7ml.cn/posts/interview/React/class_function_component.html",
      "id": "https://www.h7ml.cn/posts/interview/React/class_function_component.html",
      "summary": "前端物语|面试物语-说说对 React 中类组件和函数组件的理解？有什么区别？",
      "content_html": "<h1> 说说对 React 中类组件和函数组件的理解？有什么区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6c196d80-de39-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、类组件</h2>\n<p>类组件，顾名思义，也就是通过使用<code>ES6</code>类的编写形式去编写组件，该类必须继承<code>React.Component</code></p>\n<p>如果想要访问父组件传递过来的参数，可通过<code>this.props</code>的方式去访问</p>\n<p>在组件中必须实现<code>render</code>方法，在<code>return</code>中返回<code>React</code>对象，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、函数组件</h2>\n<p>函数组件，顾名思义，就是通过函数编写的形式去实现一个<code>React</code>组件，是<code>React</code>中定义组件最简单的方式</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>函数第一个参数为<code>props</code>用于接收父组件传递过来的参数</p>\n<h2> 三、区别</h2>\n<p>针对两种<code>React</code>组件，其区别主要分成以下几大方向：</p>\n<ul>\n<li>\n<p>编写形式</p>\n</li>\n<li>\n<p>状态管理</p>\n</li>\n<li>\n<p>生命周期</p>\n</li>\n<li>\n<p>调用方式</p>\n</li>\n<li>\n<p>获取渲染的值</p>\n</li>\n</ul>\n<h3> 编写形式</h3>\n<p>两者最明显的区别在于编写形式的不同，同一种功能的实现可以分别对应类组件和函数组件的编写形式</p>\n<p>函数组件：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>类组件：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 状态管理</h3>\n<p>在<code>hooks</code>出来之前，函数组件就是无状态组件，不能保管组件的状态，不像类组件中调用<code>setState</code></p>\n<p>如果想要管理<code>state</code>状态，可以使用<code>useState</code>，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在使用<code>hooks</code>情况下，一般如果函数组件调用<code>state</code>，则需要创建一个类组件或者<code>state</code>提升到你的父组件中，然后通过<code>props</code>对象传递到子组件</p>\n<h3> 生命周期</h3>\n<p>在函数组件中，并不存在生命周期，这是因为这些生命周期钩子都来自于继承的<code>React.Component</code></p>\n<p>所以，如果用到生命周期，就只能使用类组件</p>\n<p>但是函数组件使用<code>useEffect</code>也能够完成替代生命周期的作用，这里给出一个简单的例子：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述简单的例子对应类组件中的<code>componentDidMount</code>生命周期</p>\n<p>如果在<code>useEffect</code>回调函数中<code>return</code>一个函数，则<code>return</code>函数会在组件卸载的时候执行，正如<code>componentWillUnmount</code></p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 调用方式</h3>\n<p>如果是一个函数组件，调用则是执行函数即可：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果是一个类组件，则需要将组件进行实例化，然后调用实例对象的<code>render</code>方法：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 获取渲染的值</h3>\n<p>首先给出一个示例</p>\n<p>函数组件对应如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>类组件对应如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>两者看起来实现功能是一致的，但是在类组件中，输出<code>this.props.user</code>，<code>Props</code>在 <code>React</code>中是不可变的所以它永远不会改变，但是 <code>this</code> 总是可变的，以便您可以在 <code>render</code> 和生命周期函数中读取新版本</p>\n<p>因此，如果我们的组件在请求运行时更新。<code>this.props</code> 将会改变。<code>showMessage</code>方法从“最新”的 <code>props</code> 中读取 <code>user</code></p>\n<p>而函数组件，本身就不存在<code>this</code>，<code>props</code>并不发生改变，因此同样是点击，<code>alert</code>的内容仍旧是之前的内容</p>\n<h3> 小结</h3>\n<p>两种组件都有各自的优缺点</p>\n<p>函数组件语法更短、更简单，这使得它更容易开发、理解和测试</p>\n<p>而类组件也会因大量使用 <code>this</code>而让人感到困惑</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh-hans.reactjs.org/docs/components-and-props.html#function-and-class-components\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh-hans.reactjs.org/docs/components-and-props.html#function-and-class-components</a></li>\n<li><a href=\"https://juejin.cn/post/6844903806140973069\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903806140973069</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-04T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "React 中组件之间如何通信？",
      "url": "https://www.h7ml.cn/posts/interview/React/communication.html",
      "id": "https://www.h7ml.cn/posts/interview/React/communication.html",
      "summary": "前端物语|面试物语-React 中组件之间如何通信？",
      "content_html": "<h1> React 中组件之间如何通信？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/767a2800-dc9f-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>我们将组件间通信可以拆分为两个词：</p>\n<ul>\n<li>组件</li>\n<li>通信</li>\n</ul>\n<p>回顾<a href=\"https://mp.weixin.qq.com/s/uFjMz6BByA5eknBgkvgdeQ\" target=\"_blank\" rel=\"noopener noreferrer\">Vue 系列</a>的文章，组件是<code>vue</code>中最强大的功能之一，同样组件化是<code>React</code>的核心思想</p>\n<p>相比<code>vue</code>，<code>React</code>的组件更加灵活和多样，按照不同的方式可以分成很多类型的组件</p>\n<p>而通信指的是发送者通过某种媒体以某种格式来传递信息到收信者以达到某个目的，广义上，任何信息的交通都是通信</p>\n<p>组件间通信即指组件通过某种方式来传递信息以达到某个目的</p>\n<h2> 二、如何通信</h2>\n<p>组件传递的方式有很多种，根据传送者和接收者可以分为如下：</p>\n<ul>\n<li>父组件向子组件传递</li>\n<li>子组件向父组件传递</li>\n<li>兄弟组件之间的通信</li>\n<li>父组件向后代组件传递</li>\n<li>非关系组件传递</li>\n</ul>\n<h3> 父组件向子组件传递</h3>\n<p>由于<code>React</code>的数据流动为单向的，父组件向子组件传递是最常见的方式</p>\n<p>父组件在调用子组件的时候，只需要在子组件标签内传递参数，子组件通过<code>props</code>属性就能接收父组件传递过来的参数</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 子组件向父组件传递</h3>\n<p>子组件向父组件通信的基本思路是，父组件向子组件传一个函数，然后通过这个函数的回调，拿到子组件传过来的值</p>\n<p>父组件对应代码如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>子组件对应代码如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 兄弟组件之间的通信</h3>\n<p>如果是兄弟组件之间的传递，则父组件作为中间层来实现数据的互通，通过使用父组件传递</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 父组件向后代组件传递</h3>\n<p>父组件向后代组件传递数据是一件最普通的事情，就像全局数据一样</p>\n<p>使用<code>context</code>提供了组件之间通讯的一种方式，可以共享数据，其他数据都能读取对应的数据</p>\n<p>通过使用<code>React.createContext</code>创建一个<code>context</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>context</code>创建成功后，其下存在<code>Provider</code>组件用于创建数据源，<code>Consumer</code>组件用于接收数据，使用实例如下：</p>\n<p><code>Provider</code>组件通过<code>value</code>属性用于给后代组件传递数据：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果想要获取<code>Provider</code>传递的数据，可以通过<code>Consumer</code>组件或者或者使用<code>contextType</code>属性接收，对应分别如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Consumer</code>组件：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 非关系组件传递</h3>\n<p>如果组件之间关系类型比较复杂的情况，建议将数据进行一个全局资源管理，从而实现通信，例如<code>redux</code>。关于<code>redux</code>的使用后续再详细介绍</p>\n<h2> 三、总结</h2>\n<p>由于<code>React</code>是单向数据流，主要思想是组件不会改变接收的数据，只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值</p>\n<p>因此，可以看到通信过程中，数据的存储位置都是存放在上级位置中</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://react.docschina.org/docs/context.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://react.docschina.org/docs/context.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说对受控组件和非受控组件的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/React/controlled_Uncontrolled.html",
      "id": "https://www.h7ml.cn/posts/interview/React/controlled_Uncontrolled.html",
      "summary": "前端物语|面试物语-说说对受控组件和非受控组件的理解？应用场景？",
      "content_html": "<h1> 说说对受控组件和非受控组件的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/12990fd0-df2f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、受控组件</h2>\n<p>受控组件，简单来讲，就是受我们控制的组件，组件的状态全程响应外部数据</p>\n<p>举个简单的例子：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这时候当我们在输入框输入内容的时候，会发现输入的内容并无法显示出来，也就是<code>input</code>标签是一个可读的状态</p>\n<p>这是因为<code>value</code>被<code>this.state.username</code>所控制住。当用户输入新的内容时，<code>this.state.username</code>并不会自动更新，这样的话<code>input</code>内的内容也就不会变了</p>\n<p>如果想要解除被控制，可以为<code>input</code>标签设置<code>onChange</code>事件，输入的时候触发事件函数，在函数内部实现<code>state</code>的更新，从而导致<code>input</code>框的内容页发现改变</p>\n<p>因此，受控组件我们一般需要初始状态和一个状态更新事件函数</p>\n<h2> 二、非受控组件</h2>\n<p>非受控组件，简单来讲，就是不受我们控制的组件</p>\n<p>一般情况是在初始化的时候接受外部数据，然后自己在内部存储其自身状态</p>\n<p>当需要时，可以使用<code>ref</code> 查询 <code>DOM</code>并查找其当前值，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于<code>refs</code>的详情使用可以参考<a href=\"https://mp.weixin.qq.com/s/ZBKWcslVBi0IKQgz7lYzbA\" target=\"_blank\" rel=\"noopener noreferrer\">之前文章</a></p>\n<h2> 三、应用场景</h2>\n<p>大部分时候推荐使用受控组件来实现表单，因为在受控组件中，表单数据由<code>React</code>组件负责处理</p>\n<p>如果选择非受控组件的话，控制能力较弱，表单数据就由<code>DOM</code>本身处理，但更加方便快捷，代码量少</p>\n<p>针对两者的区别，其应用场景如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f28aed20-df2f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"http://meloguo.com/2018/10/08/%E5%8F%97%E6%8E%A7%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6/\" target=\"_blank\" rel=\"noopener noreferrer\">http://meloguo.com/2018/10/08/受控与非受控组件/</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/37579677\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/37579677</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-06T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说 React diff 的原理是什么？",
      "url": "https://www.h7ml.cn/posts/interview/React/diff.html",
      "id": "https://www.h7ml.cn/posts/interview/React/diff.html",
      "summary": "前端物语|面试物语-说说 React diff 的原理是什么？",
      "content_html": "<h1> 说说 React diff 的原理是什么？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/967e6150-ec91-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>跟<code>Vue</code>一致，<code>React</code>通过引入<code>Virtual DOM</code>的概念，极大地避免无效的<code>Dom</code>操作，使我们的页面的构建效率提到了极大的提升</p>\n<p>而<code>diff</code>算法就是更高效地通过对比新旧<code>Virtual DOM</code>来找出真正的<code>Dom</code>变化之处</p>\n<p>传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，<code>react</code>将算法进行一个优化，复杂度姜维<code>O(n)</code>，两者效率差距如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a43c9960-ec91-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、原理</h2>\n<p><code>react</code>中<code>diff</code>算法主要遵循三个层级的策略：</p>\n<ul>\n<li>\n<p>tree 层级</p>\n</li>\n<li>\n<p>conponent 层级</p>\n</li>\n<li>\n<p>element 层级</p>\n</li>\n</ul>\n<h3> tree 层级</h3>\n<p><code>DOM</code>节点跨层级的操作不做优化，只会对相同层级的节点进行比较</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ae71d1c0-ec91-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>只有删除、创建操作，没有移动操作，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b85f2bb0-ec91-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p><code>react</code>发现新树中，R 节点下没有了 A，那么直接删除 A，在 D 节点下创建 A 以及下属节点</p>\n<p>上述操作中，只有删除和创建操作</p>\n<h3> conponent 层级</h3>\n<p>如果是同一个类的组件，则会继续往下<code>diff</code>运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c1fcdf00-ec91-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>当<code>component D</code>换成了<code>component G</code> 后，即使两者的结构非常类似，也会将<code>D</code>删除再重新创建<code>G</code></p>\n<h3> element 层级</h3>\n<p>对于比较同一层级的节点们，每个节点在对应的层级用唯一的<code>key</code>作为标识</p>\n<p>提供了 3 种节点操作，分别为 <code>INSERT_MARKUP</code>(插入)、<code>MOVE_EXISTING</code> (移动)和 <code>REMOVE_NODE</code> (删除)</p>\n<p>如下场景：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/cae1c9a0-ec91-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>通过<code>key</code>可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置</p>\n<p>流程如下表：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d34c5420-ec91-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>index： 新集合的遍历下标。</li>\n<li>oldIndex：当前节点在老集合中的下标</li>\n<li>maxIndex：在新集合访问过的节点中，其在老集合的最大下标</li>\n</ul>\n<p>如果当前节点在新集合中的位置比老集合中的位置靠前的话，是不会影响后续节点操作的，这里这时候被动字节不用动</p>\n<p>操作过程中只比较 oldIndex 和 maxIndex，规则如下：</p>\n<ul>\n<li>当 oldIndex&gt;maxIndex 时，将 oldIndex 的值赋值给 maxIndex</li>\n<li>当 oldIndex=maxIndex 时，不操作</li>\n<li>当 oldIndex&lt;maxIndex 时，将当前节点移动到 index 的位置</li>\n</ul>\n<p><code>diff</code>过程如下：</p>\n<ul>\n<li>节点 B：此时 maxIndex=0，oldIndex=1；满足 maxIndex&lt; oldIndex，因此 B 节点不动，此时 maxIndex= Math.max(oldIndex, maxIndex)，就是 1</li>\n<li>节点 A：此时 maxIndex=1，oldIndex=0；不满足 maxIndex&lt; oldIndex，因此 A 节点进行移动操作，此时 maxIndex= Math.max(oldIndex, maxIndex)，还是 1</li>\n<li>节点 D：此时 maxIndex=1, oldIndex=3；满足 maxIndex&lt; oldIndex，因此 D 节点不动，此时 maxIndex= Math.max(oldIndex, maxIndex)，就是 3</li>\n<li>节点 C：此时 maxIndex=3，oldIndex=2；不满足 maxIndex&lt; oldIndex，因此 C 节点进行移动操作，当前已经比较完了</li>\n</ul>\n<p>当 ABCD 节点比较完成后，<code>diff</code>过程还没完，还会整体遍历老集合中节点，看有没有没用到的节点，有的话，就删除</p>\n<h2> 三、注意事项</h2>\n<p>对于简单列表渲染而言，不使用<code>key</code>比使用<code>key</code>的性能，例如：</p>\n<p>将一个[1,2,3,4,5]，渲染成如下的样子：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>后续更改成[1,3,2,5,4]，使用<code>key</code>与不使用<code>key</code>作用如下：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果我们对这个集合进行增删的操作改成[1,3,2,5,6]</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>由于<code>dom</code>节点的移动操作开销是比较昂贵的，没有<code>key</code>的情况下要比有<code>key</code>的性能更好</p>\n<h2> 参考文献</h2>\n<ul>\n<li>\n<p><a href=\"https://zhuanlan.zhihu.com/p/140489744\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/140489744</a></p>\n</li>\n<li>\n<p><a href=\"https://zhuanlan.zhihu.com/p/20346379\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/20346379</a></p>\n</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-09T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？",
      "url": "https://www.h7ml.cn/posts/interview/React/how_to_use_redux.html",
      "id": "https://www.h7ml.cn/posts/interview/React/how_to_use_redux.html",
      "summary": "前端物语|面试物语-你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？",
      "content_html": "<h1> 你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/31a4aff0-e7dc-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、背景</h2>\n<p>在前面文章了解中，我们了解到<code>redux</code>是用于数据状态管理，而<code>react</code>是一个视图层面的库</p>\n<p>如果将两者连接在一起，可以使用官方推荐<code>react-redux</code>库，其具有高效且灵活的特性</p>\n<p><code>react-redux</code>将组件分成：</p>\n<ul>\n<li>容器组件：存在逻辑处理</li>\n<li>UI 组件：只负责现显示和交互，内部不处理逻辑，状态由外部控制</li>\n</ul>\n<p>通过<code>redux</code>将整个应用状态存储到<code>store</code>中，组件可以派发<code>dispatch</code>行为<code>action</code>给<code>store</code></p>\n<p>其他组件通过订阅<code>store</code>中的状态<code>state</code>来更新自身的视图</p>\n<h2> 二、如何做</h2>\n<p>使用<code>react-redux</code>分成了两大核心：</p>\n<ul>\n<li>Provider</li>\n<li>connection</li>\n</ul>\n<h3> Provider</h3>\n<p>在<code>redux</code>中存在一个<code>store</code>用于存储<code>state</code>，如果将这个<code>store</code>存放在顶层元素中，其他组件都被包裹在顶层元素之上</p>\n<p>那么所有的组件都能够受到<code>redux</code>的控制，都能够获取到<code>redux</code>中的数据</p>\n<p>使用方式如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> connection</h3>\n<p><code>connect</code>方法将<code>store</code>上的<code>getState</code>和 <code>dispatch</code>包装成组件的<code>props</code></p>\n<p>导入<code>conect</code>如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>用法如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>可以传递两个参数：</p>\n<ul>\n<li>\n<p>mapStateToProps</p>\n</li>\n<li>\n<p>mapDispatchToProps</p>\n</li>\n</ul>\n<h3> mapStateToProps</h3>\n<p>把<code>redux</code>中的数据映射到<code>react</code>中的<code>props</code>中去</p>\n<p>如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>组件内部就能够通过<code>props</code>获取到<code>store</code>中的数据</p>\n<div class=\"language-cons line-numbers-mode\" data-ext=\"cons\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> mapDispatchToProps</h3>\n<p>将<code>redux</code>中的<code>dispatch</code>映射到组件内部的<code>props</code>中</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 小结</h3>\n<p>整体流程图大致如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3e47db10-e7dc-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、项目结构</h2>\n<p>可以根据项目具体情况进行选择，以下列出两种常见的组织结构</p>\n<h4> 按角色组织（MVC）</h4>\n<p>角色如下：</p>\n<ul>\n<li>reducers</li>\n<li>actions</li>\n<li>components</li>\n<li>containers</li>\n</ul>\n<p>参考如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 按功能组织</h4>\n<p>使用<code>redux</code>使用功能组织项目，也就是把完成同一应用功能的代码放在一个目录下，一个应用功能包含多个角色的代码</p>\n<p><code>Redux</code>中，不同的角色就是<code>reducer</code>、<code>actions</code>和视图，而应用功能对应的就是用户界面的交互模块</p>\n<p>参考如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>每个功能模块对应一个目录，每个目录下包含同样的角色文件：</p>\n<ul>\n<li>actionTypes.js 定义 action 类型</li>\n<li>actions.js 定义 action 构造函数</li>\n<li>reducer.js 定义这个功能模块如果响应 actions.js 定义的动作</li>\n<li>views 包含功能模块中所有的 React 组件，包括展示组件和容器组件</li>\n<li>index.js 把所有的角色导入，统一导出</li>\n</ul>\n<p>其中<code>index</code>模块用于导出对外的接口</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>导入方法如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.redux.org.cn/docs/basics/UsageWithReact.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.redux.org.cn/docs/basics/UsageWithReact.html</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000010384268\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000010384268</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-28T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说你对 immutable 的理解？如何应用在 react 项目中？",
      "url": "https://www.h7ml.cn/posts/interview/React/immutable.html",
      "id": "https://www.h7ml.cn/posts/interview/React/immutable.html",
      "summary": "前端物语|面试物语-说说你对 immutable 的理解？如何应用在 react 项目中？",
      "content_html": "<h1> 说说你对 immutable 的理解？如何应用在 react 项目中？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/797e9470-ea3f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>Immutable，不可改变的，在计算机中，即指一旦创建，就不能再被更改的数据</p>\n<p>对 <code>Immutable</code>对象的任何修改或添加删除操作都会返回一个新的 <code>Immutable</code>对象</p>\n<p><code>Immutable</code> 实现的原理是 <code>Persistent Data Structure</code>（持久化数据结构）:</p>\n<ul>\n<li>用一种数据结构来保存数据</li>\n<li>当数据被修改时，会返回一个对象，但是新的对象会尽可能的利用之前的数据结构而不会对内存造成浪费</li>\n</ul>\n<p>也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变，同时为了避免 <code>deepCopy</code>把所有节点都复制一遍带来的性能损耗，<code>Immutable</code> 使用了 <code>Structural Sharing</code>（结构共享）</p>\n<p>如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享</p>\n<p>如下图所示：</p>\n<figure><img src=\"https://pic4.zhimg.com/80/2b4c801a7b40eefcd4ee6767fb984fdf_720w.gif\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、如何使用</h2>\n<p>使用<code>Immutable</code>对象最主要的库是<code>immutable.js</code></p>\n<p>immutable.js 是一个完全独立的库，无论基于什么框架都可以用它</p>\n<p>其出现场景在于弥补 Javascript 没有不可变数据结构的问题，通过 structural sharing 来解决的性能问题</p>\n<p>内部提供了一套完整的 Persistent Data Structure，还有很多易用的数据类型，如<code>Collection</code>、<code>List</code>、<code>Map</code>、<code>Set</code>、<code>Record</code>、<code>Seq</code>，其中：</p>\n<ul>\n<li>\n<p>List: 有序索引集，类似 JavaScript 中的 Array</p>\n</li>\n<li>\n<p>Map: 无序索引集，类似 JavaScript 中的 Object</p>\n</li>\n<li>\n<p>Set: 没有重复值的集合</p>\n</li>\n</ul>\n<p>主要的方法如下：</p>\n<ul>\n<li>fromJS()：将一个 js 数据转换为 Immutable 类型的数据</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>toJS()：将一个 Immutable 数据转换为 JS 类型的数据</li>\n<li>is()：对两个对象进行比较</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p>get(key)：对数据或对象取值</p>\n</li>\n<li>\n<p>getIn([]) ：对嵌套对象或数组取值，传参为数组，表示位置</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li></li>\n</ul>\n<p>如下例子：使用方法如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果换到原生的<code>js</code>，则对应如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、在 React 中应用</h2>\n<p>使用 <code>Immutable</code>可以给 <code>React</code> 应用带来性能的优化，主要体现在减少渲染的次数</p>\n<p>在做<code>react</code>性能优化的时候，为了避免重复渲染，我们会在<code>shouldComponentUpdate()</code>中做对比，当返回<code>true</code>执行<code>render</code>方法</p>\n<p><code>Immutable</code>通过<code>is</code>方法则可以完成对比，而无需像一样通过深度比较的方式比较</p>\n<p>在使用<code>redux</code>过程中也可以结合<code>Immutable</code>，不使用<code>Immutable</code>前修改一个数据需要做一个深拷贝</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用 Immutable 后：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同理，在<code>redux</code>中也可以将数据进行<code>fromJS</code>处理</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/20295971?spm=a2c4e.11153940.blogcont69516.18.4f275a00EzBHjr&amp;columnSlug=purerender\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/20295971?spm=a2c4e.11153940.blogcont69516.18.4f275a00EzBHjr&amp;columnSlug=purerender</a></li>\n<li><a href=\"https://www.jianshu.com/p/7bf04638e82a\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/7bf04638e82a</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-02T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说 react 中引入 css 的方式有哪几种？区别？",
      "url": "https://www.h7ml.cn/posts/interview/React/import_css.html",
      "id": "https://www.h7ml.cn/posts/interview/React/import_css.html",
      "summary": "前端物语|面试物语-说说 react 中引入 css 的方式有哪几种？区别？",
      "content_html": "<h1> 说说 react 中引入 css 的方式有哪几种？区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7d825230-e217-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>组件式开发选择合适的<code>css</code>解决方案尤为重要</p>\n<p>通常会遵循以下规则：</p>\n<ul>\n<li>可以编写局部 css，不会随意污染其他组件内的原生；</li>\n<li>可以编写动态的 css，可以获取当前组件的一些状态，根据状态的变化生成不同的 css 样式；</li>\n<li>支持所有的 css 特性：伪类、动画、媒体查询等；</li>\n<li>编写起来简洁方便、最好符合一贯的 css 风格特点</li>\n</ul>\n<p>在这一方面，<code>vue</code>使用<code>css</code>起来更为简洁：</p>\n<ul>\n<li>通过 style 标签编写样式</li>\n<li>scoped 属性决定编写的样式是否局部有效</li>\n<li>lang 属性设置预处理器</li>\n<li>内联样式风格的方式来根据最新状态设置和改变 css</li>\n</ul>\n<p>而在<code>react</code>中，引入<code>CSS</code>就不如<code>Vue</code>方便简洁，其引入<code>css</code>的方式有很多种，各有利弊</p>\n<h2> 二、方式</h2>\n<p>常见的<code>CSS</code>引入方式有以下：</p>\n<ul>\n<li>在组件内直接使用</li>\n<li>组件中引入 .css 文件</li>\n<li>组件中引入 .module.css 文件</li>\n<li>CSS in JS</li>\n</ul>\n<h3> 在组件内直接使用</h3>\n<p>直接在组件中书写<code>css</code>样式，通过<code>style</code>属性直接引入，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面可以看到，<code>css</code>属性需要转换成驼峰写法</p>\n<p>这种方式优点：</p>\n<ul>\n<li>内联样式, 样式之间不会有冲突</li>\n<li>可以动态获取当前 state 中的状态</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>\n<p>写法上都需要使用驼峰标识</p>\n</li>\n<li>\n<p>某些样式没有提示</p>\n</li>\n<li>\n<p>大量的样式, 代码混乱</p>\n</li>\n<li>\n<p>某些样式无法编写(比如伪类/伪元素)</p>\n</li>\n</ul>\n<h3> 组件中引入 css 文件</h3>\n<p>将<code>css</code>单独写在一个<code>css</code>文件中，然后在组件中直接引入</p>\n<p><code>App.css</code>文件：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>组件中引入：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种方式存在不好的地方在于样式是全局生效，样式之间会互相影响</p>\n<h3> 组件中引入 .module.css 文件</h3>\n<p>将<code>css</code>文件作为一个模块引入，这个模块中的所有<code>css</code>，只作用于当前组件。不会影响当前组件的后代组件</p>\n<p>这种方式是<code>webpack</code>特工的方案，只需要配置<code>webpack</code>配置文件中<code>modules:true</code>即可</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种方式能够解决局部作用域问题，但也有一定的缺陷：</p>\n<ul>\n<li>引用的类名，不能使用连接符(.xxx-xx)，在 JavaScript 中是不识别的</li>\n<li>所有的 className 都必须使用 {style.className} 的形式来编写</li>\n<li>不方便动态来修改某些样式，依然需要使用内联样式的方式；</li>\n</ul>\n<h3> CSS in JS</h3>\n<p>CSS-in-JS， 是指一种模式，其中<code>CSS</code>由 <code>JavaScript</code>生成而不是在外部文件中定义</p>\n<p>此功能并不是 React 的一部分，而是由第三方库提供，例如：</p>\n<ul>\n<li>styled-components</li>\n<li>emotion</li>\n<li>glamorous</li>\n</ul>\n<p>下面主要看看<code>styled-components</code>的基本使用</p>\n<p>本质是通过函数的调用，最终创建出一个组件：</p>\n<ul>\n<li>这个组件会被自动添加上一个不重复的 class</li>\n<li>styled-components 会给该 class 添加相关的样式</li>\n</ul>\n<p>基本使用如下：</p>\n<p>创建一个<code>style.js</code>文件用于存放样式组件：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>引入样式组件也很简单：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、区别</h2>\n<p>通过上面四种样式的引入，可以看到：</p>\n<ul>\n<li>\n<p>在组件内直接使用<code>css</code>该方式编写方便，容易能够根据状态修改样式属性，但是大量的演示编写容易导致代码混乱</p>\n</li>\n<li>\n<p>组件中引入 .css 文件符合我们日常的编写习惯，但是作用域是全局的，样式之间会层叠</p>\n</li>\n<li>\n<p>引入.module.css 文件能够解决局部作用域问题，但是不方便动态修改样式，需要使用内联的方式进行样式的编写</p>\n</li>\n<li>\n<p>通过 css in js 这种方法，可以满足大部分场景的应用，可以类似于预处理器一样样式嵌套、定义、修改状态等</p>\n</li>\n</ul>\n<p>至于使用<code>react</code>用哪种方案引入<code>css</code>，并没有一个绝对的答案，可以根据各自情况选择合适的方案</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh-hans.reactjs.org/docs/faq-styling.html#gatsby-focus-wrapper\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh-hans.reactjs.org/docs/faq-styling.html#gatsby-focus-wrapper</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/oywTpNKEikMXn8QTBgITow\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/oywTpNKEikMXn8QTBgITow</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？",
      "url": "https://www.h7ml.cn/posts/interview/React/improve_render.html",
      "id": "https://www.h7ml.cn/posts/interview/React/improve_render.html",
      "summary": "前端物语|面试物语-说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？",
      "content_html": "<h1> 说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/de2d7e20-ecf8-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>react</code> 基于虚拟 <code>DOM</code> 和高效 <code>Diff</code>算法的完美配合，实现了对 <code>DOM</code>最小粒度的更新，大多数情况下，<code>React</code>对 <code>DOM</code>的渲染效率足以我们的业务日常</p>\n<p>复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，避免不必要的渲染则是业务中常见的优化手段之一</p>\n<h2> 二、如何做</h2>\n<p>在之前文章中，我们了解到<code>render</code>的触发时机，简单来讲就是类组件通过调用<code>setState</code>方法， 就会导致<code>render</code>，父组件一旦发生<code>render</code>渲染，子组件一定也会执行<code>render</code>渲染</p>\n<p>从上面可以看到，父组件渲染导致子组件渲染，子组件并没有发生任何改变，这时候就可以从避免无谓的渲染，具体实现的方式有如下：</p>\n<ul>\n<li>shouldComponentUpdate</li>\n<li>PureComponent</li>\n<li>React.memo</li>\n</ul>\n<h3> shouldComponentUpdate</h3>\n<p>通过<code>shouldComponentUpdate</code>生命周期函数来比对 <code>state</code>和 <code>props</code>，确定是否要重新渲染</p>\n<p>默认情况下返回<code>true</code>表示重新渲染，如果不希望组件重新渲染，返回 <code>false</code> 即可</p>\n<h3> PureComponent</h3>\n<p>跟<code>shouldComponentUpdate</code>原理基本一致，通过对 <code>props</code> 和 <code>state</code>的浅比较结果来实现 <code>shouldComponentUpdate</code>，源码大致如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>shallowEqual</code>对应方法大致如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当对象包含复杂的数据结构时，对象深层的数据已改变却没有触发 <code>render</code></p>\n<p>注意：在<code>react</code>中，是不建议使用深层次结构的数据</p>\n<h3> React.memo</h3>\n<p><code>React.memo</code>用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 <code>PureComponent</code> 十分类似。但不同的是， <code>React.memo</code> 只能用于函数组件</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果需要深层次比较，这时候可以给<code>memo</code>第二个参数传递比较函数</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、总结</h2>\n<p>在实际开发过程中，前端性能问题是一个必须考虑的问题，随着业务的复杂，遇到性能问题的概率也在增高</p>\n<p>除此之外，建议将页面进行更小的颗粒化，如果一个过大，当状态发生修改的时候，就会导致整个大组件的渲染，而对组件进行拆分后，粒度变小了，也能够减少子组件不必要的渲染</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844903781679759367#heading-12\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903781679759367#heading-12</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-21T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "React 中的 key 有什么作用？",
      "url": "https://www.h7ml.cn/posts/interview/React/key.html",
      "id": "https://www.h7ml.cn/posts/interview/React/key.html",
      "summary": "前端物语|面试物语-React 中的 key 有什么作用？",
      "content_html": "<h1> React 中的 key 有什么作用？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/31677360-dd69-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>首先，先给出<code>react</code>组件中进行列表渲染的一个示例：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后在输出就可以看到<code>react</code>所提示的警告信息：</p>\n<div class=\"language-tex line-numbers-mode\" data-ext=\"tex\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>根据意思就可以得到渲染列表的每一个子元素都应该需要一个唯一的<code>key</code>值</p>\n<p>在这里可以使用列表的<code>id</code>属性作为<code>key</code>值以解决上面这个警告</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、作用</h2>\n<p>跟<code>Vue</code>一样，<code>React</code> 也存在 <code>Diff</code>算法，而元素<code>key</code>属性的作用是用于判断元素是新创建的还是被移动的元素，从而减少不必要的元素渲染</p>\n<p>因此<code>key</code>的值需要为每一个元素赋予一个确定的标识</p>\n<p>如果列表数据渲染中，在数据后面插入一条数据，<code>key</code>作用并不大，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>前面的元素在<code>diff</code>算法中，前面的元素由于是完全相同的，并不会产生删除创建操作，在最后一个比较的时候，则需要插入到新的<code>DOM</code>树中</p>\n<p>因此，在这种情况下，元素有无<code>key</code>属性意义并不大</p>\n<p>下面再来看看在前面插入数据时，使用<code>key</code>与不使用<code>key</code>的区别：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当拥有<code>key</code>的时候，<code>react</code>根据<code>key</code>属性匹配原有树上的子元素以及最新树上的子元素，像上述情况只需要将 000 元素插入到最前面位置</p>\n<p>当没有<code>key</code>的时候，所有的<code>li</code>标签都需要进行修改</p>\n<p>同样，并不是拥有<code>key</code>值代表性能越高，如果说只是文本内容改变了，不写<code>key</code>反而性能和效率更高</p>\n<p>主要是因为不写<code>key</code>是将所有的文本内容替换一下，节点不会发生变化</p>\n<p>而写<code>key</code>则涉及到了节点的增和删，发现旧<code>key</code>不存在了，则将其删除，新<code>key</code>在之前没有，则插入，这就增加性能的开销</p>\n<h2> 三、总结</h2>\n<p>良好使用<code>key</code>属性是性能优化的非常关键的一步，注意事项为：</p>\n<ul>\n<li>\n<p>key 应该是唯一的</p>\n</li>\n<li>\n<p>key 不要使用随机值（随机数在下一次 render 时，会重新生成一个数字）</p>\n</li>\n<li>\n<p>使用 index 作为 key 值，对性能没有优化</p>\n</li>\n</ul>\n<p><code>react</code>判断<code>key</code>的流程具体如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3b9afe10-dd69-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh-hans.reactjs.org/docs/lists-and-keys.html#gatsby-focus-wrapper\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh-hans.reactjs.org/docs/lists-and-keys.html#gatsby-focus-wrapper</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017511836\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000017511836</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-05T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？",
      "url": "https://www.h7ml.cn/posts/interview/React/life_cycle.html",
      "id": "https://www.h7ml.cn/posts/interview/React/life_cycle.html",
      "summary": "前端物语|面试物语-说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？",
      "content_html": "<h1> 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5c717010-d373-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在<a href=\"https://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&amp;mid=2247484176&amp;idx=1&amp;sn=5623421ed2678046ed9e438aadf6e26f&amp;chksm=fc10c146cb67485015f24f7e9f5862c4c685fc33485fe30e1b375a534b4031978439c554e0c0&amp;scene=178&amp;cur_album_id=1711105826272116736#rd\" target=\"_blank\" rel=\"noopener noreferrer\">以前文章</a>中，我们了解到生命周期定义</p>\n<p>生命周期<code>（Life Cycle）</code>的概念应用很广泛，特别是在经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”<code>（Cradle-to-Grave）</code>的整个过程</p>\n<p>跟<code>Vue</code>一样，<code>React</code>整个组件生命周期包括从创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、卸载等一系列过程</p>\n<h2> 二、流程</h2>\n<p>这里主要讲述<code>react16.4</code>之后的生命周期，可以分成三个阶段：</p>\n<ul>\n<li>创建阶段</li>\n<li>更新阶段</li>\n<li>卸载阶段</li>\n</ul>\n<h3> 创建阶段</h3>\n<p>创建阶段主要分成了以下几个生命周期方法：</p>\n<ul>\n<li>constructor</li>\n<li>getDerivedStateFromProps</li>\n<li>render</li>\n<li>componentDidMount</li>\n</ul>\n<h4> constructor</h4>\n<p>实例过程中自动调用的方法，在方法内部通过<code>super</code>关键字获取来自父组件的<code>props</code></p>\n<p>在该方法中，通常的操作为初始化<code>state</code>状态或者在<code>this</code>上挂载方法</p>\n<h3> getDerivedStateFromProps</h3>\n<p>该方法是新增的生命周期方法，是一个静态的方法，因此不能访问到组件的实例</p>\n<p>执行时机：组件创建和更新阶段，不论是<code>props</code>变化还是<code>state</code>变化，也会调用</p>\n<p>在每次<code>render</code>方法前调用，第一个参数为即将更新的<code>props</code>，第二个参数为上一个状态的<code>state</code>，可以比较<code>props</code> 和 <code>state</code>来加一些限制条件，防止无用的 state 更新</p>\n<p>该方法需要返回一个新的对象作为新的<code>state</code>或者返回<code>null</code>表示<code>state</code>状态不需要更新</p>\n<h3> render</h3>\n<p>类组件必须实现的方法，用于渲染<code>DOM</code>结构，可以访问组件<code>state</code>与<code>prop</code>属性</p>\n<p>注意： 不要在 <code>render</code> 里面 <code>setState</code>, 否则会触发死循环导致内存崩溃</p>\n<h3> componentDidMount</h3>\n<p>组件挂载到真实<code>DOM</code>节点后执行，其在<code>render</code>方法之后执行</p>\n<p>此方法多用于执行一些数据获取，事件监听等操作</p>\n<h3> 更新阶段</h3>\n<p>该阶段的函数主要为如下方法：</p>\n<ul>\n<li>getDerivedStateFromProps</li>\n<li>shouldComponentUpdate</li>\n<li>render</li>\n<li>getSnapshotBeforeUpdate</li>\n<li>componentDidUpdate</li>\n</ul>\n<h3> getDerivedStateFromProps</h3>\n<p>该方法介绍同上</p>\n<h2> shouldComponentUpdate</h2>\n<p>用于告知组件本身基于当前的<code>props</code>和<code>state</code>是否需要重新渲染组件，默认情况返回<code>true</code></p>\n<p>执行时机：到新的 props 或者 state 时都会调用，通过返回 true 或者 false 告知组件更新与否</p>\n<p>一般情况，不建议在该周期方法中进行深层比较，会影响效率</p>\n<p>同时也不能调用<code>setState</code>，否则会导致无限循环调用更新</p>\n<h3> render</h3>\n<p>介绍如上</p>\n<h3> getSnapshotBeforeUpdate</h3>\n<p>该周期函数在<code>render</code>后执行，执行之时<code>DOM</code>元素还没有被更新</p>\n<p>该方法返回的一个<code>Snapshot</code>值，作为<code>componentDidUpdate</code>第三个参数传入</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>此方法的目的在于获取组件更新前的一些信息，比如组件的滚动位置之类的，在组件更新后可以根据这些信息恢复一些 UI 视觉上的状态</p>\n<h3> componentDidUpdate</h3>\n<p>执行时机：组件更新结束后触发</p>\n<p>在该方法中，可以根据前后的<code>props</code>和<code>state</code>的变化做相应的操作，如获取数据，修改<code>DOM</code>样式等</p>\n<h3> 卸载阶段</h3>\n<h2> componentWillUnmount</h2>\n<p>此方法用于组件卸载前，清理一些注册是监听事件，或者取消订阅的网络请求等</p>\n<p>一旦一个组件实例被卸载，其不会被再次挂载，而只可能是被重新创建</p>\n<h2> 三、总结</h2>\n<p>新版生命周期整体流程如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/66c999c0-d373-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>旧的生命周期流程图如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d379e420-d374-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>通过两个图的对比，可以发现新版的生命周期减少了以下三种方法：</p>\n<ul>\n<li>componentWillMount</li>\n<li>componentWillReceiveProps</li>\n<li>componentWillUpdate</li>\n</ul>\n<p>其实这三个方法仍然存在，只是在前者加上了<code>UNSAFE_</code>前缀，如<code>UNSAFE_componentWillMount</code>，并不像字面意思那样表示不安全，而是表示这些生命周期的代码可能在未来的 <code>react</code>版本可能废除</p>\n<p>同时也新增了两个生命周期函数：</p>\n<ul>\n<li>getDerivedStateFromProps</li>\n<li>getSnapshotBeforeUpdate</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://github.com/pomelovico/keep/issues/23\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/pomelovico/keep/issues/23</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000020268993\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000020268993</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说 React render 方法的原理？在什么时候会被触发？",
      "url": "https://www.h7ml.cn/posts/interview/React/render.html",
      "id": "https://www.h7ml.cn/posts/interview/React/render.html",
      "summary": "前端物语|面试物语-说说 React render 方法的原理？在什么时候会被触发？",
      "content_html": "<h1> 说说 React render 方法的原理？在什么时候会被触发？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3d855230-ec6d-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、原理</h2>\n<p>首先，<code>render</code>函数在<code>react</code>中有两种形式：</p>\n<p>在类组件中，指的是<code>render</code>方法：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在函数组件中，指的是函数组件本身：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在<code>render</code>中，我们会编写<code>jsx</code>，<code>jsx</code>通过<code>babel</code>编译后就会转化成我们熟悉的<code>js</code>格式，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>babel</code>编译后：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从名字上来看，<code>createElement</code>方法用来元素的</p>\n<p>在<code>react</code>中，这个元素就是虚拟<code>DOM</code>树的节点，接收三个参数：</p>\n<ul>\n<li>\n<p>type：标签</p>\n</li>\n<li>\n<p>attributes：标签属性，若无则为 null</p>\n</li>\n<li>\n<p>children：标签的子节点</p>\n</li>\n</ul>\n<p>这些虚拟<code>DOM</code>树最终会渲染成真实<code>DOM</code></p>\n<p>在<code>render</code>过程中，<code>React</code> 将新调用的 <code>render</code>函数返回的树与旧版本的树进行比较，这一步是决定如何更新 <code>DOM</code> 的必要步骤，然后进行 <code>diff</code> 比较，更新 <code>DOM</code>树</p>\n<h2> 二、触发时机</h2>\n<p><code>render</code>的执行时机主要分成了两部分：</p>\n<ul>\n<li>类组件调用 setState 修改状态</li>\n</ul>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>点击按钮，则调用<code>setState</code>方法，无论<code>count</code>发生变化辩护，控制台都会输出<code>Foo render</code>，证明<code>render</code>执行了</p>\n<ul>\n<li>函数组件通过<code>useState hook</code>修改状态</li>\n</ul>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>函数组件通过<code>useState</code>这种形式更新数据，当数组的值不发生改变了，就不会触发<code>render</code></p>\n<ul>\n<li>类组件重新渲染</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>只要点击了 <code>App</code> 组件内的 <code>Change name</code> 按钮，不管 <code>Foo</code> 具体实现是什么，都会被重新<code>render</code>渲染</p>\n<ul>\n<li>函数组件重新渲染</li>\n</ul>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以发现，使用<code>useState</code>来更新状态的时候，只有首次会触发<code>Foo render</code>，后面并不会导致<code>Foo render</code></p>\n<h2> 三、总结</h2>\n<p><code>render</code>函数里面可以编写<code>JSX</code>，转化成<code>createElement</code>这种形式，用于生成虚拟<code>DOM</code>，最终转化成真实<code>DOM</code></p>\n<p>在<code>React</code> 中，类组件只要执行了 <code>setState</code> 方法，就一定会触发 <code>render</code> 函数执行，函数组件使用<code>useState</code>更改状态不一定导致重新<code>render</code></p>\n<p>组件的<code>props</code> 改变了，不一定触发 <code>render</code> 函数的执行，但是如果 <code>props</code> 的值来自于父组件或者祖先组件的 <code>state</code></p>\n<p>在这种情况下，父组件或者祖先组件的 <code>state</code> 发生了改变，就会导致子组件的重新渲染</p>\n<p>所以，一旦执行了<code>setState</code>就会执行<code>render</code>方法，<code>useState</code> 会判断当前值有无发生改变确定是否执行<code>render</code>方法，一旦父组件发生渲染，子组件也会渲染</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/229784b0-ecf5-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/45091185\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/45091185</a></li>\n<li><a href=\"https://juejin.cn/post/6844904181493415950\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904181493415950</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-04T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说 React 服务端渲染怎么做？原理是什么？",
      "url": "https://www.h7ml.cn/posts/interview/React/server_side_rendering.html",
      "id": "https://www.h7ml.cn/posts/interview/React/server_side_rendering.html",
      "summary": "前端物语|面试物语-说说 React 服务端渲染怎么做？原理是什么？",
      "content_html": "<h1> 说说 React 服务端渲染怎么做？原理是什么？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8c93cbe0-f3f7-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在<a href=\"https://mp.weixin.qq.com/s/vvUtC_aAprUjoJRnfFjA1A\" target=\"_blank\" rel=\"noopener noreferrer\">SSR 中</a>，我们了解到<code>Server-Side Rendering</code> ，简称<code>SSR</code>，意为服务端渲染</p>\n<p>指由服务侧完成页面的 <code>HTML</code> 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/96dc3e20-f3f7-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>其解决的问题主要有两个：</p>\n<ul>\n<li>SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面</li>\n<li>加速首屏加载，解决首屏白屏问题</li>\n</ul>\n<h2> 二、如何做</h2>\n<p>在<code>react</code>中，实现<code>SSR</code>主要有两种形式：</p>\n<ul>\n<li>手动搭建一个 SSR 框架</li>\n<li>使用成熟的 SSR 框架，如 Next.JS</li>\n</ul>\n<p>这里主要以手动搭建一个<code>SSR</code>框架进行实现</p>\n<p>首先通过<code>express</code>启动一个<code>app.js</code>文件，用于监听 3000 端口的请求，当请求根目录时，返回<code>HTML</code>，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后再服务器中编写<code>react</code>代码，在<code>app.js</code>中进行应引用</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为了让服务器能够识别<code>JSX</code>，这里需要使用<code>webpakc</code>对项目进行打包转换，创建一个配置文件<code>webpack.server.js</code>并进行相关配置，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>接着借助<code>react-dom</code>提供了服务端渲染的 <code>renderToString</code>方法，负责把<code>React</code>组件解析成<code>html</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的过程中，已经能够成功将组件渲染到了页面上</p>\n<p>但是像一些事件处理的方法，是无法在服务端完成，因此需要将组件代码在浏览器中再执行一遍，这种服务器端和客户端共用一套代码的方式就称之为<strong>同构</strong></p>\n<p>重构通俗讲就是一套 React 代码在服务器上运行一遍，到达浏览器又运行一遍：</p>\n<ul>\n<li>服务端渲染完成页面结构</li>\n<li>浏览器端渲染完成事件绑定</li>\n</ul>\n<p>浏览器实现事件绑定的方式为让浏览器去拉取<code>JS</code>文件执行，让<code>JS</code>代码来控制，因此需要引入<code>script</code>标签</p>\n<p>通过<code>script</code>标签为页面引入客户端执行的<code>react</code>代码，并通过<code>express</code>的<code>static</code>中间件为<code>js</code>文件配置路由，修改如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后再客户端执行以下<code>react</code>代码，新建<code>webpack.client.js</code>作为客户端 React 代码的<code>webpack</code>配置文件如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种方法就能够简单实现首页的<code>react</code>服务端渲染，过程对应如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a2894970-f3f7-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在做完初始渲染的时候，一个应用会存在路由的情况，配置信息如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后可以通过<code>index.js</code>引用路由信息，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这时候控制台会存在报错信息，原因在于每个<code>Route</code>组件外面包裹着一层<code>div</code>，但服务端返回的代码中并没有这个<code>div</code></p>\n<p>解决方法只需要将路由信息在服务端执行一遍，使用使用<code>StaticRouter</code>来替代<code>BrowserRouter</code>，通过<code>context</code>进行参数传递</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样也就完成了路由的服务端渲染</p>\n<h2> 三、原理</h2>\n<p>整体<code>react</code>服务端渲染原理并不复杂，具体如下：</p>\n<p><code>node server</code> 接收客户端请求，得到当前的请求<code>url</code> 路径，然后在已有的路由表内查找到对应的组件，拿到需要请求的数据，将数据作为 <code>props</code>、<code>context</code>或者<code>store</code> 形式传入组件</p>\n<p>然后基于 <code>react</code> 内置的服务端渲染方法 <code>renderToString()</code>把组件渲染为 <code>html</code>字符串在把最终的 <code>html</code>进行输出前需要将数据注入到浏览器端</p>\n<p>浏览器开始进行渲染和节点对比，然后执行完成组件内事件绑定和一些交互，浏览器重用了服务端输出的 <code>html</code> 节点，整个流程结束</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/52693113\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/52693113</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000020417285\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000020417285</a></li>\n<li><a href=\"https://juejin.cn/post/6844904000387563533#heading-14\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904000387563533#heading-14</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-21T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说 React 中的 setState 执行机制",
      "url": "https://www.h7ml.cn/posts/interview/React/setState.html",
      "id": "https://www.h7ml.cn/posts/interview/React/setState.html",
      "summary": "前端物语|面试物语-说说 React 中的 setState 执行机制",
      "content_html": "<h1> 说说 React 中的 setState 执行机制</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3acb8ca0-d825-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是<code>state</code></p>\n<p>当需要修改里面的值的状态需要通过调用<code>setState</code>来改变，从而达到更新组件内部数据的作用</p>\n<p>如下例子：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过点击按钮触发<code>onclick</code>事件，执行<code>this.setState</code>方法更新<code>state</code>状态，然后重新执行<code>render</code>函数，从而导致页面的视图更新</p>\n<p>如果直接修改<code>state</code>的状态，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们会发现页面并不会有任何反应，但是<code>state</code>的状态是已经发生了改变</p>\n<p>这是因为<code>React</code>并不像<code>vue2</code>中调用<code>Object.defineProperty</code>数据响应式或者<code>Vue3</code>调用<code>Proxy</code>监听数据的变化</p>\n<p>必须通过<code>setState</code>方法来告知<code>react</code>组件<code>state</code>已经发生了改变</p>\n<p>关于<code>state</code>方法的定义是从<code>React.Component</code>中继承，定义的源码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面可以看到<code>setState</code>第一个参数可以是一个对象，或者是一个函数，而第二个参数是一个回调函数，用于可以实时的获取到更新之后的数据</p>\n<h2> 二、更新类型</h2>\n<p>在使用<code>setState</code>更新数据的时候，<code>setState</code>的更新类型分成：</p>\n<ul>\n<li>异步更新</li>\n<li>同步更新</li>\n</ul>\n<h3> 异步更新</h3>\n<p>先举出一个例子：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面可以看到，最终打印结果为<code>Hello world</code>，并不能在执行完<code>setState</code>之后立马拿到最新的<code>state</code>的结果</p>\n<p>如果想要立刻获取更新后的值，在第二个参数的回调中更新后会执行</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 同步更新</h3>\n<p>同样先给出一个在<code>setTimeout</code>中更新的例子：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的例子中，可以看到更新是同步</p>\n<p>再来举一个原生<code>DOM</code>事件的例子：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 小结</h3>\n<ul>\n<li>在组件生命周期或 React 合成事件中，setState 是异步</li>\n<li>在 setTimeout 或者原生 dom 事件中，setState 是同步</li>\n</ul>\n<h3> 三、批量更新</h3>\n<p>同样先给出一个例子：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>点击按钮触发事件，打印的都是 1，页面显示 <code>count</code> 的值为 2</p>\n<p>对同一个值进行多次 <code>setState</code>， <code>setState</code> 的批量更新策略会对其进行覆盖，取最后一次的执行结果</p>\n<p>上述的例子，实际等价于如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>由于后面的数据会覆盖前面的更改，所以最终只加了一次</p>\n<p>如果是下一个<code>state</code>依赖前一个<code>state</code>的话，推荐给<code>setState</code>一个参数传入一个<code>function</code>，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>而在<code>setTimeout</code>或者原生<code>dom</code>事件中，由于是同步的操作，所以并不会进行覆盖现象</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844903667426918408\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903667426918408</a></li>\n<li><a href=\"https://juejin.cn/post/6844903636749778958\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903636749778958</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000039077904\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000039077904</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "state 和 props 有什么区别？",
      "url": "https://www.h7ml.cn/posts/interview/React/state_props.html",
      "id": "https://www.h7ml.cn/posts/interview/React/state_props.html",
      "summary": "前端物语|面试物语-state 和 props 有什么区别？",
      "content_html": "<h1> state 和 props 有什么区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7f272780-d440-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、state</h2>\n<p>一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是 <code>state</code>，一般在 <code>constructor</code> 中初始化</p>\n<p>当需要修改里面的值的状态需要通过调用 <code>setState</code> 来改变，从而达到更新组件内部数据的作用，并且重新调用组件 <code>render</code> 方法，如下面的例子：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>setState</code> 还可以接受第二个参数，它是一个函数，会在 <code>setState</code> 调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、props</h2>\n<p><code>React</code> 的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件</p>\n<p>组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是 <code>props</code>，所以可以把 <code>props</code> 理解为从外部传入组件内部的数据</p>\n<p><code>react</code> 具有单向数据流的特性，所以他的主要作用是从父组件向子组件中传递数据</p>\n<p><code>props</code> 除了可以传字符串，数字，还可以传递对象，数组甚至是回调函数，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述 <code>name</code> 属性与 <code>onNameChanged</code> 方法都能在子组件的 <code>props</code> 变量中访问</p>\n<p>在子组件中，<code>props</code> 在内部不可变的，如果想要改变它看，只能通过外部组件传入新的 <code>props</code> 来重新渲染子组件，否则子组件的 <code>props</code> 和展示形式不会改变</p>\n<h2> 三、区别</h2>\n<p>相同点：</p>\n<ul>\n<li>两者都是 JavaScript 对象</li>\n<li>两者都是用于保存信息</li>\n<li>props 和 state 都能触发渲染更新</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>props 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化</li>\n<li>props 在组件内部是不可修改的，但 state 在组件内部可以进行修改</li>\n<li>state 是多变的、可以修改</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://lucybain.com/blog/2016/react-state-vs-pros/\" target=\"_blank\" rel=\"noopener noreferrer\">https://lucybain.com/blog/2016/react-state-vs-pros/</a></li>\n<li><a href=\"https://juejin.cn/post/6844904009203974158\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904009203974158</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-16T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "super() 和 super(props) 有什么区别？",
      "url": "https://www.h7ml.cn/posts/interview/React/super()_super(props).html",
      "id": "https://www.h7ml.cn/posts/interview/React/super()_super(props).html",
      "summary": "前端物语|面试物语-super() 和 super(props) 有什么区别？",
      "content_html": "<h1> super() 和 super(props) 有什么区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/618abaf0-d71c-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、ES6 类</h2>\n<p>在 <code>ES6</code> 中，通过 <code>extends</code> 关键字实现类的继承，方式如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在上面的例子中，可以看到通过 <code>super</code> 关键字实现调用父类，<code>super</code> 代替的是父类的构建函数，使用 <code>super(name)</code> 相当于调用 <code>sup.prototype.constructor.call(this,name)</code></p>\n<p>如果在子类中不使用 <code>super</code>，关键字，则会引发报错，如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6ab40190-d71c-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>报错的原因是 子类是没有自己的 <code>this</code> 对象的，它只能继承父类的 <code>this</code> 对象，然后对其进行加工</p>\n<p>而 <code>super()</code> 就是将父类中的 <code>this</code> 对象继承给子类的，没有 <code>super()</code> 子类就得不到 <code>this</code> 对象</p>\n<p>如果先调用 <code>this</code>，再初始化 <code>super()</code>，同样是禁止的行为</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>所以在子类 <code>constructor</code> 中，必须先代用 <code>super</code> 才能引用 <code>this</code></p>\n<h2> 二、类组件</h2>\n<p>在 <code>React</code> 中，类组件是基于 <code>ES6</code> 的规范实现的，继承 <code>React.Component</code>，因此如果用到 <code>constructor</code> 就必须写 <code>super()</code> 才初始化 <code>this</code></p>\n<p>这时候，在调用 <code>super()</code> 的时候，我们一般都需要传入 <code>props</code> 作为参数，如果不传进去，<code>React</code> 内部也会将其定义在组件实例中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>所以无论有没有 <code>constructor</code>，在 <code>render</code> 中 <code>this.props</code> 都是可以使用的，这是 <code>React</code> 自动附带的，是可以不写的：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但是也不建议使用 <code>super()</code> 代替 <code>super(props)</code></p>\n<p>因为在 <code>React</code> 会在类组件构造函数生成实例后再给 <code>this.props</code> 赋值，所以在不传递 <code>props</code> 在 <code>super</code> 的情况下，调用 <code>this.props</code> 为 <code>undefined</code>，如下情况：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>而传入 <code>props</code> 的则都能正常访问，确保了 <code>this.props</code> 在构造函数执行完毕之前已被赋值，更符合逻辑，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、总结</h2>\n<p>在 <code>React</code> 中，类组件基于 <code>ES6</code>，所以在 <code>constructor</code> 中必须使用 <code>super</code></p>\n<p>在调用 <code>super</code> 过程，无论是否传入 <code>props</code>，<code>React</code> 内部都会将 <code>porps</code> 赋值给组件实例 <code>porps</code> 属性中</p>\n<p>如果只调用了 <code>super()</code>，那么 <code>this.props</code> 在 <code>super()</code> 和构造函数结束之间仍是 <code>undefined</code></p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://overreacted.io/zh-hans/why-do-we-write-super-props/\" target=\"_blank\" rel=\"noopener noreferrer\">https://overreacted.io/zh-hans/why-do-we-write-super-props/</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000008340434\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/q/1010000008340434</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-10T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "React"
      ]
    },
    {
      "title": "说说你对算法的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/Algorithm.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/Algorithm.html",
      "summary": "前端物语|面试物语-说说你对算法的理解？应用场景？",
      "content_html": "<h1> 说说你对算法的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/eca03690-1620-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制</p>\n<p>也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出</p>\n<p>如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题</p>\n<p>一个程序=算法+数据结构，数据结构是算法实现的基础，算法总是要依赖于某种数据结构来实现的，两者不可分割</p>\n<p>因此，算法的设计和选择要同时结合数据结构，简单地说数据结构的设计就是选择存储方式，如确定问题中的信息是用数组存储还是用普通的变量存储或其他更加复杂的数据结构</p>\n<p>针对上述，可以得出一个总结：不同的算法可能用不同的时间、空间或效率来完成同样的任务</p>\n<h2> 二、特性</h2>\n<p>关于算法的五大特性，有如下：</p>\n<ul>\n<li>有限性（Finiteness）：一个算法必须保证执行有限步之后结束</li>\n<li>确切性（Definiteness）： 一个算法的每一步骤必须有确切的定义</li>\n<li>输入（Input）：一个算法有零个或多个输入，以刻画运算对象的初始情况，所谓零个输入是指算法本身给定了初始条件</li>\n<li>输出（Output）：一个算法有一个或多个输出。没有输出的算法毫无意义</li>\n<li>可行性（Effectiveness）：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）</li>\n</ul>\n<h2> 三、应用场景</h2>\n<p>在前端领域中，数据结构与算法无法不在，例如现在的<code>vue</code>或者<code>react</code>项目，实现虚拟<code>DOM</code>或者<code>Fiber</code>结构，本质就是一种数据结构，如下一个简单的虚拟<code>DOM</code>：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>vue</code>与<code>react</code>都能基于基于对应的数据结构实现<code>diff</code>算法，提高了整个框架的性能以及拓展性</p>\n<p>包括在前端<code>javascript</code>编译的时候，都会生成对应的抽象语法树<code>AST</code>，其本身不涉及到任何语法，因此你只要编写相应的转义规则，就可以将任何语法转义到任何语法，也是<code>babel</code>， <code>PostCSS</code>, <code>prettier</code>， <code>typescript</code></p>\n<p>除了这些框架或者工具底层用到算法与数据结构之外，日常业务也无处不在，例如实现一个输入框携带联想功能，如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/682d16c0-1621-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>如果我们要实现这个功能， 则可以使用前缀树，如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/55a1ed50-1621-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>包括前端可能会做一些对字符串进行相似度检测，例如\"每日一题\"和\"js 每日一题\"两个字符串进行相似度对比，这种情况可以通过“最小编辑距离”算法，如果<code>a</code>和<code>b</code>的编辑距离越小，我们认为越相似</p>\n<p>日常在编写任何代码的都需要一个良好的算法思维，选择好的算法或者数据结构，能让整个程序效率更高</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/算法/209025</a></li>\n<li><a href=\"https://lucifer.ren/blog/2019/09/18/algorthimn-fe-1/\" target=\"_blank\" rel=\"noopener noreferrer\">https://lucifer.ren/blog/2019/09/18/algorthimn-fe-1/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-14T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对二分查找的理解？如何实现？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/BinarySearch.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/BinarySearch.html",
      "summary": "前端物语|面试物语-说说你对二分查找的理解？如何实现？应用场景？",
      "content_html": "<h1> 说说你对二分查找的理解？如何实现？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d43ca230-2987-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在计算机科学中，二分查找算法，也称折半搜索算法，是一种在有序数组中查找某一特定元素的搜索算法</p>\n<p>想要应用二分查找法，则这一堆数应有如下特性：</p>\n<ul>\n<li>存储在数组中</li>\n<li>有序排序</li>\n</ul>\n<p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束</p>\n<p>如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较</p>\n<p>如果在某一步骤数组为空，则代表找不到</p>\n<p>这种搜索算法每一次比较都使搜索范围缩小一半</p>\n<p>如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e2108520-2987-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>相比普通的顺序查找，除了数据量很少的情况下，二分查找会比顺序查找更快，区别如下所示：</p>\n<figure><img src=\"https://pic2.zhimg.com/v2-43339b963db63b33107b56503ad6b1b5_b.gif\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、如何实现</h2>\n<p>基于二分查找的实现，如果数据是有序的，并且不存在重复项，实现代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果数组中存在重复项，而我们需要找出第一个制定的值，实现则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实际上，除了有序的数组可以使用，还有一种特殊的数组可以应用，那就是轮转后的有序数组</p>\n<p>有序数组即一个有序数字以某一个数为轴，将其之前的所有数都轮转到数组的末尾所得</p>\n<p>例如，[4, 5, 6, 7, 0, 1, 2]就是一个轮转后的有序数组</p>\n<p>该数组的特性是存在一个分界点用来分界两个有序数组，如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/eeee2130-2987-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>分界点有如下特性：</p>\n<ul>\n<li>分界点元素 &gt;= 第一个元素</li>\n<li>分界点元素 &lt; 第一个元素</li>\n</ul>\n<p>代码实现如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对比普通的二分查找法，为了确定目标数会落在二分后的哪个部分，我们需要更多的判定条件</p>\n<h2> 三、应用场景</h2>\n<p>二分查找法的<code>O(logn)</code>让它成为十分高效的算法。不过它的缺陷却也是比较明显，就在它的限定之上：</p>\n<ul>\n<li>有序：我们很难保证我们的数组都是有序的</li>\n<li>数组：数组读取效率是 O(1)，可是它的插入和删除某个元素的效率却是 O(n)，并且数组的存储是需要连续的内存空间，不适合大数据的情况</li>\n</ul>\n<p>关于二分查找的应用场景，主要如下：</p>\n<ul>\n<li>不适合数据量太小的数列；数列太小，直接顺序遍历说不定更快，也更简单</li>\n<li>每次元素与元素的比较是比较耗时的，这个比较操作耗时占整个遍历算法时间的大部分，那么使用二分查找就能有效减少元素比较的次数</li>\n<li>不适合数据量太大的数列，二分查找作用的数据结构是顺序表，也就是数组，数组是需要连续的内存空间的，系统并不一定有这么大的连续内存空间可以使用</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95#javascript_%E7%89%88%E6%9C%AC\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/二分搜尋演算法#javascript_版本</a></li>\n<li><a href=\"https://www.cnblogs.com/ider/archive/2012/04/01/binary_search.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/ider/archive/2012/04/01/binary_search.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-27T04:29:21.779Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对堆的理解？如何实现？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/Heap.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/Heap.html",
      "summary": "前端物语|面试物语-说说你对堆的理解？如何实现？应用场景？",
      "content_html": "<h1> 说说你对堆的理解？如何实现？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/dd12c700-1ed7-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>堆(Heap)是计算机科学中一类特殊的数据结构的统称</p>\n<p>堆通常是一个可以被看做一棵完全二叉树的数组对象，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ea0fd1f0-1ed7-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>总是满足下列性质：</p>\n<ul>\n<li>堆中某个结点的值总是不大于或不小于其父结点的值</li>\n<li>堆总是一棵完全二叉树</li>\n</ul>\n<p>堆又可以分成最大堆和最小堆：</p>\n<ul>\n<li>最大堆：每个根结点，都有根结点的值大于两个孩子结点的值</li>\n<li>最小堆：每个根结点，都有根结点的值小于孩子结点的值</li>\n</ul>\n<h2> 二、操作</h2>\n<p>堆的元素存储方式，按照完全二叉树的顺序存储方式存储在一个一维数组中，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ea0fd1f0-1ed7-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>用一维数组存储则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>根据完全二叉树的特性，可以得到如下特性：</p>\n<ul>\n<li>数组零坐标代码的是堆顶元素</li>\n<li>一个节点的父亲节点的坐标等于其坐标除以 2 整数部分</li>\n<li>一个节点的左节点等于其本身节点坐标 * 2 + 1</li>\n<li>一个节点的右节点等于其本身节点坐标 * 2 + 2</li>\n</ul>\n<p>根据上述堆的特性，下面构建最小堆的构造函数和对应的属性方法：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>涉及到堆的操作有：</p>\n<ul>\n<li>插入</li>\n<li>删除</li>\n</ul>\n<h3> 插入</h3>\n<p>将值插入堆的底部，即数组的尾部，当插入一个新的元素之后，堆的结构就会被破坏，因此需要堆中一个元素做上移操作</p>\n<p>将这个值和它父节点进行交换，直到父节点小于等于这个插入的值，大小为<code>k</code>的堆中插入元素的时间复杂度为<code>O(logk)</code></p>\n<p>如下图所示，22 节点是新插入的元素，然后进行上移操作：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/06893fb0-1ed8-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>相关代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 删除</h3>\n<p>常见操作是用数组尾部元素替换堆顶，这里不直接删除堆顶，因为所有的元素会向前移动一位，会破坏了堆的结构</p>\n<p>然后进行下移操作，将新的堆顶和它的子节点进行交换，直到子节点大于等于这个新的堆顶，删除堆顶的时间复杂度为<code>O(logk)</code></p>\n<p>整体如下图操作：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/12a2a160-1ed8-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>相关代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 时间复杂度</h3>\n<p>关于堆的插入和删除时间复杂度都是<code>Olog(n)</code>，原因在于包含 n 个节点的完全二叉树，树的高度不会超过<code>log2n</code></p>\n<p>堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是<code>Olog(n)</code>，插入数据和删除堆顶元素的主要逻辑就是堆化</p>\n<h3> 三、总结</h3>\n<ul>\n<li>堆是一个完全二叉树</li>\n<li>堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值</li>\n<li>对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”</li>\n<li>对于每个节点的值都小于等于子树中每个节点值的堆，叫作“小顶堆”</li>\n<li>根据堆的特性，我们可以使用堆来进行排序操作，也可以使用其来求第几大或者第几小的值</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E5%A0%86/20606834\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/堆/20606834</a></li>\n<li><a href=\"https://xlbpowder.cn/2021/02/26/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/\" target=\"_blank\" rel=\"noopener noreferrer\">https://xlbpowder.cn/2021/02/26/堆和堆排序/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对链表的理解？常见的操作有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/LinkedList.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/LinkedList.html",
      "summary": "前端物语|面试物语-说说你对链表的理解？常见的操作有哪些？",
      "content_html": "<h1> 说说你对链表的理解？常见的操作有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d6638dd0-1c76-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>链表（Linked List）是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，由一系列结点（链表中每一个元素称为结点）组成</p>\n<p>每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e4e93490-1c76-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>节点用代码表示，则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>data 表示节点存放的数据</li>\n<li>next 表示下一个节点指向的内存空间</li>\n</ul>\n<p>相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到<code>O(1)</code>的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要 O(n)的时间，而线性表和顺序表相应的时间复杂度分别是<code>O(logn)</code>和<code>O(1)</code></p>\n<p>链表的结构也十分多，常见的有四种形式：</p>\n<ul>\n<li>单链表：除了头节点和尾节点，其他节点只包含一个后继指针</li>\n<li>循环链表：跟单链表唯一的区别就在于它的尾结点又指回了链表的头结点，首尾相连，形成了一个环</li>\n<li>双向链表：每个结点具有两个方向指针，后继指针(next)指向后面的结点，前驱指针(prev)指向前面的结点，其中节点的前驱指针和尾结点的后继指针均指向空地址 NULL</li>\n<li>双向循环链表：跟双向链表基本一致，不过头节点前驱指针指向尾迹诶单和尾节点的后继指针指向头节点</li>\n</ul>\n<h2> 二、操作</h2>\n<p>关于链表的操作可以主要分成如下：</p>\n<ul>\n<li>遍历</li>\n<li>插入</li>\n<li>删除</li>\n</ul>\n<h3> 遍历</h3>\n<p>遍历很好理解，就是根据<code>next</code>指针遍历下去，直到为<code>null</code>，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 插入</h3>\n<p>向链表中间插入一个元素，可以如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f5fe5fd0-1c76-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>可以看到，插入节点可以分成如下步骤：</p>\n<ul>\n<li>\n<p>存储插入位置的前一个节点</p>\n</li>\n<li>\n<p>存储插入位置的后一个节点</p>\n</li>\n<li>\n<p>将插入位置的前一个节点的 next 指向插入节点</p>\n</li>\n<li>\n<p>将插入节点的 next 指向前面存储的 next 节点</p>\n</li>\n</ul>\n<p>相关代码如下所示：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果在头节点进行插入操作的时候，会实现<code>previousNode</code>节点为<code>undefined</code>，不适合上述方式</p>\n<p>解放方式可以是在头节点前面添加一个虚拟头节点，保证插入行为一致</p>\n<h3> 删除</h3>\n<p>向链表任意位置删除节点，如下图操作：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/0160cd90-1c77-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从上图可以看到删除节点的步骤为如下：</p>\n<ul>\n<li>获取删除节点的前一个节点</li>\n<li>获取删除节点的后一个节点</li>\n<li>将前一个节点的 next 指向后一个节点</li>\n<li>向删除节点的 next 指向为 null</li>\n</ul>\n<p>如果想要删除制定的节点，示意代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同样如何希望删除节点处理行为一致，可以在头节点前面添加一个虚拟头节点</p>\n<h2> 三、应用场景</h2>\n<p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的<code>CPU</code>缓存、数据库缓存、浏览器缓存等等</p>\n<p>当缓存空间被用满时，我们可能会使用<code>LRU</code>最近最好使用策略去清楚，而实现<code>LRU</code>算法的数据结构是链表，思路如下：</p>\n<p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表</p>\n<ul>\n<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据的对应结点，并将其从原来的位置删除，并插入到链表头部</li>\n<li>如果此数据没在缓存链表中\n<ul>\n<li>如果此时缓存未满，可直接在链表头部插入新节点存储此数据</li>\n<li>如果此时缓存已满，则删除链表尾部节点，再在链表头部插入新节点</li>\n</ul>\n</li>\n</ul>\n<p>由于链表插入删除效率极高，达到 O(1)。对于不需要搜索但变动频繁且无法预知数量上限的数据的情况的时候，都可以使用链表</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/zh-hans/%E9%93%BE%E8%A1%A8\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/zh-hans/链表</a></li>\n<li><a href=\"https://mah93.github.io/2019/07/19/js-linked/\" target=\"_blank\" rel=\"noopener noreferrer\">https://mah93.github.io/2019/07/19/js-linked/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-13T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "前端物语|面试物语-algorithm",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/",
      "summary": "说说你对算法的理解？应用场景？ 说说你对二分查找的理解？如何实现？应用场景？ 说说你对堆的理解？如何实现？应用场景？ 说说你对链表的理解？常见的操作有哪些？ 说说你对冒泡排序的理解？如何实现？应用场景？ 说说你对分而治之、动态规划的理解？区别？ 说说你对贪心算法、回溯算法的理解？应用场景？ 说说你对图的理解？相关操作有哪些？ 说说你对插入排序的理解？如何实现？应用场景？ 说说你对归并排序的理解？如何实现？应用场景？ 说说你对快速排序的理解？如何实现？应用场景？ 说说你对选择排序的理解？如何实现？应用场景？ 说说你对集合的理解？常见的操作有哪些？ 说说常见的排序算法有哪些？区别？ 说说你对栈、队列的理解？应用场景？ 说说你对数据结构的理解？有哪些？区别？ 说说你对算法中时间复杂度，空间复杂度的理解？如何计算？ 说说你对树的理解？相关的操作有哪些？",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/Algorithm\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对算法的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/BinarySearch\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对二分查找的理解？如何实现？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/Heap\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对堆的理解？如何实现？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/LinkedList\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对链表的理解？常见的操作有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/bubbleSort\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对冒泡排序的理解？如何实现？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/design1\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对分而治之、动态规划的理解？区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/design2\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对贪心算法、回溯算法的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/graph\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对图的理解？相关操作有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/insertionSort\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对插入排序的理解？如何实现？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/mergeSort\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对归并排序的理解？如何实现？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/quickSort\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对快速排序的理解？如何实现？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/selectionSort\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对选择排序的理解？如何实现？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/set\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对集合的理解？常见的操作有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/sort\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说常见的排序算法有哪些？区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/stack_queue\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对栈、队列的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/structure\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对数据结构的理解？有哪些？区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/time_space\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对算法中时间复杂度，空间复杂度的理解？如何计算？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/algorithm/tree\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对树的理解？相关的操作有哪些？</a></li>\n</ul>\n",
      "date_published": "2023-04-16T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "algorithm"
      ]
    },
    {
      "title": "说说你对冒泡排序的理解？如何实现？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/bubbleSort.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/bubbleSort.html",
      "summary": "前端物语|面试物语-说说你对冒泡排序的理解？如何实现？应用场景？",
      "content_html": "<h1> 说说你对冒泡排序的理解？如何实现？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6f5e0850-2652-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法</p>\n<p>冒泡排序的思想就是在每次遍历一遍未排序的数列之后，将一个数据元素浮上去（也就是排好了一个数据）</p>\n<p>如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”</p>\n<p>假如我们要把 12、35、99、18、76 这 5 个数从大到小进行排序，那么数越大，越需要把它放在前面</p>\n<p>思路如下：</p>\n<ul>\n<li>从后开始遍历，首先比较 18 和 76，发现 76 比 18 大，就把两个数交换顺序，得到 12、35、99、76、18</li>\n<li>接着比较 76 和 99，发现 76 比 99 小，所以不用交换顺序</li>\n<li>接着比较 99 和 35，发现 99 比 35 大，交换顺序</li>\n<li>接着比较 99 和 12，发现 99 比 12 大，交换顺序</li>\n</ul>\n<p>最终第 1 趟排序的结果变成了 99、12、35、76、18，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7a363770-2652-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>上述可以看到，经过第一趟的排序，可以得到最大的元素，接下来第二趟排序则对剩下的的 4 个元素进行排序，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/84b9ddf0-2652-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>经过第 2 趟排序，结果为 99、76、12、35、18</p>\n<p>然后开始第 3 趟的排序，结果为 99、76、35、12、18</p>\n<p>然后第四趟排序结果为 99、76、35、18、12</p>\n<p>经过 4 趟排序之后，只剩一个 12 需要排序了，这时已经没有可比较的元素了，这时排序完成</p>\n<h2> 二、如何实现</h2>\n<p>如果要实现一个从小到大的排序，算法原理如下：</p>\n<ul>\n<li>首先比较相邻的元素，如果第一个元素比第二个元素大，则交换它们</li>\n<li>针对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样，最后的元素回事最大的数</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li>\n</ul>\n<figure><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>用代码表示则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到：冒泡排序在每一轮排序中都会使一个元素排到一趟， 也就是最终需要 n-1 轮这样的排序</p>\n<p>而在每轮排序中都需要对相邻的两个元素进行比较，在最坏的情况下，每次比较之后都需要交换位置，此时时间复杂度为<code>O(n^2)</code></p>\n<h3> 优化</h3>\n<p>对冒泡排序常见的改进方法是加入一标志性变量<code>exchange</code>，用于标志某一趟排序过程中是否有数据交换</p>\n<p>如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程</p>\n<p>可以设置一标志性变量<code>pos</code>，用于记录每趟排序中最后一次进行交换的位置，由于<code>pos</code>位置之后的记录均已交换到位，故在进行下一趟排序时只要扫描到<code>pos</code>位置即可，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在待排序的数列有序的情况下，只需要一轮排序并且不用交换，此时情况最好，时间复杂度为<code>O(n)</code></p>\n<p>并且从上述比较中看到，只有后一个元素比前面的元素大（小）时才会对它们交换位置并向上冒出，对于同样大小的元素，是不需要交换位置的，所以对于同样大小的元素来说，相对位置是不会改变的，因此， 冒泡排序是稳定的</p>\n<h2> 三、应用场景</h2>\n<p>冒泡排的核心部分是双重嵌套循环，时间复杂度是 O(N 2 )，相比其它排序算法，这是一个相对较高的时间复杂度，一般情况不推荐使用，由于冒泡排序的简洁性，通常被用来对于程序设计入门的学生介绍算法的概念</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/冒泡排序/4602306</a></li>\n<li><a href=\"https://www.runoob.com/w3cnote/bubble-sort.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.runoob.com/w3cnote/bubble-sort.html</a></li>\n<li><a href=\"http://data.biancheng.net/view/116.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://data.biancheng.net/view/116.html</a></li>\n<li><a href=\"https://dsb123dsb.github.io/2017/03/07/js%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener noreferrer\">https://dsb123dsb.github.io/2017/03/07/js实现冒泡排序以及优化/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-28T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对分而治之、动态规划的理解？区别？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/design1.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/design1.html",
      "summary": "前端物语|面试物语-说说你对分而治之、动态规划的理解？区别？",
      "content_html": "<h1> 说说你对分而治之、动态规划的理解？区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/298437b0-29d0-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、分而治之</h2>\n<p>分而治之是算法设计中的一种方法，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</p>\n<p>关于分而治之的实现，都会经历三个步骤：</p>\n<ul>\n<li>分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题</li>\n<li>解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题</li>\n<li>合并：将各子问题的解合并为原问题的解</li>\n</ul>\n<p>实际上，关于分而治之的思想，我们在前面已经使用，例如归并排序的实现，同样经历了实现分而治之的三个步骤：</p>\n<ul>\n<li>\n<p>分解：把数组从中间一分为二</p>\n</li>\n<li>\n<p>解决：递归地对两个子数组进行归并排序</p>\n</li>\n<li>\n<p>合并：将两个字数组合并称有序数组</p>\n</li>\n</ul>\n<p>同样关于快速排序的实现，亦如此：</p>\n<ul>\n<li>分：选基准，按基准把数组分成两个字数组</li>\n<li>解：递归地对两个字数组进行快速排序</li>\n<li>合：对两个字数组进行合并</li>\n</ul>\n<p>同样二分搜索也能使用分而治之的思想去实现，代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、动态规划</h2>\n<p>动态规划，同样是算法设计中的一种方法，是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法</p>\n<p>常常适用于有重叠子问题和最优子结构性质的问题</p>\n<p>简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决</p>\n<p>然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。</p>\n<p>一般这些子问题很相似，可以通过函数关系式递推出来，例如斐波那契数列，我们可以得到公式：当 n 大于 2 的时候，F(n) = F(n-1) + F(n-2) ，</p>\n<p>f(10)= f(9)+f(8),f(9) = f(8) + f(7)...是重叠子问题，当 n = 1、2 的时候，对应的值为 2，这时候就通过可以使用一个数组记录每一步计算的结果，以此类推，减少不必要的重复计算</p>\n<h3> 适用场景</h3>\n<p>如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划</p>\n<p>比如一些求最值的场景，如最长递增子序列、最小编辑距离、背包问题、凑零钱问题等等，都是动态规划的经典应用场景</p>\n<p>关于动态规划题目解决的步骤，一般如下：</p>\n<ul>\n<li>描述最优解的结构</li>\n<li>递归定义最优解的值</li>\n<li>按自底向上的方式计算最优解的值</li>\n<li>由计算出的结果构造一个最优解</li>\n</ul>\n<h2> 三、区别</h2>\n<p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</p>\n<p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往<strong>不是互相独立</strong>的，而分而治之的子问题是相互独立的</p>\n<p>若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次</p>\n<p>如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间</p>\n<p>综上，可得：</p>\n<ul>\n<li>\n<p>动态规划：有最优子结构和重叠子问题</p>\n</li>\n<li>\n<p>分而治之：各子问题独立</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/动态规划/529408</a></li>\n<li><a href=\"https://juejin.cn/post/6951922898638471181\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6951922898638471181</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对贪心算法、回溯算法的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/design2.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/design2.html",
      "summary": "前端物语|面试物语-说说你对贪心算法、回溯算法的理解？应用场景？",
      "content_html": "<h1> 说说你对贪心算法、回溯算法的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1d49eae0-2e8e-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、贪心算法</h2>\n<p>贪心算法，又称贪婪算法，是算法设计中的一种思想</p>\n<p>其期待每一个阶段都是局部最优的选择，从而达到全局最优，但是结果并不一定是最优的</p>\n<p>举个零钱兑换的例子，如果你有 1 元、2 元、5 元的钱币数张，用于兑换一定的金额，但是要求兑换的钱币张数最少</p>\n<p>如果现在你要兑换 11 元，按照贪心算法的思想，先选择面额最大的 5 元钱币进行兑换，那么就得到 11 = 5 + 5 + 1 的选择，这种情况是最优的</p>\n<p>但是如果你手上钱币的面额为 1、3、4，想要兑换 6 元，按照贪心算法的思路，我们会 6 = 4 + 1 + 1 这样选择，这种情况结果就不是最优的选择</p>\n<p>从上面例子可以看到，贪心算法存在一些弊端，使用到贪心算法的场景，都会存在一个特性：</p>\n<p>一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法</p>\n<p>至于是否选择贪心算法，主要看是否有如下两大特性：</p>\n<ul>\n<li>贪心选择：当某一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次做出的选择可以依赖以前做出的选择，但不需要依赖后面需要做出的选择</li>\n<li>最优子结构：如果一个问题的最优解包含其子问题的最优解，则此问题具备最优子结构的性质。问题的最优子结构性质是该问题是否可以用贪心算法求解的关键所在</li>\n</ul>\n<h2> 二、回溯算法</h2>\n<p>回溯算法，也是算法设计中的一种思想，是一种渐进式寻找并构建问题解决方式的策略</p>\n<p>回溯算法会先从一个可能的工作开始解决问题，如果不行，就回溯并选择另一个动作，知道将问题解决</p>\n<p>使用回溯算法的问题，有如下特性：</p>\n<ul>\n<li>有很多路，例如一个矩阵的方向或者树的路径</li>\n<li>在这些的路里面，有死路也有生路，思路即不符合题目要求的路，生路则符合</li>\n<li>通常使用递归来模拟所有的路</li>\n</ul>\n<p>常见的伪代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>重点解决三个问题：</p>\n<ul>\n<li>路径：也就是已经做出的选择</li>\n<li>选择列表</li>\n<li>结束条件</li>\n</ul>\n<p>例如经典使用回溯算法为解决全排列的问题，如下：</p>\n<p>一个不含重复数字的数组 <code>nums</code> ，我们要返回其所有可能的全排列，解决这个问题的思路是：</p>\n<ul>\n<li>用递归模拟所有的情况</li>\n<li>遇到包含重复元素的情况则回溯</li>\n<li>收集到所有到达递归终点的情况，并返回、</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2a030f00-2e8e-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>用代码表示则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、总结</h2>\n<p>前面也初步了解到分而治之、动态规划，现在再了解到贪心算法、回溯算法</p>\n<p>其中关于分而治之、动态规划、贪心策略三者的求解思路如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/504b5230-2e8e-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>其中三者对应的经典问题如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/62cdc910-2e8e-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/贪心算法</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/permutations/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-mfrp/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode-cn.com/problems/permutations/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-mfrp/</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1767046\" target=\"_blank\" rel=\"noopener noreferrer\">https://cloud.tencent.com/developer/article/1767046</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-29T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对图的理解？相关操作有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/graph.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/graph.html",
      "summary": "前端物语|面试物语-说说你对图的理解？相关操作有哪些？",
      "content_html": "<h1> 说说你对图的理解？相关操作有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7876c2f0-2059-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在计算机科学中，图是一种抽象的数据类型，在图中的数据元素通常称为结点，<code>V</code>是所有顶点的集合，<code>E</code>是所有边的集合</p>\n<p>如果两个顶点<code>v</code>,<code>w</code>，只能由<code>v</code>向<code>w</code>，而不能由<code>w</code>向<code>v</code>，那么我们就把这种情况叫做一个从 <code>v</code> 到 <code>w</code> 的有向边。<code>v</code>也被称做初始点，<code>w</code>也被称为终点。这种图就被称做有向图</p>\n<p>如果<code>v</code>和<code>w</code>是没有顺序的，从<code>v</code>到达<code>w</code>和从<code>w</code>到达<code>v</code>是完全相同的，这种图就被称为无向图</p>\n<p>图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系</p>\n<p>常见表达图的方式有如下：</p>\n<ul>\n<li>\n<p>邻接矩阵</p>\n</li>\n<li>\n<p>邻接表</p>\n</li>\n</ul>\n<h3> 邻接矩阵</h3>\n<p>通过使用一个二维数组<code>G[N][N]</code>进行表示<code>N</code>个点到<code>N-1</code>编号，通过邻接矩阵可以立刻看出两顶点之间是否存在一条边，只需要检查邻接矩阵行<code>i</code>和列<code>j</code>是否是非零值，对于无向图，邻接矩阵是对称的</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/881d4300-2059-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 邻接表</h3>\n<p>存储方式如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/949fedd0-2059-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在<code>javascript</code>中，可以使用<code>Object</code>进行表示，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>图的数据结构还可能包含和每条边相关联的数值（edge value），例如一个标号或一个数值（即权重，weight；表示花费、容量、长度等）</p>\n<h2> 二、操作</h2>\n<p>关于的图的操作常见的有：</p>\n<ul>\n<li>深度优先遍历</li>\n<li>广度优先遍历</li>\n</ul>\n<p>首先构建一个图的邻接矩阵表示，如下面的图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a1311790-2059-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>用代码表示则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 深度优先遍历</h3>\n<p>也就是尽可能的往深处的搜索图的分支</p>\n<p>实现思路是，首先应该确定一个根节点，然后对根节点的没访问过的相邻节点进行深度优先遍历</p>\n<p>确定以 0 为根节点，然后进行深度遍历，然后遍历 1，接着遍历 2，然后 3，此时完成一条分支<code>0 - 1- 2- 3</code>的遍历，换一条分支，也就是 4，4 后面因为 3 已经遍历过了，所以就不访问了</p>\n<p>用代码表示则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 广度优先遍历</h3>\n<p>先访问离根节点最近的节点，然后进行入队操作，解决思路如下：</p>\n<ul>\n<li>新建一个队列，把根节点入队</li>\n<li>把队头出队并访问</li>\n<li>把队头的没访问过的相邻节点入队</li>\n<li>重复二、三步骤，知道队列为空</li>\n</ul>\n<p>用代码标识则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、总结</h2>\n<p>通过上面的初步了解，可以看到图就是由顶点的有穷非空集合和顶点之间的边组成的集合，分成了无向图与有向图</p>\n<p>图的表达形式可以分成邻接矩阵和邻接表两种形式，在<code>javascript</code>中，则可以通过二维数组和对象的形式进行表达</p>\n<p>图实际是很复杂的，后续还可以延伸出无向图和带权图，对应如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b0d88200-2059-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/图_(数据结构)</a></li>\n<li><a href=\"https://www.kancloud.cn/imnotdown1019/java_core_full/2159607\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.kancloud.cn/imnotdown1019/java_core_full/2159607</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-16T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对插入排序的理解？如何实现？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/insertionSort.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/insertionSort.html",
      "summary": "前端物语|面试物语-说说你对插入排序的理解？如何实现？应用场景？",
      "content_html": "<h1> 说说你对插入排序的理解？如何实现？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/912adc10-267f-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>插入排序（Insertion Sort），一般也被称为直接插入排序。对于少量元素的排序，它是一个有效、简单的算法</p>\n<p>其主要的实现思想是将数据按照一定的顺序一个一个的插入到有序的表中，最终得到的序列就是已经排序好的数据</p>\n<p>插入排序的工作方式像许多人排序一手扑克牌，开始时，我们的左手为空并且桌子上的牌面向下</p>\n<p>然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置，该正确位置需要从右到左将它与已在手中的每张牌进行比较</p>\n<p>例如一个无序数组 3、1、7、5、2、4、9、6，将其升序的结果则如下：</p>\n<p>一开始有序表中无数据，直接插入 3</p>\n<p>从第二个数开始，插入一个元素 1，然后和有序表中记录 3 比较，1&lt;3，所以插入到记录 3 的左侧</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9d24f5f0-267f-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>向有序表插入记录 7 时，同有序表中记录 3 进行比较，3&lt;7，所以插入到记录 3 的右侧</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a6a954e0-267f-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>向有序表中插入记录 5 时，同有序表中记录 7 进行比较，5&lt;7，同时 5&gt;3，所以插入到 3 和 7 中间</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b1981940-267f-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>照此规律，依次将无序表中的记录 4，9 和 6 插入到有序表中</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bc2ed290-267f-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、如何实现</h2>\n<p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>\n<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置</p>\n<p>如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面</p>\n<figure><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>用代码表示则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较<code>N- 1</code>次，时间复杂度为<code>O(n)</code></p>\n<p>最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为<code>O(n^2)</code></p>\n<p>通过上面了解，可以看到插入排序是一种稳定的排序方式</p>\n<h2> 三、应用场景</h2>\n<p>插入排序时间复杂度是 O(n2)，适用于数据量不大，算法稳定性要求高，且数据局部或整体有序的数列排序</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/插入排序/7214992</a></li>\n<li><a href=\"http://data.biancheng.net/view/65.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://data.biancheng.net/view/65.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-09T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对归并排序的理解？如何实现？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/mergeSort.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/mergeSort.html",
      "summary": "前端物语|面试物语-说说你对归并排序的理解？如何实现？应用场景？",
      "content_html": "<h1> 说说你对归并排序的理解？如何实现？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fa1d5720-26ac-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>归并排序（Merge Sort）是建立归并操作上的一种有效，稳定的排序算法，该算法是采用分治法的一个非常典型的应用</p>\n<p>将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序</p>\n<p>例如对于含有 <code>n</code> 个记录的无序表，首先默认表中每个记录各为一个有序表（只不过表的长度都为 1）</p>\n<p>然后进行两两合并，使 <code>n</code> 个有序表变为<code>n/2</code> 个长度为 2 或者 1 的有序表（例如 4 个小有序表合并为 2 个大的有序表）</p>\n<p>通过不断地进行两两合并，直到得到一个长度为 <code>n</code> 的有序表为止</p>\n<p>例如对无序表{49，38，65，97，76，13，27}进行归并排序分成了分、合两部分：</p>\n<p>如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/05f14b60-26ad-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>归并合过程中，每次得到的新的子表本身有序，所以最终得到有序表</p>\n<p>上述分成两部分，则称为二路归并，如果分成三个部分则称为三路归并，以此类推</p>\n<h2> 二、如何实现</h2>\n<p>关于归并排序的算法思路如下：</p>\n<ul>\n<li>\n<p>分：把数组分成两半，再递归对子数组进行分操作，直至到一个个单独数字</p>\n</li>\n<li>\n<p>合：把两个数合成有序数组，再对有序数组进行合并操作，直到全部子数组合成一个完整的数组</p>\n<ul>\n<li>合并操作可以新建一个数组，用于存放排序后的数组</li>\n<li>比较两个有序数组的头部，较小者出队并且推入到上述新建的数组中</li>\n<li>如果两个数组还有值，则重复上述第二步</li>\n<li>如果只有一个数组有值，则将该数组的值出队并推入到上述新建的数组中</li>\n</ul>\n</li>\n</ul>\n<figure><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>用代码表示则如下图所示：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述归并分成了分、合两部分，在处理分过程中递归调用两个分的操作，所花费的时间为 2 乘<code>T(n/2)</code>，合的操作时间复杂度则为<code>O(n)</code>，因此可以得到以下公式：</p>\n<p>总的执行时间 = 2 × 输入长度为<code>n/2</code>的<code>sort</code>函数的执行时间 + <code>merge</code>函数的执行时间<code>O(n)</code></p>\n<p>当只有一个元素时，<code>T(1) = O(1)</code></p>\n<p>如果对<code>T(n) = 2 * T(n/2) + O(n)</code>进行左右 / n 的操作，得到 <code>T(n) / n = (n / 2) * T(n/2) + O(1)</code></p>\n<p>现在令 <code>S(n) = T(n)/n</code>，则<code>S(1) = O(1)</code>，然后利用表达式带入得到<code>S(n) = S(n/2) + O(1)</code></p>\n<p>所以可以得到：<code>S(n) = S(n/2) + O(1) = S(n/4) + O(2) = S(n/8) + O(3) = S(n/2^k) + O(k) = S(1) + O(logn) = O(logn)</code></p>\n<p>综上可得，<code>T(n) = n * log(n) = nlogn</code></p>\n<p>关于归并排序的稳定性，在进行合并过程，在 1 个或 2 个元素时，1 个元素不会交换，2 个元素如果大小相等也不会交换，由此可见归并排序是稳定的排序算法</p>\n<h2> 三、应用场景</h2>\n<p>在外排序中通常使用排序-归并的策略，外排序是指处理超过内存限度的数据的排序算法，通常将中间结果放在读写较慢的外存储器，如下分成两个阶段：</p>\n<ul>\n<li>排序阶段：读入能够放进内存中的数据量，将其排序输出到临时文件，一次进行，将带排序数据组织为多个有序的临时文件</li>\n<li>归并阶段：将这些临时文件组合为大的有序文件</li>\n</ul>\n<p>例如，使用 100m 内存对 900m 的数据进行排序，过程如下：</p>\n<ul>\n<li>读入 100m 数据内存，用常规方式排序</li>\n<li>将排序后的数据写入磁盘</li>\n<li>重复前两个步骤，得到 9 个 100m 的临时文件</li>\n<li>将 100m 的内存划分为 10 份，将 9 份为输入缓冲区，第 10 份为输出缓冲区</li>\n<li>进行九路归并排序，将结果输出到缓冲区\n<ul>\n<li>若输出缓冲区满，将数据写到目标文件，清空缓冲区</li>\n<li>若缓冲区空，读入相应文件的下一份数据</li>\n</ul>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/归并排序/1639015</a></li>\n<li><a href=\"https://chowdera.com/2021/09/20210920201630258d.html#_127\" target=\"_blank\" rel=\"noopener noreferrer\">https://chowdera.com/2021/09/20210920201630258d.html#_127</a></li>\n<li><a href=\"https://juejin.cn/post/6844904007899561998\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904007899561998</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-03T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对快速排序的理解？如何实现？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/quickSort.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/quickSort.html",
      "summary": "前端物语|面试物语-说说你对快速排序的理解？如何实现？应用场景？",
      "content_html": "<h1> 说说你对快速排序的理解？如何实现？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bafae570-268a-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>快速排序（Quick Sort）算法是在冒泡排序的基础上进行改进的一种算法，从名字上看就知道该排序算法的特点是快、效率高，是处理大数据最快的排序算法之一</p>\n<p>实现的基本思想是：通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小</p>\n<p>然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就变成有序序列</p>\n<p>例如，对无序表 49，38，65，97，76，13，27，49 进行快速排序，大致过程为：</p>\n<ul>\n<li>\n<p>首先从表中选取一个记录的关键字作为分割点（称为“枢轴”或者支点，一般选择第一个关键字），例如选取 49</p>\n</li>\n<li 27，38，13，49，65，97，76，49=\"\">\n<p>将表格中大于 49 个放置于 49 的右侧，小于 49 的放置于 49 的左侧，假设完成后的无序表为：</p>\n</li>\n<li>\n<p>以 49 为支点，将整个无序表分割成了两个部分，分别为{27，38，13}和{65，97，76，49}，继续采用此种方法分别对两个子表进行排序</p>\n</li>\n<li 49，65，97，76=\"\">\n<p>前部分子表以 27 为支点，排序后的子表为{13，27，38}，此部分已经有序；后部分子表以 65 为支点，排序后的子表为</p>\n</li>\n<li 97=\"\" 76，=\"\">\n<p>此时前半部分子表中的数据已完成排序；后部分子表继续以 65 为支点，将其分割为{49}和{97，76}，前者不需排序，后者排序后的结果为</p>\n</li>\n<li 13，27，38，49，49，65，76，97=\"\">\n<p>通过以上几步的排序，最后由子表{13，27，38}、{49}、{49}、{65}、{76，97}构成有序表：</p>\n</li>\n</ul>\n<h2> 二、如何实现</h2>\n<p>可以分成以下步骤：</p>\n<ul>\n<li>分区：从数组中选择任意一个基准，所有比基准小的元素放在基准的左边，比基准大的元素放到基准的右边</li>\n<li>递归：递归地对基准前后的子数组进行分区</li>\n</ul>\n<figure><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>用代码表示则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>快速排序是冒泡排序的升级版，最坏情况下每一次基准元素都是数组中最小或者最大的元素，则快速排序就是冒泡排序</p>\n<p>这种情况时间复杂度就是冒泡排序的时间复杂度：<code>T[n] = n * (n-1) = n^2 + n</code>，也就是<code>O(n^2)</code></p>\n<p>最好情况下是<code>O(nlogn)</code>，其中递归算法的时间复杂度公式：<code>T[n] = aT[n/b] + f(n)</code>，推导如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b6019540-2b5e-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>关于上述代码实现的快速排序，可以看到是稳定的</p>\n<h2> 三、应用场景</h2>\n<p>快速排序时间复杂度为<code>O(nlogn)</code>，是目前基于比较的内部排序中被认为最好的方法，当数据过大且数据杂乱无章时，则适合采用快速排序</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/快速排序算法/369842</a></li>\n<li><a href=\"https://www.cnblogs.com/l199616j/p/10597245.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/l199616j/p/10597245.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-31T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对选择排序的理解？如何实现？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/selectionSort.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/selectionSort.html",
      "summary": "前端物语|面试物语-说说你对选择排序的理解？如何实现？应用场景？",
      "content_html": "<h1> 说说你对选择排序的理解？如何实现？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/50a05ed0-2671-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>选择排序（Selection sort）是一种简单直观的排序算法，无论什么数据进去都是 <code>O(n²)</code>的时间复杂度，所以用到它的时候，数据规模越小越好</p>\n<p>其基本思想是：首先在未排序的数列中找到最小(or 最大)元素，然后将其存放到数列的起始位置</p>\n<p>然后再从剩余未排序的元素中继续寻找最小(or 最大)元素，然后放到已排序序列的末尾</p>\n<p>以此类推，直到所有元素均排序完毕</p>\n<p>举个例子，一个数组为 56、12、80、91、29，其排序过程如下：</p>\n<ul>\n<li>第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置。此时数组为 12、56、80、91、20</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/60bd2050-2671-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置，此时数组为 12、20、80、91、56</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6b04cf40-2671-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置，此时数组为 12、20、56、91、80</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/757f4e00-2671-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置，此时排序完成，变成有序数组</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/757f4e00-2671-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、如何实现</h2>\n<p>从上面可以看到，对于具有 <code>n</code> 个记录的无序表遍历 <code>n-1</code> 次，第<code>i</code> 次从无序表中第 <code>i</code> 个记录开始，找出后序关键字中最小的记录，然后放置在第 <code>i</code> 的位置上</p>\n<p>直至到从第<code>n</code>个和第<code>n-1</code>个元素中选出最小的放在第<code>n-1</code>个位置</p>\n<p>如下动画所示：</p>\n<figure><img src=\"https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>用代码表示则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>第一次内循环比较<code>N - 1</code>次，然后是<code>N-2</code>次，<code>N-3</code>次，……，最后一次内循环比较 1 次共比较的次数是 <code>(N - 1) + (N - 2) + ... + 1</code>，求等差数列和，得 <code>(N - 1 + 1)* N / 2 = N^2 / 2</code>，舍去最高项系数，其时间复杂度为 <code>O(N^2)</code></p>\n<p>从上述也可以看到，选择排序是一种稳定的排序</p>\n<h2> 三、应用场景</h2>\n<p>和冒泡排序一致，相比其它排序算法，这也是一个相对较高的时间复杂度，一般情况不推荐使用</p>\n<p>但是我们还是要掌握冒泡排序的思想及实现，这对于我们的算法思维是有很大帮助的</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/9762418\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/选择排序/9762418</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/29889599\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/29889599</a></li>\n<li><a href=\"http://data.biancheng.net/view/72.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://data.biancheng.net/view/72.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对集合的理解？常见的操作有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/set.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/set.html",
      "summary": "前端物语|面试物语-说说你对集合的理解？常见的操作有哪些？",
      "content_html": "<h1> 说说你对集合的理解？常见的操作有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e3de7810-1d36-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>集合（Set），指具有某种特定性质的事物的总体，里面的每一项内容称作元素</p>\n<p>在数学中，我们经常会遇到集合的概念：</p>\n<ul>\n<li>有限集合：例如一个班集所有的同学构成的集合</li>\n<li>无限集合：例如全体自然数集合</li>\n</ul>\n<p>在计算机中集合道理也基本一致，具有三大特性：</p>\n<ul>\n<li>确定性：于一个给定的集合，集合中的元素是确定的。即一个元素，或者属于该集合，或者不属于该集合，两者必居其一</li>\n<li>无序性：在一个集合中，不考虑元素之间的顺序，只要元素完全相同，就认为是同一个集合</li>\n<li>互异性：集合中任意两个元素都是不同的</li>\n</ul>\n<h2> 二、操作</h2>\n<p>在<code>ES6</code>中，集合本身是一个构建函数<code>Set</code>，用来生成 <code>Set</code> 数据结构，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>关于集合常见的方法有：</p>\n<ul>\n<li>add()：增</li>\n<li>delete()：删</li>\n<li>has()：改</li>\n<li>clear()：查</li>\n</ul>\n<h3> add()</h3>\n<p>添加某个值，返回 <code>Set</code> 结构本身</p>\n<p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>体现了集合的互异性特性</p>\n<h3> delete()</h3>\n<p>删除某个值，返回一个布尔值，表示删除是否成功</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> has()</h3>\n<p>返回一个布尔值，判断该值是否为<code>Set</code>的成员</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> clear()</h3>\n<p>清除所有成员，没有返回值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>关于多个集合常见的操作有：</p>\n<ul>\n<li>并集</li>\n<li>交集</li>\n<li>差集</li>\n</ul>\n<h3> 并集</h3>\n<p>两个集合的共同元素，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ed96df50-1d36-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>代码实现方式如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 交集</h3>\n<p>两个集合<code>A</code> 和 <code>B</code>，即属于<code>A</code>又属于<code>B</code>的元素，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f8a9cd80-1d36-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>用代码标识则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 差集</h3>\n<p>两个集合<code>A</code> 和 <code>B</code>，属于<code>A</code>的元素但不属于<code>B</code>的元素称为<code>A</code>相对于<code>B</code>的差集，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/0191c560-1d37-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>代码标识则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、应用场景</h2>\n<p>一般情况下，使用数组的概率会比集合概率高很多</p>\n<p>使用<code>set</code>集合的场景一般是借助其确定性，其本身只包含不同的元素</p>\n<p>所以，可以利用<code>Set</code>的一些原生方法轻松的完成数组去重，查找数组公共元素及不同元素等操作</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%B9%B6%E9%9B%86\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/并集</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%A1%A5%E9%9B%86\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/补集</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-13T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说常见的排序算法有哪些？区别？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/sort.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/sort.html",
      "summary": "前端物语|面试物语-说说常见的排序算法有哪些？区别？",
      "content_html": "<h1> 说说常见的排序算法有哪些？区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/63eb7920-211c-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>排序是程序开发中非常常见的操作，对一组任意的数据元素经过排序操作后，就可以把他们变成一组一定规则排序的有序序列</p>\n<p>排序算法属于算法中的一种，而且是覆盖范围极小的一种，彻底掌握排序算法对程序开发是有很大的帮助的</p>\n<p>对与排序算法的好坏衡量，主要是从时间复杂度、空间复杂度、稳定性</p>\n<p>时间复杂度、空间复杂度前面已经讲过，这里主要看看稳定性的定义</p>\n<p>稳定性指的是假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变</p>\n<p>即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的</p>\n<h2> 二、有哪些</h2>\n<p>常见的算法排序算法有：</p>\n<ul>\n<li>冒泡排序</li>\n<li>选择排序</li>\n<li>插入排序</li>\n<li>归并排序</li>\n<li>快速排序</li>\n</ul>\n<h3> 冒泡排序</h3>\n<p>一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来</p>\n<p>思路如下：</p>\n<ul>\n<li>\n<p>比较相邻的元素，如果第一个比第二个大，就交换它们两个</p>\n</li>\n<li>\n<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数</p>\n</li>\n<li>\n<p>针对所有的元素重复以上的步骤，除了最后一个</p>\n</li>\n<li>\n<p>重复上述步骤，直到没有任何一堆数字需要比较</p>\n</li>\n</ul>\n<figure><img src=\"https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 选择排序</h3>\n<p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法</p>\n<p>无论什么数据进去都是 <code>O(n²)</code>的时间复杂度。所以用到它的时候，数据规模越小越好</p>\n<p>唯一的好处是不占用额外的内存存储空间</p>\n<p>思路如下：</p>\n<ul>\n<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>\n<li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>\n<li>重复第二步，直到所有元素均排序完毕</li>\n</ul>\n<figure><img src=\"https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 插入排序</h3>\n<p>插入排序是一种简单直观的排序算法</p>\n<p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p>\n<p>解决思路如下：</p>\n<ul>\n<li>把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的</li>\n<li>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>\n<li>重复上述过程直到最后一个元素被插入有序子数组中</li>\n</ul>\n<figure><img src=\"https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 归并排序</h3>\n<p>归并排序是建立在归并操作上的一种有效的排序算法</p>\n<p>该算法是采用分治法的一个非常典型的应用</p>\n<p>将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序</p>\n<p>解决思路如下：</p>\n<ul>\n<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>\n<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>\n<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>\n<li>重复步骤 3 直到某一指针到达序列尾</li>\n<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>\n</ul>\n<figure><img src=\"https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.jpg\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 快速排序</h3>\n<p>快速排序是对冒泡排序算法的一种改进，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小</p>\n<p>再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列</p>\n<p>解决思路如下：</p>\n<ul>\n<li>从数列中挑出一个元素，称为\"基准\"（pivot）</li>\n<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</li>\n<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序</li>\n</ul>\n<figure><img src=\"https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.jpg\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、区别</h2>\n<p>除了上述的排序算法之外，还存在其他的排序算法，例如希尔排序、堆排序等等......</p>\n<p>区别如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5c3d7b50-2131-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.runoob.com/w3cnote/bubble-sort.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.runoob.com/w3cnote/bubble-sort.html</a></li>\n<li><a href=\"http://www.x-lab.info/post/sort-algorithm/\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.x-lab.info/post/sort-algorithm/</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/42586566\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/42586566</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-02T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对栈、队列的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/stack_queue.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/stack_queue.html",
      "summary": "前端物语|面试物语-说说你对栈、队列的理解？应用场景？",
      "content_html": "<h1> 说说你对栈、队列的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bc57f530-1b99-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、栈</h2>\n<p>栈（stack）又名堆栈，它是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表</p>\n<p>表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈</p>\n<p>所以其按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用</p>\n<p>关于栈的简单实现，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于栈的操作主要的方法如下：</p>\n<ul>\n<li>push：入栈操作</li>\n<li>pop：出栈操作</li>\n</ul>\n<h2> 二、队列</h2>\n<p>跟栈十分相似，队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作</p>\n<p>进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列</p>\n<p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出</p>\n<p>简单实现一个队列的方式，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述这种入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用</p>\n<p>当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作，出该现象称为\"假溢\"</p>\n<p>在实际使用队列时，为了使队列空间能重复使用，往往对队列的使用方法稍加改进：</p>\n<p>无论插入或删除，一旦<code>rear</code>指针增 1 或<code>front</code>指针增 1 时超出了所分配的队列空间，就让它指向这片连续空间的起始位置，这种队列也就是循环队列</p>\n<p>下面实现一个循环队列，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述通过求余的形式代表首尾指针增 1 时超出了所分配的队列空间</p>\n<h2> 三、应用场景</h2>\n<h3> 栈</h3>\n<p>借助栈的先进后出的特性，可以简单实现一个逆序数处的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出</p>\n<p>包括编译器的在对输入的语法进行分析的时候，例如<code>\"()\"</code>、<code>\"{}\"</code>、<code>\"[]\"</code>这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p>\n<p>包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值</p>\n<p>生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型</p>\n<h3> 队列</h3>\n<p>当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题</p>\n<p>队列的使用广泛应用在广度优先搜索种，例如层次遍历一个二叉树的节点值（后续将到）</p>\n<p>生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E6%A0%88/12808149\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/栈/12808149</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/队列/14580481</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-07T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对数据结构的理解？有哪些？区别？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/structure.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/structure.html",
      "summary": "前端物语|面试物语-说说你对数据结构的理解？有哪些？区别？",
      "content_html": "<h1> 说说你对数据结构的理解？有哪些？区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3d87b540-1aa6-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>数据结构是计算机存储、组织数据的方式，是指相互之间存在一种或多种特定关系的数据元素的集合</p>\n<p>前面讲到，一个程序 = 算法 + 数据结构，数据结构是实现算法的基础，选择合适的数据结构可以带来更高的运行或者存储效率</p>\n<p>数据元素相互之间的关系称为结构，根据数据元素之间关系的不同特性，通常有如下四类基本的结构：</p>\n<ul>\n<li>集合结构：该结构的数据元素间的关系是“属于同一个集合”</li>\n<li>线性结构：该结构的数据元素之间存在着一对一的关系</li>\n<li>树型结构：该结构的数据元素之间存在着一对多的关系</li>\n<li>图形结构：该结构的数据元素之间存在着多对多的关系，也称网状结构</li>\n</ul>\n<p>由于数据结构种类太多，逻辑结构可以再分成为：</p>\n<ul>\n<li>线性结构：有序数据元素的集合，其中数据元素之间的关系是一对一的关系，除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的</li>\n<li>非线性结构：各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生关联</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9aedc5d0-1aa6-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、有哪些</h2>\n<p>常见的数据结构有如下：</p>\n<ul>\n<li>数组</li>\n<li>栈</li>\n<li>队列</li>\n<li>链表</li>\n<li>树</li>\n<li>图</li>\n<li>堆</li>\n<li>散列表</li>\n</ul>\n<h3> 数组</h3>\n<p>在程序设计中，为了处理方便， 一般情况把具有相同类型的若干变量按有序的形式组织起来，这些按序排列的同类数据元素的集合称为数组</p>\n<h3> 栈</h3>\n<p>一种特殊的线性表，只能在某一端插入和删除的特殊线性表，按照先进后出的特性存储数据</p>\n<p>先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据</p>\n<h3> 队列</h3>\n<p>跟栈基本一致，也是一种特殊的线性表，其特性是先进先出，只允许在表的前端进行删除操作，而在表的后端进行插入操作</p>\n<h3> 链表</h3>\n<p>是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的</p>\n<p>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成</p>\n<p>一般情况，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>\n<h3> 树</h3>\n<p>树是典型的非线性结构，在树的结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个以上的后继结点</p>\n<h3> 图</h3>\n<p>一种非线性结构。在图结结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系</p>\n<h3> 堆</h3>\n<p>堆是一种特殊的树形数据结构，每个结点都有一个值，特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆</p>\n<h3> 散列表</h3>\n<p>若结构中存在关键字和<code>K</code>相等的记录，则必定在<code>f(K)</code>的存储位置上，不需比较便可直接取得所查记录</p>\n<h2> 三、区别</h2>\n<p>上述的数据结构，之前的区别可以分成线性结构和非线性结构：</p>\n<ul>\n<li>线性结构有：数组、栈、队列、链表等</li>\n<li>非线性结构有：树、图、堆等</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/数据结构</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/数据结构/1450</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对算法中时间复杂度，空间复杂度的理解？如何计算？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/time_space.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/time_space.html",
      "summary": "前端物语|面试物语-说说你对算法中时间复杂度，空间复杂度的理解？如何计算？",
      "content_html": "<h1> 说说你对算法中时间复杂度，空间复杂度的理解？如何计算？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/07fd4050-16fc-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、前言</h2>\n<p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别</p>\n<p>衡量不同算法之间的优劣主要是通过<strong>时间</strong>和<strong>空间</strong>两个维度去考量：</p>\n<ul>\n<li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li>\n<li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述</li>\n</ul>\n<p>通常会遇到一种情况，时间和空间维度不能够兼顾，需要在两者之间取得一个平衡点是我们需要考虑的</p>\n<p>一个算法通常存在最好、平均、最坏三种情况，我们一般关注的是最坏情况</p>\n<p>最坏情况是算法运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，也意味着平均情况和最坏情况一样差</p>\n<h2> 二、时间复杂度</h2>\n<p>时间复杂度是指执行这个算法所需要的计算工作量，其复杂度反映了程序执行时间「随输入规模增长而增长的量级」，在很大程度上能很好地反映出算法的优劣与否</p>\n<p>一个算法花费的时间与算法中语句的「执行次数成正比」，执行次数越多，花费的时间就越多</p>\n<p>算法的复杂度通常用大 O 符号表述，定义为<code>T(n) = O(f(n))</code>，常见的时间复杂度有：O(1)常数型、O(log n)对数型、O(n)线性型、O(nlogn)线性对数型、O(n<sup>2)平方型、O(n</sup>3)立方型、O(n^k)k 次方型、O(2^n)指数型，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/33d5ebf0-16fc-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从上述可以看到，随着问题规模<code>n</code>的不断增大，上述时间复杂度不断增大，算法的执行效率越低，由小到大排序如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>注意的是，算法复杂度只是描述算法的增长趋势，并不能说一个算法一定比另外一个算法高效，如果常数项过大的时候也会导致算法的执行时间变长</p>\n<p>关于如何计算时间复杂度，可以看看如下简单例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>该函数算法需要执行的运算次数用输入大小<code>n</code>的函数表示，即 <code>T(n) = 2 + n + 1</code>，那么时间复杂度为<code>O(n + 3)</code>，又因为时间复杂度只关注最高数量级，且与之系数也没有关系，因此上述的时间复杂度为<code>O(n)</code></p>\n<p>又比如下面的例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>循环里面嵌套循环，外面的循环执行一次，里面的循环执行<code>n</code>次，因此时间复杂度为 <code>O(n*n*1 + 2) = O(n^2)</code></p>\n<p>对于顺序执行的语句，总的时间复杂度等于其中最大的时间复杂度，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述第一部分复杂度为<code>O(n)</code>，第二部分复杂度为<code>O(n^2)</code>，总复杂度为<code>max(O(n^2), O(n)) = O(n^2)</code></p>\n<p>又如下一个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>循环语句中以 2 的倍数来逼近<code>n</code>，每次都乘以 2。如果用公式表示就是 1 <em>2</em> 2 <em>2 …</em> 2 &lt;=n，也就是说 2 的<code>x</code>次方小于等于<code>n</code>时会执行循环体，记作<code>2^x &lt;= n</code>，于是得出<code>x&lt;=logn</code></p>\n<p>因此循环在执行<code>logn</code>次之后，便结束，因此时间复杂度为<code>O(logn)</code></p>\n<p>同理，如果一个<code>O(n)</code>循环里面嵌套<code>O(logn)</code>的循环，则时间复杂度为<code>O(nlogn)</code>，像<code>O(n^3)</code>无非也就是嵌套了三层<code>O(n)</code>循环</p>\n<h2> 三、空间复杂度</h2>\n<p>空间复杂度主要指执行算法所需内存的大小，用于对程序运行过程中所需要的临时存储空间的度量</p>\n<p>除了需要存储空间、指令、常数、变量和输入数据外，还包括对数据进行操作的工作单元和存储计算所需信息的辅助空间</p>\n<p>下面给出空间复杂度为<code>O(1)</code>的示例，如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码的临时空间不会随着<code>n</code>的变化而变化，因此空间复杂度为<code>O(1)</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述可以看到，随着<code>n</code>的增加，数组的占用的内存空间越大</p>\n<p>通常来说，只要算法不涉及到动态分配的空间，以及递归、栈所需的空间，空间复杂度通常为<code>O(1)</code>，一个一维数组<code>a[n]</code>，空间复杂度<code>O(n)</code>，二维数组为<code>O(n^2)</code></p>\n<h2> 参考文献</h2>\n<ul>\n<li>\n<p><a href=\"https://juejin.cn/post/6844904167824162823#heading-7\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904167824162823#heading-7</a></p>\n</li>\n<li>\n<p><a href=\"https://zhuanlan.zhihu.com/p/50479555\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/50479555</a></p>\n</li>\n<li>\n<p><a href=\"https://cloud.tencent.com/developer/article/1769988\" target=\"_blank\" rel=\"noopener noreferrer\">https://cloud.tencent.com/developer/article/1769988</a></p>\n</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-05T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "说说你对树的理解？相关的操作有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/algorithm/tree.html",
      "id": "https://www.h7ml.cn/posts/interview/algorithm/tree.html",
      "summary": "前端物语|面试物语-说说你对树的理解？相关的操作有哪些？",
      "content_html": "<h1> 说说你对树的理解？相关的操作有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5a7616f0-1dfe-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在计算机领域，树形数据结构是一类重要的非线性数据结构，可以表示数据之间一对多的关系。以树与二叉树最为常用，直观看来，树是以分支关系定义的层次结构</p>\n<p>二叉树满足以下两个条件：</p>\n<ul>\n<li>本身是有序树</li>\n<li>树中包含的各个结点的不能超过 2，即只能是 0、1 或者 2</li>\n</ul>\n<p>如下图，左侧的为二叉树，而右侧的因为头结点的子结点超过 2，因此不属于二叉树：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/66758800-1dfe-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>同时，二叉树可以继续进行分类，分成了满二叉树和完成二叉树：</p>\n<ul>\n<li>满二叉树：如果二叉树中除了叶子结点，每个结点的度都为 2</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/759db050-1dfe-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>完成二叉树：如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/84ae31f0-1dfe-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、操作</h2>\n<p>关于二叉树的遍历，常见的有：</p>\n<ul>\n<li>\n<p>前序遍历</p>\n</li>\n<li>\n<p>中序遍历</p>\n</li>\n<li>\n<p>后序遍历</p>\n</li>\n<li>\n<p>层序遍历</p>\n</li>\n</ul>\n<h3> 前序遍历</h3>\n<p>前序遍历的实现思想是：</p>\n<ul>\n<li>访问根节点</li>\n<li>访问当前节点的左子树</li>\n<li>若当前节点无左子树，则访问当前节点的右子</li>\n</ul>\n<p>根据遍历特性，递归版本用代码表示则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果不使用递归版本，可以借助栈先进后出的特性实现，先将根节点压入栈，再分别压入右节点和左节点，直到栈中没有元素，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 中序遍历</h3>\n<p>前序遍历的实现思想是：</p>\n<ul>\n<li>访问当前节点的左子树</li>\n<li>访问根节点</li>\n<li>访问当前节点的右子</li>\n</ul>\n<p>递归版本很好理解，用代码表示则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>非递归版本也是借助栈先进后出的特性，可以一直首先一直压入节点的左元素，当左节点没有后，才开始进行出栈操作，压入右节点，然后有依次压入左节点，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 后序遍历</h3>\n<p>前序遍历的实现思想是：</p>\n<ul>\n<li>访问当前节点的左子树</li>\n<li>访问当前节点的右子</li>\n<li>访问根节点</li>\n</ul>\n<p>递归版本，用代码表示则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>后序遍历非递归版本实际根全序遍历是逆序关系，可以再多创建一个栈用来进行输出，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 层序遍历</h3>\n<p>按照二叉树中的层次从左到右依次遍历每层中的结点</p>\n<p>借助队列先进先出的特性，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果</p>\n<p>用代码表示则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、总结</h2>\n<p>树是一个非常重要的非线性结构，其中二叉树以二叉树最常见，二叉树的遍历方式可以分成前序遍历、中序遍历、后序遍历</p>\n<p>同时，二叉树又分成了完成二叉树和满二叉树</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/二叉树</a></li>\n<li><a href=\"http://data.biancheng.net/view/27.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://data.biancheng.net/view/27.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-06T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "algorithm"
      ]
    },
    {
      "title": "前端物语|面试物语-applet",
      "url": "https://www.h7ml.cn/posts/interview/applet/",
      "id": "https://www.h7ml.cn/posts/interview/applet/",
      "summary": "说说微信小程序的实现原理？ 说说你对微信小程序的理解？优缺点？ 说说微信小程序的生命周期函数有哪些？ 说说微信小程序的登录流程？ 说说微信小程序中路由跳转的方式有哪些？区别？ 说说提高微信小程序的应用速度的手段有哪些？ 说说微信小程序的发布流程？ 说说微信小程序的支付流程？",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/interview/applet/WebView_jscore\" target=\"_blank\" rel=\"noopener noreferrer\">说说微信小程序的实现原理？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/applet/applet\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对微信小程序的理解？优缺点？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/applet/lifecycle\" target=\"_blank\" rel=\"noopener noreferrer\">说说微信小程序的生命周期函数有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/applet/login\" target=\"_blank\" rel=\"noopener noreferrer\">说说微信小程序的登录流程？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/applet/navigate\" target=\"_blank\" rel=\"noopener noreferrer\">说说微信小程序中路由跳转的方式有哪些？区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/applet/optimization\" target=\"_blank\" rel=\"noopener noreferrer\">说说提高微信小程序的应用速度的手段有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/applet/publish\" target=\"_blank\" rel=\"noopener noreferrer\">说说微信小程序的发布流程？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/applet/requestPayment\" target=\"_blank\" rel=\"noopener noreferrer\">说说微信小程序的支付流程？</a></li>\n</ul>\n",
      "date_published": "2023-03-26T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "applet"
      ]
    },
    {
      "title": "说说微信小程序的实现原理？",
      "url": "https://www.h7ml.cn/posts/interview/applet/WebView_jscore.html",
      "id": "https://www.h7ml.cn/posts/interview/applet/WebView_jscore.html",
      "summary": "前端物语|面试物语-说说微信小程序的实现原理？",
      "content_html": "<h1> 说说微信小程序的实现原理？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/4407cb60-3722-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、背景</h2>\n<p>网页开发，渲染线程和脚本是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应的原因，本质就是我们常说的 <code>JS</code> 是单线程的</p>\n<p>而在小程序中，选择了 <code>Hybrid</code> 的渲染方式，将视图层和逻辑层是分开的，双线程同时运行，视图层的界面使用 <code>WebView</code> 进行渲染，逻辑层运行在 <code>JSCore</code> 中</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/4e322e50-3722-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>渲染层：界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程</li>\n<li>逻辑层：采用 JsCore 线程运行 JS 脚本，在这个环境下执行的都是有关小程序业务逻辑的代码</li>\n</ul>\n<h2> 二、通信</h2>\n<p>小程序在渲染层，宿主环境会把<code>wxml</code>转化成对应的<code>JS</code>对象</p>\n<p>在逻辑层发生数据变更的时候，通过宿主环境提供的<code>setData</code>方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的<code>Dom</code>树上，渲染出正确的视图</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5948ed10-3722-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>当视图存在交互的时候，例如用户点击你界面上某个按钮，这类反馈应该通知给开发者的逻辑层，需要将对应的处理状态呈现给用户</p>\n<p>对于事件的分发处理，微信进行了特殊的处理，将所有的事件拦截后，丢到逻辑层交给<code>JavaScript</code>进行处理</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/61f9f670-3722-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>由于小程序是基于双线程的，也就是任何在视图层和逻辑层之间的数据传递都是线程间的通信，会有一定的延时，因此在小程序中，页面更新成了异步操作</p>\n<p>异步会使得各部分的运行时序变得复杂一些，比如在渲染首屏的时候，逻辑层与渲染层会同时开始初始化工作，但是渲染层需要有逻辑层的数据才能把界面渲染出来</p>\n<p>如果渲染层初始化工作较快完成，就要等逻辑层的指令才能进行下一步工作</p>\n<p>因此逻辑层与渲染层需要有一定的机制保证时序正确，在每个小程序页面的生命周期中，存在着若干次页面数据通信</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6cb798b0-3722-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、运行机制</h2>\n<p>小程序启动运行两种情况：</p>\n<ul>\n<li>冷启动（重新开始）：用户首次打开或者小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即为冷启动</li>\n<li>热启动：用户已经打开过小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需要将后台态的小程序切换到前台，这个过程就是热启动</li>\n</ul>\n<h4> 需要注意</h4>\n<blockquote>\n<p>1.小程序没有重启的概念<br>\n2.当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后会被微信主动销毁<br>\n3.短时间内收到系统两次以上内存警告，也会对小程序进行销毁，这也就为什么一旦页面内存溢出，页面会奔溃的本质原因了</p>\n</blockquote>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/968c8510-3722-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户</p>\n<p>每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://developers.weixin.qq.com/community/develop/article/doc/0008a4c4f28f30fe3eb863b2750813\" target=\"_blank\" rel=\"noopener noreferrer\">https://developers.weixin.qq.com/community/develop/article/doc/0008a4c4f28f30fe3eb863b2750813</a></li>\n<li><a href=\"https://juejin.cn/post/6976805521407868958#heading-5\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6976805521407868958#heading-5</a></li>\n<li><a href=\"https://juejin.cn/post/6844903805675388942\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903805675388942</a></li>\n<li><a href=\"https://juejin.cn/post/6844903999863259144#heading-1\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903999863259144#heading-1</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-10T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "applet"
      ]
    },
    {
      "title": "说说你对微信小程序的理解？优缺点？",
      "url": "https://www.h7ml.cn/posts/interview/applet/applet.html",
      "id": "https://www.h7ml.cn/posts/interview/applet/applet.html",
      "summary": "前端物语|面试物语-说说你对微信小程序的理解？优缺点？",
      "content_html": "<h1> 说说你对微信小程序的理解？优缺点？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/be367c80-300e-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>2017 年，微信正式推出了小程序，允许外部开发者在微信内部运行自己的代码，开展业务</p>\n<p>截至目前，小程序已经成为国内前端的一个重要业务，跟 <code>Web</code> 和手机 <code>App</code> 有着同等的重要性</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ce751de0-300e-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用</p>\n<p>也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载</p>\n<p>注意的是，除了微信小程序，还有百度小程序、微信小程序、支付宝小程序、抖音小程序，都是每个平台自己开发的，都是有针对性平台的应用程序</p>\n<h2> 二、背景</h2>\n<p>⼩程序并⾮凭空冒出来的⼀个概念，当微信中的 <code>WebView</code> 逐渐成为移动 <code>Web</code>的⼀个重要⼊⼝时，微信就有相关的 <code>JS-SDK</code></p>\n<p><code>JS-SDK</code> 解决了移动⽹⻚能⼒不⾜的问题，通过暴露微信的接⼝使得 <code>Web</code> 开发者能够拥有更多的能⼒，然⽽在更多的能⼒之外，<code>JS-SDK</code>的模式并没有解决使⽤移动⽹⻚遇到的体验不良的问题</p>\n<p>因此需要设计⼀个⽐较好的系统，使得所有开发者在微信中都能获得⽐较好的体验：</p>\n<ul>\n<li>快速的加载</li>\n<li>更强⼤的能⼒</li>\n<li>原⽣的体验</li>\n<li>易⽤且安全的微信数据开放</li>\n<li>⾼效和简单的开发</li>\n</ul>\n<p>这些是<code>JS-SDK</code>做不到的，需要设计一个全新的小程序系统</p>\n<p>对于小程序的开发，提供一个简单、高效的应用开发框架和丰富的组件及<code>API</code>，帮助开发者开发出具有原生体验的服务</p>\n<p>其中相比<code>H5</code>，小程序与其的区别有如下：</p>\n<ul>\n<li>运⾏环境：⼩程序基于浏览器内核重构的内置解析器</li>\n<li>系统权限：⼩程序能获得更多的系统权限，如⽹络通信状态、数据缓存能⼒等</li>\n<li>渲染机制：⼩程序的逻辑层和渲染层是分开的</li>\n</ul>\n<p>小程序可以视为只能用微信打开和浏览的<code>H5</code>，小程序和网页的技术模型是一样的，用到的 <code>JavaScript</code> 语言和 <code>CSS</code> 样式也是一样的，只是网页的 <code>HTML</code> 标签被稍微修改成了 <code>WXML</code> 标签</p>\n<p>因此可以说，小程序页面本质上就是网页</p>\n<p>其中关于微信小程序的实现原理，我们在后面的文章讲到</p>\n<h2> 三、优缺点</h2>\n<p>优点：</p>\n<ul>\n<li>随搜随用，用完即走：使得小程序可以代替许多 APP，或是做 APP 的整体嫁接，或是作为阉割版功能的承载体</li>\n<li>流量大，易接受：小程序借助自身平台更加容易引入更多的流量</li>\n<li>安全</li>\n<li>开发门槛低</li>\n<li>降低兼容性限制</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>用户留存：及相关数据显示，小程序的平均次日留存在 13%左右，但是双周留存骤降到仅有 1%</li>\n<li>体积限制：微信小程序只有 2M 的大小，这样导致无法开发大型一些的小程序</li>\n<li>受控微信：比起 APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/\" target=\"_blank\" rel=\"noopener noreferrer\">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></li>\n<li><a href=\"https://www.zhihu.com/question/263816362\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zhihu.com/question/263816362</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-20T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "applet"
      ]
    },
    {
      "title": "说说微信小程序的生命周期函数有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/applet/lifecycle.html",
      "id": "https://www.h7ml.cn/posts/interview/applet/lifecycle.html",
      "summary": "前端物语|面试物语-说说微信小程序的生命周期函数有哪些？",
      "content_html": "<h1> 说说微信小程序的生命周期函数有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1df64890-30e0-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>跟<code>vue</code>、<code>react</code>框架一样，微信小程序框架也存在生命周期，实质也是一堆会在特定时期执行的函数</p>\n<p>小程序中，生命周期主要分成了三部分：</p>\n<ul>\n<li>应用的生命周期</li>\n<li>页面的生命周期</li>\n<li>组件的生命周期</li>\n</ul>\n<h3> 应用的生命周期</h3>\n<p>小程序的生命周期函数是在<code>app.js</code>里面调用的，通过<code>App(Object)</code>函数用来注册一个小程序，指定其小程序的生命周期回调</p>\n<h3> 页面的生命周期</h3>\n<p>页面生命周期函数就是当你每进入/切换到一个新的页面的时候，就会调用的生命周期函数，同样通过<code>App(Object)</code>函数用来注册一个页面</p>\n<h3> 组件的生命周期</h3>\n<p>组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发，通过<code>Component(Object)</code>进行注册组件</p>\n<h2> 二、有哪些</h2>\n<h3> 应用的生命周期</h3>\n<table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onLaunch</td>\n<td>小程序初始化完成时触发，全局只触发一次</td>\n</tr>\n<tr>\n<td>onShow</td>\n<td>小程序启动，或从后台进入前台显示时触发</td>\n</tr>\n<tr>\n<td>onHide</td>\n<td>小程序从前台进入后台时触发</td>\n</tr>\n<tr>\n<td>onError</td>\n<td>小程序发生脚本错误或 API 调用报错时触发</td>\n</tr>\n<tr>\n<td>onPageNotFound</td>\n<td>小程序要打开的页面不存在时触发</td>\n</tr>\n<tr>\n<td>onUnhandledRejection()</td>\n<td>小程序有未处理的 Promise 拒绝时触发</td>\n</tr>\n<tr>\n<td>onThemeChange</td>\n<td>系统切换主题时触发</td>\n</tr>\n</tbody>\n</table>\n<h3> 页面的生命周期</h3>\n<table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>说明</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onLoad</td>\n<td>生命周期回调—监听页面加载</td>\n<td>发送请求获取数据</td>\n</tr>\n<tr>\n<td>onShow</td>\n<td>生命周期回调—监听页面显示</td>\n<td>请求数据</td>\n</tr>\n<tr>\n<td>onReady</td>\n<td>生命周期回调—监听页面初次渲染完成</td>\n<td>获取页面元素（少用）</td>\n</tr>\n<tr>\n<td>onHide</td>\n<td>生命周期回调—监听页面隐藏</td>\n<td>终止任务，如定时器或者播放音乐</td>\n</tr>\n<tr>\n<td>onUnload</td>\n<td>生命周期回调—监听页面卸载</td>\n<td>终止任务</td>\n</tr>\n</tbody>\n</table>\n<h3> 组件的生命周期</h3>\n<table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>created</td>\n<td>生命周期回调—监听页面加载</td>\n</tr>\n<tr>\n<td>attached</td>\n<td>生命周期回调—监听页面显示</td>\n</tr>\n<tr>\n<td>ready</td>\n<td>生命周期回调—监听页面初次渲染完成</td>\n</tr>\n<tr>\n<td>moved</td>\n<td>生命周期回调—监听页面隐藏</td>\n</tr>\n<tr>\n<td>detached</td>\n<td>生命周期回调—监听页面卸载</td>\n</tr>\n<tr>\n<td>error</td>\n<td>每当组件方法抛出错误时执行</td>\n</tr>\n</tbody>\n</table>\n<p>注意的是：</p>\n<ul>\n<li>组件实例刚刚被创建好时， created 生命周期被触发，此时，组件数据 this.data 就是在 Component 构造器中定义的数据 data ， 此时不能调用 setData</li>\n<li>在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行</li>\n<li>在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发</li>\n</ul>\n<p>还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理，这样的生命周期称为“组件所在页面的生命周期”，在 <code>pageLifetimes</code> 定义段中定义，如下：</p>\n<table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>show</td>\n<td>组件所在的页面被展示时执行</td>\n</tr>\n<tr>\n<td>hide</td>\n<td>组件所在的页面被隐藏时执行</td>\n</tr>\n</tbody>\n</table>\n<p>代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、执行过程</h2>\n<h3> 应⽤的⽣命周期执行过程</h3>\n<ul>\n<li>\n<p>⽤户⾸次打开⼩程序，触发 onLaunch（全局只触发⼀次）</p>\n</li>\n<li>\n<p>⼩程序初始化完成后，触发 onShow ⽅法，监听⼩程序显示</p>\n</li>\n<li>\n<p>⼩程序从前台进⼊后台，触发 onHide ⽅法</p>\n</li>\n<li>\n<p>⼩程序从后台进⼊前台显示，触发 onShow ⽅法</p>\n</li>\n<li>\n<p>⼩程序后台运⾏⼀定时间，或系统资源占⽤过⾼，会被销毁</p>\n</li>\n</ul>\n<h3> ⻚⾯⽣命周期的执行过程</h3>\n<ul>\n<li>⼩程序注册完成后，加载⻚⾯，触发 onLoad ⽅法</li>\n<li>⻚⾯载⼊后触发 onShow ⽅法，显示⻚⾯</li>\n<li>⾸次显示⻚⾯，会触发 onReady ⽅法，渲染⻚⾯元素和样式，⼀个⻚⾯只会调⽤⼀次</li>\n<li>当⼩程序后台运⾏或跳转到其他⻚⾯时，触发 onHide ⽅法</li>\n<li>当⼩程序有后台进⼊到前台运⾏或重新进⼊⻚⾯时，触发 onShow ⽅法</li>\n<li>当使⽤重定向⽅法 wx.redirectTo() 或关闭当前⻚返回上⼀⻚ wx.navigateBack()，触发 onUnload</li>\n</ul>\n<p>当存在也应用生命周期和页面周期的时候，相关的执行顺序如下：</p>\n<ul>\n<li>\n<p>打开小程序：(App)onLaunch --&gt; (App)onShow --&gt; (Pages)onLoad --&gt; (Pages)onShow --&gt; (pages)onRead</p>\n</li>\n<li>\n<p>进入下一个页面：(Pages)onHide --&gt; (Next)onLoad --&gt; (Next)onShow --&gt; (Next)onReady</p>\n</li>\n<li>\n<p>返回上一个页面：(curr)onUnload --&gt; (pre)onShow</p>\n</li>\n<li>\n<p>离开小程序：(App)onHide</p>\n</li>\n<li>\n<p>再次进入：小程序未销毁 --&gt; (App)onShow(执行上面的顺序），小程序被销毁，（App)onLaunch 重新开始执行.</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object\" target=\"_blank\" rel=\"noopener noreferrer\">https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object</a></li>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onLoad-Object-query\" target=\"_blank\" rel=\"noopener noreferrer\">https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onLoad-Object-query</a></li>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object\" target=\"_blank\" rel=\"noopener noreferrer\">https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-22T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "applet"
      ]
    },
    {
      "title": "说说微信小程序的登录流程？",
      "url": "https://www.h7ml.cn/posts/interview/applet/login.html",
      "id": "https://www.h7ml.cn/posts/interview/applet/login.html",
      "summary": "前端物语|面试物语-说说微信小程序的登录流程？",
      "content_html": "<h1> 说说微信小程序的登录流程？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/aa3ccbd0-3428-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、背景</h2>\n<p>传统的<code>web</code>开发实现登陆功能，一般的做法是输入账号密码、或者输入手机号及短信验证码进行登录</p>\n<p>服务端校验用户信息通过之后，下发一个代表登录态的 <code>token</code> 给客户端，以便进行后续的交互,每当<code>token</code>过期，用户都需要重新登录</p>\n<p>而在微信小程序中，可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系，从而实现登陆功能</p>\n<p>实现小程序用户体系主要涉及到<code>openid</code>和<code>code</code>的概念：</p>\n<ul>\n<li>调用<code>wx.login()</code>方法会生成<code>code</code>，将<code>code</code>作为参数传递给微信服务器指定接口，就可以获取用户的<code>openid</code></li>\n</ul>\n<p>对于每个小程序，微信都会将用户的微信<code>ID</code>映射出一个小程序 <code>openid</code>，作为这个用户在这个小程序的唯一标识</p>\n<h2> 二、流程</h2>\n<p>微信小程序登陆具体实现的逻辑如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b60638c0-3428-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>通过 wx.login() 获取到用户的 code 判断用户是否授权读取用户信息，调用 wx.getUserInfo 读取用户数据</li>\n<li>由于小程序后台授权域名无法授权微信的域名，所以需要自身后端调用微信服务器获取用户信息</li>\n<li>通过 wx.request() 方法请求业务方服务器，后端把 appid , appsecret 和 code 一起发送到微信服务器。 appid 和 appsecret 都是微信提供的，可以在管理员后台找到</li>\n<li>微信服务器返回了 openid 及本次登录的会话密钥 session_key</li>\n<li>后端从数据库中查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走</li>\n<li>session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输</li>\n<li>然后生成 session 并返回给小程序</li>\n<li>小程序把 session 存到 storage 里面</li>\n<li>下次请求时，先从 storage 里面读取，然后带给服务端</li>\n<li>服务端对比 session 对应的记录，然后校验有效期</li>\n</ul>\n<p>更加详细的功能图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c3cfbb70-3428-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、扩展</h2>\n<p>实际业务中，我们还需要登录态是否过期，通常的做法是在登录态（临时令牌）中保存有效期数据，该有效期数据应该在服务端校验登录态时和约定的时间（如服务端本地的系统时间或时间服务器上的标准时间）做对比</p>\n<p>这种方法需要将本地存储的登录态发送到小程序的服务端，服务端判断为无效登录态时再返回需重新执行登录过程的消息给小程</p>\n<p>另一种方式可以通过调用<code>wx.checkSession</code>检查微信登陆态是否过期：</p>\n<ul>\n<li>如果过期，则发起完整的登录流程</li>\n<li>如果不过期，则继续使用本地保存的自定义登录态</li>\n</ul>\n<p>这种方式的好处是不需要小程序服务端来参与校验，而是在小程序端调用 AP，流程如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8b446d30-349d-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000016750340\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000016750340</a></li>\n<li><a href=\"https://juejin.cn/post/6955754095860776973\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6955754095860776973</a></li>\n<li><a href=\"https://www.cnblogs.com/zwh0910/p/13977278.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/zwh0910/p/13977278.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-15T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "applet"
      ]
    },
    {
      "title": "说说微信小程序中路由跳转的方式有哪些？区别？",
      "url": "https://www.h7ml.cn/posts/interview/applet/navigate.html",
      "id": "https://www.h7ml.cn/posts/interview/applet/navigate.html",
      "summary": "前端物语|面试物语-说说微信小程序中路由跳转的方式有哪些？区别？",
      "content_html": "<h1> 说说微信小程序中路由跳转的方式有哪些？区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/52bd3820-31a5-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>微信小程序拥有<code>web</code>网页和<code>Application</code>共同的特征，我们的页面都不是孤立存在的，而是通过和其他页面进行交互，来共同完成系统的功能</p>\n<p>在微信小程序中，每个页面可以看成是一个<code>pageModel</code>，<code>pageModel</code>全部以栈的形式进行管理</p>\n<h2> 二、有哪些</h2>\n<p>常见的微信小程序页面跳转方式有如下：</p>\n<ul>\n<li>wx.navigateTo(Object)</li>\n<li>wx.redirectTo(Object)</li>\n<li>wx.switchTab(Object)</li>\n<li>wx.navigateBack(Object)</li>\n<li>wx.reLaunch(Object)</li>\n</ul>\n<h3> wx.navigateTo(Object)</h3>\n<p><code>wx.navigateTo()</code>用于保留当前页面、跳转到应用内的某个页面，使用 <code>wx.navigateBack</code>可以返回到原页面</p>\n<p>对于页面不是特别多的小程序，通常推荐使用 <code>wx.navigateTo</code>进行跳转， 以便返回原页面，以提高加载速度。当页面特别多时，则不推荐使用</p>\n<p>参数表如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5e524ea0-31a5-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>流程图如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/68f033e0-31a5-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> wx.redirectTo(Object)</h3>\n<p>重定向，当页面过多时，被保留页面会挤占微信分配给小程序的内存，或是达到微信所限制的 10 层页面栈的情况下，我们应该考虑选择 <code>wx.redirectTo</code></p>\n<p><code>wx.redirectTo()</code>用于关闭当前页面，跳转到应用内的某个页面</p>\n<p>这样的跳转，可以避免跳转前页面占据运行内存，但返回时页面需要重新加载，增加了返回页面的显示时间</p>\n<p>参数表如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/76066c20-31a5-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>流程图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/828c4b40-31a5-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> wx.switchTab(Object)</h3>\n<p>跳转到 <code>tabBar</code>页面，并关闭其他所有非 <code>tabBar</code> 页面</p>\n<p>参数表如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/968869d0-31a5-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> wx.navigateBack(Object)</h3>\n<p><code>wx.navigateBack()</code> 用于关闭当前页面，并返回上一页面或多级页面，开发者可通过 <code>getCurrentPages()</code> 获取当前的页面栈，决定需要返回几层则设置对象的<code>delta</code>属性即可</p>\n<p>参数表如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a28d8030-31a5-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> wx.reLaunch(Object)</h3>\n<p>关闭所有页面，打开到应用内的某个页面，返回的时候跳到首页</p>\n<p>流程图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/accca3a0-31a5-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>参数表如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b98c7e80-31a5-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、总结</h2>\n<p>关于上述五种跳转方式，做下总结：</p>\n<ul>\n<li>navigateTo 保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页</li>\n<li>redirectTo 关闭当前页面，跳转到应用内的某个页面</li>\n<li>switchTab 跳转到 tabBar 页面，同时关闭其他非 tabBar 页面</li>\n<li>navigateBack 返回上一页面</li>\n<li>reLanch 关闭所有页面，打开到应用内的某个页面</li>\n</ul>\n<p>其中关于它们的页面栈的关系如下：</p>\n<ul>\n<li>\n<p>avigateTo 新页面入栈</p>\n</li>\n<li>\n<p>redirectTo 当前页面出栈，新页面入栈</p>\n</li>\n<li>\n<p>navigateBack 页面不断出栈，直到目标返回页，新页面入栈</p>\n</li>\n<li>\n<p>switchTab 页面全部出栈，只留下新的 Tab 页面</p>\n</li>\n<li>\n<p>reLanch 页面全部出栈，只留下新的页面</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-25T05:08:15.341Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "applet"
      ]
    },
    {
      "title": "说说提高微信小程序的应用速度的手段有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/applet/optimization.html",
      "id": "https://www.h7ml.cn/posts/interview/applet/optimization.html",
      "summary": "前端物语|面试物语-说说提高微信小程序的应用速度的手段有哪些？",
      "content_html": "<h1> 说说提高微信小程序的应用速度的手段有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f606d530-3278-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>小程序启动会常常遇到如下图场景：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/03941230-3279-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>这是因为，小程序首次启动前，微信会在小程序启动前为小程序准备好通用的运行环境，如运行中的线程和一些基础库的初始化</p>\n<p>然后才开始进入启动状态，展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：</p>\n<ul>\n<li>下载小程序代码包</li>\n<li>加载小程序代码包</li>\n<li>初始化小程序首页</li>\n</ul>\n<p>下载到的小程序代码包不是小程序的源代码，而是编译、压缩、打包之后的代码包</p>\n<p>整体流程如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/11c0ea90-3279-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、手段</h2>\n<p>围绕上图小程序的启动流程， 我们可以从加载、渲染两个纬度进行切入：</p>\n<h3> 加载</h3>\n<p>提升体验最直接的方法是控制小程序包的大小，常见手段有如下：</p>\n<ul>\n<li>\n<p>代码包的体积压缩可以通过勾选开发者工具中“上传代码时，压缩代码”选项</p>\n</li>\n<li>\n<p>及时清理无用的代码和资源文件</p>\n</li>\n<li>\n<p>减少资源包中的图片等资源的数量和大小（理论上除了小 icon，其他图片资源从网络下载），图片资源压缩率有限</p>\n</li>\n</ul>\n<p>并且可以采取分包加载的操作，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载</p>\n<p>当用户点击到子包的目录时，还是有一个代码包下载的过程，这会感觉到明显的卡顿，所以子包也不建议拆的太大，当然我们可以采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2034de10-3279-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 渲染</h3>\n<p>关于微信小程序首屏渲染优化的手段如下：</p>\n<ul>\n<li>请求可以在页面 onLoad 就加载，不需要等页面 ready 后在异步请求数据</li>\n<li>尽量减少不必要的 https 请求，可使用 getStorageSync() 及 setStorageSync() 方法将数据存储在本地</li>\n<li>可以在前置页面将一些有用的字段带到当前页，进行首次渲染（列表页的某些数据--&gt; 详情页），没有数据的模块可以进行骨架屏的占位</li>\n</ul>\n<p>在微信小程序中，提高页面的多次渲染效率主要在于正确使用<code>setData</code>：</p>\n<ul>\n<li>不要过于频繁调用 setData，应考虑将多次 setData 合并成一次 setData 调用</li>\n<li>数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用<code>setData</code>来设置这些数据</li>\n<li>与界面渲染无关的数据最好不要设置在 data 中，可以考虑设置在 page 对象的其他字段下</li>\n</ul>\n<p>除此之外，对于一些独立的模块我们尽可能抽离出来，这是因为自定义组件的更新并不会影响页面上其他元素的更新</p>\n<p>各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、<code>setData</code>调用</p>\n<h2> 三、总结</h2>\n<p><strong>小程序启动加载性能</strong>：</p>\n<ul>\n<li>控制代码包的大小</li>\n<li>分包加载</li>\n<li>首屏体验（预请求，利用缓存，避免白屏，及时反馈</li>\n</ul>\n<p><strong>小程序渲染性能</strong>：</p>\n<ul>\n<li>避免不当的使用 setData</li>\n<li>使用自定义组件</li>\n</ul>\n<h3> 参考文献</h3>\n<ul>\n<li><a href=\"https://juejin.cn/post/6969779451177484296\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6969779451177484296</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008925450\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000008925450</a></li>\n<li><a href=\"https://juejin.cn/post/6844903638226173965\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903638226173965</a></li>\n<li><a href=\"https://juejin.cn/post/6844903726939897869\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903726939897869</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-26T10:08:48.415Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "applet"
      ]
    },
    {
      "title": "说说微信小程序的发布流程？",
      "url": "https://www.h7ml.cn/posts/interview/applet/publish.html",
      "id": "https://www.h7ml.cn/posts/interview/applet/publish.html",
      "summary": "前端物语|面试物语-说说微信小程序的发布流程？",
      "content_html": "<h1> 说说微信小程序的发布流程？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d5cccdf0-3652-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、背景</h2>\n<p>在中大型的公司里，人员的分工非常仔细，一般会有不同岗位角色的员工同时参与同一个小程序项目。为此，小程序平台设计了不同的权限管理使得项目管理者可以更加高效管理整个团队的协同工作</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e76aff50-3652-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>以往我们在开发完网页之后，需要把网页的代码和资源放在服务器上，让用户通过互联网来访问</p>\n<p>在小程序的平台里，开发者完成开发之后，需要在开发者工具提交小程序的代码包，然后在小程序后台发布小程序</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fe5da190-3652-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、流程</h2>\n<p>关于发布的流程，主要分成了三个部分：</p>\n<ul>\n<li>上传代码</li>\n<li>提交审核</li>\n<li>发布版本</li>\n</ul>\n<h3> 上传代码</h3>\n<p>在开发者工具中，可以点击代码上传功能：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/08f19bc0-3653-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>然后就可以填写版本信息：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1d02c8f0-3653-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>然后点击上传，编译器则会提示上传代码成功</p>\n<h3> 提交审核</h3>\n<p>代码上传完毕，就可以登陆微信公众号的官网首页，点击【开发管理】，查看应用详情：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/281038e0-3653-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>提交审核过程需要填写审核信息，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/33d97ec0-3653-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>提交审核成功之后如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3e4c3550-3653-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 发布版本</h3>\n<p>当审核通过之后，即可提交发布</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/495140d0-3653-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>发布成功之后则如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5293b4c0-3653-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、扩展</h2>\n<p>上述是最简单的小程序代码发布的流程，通常的流程如下：</p>\n<ul>\n<li>代码管理服务器上新建分支</li>\n<li>开发测试新需求</li>\n<li>测试完成后，将本地分支合并到 master 分支</li>\n<li>拉取 master 分支最新代码，执行 build 命令生成小程序可执行文件</li>\n<li>开发者工具点击“上传”</li>\n<li>提审</li>\n<li>发布</li>\n</ul>\n<p>但是面对多人协调开发的时候，有可能出现已经上线的代码还没合并到<code>master</code>的情况</p>\n<p>因此可以考虑自动化构建部署，就是将从开发到部署的一系列流程变成自动化，衔接连贯，在构建失败时能够告知开发者，构建成功后能够告知测试和实施人员，可参考如下流程图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/602d9bf0-3653-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6994414162700927012\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6994414162700927012</a></li>\n<li><a href=\"https://www.leapcloud.cn/website/docs/doc_config/xiaochengxu/xiaochengxu.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.leapcloud.cn/website/docs/doc_config/xiaochengxu/xiaochengxu.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-26T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "applet"
      ]
    },
    {
      "title": "说说微信小程序的支付流程？",
      "url": "https://www.h7ml.cn/posts/interview/applet/requestPayment.html",
      "id": "https://www.h7ml.cn/posts/interview/applet/requestPayment.html",
      "summary": "前端物语|面试物语-说说微信小程序的支付流程？",
      "content_html": "<h1> 说说微信小程序的支付流程？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2266fff0-34a0-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、前言</h2>\n<p>微信小程序为电商类小程序，提供了非常完善、优秀、安全的支付功能</p>\n<p>在小程序内可调用微信的<code>API</code>完成支付功能，方便、快捷</p>\n<p>场景如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6e0cff40-34a0-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/34864830-34a0-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>用户通过分享或扫描二维码进入商户小程序，用户选择购买，完成选购流程</li>\n<li>调起微信支付控件，用户开始输入支付密码</li>\n<li>密码验证通过，支付成功。商户后台得到支付成功的通知</li>\n<li>返回商户小程序，显示购买成功</li>\n<li>微信支付公众号下发支付凭证</li>\n</ul>\n<h2> 二、流程</h2>\n<p>以电商小程序为例</p>\n<p>支付流程图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/76b66780-34a0-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>具体的做法：</p>\n<ul>\n<li>打开某小程序，点击直接下单</li>\n<li>wx.login 获取用户临时登录凭证 code，发送到后端服务器换取 openId</li>\n<li>在下单时，小程序需要将购买的商品 Id，商品数量，以及用户的 openId 传送到服务器</li>\n<li>服务器在接收到商品 Id、商品数量、openId 后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息</li>\n<li>小程序端在获取对应的参数后，调用 wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付</li>\n<li>接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付</li>\n<li>鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示</li>\n<li>推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态</li>\n</ul>\n<p>其中后端响应数据必要的信息则是<code>wx.requestPayment</code>方法所需要的参数，大致如下：</p>\n<div class=\"language-JS line-numbers-mode\" data-ext=\"JS\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>参数表如下所示：</p>\n<figure><img src=\"https://files.mdnice.com/user/155/48efed1f-d67f-45a7-ab2c-89a6424fafa0.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、结束</h2>\n<p>小程序支付和以往的网页、APP 微信支付大同小异，可以说小程序的支付变得更加简洁，不需要设置支付目录、域名授权等操作</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_8_0.shtml\" target=\"_blank\" rel=\"noopener noreferrer\">https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_8_0.shtml</a></li>\n<li><a href=\"https://juejin.cn/post/6844903895970349064\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903895970349064</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "applet"
      ]
    },
    {
      "title": "谈谈你对 BFC 的理解？",
      "url": "https://www.h7ml.cn/posts/interview/css/BFC.html",
      "id": "https://www.h7ml.cn/posts/interview/css/BFC.html",
      "summary": "前端物语|面试物语-谈谈你对 BFC 的理解？",
      "content_html": "<h1> 谈谈你对 BFC 的理解？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c3d68290-9511-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>我们在页面布局的时候，经常出现以下情况：</p>\n<ul>\n<li>这个元素高度怎么没了？</li>\n<li>这两栏布局怎么没法自适应？</li>\n<li>这两个元素的间距怎么有点奇怪的样子？</li>\n<li>......</li>\n</ul>\n<p>原因是元素之间相互的影响，导致了意料之外的情况，这里就涉及到<code>BFC</code>概念</p>\n<p><code>BFC</code>（Block Formatting Context），即块级格式化上下文，它是页面中的一块渲染区域，并且有一套属于自己的渲染规则：</p>\n<ul>\n<li>内部的盒子会在垂直方向上一个接一个的放置</li>\n<li>对于同一个 BFC 的俩个相邻的盒子的 margin 会发生重叠，与方向无关。</li>\n<li>每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此</li>\n<li>BFC 的区域不会与 float 的元素区域重叠</li>\n<li>计算 BFC 的高度时，浮动子元素也参与计算</li>\n<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li>\n</ul>\n<p><code>BFC</code>目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素</p>\n<h2> 二、触发条件</h2>\n<p>触发<code>BFC</code>的条件包含不限于：</p>\n<ul>\n<li>根元素，即 HTML 元素</li>\n<li>浮动元素：float 值为 left、right</li>\n<li>overflow 值不为 visible，为 auto、scroll、hidden</li>\n<li>display 的值为 inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid</li>\n<li>position 的值为 absolute 或 fixed</li>\n</ul>\n<h2> 三、应用场景</h2>\n<p>利用<code>BFC</code>的特性，我们将<code>BFC</code>应用在以下场景：</p>\n<h4> 防止 margin 重叠（塌陷）</h4>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>页面显示如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d0ce3650-9511-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>两个<code>p</code>元素之间的距离为<code>100px</code>，发生了<code>margin</code>重叠（塌陷），以最大的为准，如果第一个 P 的<code>margin</code>为 80 的话，两个 P 之间的距离还是 100，以最大的为准。</p>\n<p>前面讲到，同一个<code>BFC</code>的俩个相邻的盒子的<code>margin</code>会发生重叠</p>\n<p>可以在<code>p</code>外面包裹一层容器，并触发这个容器生成一个<code>BFC</code>，那么两个<code>p</code>就不属于同一个<code>BFC</code>，则不会出现<code>margin</code>重叠</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这时候，边距则不会重叠：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/dec44740-9511-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h4> 清除内部浮动</h4>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>页面显示如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ec5d4410-9511-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>而<code>BFC</code>在计算高度时，浮动元素也会参与，所以我们可以触发<code>.par</code>元素生成<code>BFC</code>，则内部浮动元素计算高度时候也会计算</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实现效果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f6487b20-9511-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h4> 自适应多栏布局</h4>\n<p>这里举个两栏的布局</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>效果图如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ffb95210-9511-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>前面讲到，每个元素的左外边距与包含块的左边界相接触</p>\n<p>因此，虽然<code>.aslide</code>为浮动元素，但是<code>main</code>的左边依然会与包含块的左边相接触</p>\n<p>而<code>BFC</code>的区域不会与浮动盒子重叠</p>\n<p>所以我们可以通过触发<code>main</code>生成<code>BFC</code>，以此适应两栏布局</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这时候，新的<code>BFC</code>不会与浮动的<code>.aside</code>元素重叠。因此会根据包含块的宽度，和<code>.aside</code>的宽度，自动变窄</p>\n<p>效果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/0a5f2690-9512-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 小结</h3>\n<p>可以看到上面几个案例，都体现了<code>BFC</code>实际就是页面一个独立的容器，里面的子元素不影响外面的元素</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</a></li>\n<li><a href=\"https://github.com/zuopf769/notebook/blob/master/fe/BFC%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/README.md\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/zuopf769/notebook/blob/master/fe/BFC原理剖析/README.md</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-03T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "前端物语|面试物语-css",
      "url": "https://www.h7ml.cn/posts/interview/css/",
      "id": "https://www.h7ml.cn/posts/interview/css/",
      "summary": "谈谈你对 BFC 的理解？ css3 动画有哪些？ 说说你对盒子模型的理解? 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？ 如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？ CSS3 新增了哪些新特性？ 如果要做优化，CSS 提高性能的方法有哪些？ 说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？ 说说 em/px/rem/vh/vw 区别? 说说 flexbox（弹性盒布局模型）,以及适用场景？ 介绍一下 grid 网格布局 css 中，有哪些方式可以隐藏页面元素？区别? 怎么理解回流跟重绘？什么场景下会触发？ 让 Chrome 支持小于 12px 的文字方式有哪些？区别？ 什么是响应式设计？响应式设计的基本原理是什么？如何做？ 说说对 Css 预编语言的理解？有哪些区别? 如何实现单行／多行文本溢出的省略样式？ CSS 如何画一个三角形？原理是什么？ 如何使用 css 完成视差滚动效果?",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/BFC\" target=\"_blank\" rel=\"noopener noreferrer\">谈谈你对 BFC 的理解？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/animation\" target=\"_blank\" rel=\"noopener noreferrer\">css3 动画有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/box\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对盒子模型的理解?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/center\" target=\"_blank\" rel=\"noopener noreferrer\">元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/column_layout\" target=\"_blank\" rel=\"noopener noreferrer\">如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/css3_features\" target=\"_blank\" rel=\"noopener noreferrer\">CSS3 新增了哪些新特性？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/css_performance\" target=\"_blank\" rel=\"noopener noreferrer\">如果要做优化，CSS 提高性能的方法有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/dp_px_dpr_ppi\" target=\"_blank\" rel=\"noopener noreferrer\">说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/em_px_rem_vh_vw\" target=\"_blank\" rel=\"noopener noreferrer\">说说 em/px/rem/vh/vw 区别?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/flexbox\" target=\"_blank\" rel=\"noopener noreferrer\">说说 flexbox（弹性盒布局模型）,以及适用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/grid\" target=\"_blank\" rel=\"noopener noreferrer\">介绍一下 grid 网格布局</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/hide_attributes\" target=\"_blank\" rel=\"noopener noreferrer\">css 中，有哪些方式可以隐藏页面元素？区别?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/layout_painting\" target=\"_blank\" rel=\"noopener noreferrer\">怎么理解回流跟重绘？什么场景下会触发？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/less_12px\" target=\"_blank\" rel=\"noopener noreferrer\">让 Chrome 支持小于 12px 的文字方式有哪些？区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/responsive_layout\" target=\"_blank\" rel=\"noopener noreferrer\">什么是响应式设计？响应式设计的基本原理是什么？如何做？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/sass_less_stylus\" target=\"_blank\" rel=\"noopener noreferrer\">说说对 Css 预编语言的理解？有哪些区别?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/single_multi_line\" target=\"_blank\" rel=\"noopener noreferrer\">如何实现单行／多行文本溢出的省略样式？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/triangle\" target=\"_blank\" rel=\"noopener noreferrer\">CSS 如何画一个三角形？原理是什么？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/css/visual_scrolling\" target=\"_blank\" rel=\"noopener noreferrer\">如何使用 css 完成视差滚动效果?</a></li>\n</ul>\n",
      "date_published": "2023-04-07T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "css"
      ]
    },
    {
      "title": "css3 动画有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/css/animation.html",
      "id": "https://www.h7ml.cn/posts/interview/css/animation.html",
      "summary": "前端物语|面试物语-css3 动画有哪些？",
      "content_html": "<h1> css3 动画有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d12e2380-9c0a-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>CSS 动画（CSS Animations）是为层叠样式表建议的允许可扩展标记语言（XML）元素使用 CSS 的动画的模块</p>\n<p>即指元素从一种样式逐渐过渡为另一种样式的过程</p>\n<p>常见的动画效果有很多，如平移、旋转、缩放等等，复杂动画则是多个简单动画的组合</p>\n<p><code>css</code>实现动画的方式，有如下几种：</p>\n<ul>\n<li>transition 实现渐变动画</li>\n<li>transform 转变动画</li>\n<li>animation 实现自定义动画</li>\n</ul>\n<h2> 二、实现方式</h2>\n<h3> transition 实现渐变动画</h3>\n<p><code>transition</code>的属性如下：</p>\n<ul>\n<li>property:填写需要变化的 css 属性</li>\n<li>duration:完成过渡效果需要的时间单位(s 或者 ms)</li>\n<li>timing-function:完成效果的速度曲线</li>\n<li>delay: 动画效果的延迟触发时间</li>\n</ul>\n<p>其中<code>timing-function</code>的值有如下：</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>linear</td>\n<td>匀速（等于 cubic-bezier(0,0,1,1)）</td>\n</tr>\n<tr>\n<td>ease</td>\n<td>从慢到快再到慢（cubic-bezier(0.25,0.1,0.25,1)）</td>\n</tr>\n<tr>\n<td>ease-in</td>\n<td>慢慢变快（等于 cubic-bezier(0.42,0,1,1)）</td>\n</tr>\n<tr>\n<td>ease-out</td>\n<td>慢慢变慢（等于 cubic-bezier(0,0,0.58,1)）</td>\n</tr>\n<tr>\n<td>ease-in-out</td>\n<td>先变快再到慢（等于 cubic-bezier(0.42,0,0.58,1)），渐显渐隐效果</td>\n</tr>\n<tr>\n<td>cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>\n<td>在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值</td>\n</tr>\n</tbody>\n</table>\n<p>注意：并不是所有的属性都能使用过渡的，如<code>display:none&lt;-&gt;display:block</code></p>\n<p>举个例子，实现鼠标移动上去发生变化动画效果</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> transform 转变动画</h3>\n<p>包含四个常用的功能：</p>\n<ul>\n<li>translate：位移</li>\n<li>scale：缩放</li>\n<li>rotate：旋转</li>\n<li>skew：倾斜</li>\n</ul>\n<p>一般配合<code>transition</code>过度使用</p>\n<p>注意的是，<code>transform</code>不支持<code>inline</code>元素，使用前把它变成<code>block</code></p>\n<p>举个例子</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到盒子发生了旋转，倾斜，平移，放大</p>\n<h3> animation 实现自定义动画</h3>\n<p><code>animation</code>是由 8 个属性的简写，分别如下：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>属性值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>animation-duration</td>\n<td>指定动画完成一个周期所需要时间，单位秒（s）或毫秒（ms），默认是 0</td>\n<td></td>\n</tr>\n<tr>\n<td>animation-timing-function</td>\n<td>指定动画计时函数，即动画的速度曲线，默认是 \"ease\"</td>\n<td>linear、ease、ease-in、ease-out、ease-in-out</td>\n</tr>\n<tr>\n<td>animation-delay</td>\n<td>指定动画延迟时间，即动画何时开始，默认是 0</td>\n<td></td>\n</tr>\n<tr>\n<td>animation-iteration-count</td>\n<td>指定动画播放的次数，默认是 1</td>\n<td></td>\n</tr>\n<tr>\n<td>animation-direction 指定动画播放的方向</td>\n<td>默认是 normal</td>\n<td>normal、reverse、alternate、alternate-reverse</td>\n</tr>\n<tr>\n<td>animation-fill-mode</td>\n<td>指定动画填充模式。默认是 none</td>\n<td>forwards、backwards、both</td>\n</tr>\n<tr>\n<td>animation-play-state</td>\n<td>指定动画播放状态，正在运行或暂停。默认是 running</td>\n<td>running、pauser</td>\n</tr>\n<tr>\n<td>animation-name</td>\n<td>指定 @keyframes 动画的名称</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><code>CSS</code> 动画只需要定义一些关键的帧，而其余的帧，浏览器会根据计时函数插值计算出来，</p>\n<p>通过 <code>@keyframes</code> 来定义关键帧</p>\n<p>因此，如果我们想要让元素旋转一圈，只需要定义开始和结束两帧即可：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>from</code> 表示最开始的那一帧，<code>to</code> 表示结束时的那一帧</p>\n<p>也可以使用百分比刻画生命周期</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定义好了关键帧后，下来就可以直接用它了：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 三、总结</h2>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>transition（过度）</td>\n<td>用于设置元素的样式过度，和 animation 有着类似的效果，但细节上有很大的不同</td>\n</tr>\n<tr>\n<td>transform（变形）</td>\n<td>用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，就相当于 color 一样用来设置元素的“外表”</td>\n</tr>\n<tr>\n<td>translate（移动）</td>\n<td>只是 transform 的一个属性值，即移动</td>\n</tr>\n<tr>\n<td>animation（动画）</td>\n<td>用于设置动画属性，他是一个简写的属性，包含 6 个属性</td>\n</tr>\n</tbody>\n</table>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000022540857\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000022540857</a></li>\n<li><a href=\"https://zh.m.wikipedia.org/wiki/CSS%E5%8A%A8%E7%94%BB\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.m.wikipedia.org/wiki/CSS动画</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-26T00:47:56.517Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "说说你对盒子模型的理解?",
      "url": "https://www.h7ml.cn/posts/interview/css/box.html",
      "id": "https://www.h7ml.cn/posts/interview/css/box.html",
      "summary": "前端物语|面试物语-说说你对盒子模型的理解?",
      "content_html": "<h1> 说说你对盒子模型的理解?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8d0e9ca0-8f9b-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）</p>\n<p>一个盒子由四个部分组成：<code>content</code>、<code>padding</code>、<code>border</code>、<code>margin</code></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/976789a0-8f9b-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p><code>content</code>，即实际内容，显示文本和图像</p>\n<p><code>boreder</code>，即边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成</p>\n<p><code>padding</code>，即内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的<code>background</code>属性影响</p>\n<p><code>margin</code>，即外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域</p>\n<p>上述是一个从二维的角度观察盒子，下面再看看看三维图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b2548b00-8f9b-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>下面来段代码：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当我们在浏览器查看元素时，却发现元素的大小变成了<code>240px</code></p>\n<p>这是因为，在<code>CSS</code>中，盒子模型可以分成：</p>\n<ul>\n<li>W3C 标准盒子模型</li>\n<li>IE 怪异盒子模型</li>\n</ul>\n<p>默认情况下，盒子模型为<code>W3C</code> 标准盒子模型</p>\n<h2> 二、标准盒子模型</h2>\n<p>标准盒子模型，是浏览器默认的盒子模型</p>\n<p>下面看看标准盒子模型的模型图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c0e1d2e0-8f9b-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从上图可以看到：</p>\n<ul>\n<li>\n<p>盒子总宽度 = width + padding + border + margin;</p>\n</li>\n<li>\n<p>盒子总高度 = height + padding + border + margin</p>\n</li>\n</ul>\n<p>也就是，<code>width/height</code> 只是内容高度，不包含 <code>padding</code> 和 <code>border</code>值</p>\n<p>所以上面问题中，设置<code>width</code>为 200px，但由于存在<code>padding</code>，但实际上盒子的宽度有 240px</p>\n<h2> 三、IE 怪异盒子模型</h2>\n<p>同样看看 IE 怪异盒子模型的模型图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/cfbb3ef0-8f9b-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从上图可以看到：</p>\n<ul>\n<li>\n<p>盒子总宽度 = width + margin;</p>\n</li>\n<li>\n<p>盒子总高度 = height + margin;</p>\n</li>\n</ul>\n<p>也就是，<code>width/height</code> 包含了 <code>padding</code>和 <code>border</code>值</p>\n<h2> Box-sizing</h2>\n<p>CSS 中的 box-sizing 属性定义了引擎应该如何计算一个元素的总宽度和总高度</p>\n<p>语法：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>content-box 默认值，元素的 width/height 不包含 padding，border，与标准盒子模型表现一致</li>\n<li>border-box 元素的 width/height 包含 padding，border，与怪异盒子模型表现一致</li>\n<li>inherit 指定 box-sizing 属性的值，应该从父元素继承</li>\n</ul>\n<p>回到上面的例子里，设置盒子为 border-box 模型</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这时候，就可以发现盒子的所占据的宽度为 200px</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "元素水平垂直居中的方法有哪些？如果元素不定宽高呢？",
      "url": "https://www.h7ml.cn/posts/interview/css/center.html",
      "id": "https://www.h7ml.cn/posts/interview/css/center.html",
      "summary": "前端物语|面试物语-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？",
      "content_html": "<h1> 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7b64c8d0-95f9-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、背景</h2>\n<p>在开发中经常遇到这个问题，即让某个元素的内容在水平和垂直方向上都居中，内容不仅限于文字，可能是图片或其他元素</p>\n<p>居中是一个非常基础但又是非常重要的应用场景，实现居中的方法存在很多，可以将这些方法分成两个大类：</p>\n<ul>\n<li>居中元素（子元素）的宽高已知</li>\n<li>居中元素宽高未知</li>\n</ul>\n<h2> 二、实现方式</h2>\n<p>实现元素水平垂直居中的方式：</p>\n<ul>\n<li>\n<p>利用定位+margin:auto</p>\n</li>\n<li>\n<p>利用定位+margin:负值</p>\n</li>\n<li>\n<p>利用定位+transform</p>\n</li>\n<li>\n<p>table 布局</p>\n</li>\n<li>\n<p>flex 布局</p>\n</li>\n<li>\n<p>grid 布局</p>\n</li>\n</ul>\n<h3> 利用定位+margin:auto</h3>\n<p>先上代码：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>父级设置为相对定位，子级绝对定位 ，并且四个定位属性的值都设置了 0，那么这时候如果子级没有设置宽高，则会被拉开到和父级一样宽高</p>\n<p>这里子元素设置了宽高，所以宽高会按照我们的设置来显示，但是实际上子级的虚拟占位已经撑满了整个父级，这时候再给它一个<code>margin：auto</code>它就可以上下左右都居中了</p>\n<h3> 利用定位+margin:负值</h3>\n<p>绝大多数情况下，设置父元素为相对定位， 子元素移动自身 50%实现水平垂直居中</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>整个实现思路如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/922dc300-95f9-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>初始位置为方块 1 的位置</li>\n<li>当设置 left、top 为 50%的时候，内部子元素为方块 2 的位置</li>\n<li>设置 margin 为负数时，使内部子元素到方块 3 的位置，即中间位置</li>\n</ul>\n<p>这种方案不要求父元素的高度，也就是即使父元素的高度变化了，仍然可以保持在父元素的垂直居中位置，水平方向上是一样的操作</p>\n<p>但是该方案需要知道子元素自身的宽高，但是我们可以通过下面<code>transform</code>属性进行移动</p>\n<h3> 利用定位+transform</h3>\n<p>实现代码如下：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>translate(-50%, -50%)</code>将会将元素位移自己宽度和高度的-50%</p>\n<p>这种方法其实和最上面被否定掉的 margin 负值用法一样，可以说是<code>margin</code>负值的替代方案，并不需要知道自身元素的宽高</p>\n<h3> table 布局</h3>\n<p>设置父元素为<code>display:table-cell</code>，子元素设置 <code>display: inline-block</code>。利用<code>vertical</code>和<code>text-align</code>可以让所有的行内块级元素水平垂直居中</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> flex 弹性布局</h3>\n<p>还是看看实现的整体代码：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>css3</code>中了<code>flex</code>布局，可以非常简单实现垂直水平居中</p>\n<p>这里可以简单看看<code>flex</code>布局的关键属性作用：</p>\n<ul>\n<li>\n<p>display: flex 时，表示该容器内部的元素将按照 flex 进行布局</p>\n</li>\n<li>\n<p>align-items: center 表示这些元素将相对于本容器水平居中</p>\n</li>\n<li>\n<p>justify-content: center 也是同样的道理垂直居中</p>\n</li>\n</ul>\n<h3> grid 网格布局</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里看到，<code>gird</code>网格布局和<code>flex</code>弹性布局都简单粗暴</p>\n<h3> 小结</h3>\n<p>上述方法中，不知道元素宽高大小仍能实现水平垂直居中的方法有：</p>\n<ul>\n<li>利用定位+margin:auto</li>\n<li>利用定位+transform</li>\n<li>flex 布局</li>\n<li>grid 布局</li>\n</ul>\n<h2> 三、总结</h2>\n<p>根据元素标签的性质，可以分为：</p>\n<ul>\n<li>内联元素居中布局</li>\n<li>块级元素居中布局</li>\n</ul>\n<h3> 内联元素居中布局</h3>\n<p>水平居中</p>\n<ul>\n<li>行内元素可设置：text-align: center</li>\n<li>flex 布局设置父元素：display: flex; justify-content: center</li>\n</ul>\n<p>垂直居中</p>\n<ul>\n<li>单行文本父元素确认高度：height === line-height</li>\n<li>多行文本父元素确认高度：display: table-cell; vertical-align: middle</li>\n</ul>\n<h3> 块级元素居中布局</h3>\n<p>水平居中</p>\n<ul>\n<li>定宽: margin: 0 auto</li>\n<li>绝对定位+left:50%+margin:负自身一半</li>\n</ul>\n<p>垂直居中</p>\n<ul>\n<li>position: absolute 设置 left、top、margin-left、margin-top(定高)</li>\n<li>display: table-cell</li>\n<li>transform: translate(x, y)</li>\n<li>flex(不定高，不定宽)</li>\n<li>grid(不定高，不定宽)，兼容性相对比较差</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844903982960214029#heading-10\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903982960214029#heading-10</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-02T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？",
      "url": "https://www.h7ml.cn/posts/interview/css/column_layout.html",
      "id": "https://www.h7ml.cn/posts/interview/css/column_layout.html",
      "summary": "前端物语|面试物语-如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？",
      "content_html": "<h1> 如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f335d400-976e-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、背景</h2>\n<p>在日常布局中，无论是两栏布局还是三栏布局，使用的频率都非常高</p>\n<h3> 两栏布局</h3>\n<p>两栏布局实现效果就是将页面分割成左右宽度不等的两列，宽度较小的列设置为固定宽度，剩余宽度由另一列撑满，</p>\n<p>比如 <code>Ant Design</code> 文档，蓝色区域为主要内容布局容器，侧边栏为次要内容布局容器</p>\n<blockquote>\n<p>这里称宽度较小的列父元素为次要布局容器，宽度较大的列父元素为主要布局容器</p>\n</blockquote>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fcb8ac50-976e-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>这种布局适用于内容上具有明显主次关系的网页</p>\n<h3> 三栏布局</h3>\n<p>三栏布局按照左中右的顺序进行排列，通常中间列最宽，左右两列次之</p>\n<p>大家最常见的就是<code>github</code>：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/0bf016e0-976f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、两栏布局</h2>\n<p>两栏布局非常常见，往往是以一个定宽栏和一个自适应的栏并排展示存在</p>\n<p>实现思路也非常的简单：</p>\n<ul>\n<li>使用 float 左浮左边栏</li>\n<li>右边模块使用 margin-left 撑出内容块做内容展示</li>\n<li>为父级元素添加 BFC，防止下方元素飞到上方内容</li>\n</ul>\n<p>代码如下：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>还有一种更为简单的使用则是采取：flex 弹性布局</p>\n<h3> flex 弹性布局</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>flex</code>可以说是最好的方案了，代码少，使用简单</p>\n<p>注意的是，<code>flex</code>容器的一个默认属性值:<code>align-items: stretch;</code></p>\n<p>这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: <code>align-items: flex-start</code></p>\n<h2> 三、三栏布局</h2>\n<p>实现三栏布局中间自适应的布局方式有：</p>\n<ul>\n<li>两边使用 float，中间使用 margin</li>\n<li>两边使用 absolute，中间使用 margin</li>\n<li>两边使用 float 和负 margin</li>\n<li>display: table 实现</li>\n<li>flex 实现</li>\n<li>grid 网格布局</li>\n</ul>\n<h3> 两边使用 float，中间使用 margin</h3>\n<p>需要将中间的内容放在<code>html</code>结构最后，否则右侧会臣在中间内容的下方</p>\n<p>实现代码如下：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>原理如下：</p>\n<ul>\n<li>两边固定宽度，中间宽度自适应。</li>\n<li>利用中间元素的 margin 值控制两边的间距</li>\n<li>宽度小于左右部分宽度之和时，右侧部分会被挤下去</li>\n</ul>\n<p>这种实现方式存在缺陷：</p>\n<ul>\n<li>\n<p>主体内容是最后加载的。</p>\n</li>\n<li>\n<p>右边在主体内容之前，如果是响应式设计，不能简单的换行展示</p>\n</li>\n</ul>\n<h3> 两边使用 absolute，中间使用 margin</h3>\n<p>基于绝对定位的三栏布局：注意绝对定位的元素脱离文档流，相对于最近的已经定位的祖先元素进行定位。无需考虑 HTML 中结构的顺序</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实现流程：</p>\n<ul>\n<li>左右两边使用绝对定位，固定在两侧。</li>\n<li>中间占满一行，但通过 margin 和左右两边留出 10px 的间隔</li>\n</ul>\n<h3> 两边使用 float 和负 margin</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实现过程：</p>\n<ul>\n<li>中间使用了双层标签，外层是浮动的，以便左中右能在同一行展示</li>\n<li>左边通过使用负 margin-left:-100%，相当于中间的宽度，所以向上偏移到左侧</li>\n<li>右边通过使用负 margin-left:-100px，相当于自身宽度，所以向上偏移到最右侧</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>增加了 .main-wrapper 一层，结构变复杂</li>\n<li>使用负 margin，调试也相对麻烦</li>\n</ul>\n<h3> 使用 display: table 实现</h3>\n<p><code>&lt;table&gt;</code> 标签用于展示行列数据，不适合用于布局。但是可以使用 <code>display: table</code> 来实现布局的效果</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实现原理：</p>\n<ul>\n<li>层通过 display: table 设置为表格，设置 table-layout: fixed`表示列宽自身宽度决定，而不是自动计算。</li>\n<li>内层的左中右通过 display: table-cell 设置为表格单元。</li>\n<li>左右设置固定宽度，中间设置 width: 100% 填充剩下的宽度</li>\n</ul>\n<h3> 使用 flex 实现</h3>\n<p>利用<code>flex</code>弹性布局，可以简单实现中间自适应</p>\n<p>代码如下：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实现过程：</p>\n<ul>\n<li>仅需将容器设置为<code>display:flex;</code>，</li>\n<li>盒内元素两端对其，将中间元素设置为<code>100%</code>宽度，或者设为<code>flex:1</code>，即可填充空白</li>\n<li>盒内元素的高度撑开容器的高度</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>结构简单直观</li>\n<li>可以结合 flex 的其他功能实现更多效果，例如使用 order 属性调整显示顺序，让主体内容优先加载，但展示在中间</li>\n</ul>\n<h3> grid 网格布局</h3>\n<p>代码如下：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>跟<code>flex</code>弹性布局一样的简单</p>\n<h2> 参考文献</h2>\n<ul>\n<li>\n<p><a href=\"https://zhuqingguang.github.io/2017/08/16/adapting-two-layout/\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuqingguang.github.io/2017/08/16/adapting-two-layout/</a></p>\n</li>\n<li>\n<p><a href=\"https://segmentfault.com/a/1190000008705541\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000008705541</a></p>\n</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-25T10:08:14.666Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "CSS3 新增了哪些新特性？",
      "url": "https://www.h7ml.cn/posts/interview/css/css3_features.html",
      "id": "https://www.h7ml.cn/posts/interview/css/css3_features.html",
      "summary": "前端物语|面试物语-CSS3 新增了哪些新特性？",
      "content_html": "<h1> CSS3 新增了哪些新特性？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d58f6df0-9b5e-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>css</code>，即层叠样式表（Cascading Style Sheets）的简称，是一种标记语言，由浏览器解释执行用来使页面变得更美观</p>\n<p><code>css3</code>是<code>css</code>的最新标准，是向后兼容的，<code>CSS1/2</code>的特性在<code>CSS3</code> 里都是可以使用的</p>\n<p>而<code>CSS3</code> 也增加了很多新特性，为开发带来了更佳的开发体验</p>\n<h2> 二、选择器</h2>\n<p><code>css3</code>中新增了一些选择器，主要为如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e368cf20-9b5e-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、新样式</h2>\n<h3> 边框</h3>\n<p><code>css3</code>新增了三个边框属性，分别是：</p>\n<ul>\n<li>\n<p>border-radius：创建圆角边框</p>\n</li>\n<li>\n<p>box-shadow：为元素添加阴影</p>\n</li>\n<li>\n<p>border-image：使用图片来绘制边框</p>\n</li>\n</ul>\n<h4> box-shadow</h4>\n<p>设置元素阴影，设置属性如下：</p>\n<ul>\n<li>水平阴影</li>\n<li>垂直阴影</li>\n<li>模糊距离(虚实)</li>\n<li>阴影尺寸(影子大小)</li>\n<li>阴影颜色</li>\n<li>内/外阴影</li>\n</ul>\n<p>其中水平阴影和垂直阴影是必须设置的</p>\n<h3> 背景</h3>\n<p>新增了几个关于背景的属性，分别是<code>background-clip</code>、<code>background-origin</code>、<code>background-size</code>和<code>background-break</code></p>\n<h4> background-clip</h4>\n<p>用于确定背景画区，有以下几种可能的属性：</p>\n<ul>\n<li>background-clip: border-box; 背景从 border 开始显示</li>\n<li>background-clip: padding-box; 背景从 padding 开始显示</li>\n<li>background-clip: content-box; 背景显 content 区域开始显示</li>\n<li>background-clip: no-clip; 默认属性，等同于 border-box</li>\n</ul>\n<p>通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围</p>\n<h4> background-origin</h4>\n<p>当我们设置背景图片时，图片是会以左上角对齐，但是是以<code>border</code>的左上角对齐还是以<code>padding</code>的左上角或者<code>content</code>的左上角对齐? <code>border-origin</code>正是用来设置这个的</p>\n<ul>\n<li>background-origin: border-box; 从 border 开始计算 background-position</li>\n<li>background-origin: padding-box; 从 padding 开始计算 background-position</li>\n<li>background-origin: content-box; 从 content 开始计算 background-position</li>\n</ul>\n<p>默认情况是<code>padding-box</code>，即以<code>padding</code>的左上角为原点</p>\n<h4> background-size</h4>\n<p>background-size 属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：</p>\n<ul>\n<li>background-size: contain; 缩小图片以适合元素（维持像素长宽比）</li>\n<li>background-size: cover; 扩展元素以填补元素（维持像素长宽比）</li>\n<li>background-size: 100px 100px; 缩小图片至指定的大小</li>\n<li>background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸</li>\n</ul>\n<h3> background-break</h3>\n<p>元素可以被分成几个独立的盒子（如使内联元素 span 跨越多行），<code>background-break</code> 属性用来控制背景怎样在这些不同的盒子中显示</p>\n<ul>\n<li>background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）</li>\n<li>background-break: bounding-box; 把盒之间的距离计算在内；</li>\n<li>background-break: each-box; 为每个盒子单独重绘背景</li>\n</ul>\n<h3> 文字</h3>\n<h3> word-wrap</h3>\n<p>语法：<code>word-wrap: normal|break-word</code></p>\n<ul>\n<li>normal：使用浏览器默认的换行</li>\n<li>break-all：允许在单词内换行</li>\n</ul>\n<h3> text-overflow</h3>\n<p><code>text-overflow</code>设置或检索当当前行超过指定容器的边界时如何显示，属性有两个值选择：</p>\n<ul>\n<li>clip：修剪文本</li>\n<li>ellipsis：显示省略符号来代表被修剪的文本</li>\n</ul>\n<h3> text-shadow</h3>\n<p><code>text-shadow</code>可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色</p>\n<h3> text-decoration</h3>\n<p>CSS3 里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：</p>\n<ul>\n<li>\n<p>text-fill-color: 设置文字内部填充颜色</p>\n</li>\n<li>\n<p>text-stroke-color: 设置文字边界填充颜色</p>\n</li>\n<li>\n<p>text-stroke-width: 设置文字边界宽度</p>\n</li>\n</ul>\n<h3> 颜色</h3>\n<p><code>css3</code>新增了新的颜色表示方式<code>rgba</code>与<code>hsla</code></p>\n<ul>\n<li>rgba 分为两部分，rgb 为颜色值，a 为透明度</li>\n<li>hala 分为四部分，h 为色相，s 为饱和度，l 为亮度，a 为透明度</li>\n</ul>\n<h2> 四、transition 过渡</h2>\n<p><code>transition</code>属性可以被指定为一个或多个<code>CSS</code>属性的过渡效果，多个属性之间用逗号进行分隔，必须规定两项内容：</p>\n<ul>\n<li>过度效果</li>\n<li>持续时间</li>\n</ul>\n<p>语法如下：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>上面为简写模式，也可以分开写各个属性</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 五、transform 转换</h3>\n<p><code>transform</code>属性允许你旋转，缩放，倾斜或平移给定元素</p>\n<p><code>transform-origin</code>：转换元素的位置（围绕那个点进行转换），默认值为<code>(x,y,z):(50%,50%,0)</code></p>\n<p>使用方式：</p>\n<ul>\n<li>transform: translate(120px, 50%)：位移</li>\n<li>transform: scale(2, 0.5)：缩放</li>\n<li>transform: rotate(0.5turn)：旋转</li>\n<li>transform: skew(30deg, 20deg)：倾斜</li>\n</ul>\n<h3> 六、animation 动画</h3>\n<p>动画这个平常用的也很多，主要是做一个预设的动画。和一些页面交互的动画效果，结果和过渡应该一样，让页面不会那么生硬</p>\n<p>animation 也有很多的属性</p>\n<ul>\n<li>animation-name：动画名称</li>\n<li>animation-duration：动画持续时间</li>\n<li>animation-timing-function：动画时间函数</li>\n<li>animation-delay：动画延迟时间</li>\n<li>animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为 infinite，意思是无限循环</li>\n<li>animation-direction：动画执行方向</li>\n<li>animation-paly-state：动画播放状态</li>\n<li>animation-fill-mode：动画填充模式</li>\n</ul>\n<h2> 七、渐变</h2>\n<p>颜色渐变是指在两个颜色之间平稳的过渡，<code>css3</code>渐变包括</p>\n<ul>\n<li>linear-gradient：线性渐变</li>\n</ul>\n<blockquote>\n<p>background-image: linear-gradient(direction, color-stop1, color-stop2, ...);</p>\n</blockquote>\n<ul>\n<li>radial-gradient：径向渐变</li>\n</ul>\n<blockquote>\n<p>linear-gradient(0deg, red, green);</p>\n</blockquote>\n<h2> 八、其他</h2>\n<p>关于<code>css3</code>其他的新特性还包括<code>flex</code>弹性布局、<code>Grid</code>栅格布局，这两个布局在以前就已经讲过，这里就不再展示</p>\n<p>除此之外，还包括多列布局、媒体查询、混合模式等等......</p>\n<h2> 参考文献</h2>\n<ul>\n<li>\n<p><a href=\"https://juejin.cn/post/6844903518520901639#heading-1\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903518520901639#heading-1</a></p>\n</li>\n<li>\n<p><a href=\"https://www.w3school.com.cn/css/index.asp\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.w3school.com.cn/css/index.asp</a></p>\n</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-26T05:07:54.428Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "如果要做优化，CSS 提高性能的方法有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/css/css_performance.html",
      "id": "https://www.h7ml.cn/posts/interview/css/css_performance.html",
      "summary": "前端物语|面试物语-如果要做优化，CSS 提高性能的方法有哪些？",
      "content_html": "<h1> 如果要做优化，CSS 提高性能的方法有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c071c820-9fa3-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、前言</h2>\n<p>每一个网页都离不开<code>css</code>，但是很多人又认为，<code>css</code>主要是用来完成页面布局的，像一些细节或者优化，就不需要怎么考虑，实际上这种想法是不正确的</p>\n<p>作为页面渲染和内容展现的重要环节，<code>css</code>影响着用户对整个网站的第一体验</p>\n<p>因此，在整个产品研发过程中，<code>css</code>性能优化同样需要贯穿全程</p>\n<h2> 二、实现方式</h2>\n<p>实现方式有很多种，主要有如下：</p>\n<ul>\n<li>内联首屏关键 CSS</li>\n<li>异步加载 CSS</li>\n<li>资源压缩</li>\n<li>合理使用选择器</li>\n<li>减少使用昂贵的属性</li>\n<li>不要使用@import</li>\n</ul>\n<h3> 内联首屏关键 CSS</h3>\n<p>在打开一个页面，页面首要内容出现在屏幕的时间影响着用户的体验，而通过内联<code>css</code>关键代码能够使浏览器在下载完<code>html</code>后就能立刻渲染</p>\n<p>而如果外部引用<code>css</code>代码，在解析<code>html</code>结构过程中遇到外部<code>css</code>文件，才会开始下载<code>css</code>代码，再渲染</p>\n<p>所以，<code>CSS</code>内联使用使渲染时间提前</p>\n<p>注意：但是较大的<code>css</code>代码并不合适内联（初始拥塞窗口、没有缓存），而其余代码则采取外部引用方式</p>\n<h3> 异步加载 CSS</h3>\n<p>在<code>CSS</code>文件请求、下载、解析完成之前，<code>CSS</code>会阻塞渲染，浏览器将不会渲染任何已处理的内容</p>\n<p>前面加载内联代码后，后面的外部引用<code>css</code>则没必要阻塞浏览器渲染。这时候就可以采取异步加载的方案，主要有如下：</p>\n<ul>\n<li>使用 javascript 将 link 标签插到 head 标签最后</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>设置 link 标签 media 属性为 noexis，浏览器会认为当前样式表不适用当前类型，会在不阻塞页面渲染的情况下再进行下载。加载完成后，将<code>media</code>的值设为<code>screen</code>或<code>all</code>，从而让浏览器开始解析 CSS</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>通过 rel 属性将 link 元素标记为 alternate 可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将 rel 设回 stylesheet</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 资源压缩</h3>\n<p>利用<code>webpack</code>、<code>gulp/grunt</code>、<code>rollup</code>等模块化工具，将<code>css</code>代码进行压缩，使文件变小，大大降低了浏览器的加载时间</p>\n<h3> 合理使用选择器</h3>\n<p><code>css</code>匹配的规则是从右往左开始匹配，例如<code>#markdown .content h3</code>匹配规则如下：</p>\n<ul>\n<li>先找到 h3 标签元素</li>\n<li>然后去除祖先不是.content 的元素</li>\n<li>最后去除祖先不是#markdown 的元素</li>\n</ul>\n<p>如果嵌套的层级更多，页面中的元素更多，那么匹配所要花费的时间代价自然更高</p>\n<p>所以我们在编写选择器的时候，可以遵循以下规则：</p>\n<ul>\n<li>不要嵌套使用过多复杂选择器，最好不要三层以上</li>\n<li>使用 id 选择器就没必要再进行嵌套</li>\n<li>通配符和属性选择器效率最低，避免使用</li>\n</ul>\n<h3> 减少使用昂贵的属性</h3>\n<p>在页面发生重绘的时候，昂贵属性如<code>box-shadow</code>/<code>border-radius</code>/<code>filter</code>/透明度/<code>:nth-child</code>等，会降低浏览器的渲染性能</p>\n<h3> 不要使用@import</h3>\n<p>css 样式文件有两种引入方式，一种是<code>link</code>元素，另一种是<code>@import</code></p>\n<p><code>@import</code>会影响浏览器的并行下载，使得页面在加载时增加额外的延迟，增添了额外的往返耗时</p>\n<p>而且多个<code>@import</code>可能会导致下载顺序紊乱</p>\n<p>比如一个 css 文件<code>index.css</code>包含了以下内容：<code>@import url(\"reset.css\")</code></p>\n<p>那么浏览器就必须先把<code>index.css</code>下载、解析和执行后，才下载、解析和执行第二个文件<code>reset.css</code></p>\n<h3> 其他</h3>\n<ul>\n<li>减少重排操作，以及减少不必要的重绘</li>\n<li>了解哪些属性可以继承而来，避免对这些属性重复编写</li>\n<li>cssSprite，合成所有 icon 图片，用宽高加上 backgroud-position 的背景图方式显现出我们要的 icon 图，减少了 http 请求</li>\n<li>把小的 icon 图片转成 base64 编码</li>\n<li>CSS3 动画或者过渡尽量使用 transform 和 opacity 来实现动画，不要使用 left 和 top 属性</li>\n</ul>\n<h2> 三、总结</h2>\n<p><code>css</code>实现性能的方式可以从选择器嵌套、属性特性、减少<code>http</code>这三面考虑，同时还要注意<code>css</code>代码的加载顺序</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/19886806\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zhihu.com/question/19886806</a></li>\n<li><a href=\"https://juejin.cn/post/6844903649605320711#heading-1\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903649605320711#heading-1</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？",
      "url": "https://www.h7ml.cn/posts/interview/css/dp_px_dpr_ppi.html",
      "id": "https://www.h7ml.cn/posts/interview/css/dp_px_dpr_ppi.html",
      "summary": "前端物语|面试物语-说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？",
      "content_html": "<h1> 说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c4d9bfd0-91f2-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、背景</h2>\n<p>在<code>css</code>中我们通常使用 px 作为单位，在 PC 浏览器中<code>css</code>的 1 个像素都是对应着电脑屏幕的 1 个物理像素</p>\n<p>这会造成一种错觉，我们会认为<code>css</code>中的像素就是设备的物理像素</p>\n<p>但实际情况却并非如此，<code>css</code>中的像素只是一个抽象的单位，在不同的设备或不同的环境中，<code>css</code>中的 1px 所代表的设备物理像素是不同的</p>\n<p>当我们做移动端开发时，同为 1px 的设置，在不同分辨率的移动设备上显示效果却有很大差异</p>\n<p>这背后就涉及了 css 像素、设备像素、设备独立像素、dpr、ppi 的概念</p>\n<h2> 二、介绍</h2>\n<h3> CSS 像素</h3>\n<p>CSS 像素（css pixel, px）: 适用于 web 编程，在 CSS 中以 px 为后缀，是一个长度单位</p>\n<p>在 CSS 规范中，长度单位可以分为两类，绝对单位以及相对单位</p>\n<p>px 是一个相对单位，相对的是设备像素（device pixel）</p>\n<p>一般情况，页面缩放比为 1，1 个 CSS 像素等于 1 个设备独立像素</p>\n<p><code>CSS</code>像素又具有两个方面的相对性：</p>\n<ul>\n<li>在同一个设备上，每 1 个 CSS 像素所代表的设备像素是可以变化的（比如调整屏幕的分辨率）</li>\n<li>在不同的设备之间，每 1 个 CSS 像素所代表的设备像素是可以变化的（比如两个不同型号的手机）</li>\n</ul>\n<p>在页面进行缩放操作也会 引起<code>css</code>中<code>px</code>的变化，假设页面放大一倍，原来的 1px 的东西变成 2px，在实际宽度不变的情况下 1px 变得跟原来的 2px 的长度（长宽）一样了（元素会占据更多的设备像素）</p>\n<p>假设原来需要 320px 才能填满的宽度现在只需要 160px</p>\n<p>px 会受到下面的因素的影响而变化：</p>\n<ul>\n<li>每英寸像素（PPI）</li>\n<li>设备像素比（DPR）</li>\n</ul>\n<h3> 设备像素</h3>\n<p>设备像素（device pixels），又称为物理像素</p>\n<p>指设备能控制显示的最小物理单位，不一定是一个小正方形区块，也没有标准的宽高，只是用于显示丰富色彩的一个“点”而已</p>\n<p>可以参考公园里的景观变色彩灯，一个彩灯(物理像素)由红、蓝、绿小灯组成，三盏小灯不同的亮度混合出各种色彩</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/cffc6570-91f2-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，单位为<code>pt</code></p>\n<h3> 设备独立像素</h3>\n<p>设备独立像素（Device Independent Pixel）：与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括了 CSS 像素</p>\n<p>在<code>javaScript</code>中可以通过<code>window.screen.width/ window.screen.height</code> 查看</p>\n<p>比如我们会说“电脑屏幕在 2560x1600 分辨率下不适合玩游戏，我们把它调为 1440x900”，这里的“分辨率”（非严谨说法）指的就是设备独立像素</p>\n<p>一个设备独立像素里可能包含 1 个或者多个物理像素点，包含的越多则屏幕看起来越清晰</p>\n<p>至于为什么出现设备独立像素这种虚拟像素单位概念，下面举个例子：</p>\n<p>iPhone 3GS 和 iPhone 4/4s 的尺寸都是 3.5 寸，但 iPhone 3GS 的分辨率是 320x480，iPhone 4/4s 的分辨率是 640x960</p>\n<p>这意味着，iPhone 3GS 有 320 个物理像素，iPhone 4/4s 有 640 个物理像素</p>\n<p>如果我们按照真实的物理像素进行布局，比如说我们按照 320 物理像素进行布局，到了 640 物理像素的手机上就会有一半的空白，为了避免这种问题，就产生了虚拟像素单位</p>\n<p>我们统一 iPhone 3GS 和 iPhone 4/4s 都是 320 个虚拟像素，只是在 iPhone 3GS 上，最终 1 个虚拟像素换算成 1 个物理像素，在 iphone 4s 中，1 个虚拟像素最终换算成 2 个物理像素</p>\n<p>至于 1 个虚拟像素被换算成几个物理像素，这个数值我们称之为设备像素比，也就是下面介绍的<code>dpr</code></p>\n<h3> dpr</h3>\n<p>dpr（device pixel ratio），设备像素比，代表设备独立像素到设备像素的转换关系，在<code>JavaScript</code>中可以通过 <code>window.devicePixelRatio</code> 获取</p>\n<p>计算公式如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/dd45e2b0-91f2-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>当设备像素比为 1:1 时，使用 1（1×1）个设备像素显示 1 个 CSS 像素</p>\n<p>当设备像素比为 2:1 时，使用 4（2×2）个设备像素显示 1 个 CSS 像素</p>\n<p>当设备像素比为 3:1 时，使用 9（3×3）个设备像素显示 1 个 CSS 像素</p>\n<p>如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e63cceb0-91f2-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>当<code>dpr</code>为 3，那么<code>1px</code>的<code>CSS</code>像素宽度对应<code>3px</code>的物理像素的宽度，1px 的<code>CSS</code>像素高度对应<code>3px</code>的物理像素高度</p>\n<h3> ppi</h3>\n<p>ppi （pixel per inch），每英寸像素，表示每英寸所包含的像素点数目，更确切的说法应该是像素密度。数值越高，说明屏幕能以更高密度显示图像</p>\n<p>计算公式如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f734adf0-91f2-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、总结</h2>\n<p>无缩放情况下，1 个 CSS 像素等于 1 个设备独立像素</p>\n<p>设备像素由屏幕生产之后就不发生改变，而设备独立像素是一个虚拟单位会发生改变</p>\n<p>PC 端中，1 个设备独立像素 = 1 个设备像素 （在 100%，未缩放的情况下）</p>\n<p>在移动端中，标准屏幕（160ppi）下 1 个设备独立像素 = 1 个设备像素</p>\n<p>设备像素比（dpr） = 设备像素 / 设备独立像素</p>\n<p>每英寸像素（ppi），值越大，图像越清晰</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/CSS_pixel\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Glossary/CSS_pixel</a></li>\n<li><a href=\"https://hijiangtao.github.io/2017/07/09/Device-Viewport-and-Pixel-Introduction/\" target=\"_blank\" rel=\"noopener noreferrer\">https://hijiangtao.github.io/2017/07/09/Device-Viewport-and-Pixel-Introduction/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-07T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "说说 em/px/rem/vh/vw 区别?",
      "url": "https://www.h7ml.cn/posts/interview/css/em_px_rem_vh_vw.html",
      "id": "https://www.h7ml.cn/posts/interview/css/em_px_rem_vh_vw.html",
      "summary": "前端物语|面试物语-说说 em/px/rem/vh/vw 区别?",
      "content_html": "<h1> 说说 em/px/rem/vh/vw 区别?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/51b036e0-9131-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、介绍</h2>\n<p>传统的项目开发中，我们只会用到<code>px</code>、<code>%</code>、<code>em</code>这几个单位，它可以适用于大部分的项目开发，且拥有比较良好的兼容性</p>\n<p>从<code>CSS3</code>开始，浏览器对计量单位的支持又提升到了另外一个境界，新增了<code>rem</code>、<code>vh</code>、<code>vw</code>、<code>vm</code>等一些新的计量单位</p>\n<p>利用这些新的单位开发出比较良好的响应式页面，适应多种不同分辨率的终端，包括移动设备等</p>\n<h2> 二、单位</h2>\n<p>在<code>css</code>单位中，可以分为长度单位、绝对单位，如下表所指示</p>\n<table>\n<thead>\n<tr>\n<th>CSS 单位</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>相对长度单位</td>\n<td>em、ex、ch、rem、vw、vh、vmin、vmax、%</td>\n</tr>\n<tr>\n<td>绝对长度单位</td>\n<td>cm、mm、in、px、pt、pc</td>\n</tr>\n</tbody>\n</table>\n<p>这里我们主要讲述 px、em、rem、vh、vw</p>\n<h3> px</h3>\n<p>px，表示像素，所谓像素就是呈现在我们显示器上的一个个小点，每个像素点都是大小等同的，所以像素为计量单位被分在了绝对长度单位中</p>\n<p>有些人会把<code>px</code>认为是相对长度，原因在于在移动端中存在设备像素比，<code>px</code>实际显示的大小是不确定的</p>\n<p>这里之所以认为<code>px</code>为绝对单位，在于<code>px</code>的大小和元素的其他属性无关</p>\n<h3> em</h3>\n<p>em 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（<code>1em = 16px</code>）</p>\n<p>为了简化 <code>font-size</code> 的换算，我们需要在<code>css</code>中的 <code>body</code> 选择器中声明<code>font-size</code>= <code>62.5%</code>，这就使 em 值变为 <code>16px*62.5% = 10px</code></p>\n<p>这样 <code>12px = 1.2em</code>, <code>10px = 1em</code>, 也就是说只需要将你的原来的<code>px</code> 数值除以 10，然后换上 <code>em</code>作为单位就行了</p>\n<p>特点：</p>\n<ul>\n<li>em 的值并不是固定的</li>\n<li>em 会继承父级元素的字体大小</li>\n<li>em 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸</li>\n<li>任意浏览器的默认字体高都是 16px</li>\n</ul>\n<p>举个例子</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>样式为</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这时候<code>.big</code>元素的<code>font-size</code>为 14px，而<code>.small</code>元素的<code>font-size</code>为 12px</p>\n<h3> rem</h3>\n<p>rem，相对单位，相对的只是 HTML 根元素<code>font-size</code>的值</p>\n<p>同理，如果想要简化<code>font-size</code>的转化，我们可以在根元素<code>html</code>中加入<code>font-size: 62.5%</code></p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样页面中 1rem=10px、1.2rem=12px、1.4rem=14px、1.6rem=16px;使得视觉、使用、书写都得到了极大的帮助</p>\n<p>特点：</p>\n<ul>\n<li>rem 单位可谓集相对大小和绝对大小的优点于一身</li>\n<li>和 em 不同的是 rem 总是相对于根元素，而不像 em 一样使用级联的方式来计算尺寸</li>\n</ul>\n<h3> vh、vw</h3>\n<p>vw ，就是根据窗口的宽度，分成 100 等份，100vw 就表示满宽，50vw 就表示一半宽。（vw 始终是针对窗口的宽），同理，<code>vh</code>则为窗口的高度</p>\n<p>这里的窗口分成几种情况：</p>\n<ul>\n<li>\n<p>在桌面端，指的是浏览器的可视区域</p>\n</li>\n<li>\n<p>移动端指的就是布局视口</p>\n</li>\n</ul>\n<p>像<code>vw</code>、<code>vh</code>，比较容易混淆的一个单位是<code>%</code>，不过百分比宽泛的讲是相对于父元素：</p>\n<ul>\n<li>对于普通定位元素就是我们理解的父元素</li>\n<li>对于 position: absolute;的元素是相对于已定位的父元素</li>\n<li>对于 position: fixed;的元素是相对于 ViewPort（可视窗口）</li>\n</ul>\n<h2> 三、总结</h2>\n<p><strong>px</strong>：绝对单位，页面按精确像素展示</p>\n<p><strong>em</strong>：相对单位，基准点为父节点字体的大小，如果自身定义了<code>font-size</code>按自身来计算，整个页面内<code>1em</code>不是一个固定的值</p>\n<p><strong>rem</strong>：相对单位，可理解为<code>root em</code>, 相对根节点<code>html</code>的字体大小来计算</p>\n<p><strong>vh、vw</strong>：主要用于页面视口大小布局，在页面布局上更加方便简单</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-28T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "说说 flexbox（弹性盒布局模型）,以及适用场景？",
      "url": "https://www.h7ml.cn/posts/interview/css/flexbox.html",
      "id": "https://www.h7ml.cn/posts/interview/css/flexbox.html",
      "summary": "前端物语|面试物语-说说 flexbox（弹性盒布局模型）,以及适用场景？",
      "content_html": "<h1> 说说 flexbox（弹性盒布局模型）,以及适用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ef25b0a0-9837-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>Flexible Box</code> 简称 <code>flex</code>，意为”弹性布局”，可以简便、完整、响应式地实现各种页面布局</p>\n<p>采用 Flex 布局的元素，称为<code>flex</code>容器<code>container</code></p>\n<p>它的所有子元素自动成为容器成员，称为<code>flex</code>项目<code>item</code></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fbc5f590-9837-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>容器中默认存在两条轴，主轴和交叉轴，呈 90 度关系。项目默认沿主轴排列，通过<code>flex-direction</code>来决定主轴的方向</p>\n<p>每根轴都有起点和终点，这对于元素的对齐非常重要</p>\n<h2> 二、属性</h2>\n<p>关于<code>flex</code>常用的属性，我们可以划分为容器属性和容器成员属性</p>\n<p>容器属性有：</p>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n<h3> flex-direction</h3>\n<p>决定主轴的方向(即项目的排列方向)</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>属性对应如下：</p>\n<ul>\n<li>row（默认值）：主轴为水平方向，起点在左端</li>\n<li>row-reverse：主轴为水平方向，起点在右端</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿</li>\n</ul>\n<p>如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/0c9abc70-9838-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> flex-wrap</h3>\n<p>弹性元素永远沿主轴排列，那么如果主轴排不下，通过<code>flex-wrap</code>决定容器内项目是否可换行</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>属性对应如下：</p>\n<ul>\n<li>nowrap（默认值）：不换行</li>\n<li>wrap：换行，第一行在下方</li>\n<li>wrap-reverse：换行，第一行在上方</li>\n</ul>\n<p>默认情况是不换行，但这里也不会任由元素直接溢出容器，会涉及到元素的弹性伸缩</p>\n<h3> flex-flow</h3>\n<p>是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code></p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> justify-content</h3>\n<p>定义了项目在主轴上的对齐方式</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>属性对应如下：</p>\n<ul>\n<li>flex-start（默认值）：左对齐</li>\n<li>flex-end：右对齐</li>\n<li>center：居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等</li>\n<li>space-around：两个项目两侧间隔相等</li>\n</ul>\n<p>效果图如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2d5ca950-9838-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> align-items</h3>\n<p>定义项目在交叉轴上如何对齐</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>属性对应如下：</p>\n<ul>\n<li>flex-start：交叉轴的起点对齐</li>\n<li>flex-end：交叉轴的终点对齐</li>\n<li>center：交叉轴的中点对齐</li>\n<li>baseline: 项目的第一行文字的基线对齐</li>\n<li>stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度</li>\n</ul>\n<h3> align-content</h3>\n<p>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>属性对应如吓：</p>\n<ul>\n<li>flex-start：与交叉轴的起点对齐</li>\n<li>flex-end：与交叉轴的终点对齐</li>\n<li>center：与交叉轴的中点对齐</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li>\n<li>stretch（默认值）：轴线占满整个交叉轴</li>\n</ul>\n<p>效果图如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/39bcb0f0-9838-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>容器成员属性如下：</p>\n<ul>\n<li><code>order</code></li>\n<li><code>flex-grow</code></li>\n<li><code>flex-shrink</code></li>\n<li><code>flex-basis</code></li>\n<li><code>flex</code></li>\n<li><code>align-self</code></li>\n</ul>\n<h3> order</h3>\n<p>定义项目的排列顺序。数值越小，排列越靠前，默认为 0</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> flex-grow</h3>\n<p>上面讲到当容器设为<code>flex-wrap: nowrap;</code>不换行的时候，容器宽度有不够分的情况，弹性元素会根据<code>flex-grow</code>来决定</p>\n<p>定义项目的放大比例（容器宽度&gt;元素总宽度时如何伸展）</p>\n<p>默认为<code>0</code>，即如果存在剩余空间，也不放大</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果所有项目的<code>flex-grow</code>属性都为 1，则它们将等分剩余空间（如果有的话）</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/48c8c5c0-9838-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>如果一个项目的<code>flex-grow</code>属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5b822b20-9838-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论<code>flex-grow</code>是什么值都不会生效</p>\n<h3> flex-shrink</h3>\n<p>定义了项目的缩小比例（容器宽度&lt;元素总宽度时如何收缩），默认为 1，即如果空间不足，该项目将缩小</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果所有项目的<code>flex-shrink</code>属性都为 1，当空间不足时，都将等比例缩小</p>\n<p>如果一个项目的<code>flex-shrink</code>属性为 0，其他项目都为 1，则空间不足时，前者不缩小</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/658c5be0-9838-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在容器宽度有剩余时，<code>flex-shrink</code>也是不会生效的</p>\n<h3> flex-basis</h3>\n<p>设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在<code>flex-grow</code>和<code>flex-shrink</code>生效前的尺寸</p>\n<p>浏览器根据这个属性，计算主轴是否有多余空间，默认值为<code>auto</code>，即项目的本来大小，如设置了<code>width</code>则元素尺寸由<code>width/height</code>决定（主轴方向），没有设置则由内容决定</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当设置为 0 的是，会根据内容撑开</p>\n<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如 350px），则项目将占据固定空间</p>\n<h3> flex</h3>\n<p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>，也是比较难懂的一个复合属性</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>一些属性有：</p>\n<ul>\n<li>flex: 1 = flex: 1 1 0%</li>\n<li>flex: 2 = flex: 2 1 0%</li>\n<li>flex: auto = flex: 1 1 auto</li>\n<li>flex: none = flex: 0 0 auto，常用于固定尺寸不伸缩</li>\n</ul>\n<p><code>flex:1</code> 和 <code>flex:auto</code> 的区别，可以归结于<code>flex-basis:0</code>和<code>flex-basis:auto</code>的区别</p>\n<p>当设置为 0 时（绝对弹性元素），此时相当于告诉<code>flex-grow</code>和<code>flex-shrink</code>在伸缩的时候不需要考虑我的尺寸</p>\n<p>当设置为<code>auto</code>时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑</p>\n<p>注意：建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值</p>\n<h3> align-self</h3>\n<p>允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性</p>\n<p>默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code></p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>效果图如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6f8304a0-9838-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、应用场景</h2>\n<p>在以前的文章中，我们能够通过<code>flex</code>简单粗暴的实现元素水平垂直方向的居中，以及在两栏三栏自适应布局中通过<code>flex</code>完成，这里就不再展开代码的演示</p>\n<p>包括现在在移动端、小程序这边的开发，都建议使用<code>flex</code>进行布局</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "介绍一下 grid 网格布局",
      "url": "https://www.h7ml.cn/posts/interview/css/grid.html",
      "id": "https://www.h7ml.cn/posts/interview/css/grid.html",
      "summary": "前端物语|面试物语-介绍一下 grid 网格布局",
      "content_html": "<h1> 介绍一下 grid 网格布局</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/4d73e3d0-9a94-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>Grid</code> 布局即网格布局，是一个二维的布局方式，由纵横相交的两组网格线形成的框架性布局结构，能够同时处理行与列</p>\n<p>擅长将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/59680a40-9a94-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>这与之前讲到的<code>flex</code>一维布局不相同</p>\n<p>设置<code>display:grid/inline-grid</code>的元素就是网格布局容器，这样就能出发浏览器渲染引擎的网格布局算法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码实例中，<code>.container</code>元素就是网格布局容器，<code>.item</code>元素就是网格的项目，由于网格元素只能是容器的顶层子元素，所以<code>p</code>元素并不是网格元素</p>\n<p>这里提一下，网格线概念，有助于下面对<code>grid-column</code>系列属性的理解</p>\n<p>网格线，即划分网格的线，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/61be7080-9a94-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>上图是一个 2 x 3 的网格，共有 3 根水平网格线和 4 根垂直网格线</p>\n<h2> 二、属性</h2>\n<p>同样，<code>Grid</code> 布局属性可以分为两大类：</p>\n<ul>\n<li>容器属性，</li>\n<li>项目属性</li>\n</ul>\n<p>关于容器属性有如下：</p>\n<h3> display 属性</h3>\n<p>文章开头讲到，在元素上设置<code>display：grid</code> 或 <code>display：inline-grid</code> 来创建一个网格容器</p>\n<ul>\n<li>\n<p>display：grid 则该容器是一个块级元素</p>\n</li>\n<li>\n<p>display: inline-grid 则容器元素为行内元素</p>\n</li>\n</ul>\n<h3> grid-template-columns 属性，grid-template-rows 属性</h3>\n<p><code>grid-template-columns</code> 属性设置列宽，<code>grid-template-rows</code> 属性设置行高</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上表示固定列宽为 200px 200px 200px，行高为 50px 50px</p>\n<p>上述代码可以看到重复写单元格宽高，通过使用<code>repeat()</code>函数，可以简写重复的值</p>\n<ul>\n<li>第一个参数是重复的次数</li>\n<li>第二个参数是重复的值</li>\n</ul>\n<p>所以上述代码可以简写成</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>除了上述的<code>repeact</code>关键字，还有：</p>\n<ul>\n<li>auto-fill：示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格</li>\n</ul>\n<blockquote>\n<p><code>grid-template-columns: repeat(auto-fill, 200px)</code> 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素</p>\n</blockquote>\n<ul>\n<li>fr：片段，为了方便表示比例关系</li>\n</ul>\n<blockquote>\n<p><code>grid-template-columns: 200px 1fr 2fr</code> 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1/3 和 2/3</p>\n</blockquote>\n<ul>\n<li>minmax：产生一个长度范围，表示长度就在这个范围之中都可以应用到网格项目中。第一个参数就是最小值，第二个参数就是最大值</li>\n</ul>\n<blockquote>\n<p><code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code></p>\n</blockquote>\n<ul>\n<li>auto：由浏览器自己决定长度</li>\n</ul>\n<blockquote>\n<p><code>grid-template-columns: 100px auto 100px</code> 表示第一第三列为 100px，中间由浏览器决定长度</p>\n</blockquote>\n<h3> grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性</h3>\n<p><code>grid-row-gap</code> 属性、<code>grid-column-gap</code> 属性分别设置行间距和列间距。<code>grid-gap</code> 属性是两者的简写形式</p>\n<p><code>grid-row-gap: 10px</code> 表示行间距是 10px</p>\n<p><code>grid-column-gap: 20px</code> 表示列间距是 20px</p>\n<p><code>grid-gap: 10px 20px</code> 等同上述两个属性</p>\n<h3> grid-template-areas 属性</h3>\n<p>用于定义区域，一个区域由一个或者多个单元格组成</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码先划分出 9 个单元格，然后将其定名为<code>a</code>到<code>i</code>的九个区域，分别对应这九个单元格。</p>\n<p>多个单元格合并成一个区域的写法如下</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码将 9 个单元格分成<code>a</code>、<code>b</code>、<code>c</code>三个区域</p>\n<p>如果某些区域不需要利用，则使用\"点\"（<code>.</code>）表示</p>\n<h3> grid-auto-flow 属性</h3>\n<p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。</p>\n<p>顺序就是由<code>grid-auto-flow</code>决定，默认为行，代表\"先行后列\"，即先填满第一行，再开始放入第二行</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/70fb3240-9a94-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>当修改成<code>column</code>后，放置变为如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7c26ffa0-9a94-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> justify-items 属性， align-items 属性， place-items 属性</h3>\n<p><code>justify-items</code> 属性设置单元格内容的水平位置（左中右），<code>align-items</code> 属性设置单元格的垂直位置（上中下）</p>\n<p>两者属性的值完成相同</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>属性对应如下：</p>\n<ul>\n<li>start：对齐单元格的起始边缘</li>\n<li>end：对齐单元格的结束边缘</li>\n<li>center：单元格内部居中</li>\n<li>stretch：拉伸，占满单元格的整个宽度（默认值）</li>\n</ul>\n<p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式</p>\n<h3> justify-content 属性， align-content 属性， place-content 属性</h3>\n<p><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code>属性是整个内容区域的垂直位置（上中下）</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>两个属性的写法完全相同，都可以取下面这些值：</p>\n<ul>\n<li>start - 对齐容器的起始边框</li>\n<li>end - 对齐容器的结束边框</li>\n<li>center - 容器内部居中</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9d1ec990-9a94-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>\n<p>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍</p>\n</li>\n<li>\n<p>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔</p>\n</li>\n<li>\n<p>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔</p>\n</li>\n<li>\n<p>stretch - 项目大小没有指定时，拉伸占据整个网格容器</p>\n</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a620b210-9a94-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> grid-auto-columns 属性和 grid-auto-rows 属性</h3>\n<p>有时候，一些项目的指定位置，在现有网格的外部，就会产生显示网格和隐式网格</p>\n<p>比如网格只有 3 列，但是某一个项目指定在第 5 行。这时，浏览器会自动生成多余的网格，以便放置项目。超出的部分就是隐式网格</p>\n<p>而<code>grid-auto-rows</code>与<code>grid-auto-columns</code>就是专门用于指定隐式网格的宽高</p>\n<p>关于项目属性，有如下：</p>\n<h3> grid-column-start 属性、grid-column-end 属性、grid-row-start 属性以及 grid-row-end 属性</h3>\n<p>指定网格项目所在的四个边框，分别定位在哪根网格线，从而指定项目的位置</p>\n<ul>\n<li>grid-column-start 属性：左边框所在的垂直网格线</li>\n<li>grid-column-end 属性：右边框所在的垂直网格线</li>\n<li>grid-row-start 属性：上边框所在的水平网格线</li>\n<li>grid-row-end 属性：下边框所在的水平网格线</li>\n</ul>\n<p>举个例子：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过设置<code>grid-column</code>属性，指定 1 号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b7925530-9a94-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> grid-area 属性</h3>\n<p><code>grid-area</code> 属性指定项目放在哪一个区域</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>意思为将 1 号项目位于<code>e</code>区域</p>\n<p>与上述讲到的<code>grid-template-areas</code>搭配使用</p>\n<h3> justify-self 属性、align-self 属性以及 place-self 属性</h3>\n<p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p>\n<p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这两个属性都可以取下面四个值。</p>\n<ul>\n<li>start：对齐单元格的起始边缘。</li>\n<li>end：对齐单元格的结束边缘。</li>\n<li>center：单元格内部居中。</li>\n<li>stretch：拉伸，占满单元格的整个宽度（默认值）</li>\n</ul>\n<h2> 三、应用场景</h2>\n<p>文章开头就讲到，<code>Grid</code>是一个强大的布局，如一些常见的 CSS 布局，如居中，两列布局，三列布局等等是很容易实现的，在以前的文章中，也有使用<code>Grid</code>布局完成对应的功能</p>\n<p>关于兼容性问题，结果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c24a2b10-9a94-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>总体兼容性还不错，但在 IE 10 以下不支持</p>\n<p>目前，<code>Grid</code>布局在手机端支持还不算太友好</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></li>\n<li><a href=\"https://juejin.cn/post/6854573220306255880#heading-2\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6854573220306255880#heading-2</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "css 中，有哪些方式可以隐藏页面元素？区别?",
      "url": "https://www.h7ml.cn/posts/interview/css/hide_attributes.html",
      "id": "https://www.h7ml.cn/posts/interview/css/hide_attributes.html",
      "summary": "前端物语|面试物语-css 中，有哪些方式可以隐藏页面元素？区别?",
      "content_html": "<h1> css 中，有哪些方式可以隐藏页面元素？区别?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ccf96f50-929a-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、前言</h2>\n<p>在平常的样式排版中，我们经常遇到将某个模块隐藏的场景</p>\n<p>通过<code>css</code>隐藏元素的方法有很多种，它们看起来实现的效果是一致的</p>\n<p>但实际上每一种方法都有一丝轻微的不同，这些不同决定了在一些特定场合下使用哪一种方法</p>\n<h2> 二、实现方式</h2>\n<p>通过<code>css</code>实现隐藏元素方法有如下：</p>\n<ul>\n<li>display:none</li>\n<li>visibility:hidden</li>\n<li>opacity:0</li>\n<li>设置 height、width 模型属性为 0</li>\n<li>position:absolute</li>\n<li>clip-path</li>\n</ul>\n<h3> display:none</h3>\n<p>设置元素的<code>display</code>为<code>none</code>是最常用的隐藏元素的方法</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>将元素设置为<code>display:none</code>后，元素在页面上将彻底消失</p>\n<p>元素本身占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘</p>\n<p>消失后，自身绑定的事件不会触发，也不会有过渡效果</p>\n<p>特点：元素不可见，不占据空间，无法响应点击事件</p>\n<h3> visibility:hidden</h3>\n<p>设置元素的<code>visibility</code>为<code>hidden</code>也是一种常用的隐藏元素的方法</p>\n<p>从页面上仅仅是隐藏该元素，DOM 结果均会存在，只是当时在一个不可见的状态，不会触发重排，但是会触发重绘</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>给人的效果是隐藏了，所以他自身的事件不会触发</p>\n<p>特点：元素不可见，占据页面空间，无法响应点击事件</p>\n<h3> opacity:0</h3>\n<p><code>opacity</code>属性表示元素的透明度，将元素的透明度设置为 0 后，在我们用户眼中，元素也是隐藏的</p>\n<p>不会引发重排，一般情况下也会引发重绘</p>\n<blockquote>\n<p>如果利用 animation 动画，对 opacity 做变化（animation 会默认触发 GPU 加速），则只会触发 GPU 层面的 composite，不会触发重绘</p>\n</blockquote>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>由于其仍然是存在于页面上的，所以他自身的的事件仍然是可以触发的，但被他遮挡的元素是不能触发其事件的</p>\n<p>需要注意的是：其子元素不能设置 opacity 来达到显示的效果</p>\n<p>特点：改变元素透明度，元素不可见，占据页面空间，可以响应点击事件</p>\n<h3> 设置 height、width 属性为 0</h3>\n<p>将元素的<code>margin</code>，<code>border</code>，<code>padding</code>，<code>height</code>和<code>width</code>等影响元素盒模型的属性设置成 0，如果元素内有子元素或内容，还应该设置其<code>overflow:hidden</code>来隐藏其子元素</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>特点：元素不可见，不占据页面空间，无法响应点击事件</p>\n<h3> position:absolute</h3>\n<p>将元素移出可视区域</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>特点：元素不可见，不影响页面布局</p>\n<h3> clip-path</h3>\n<p>通过裁剪的形式</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>特点：元素不可见，占据页面空间，无法响应点击事件</p>\n<h3> 小结</h3>\n<p>最常用的还是<code>display:none</code>和<code>visibility:hidden</code>，其他的方式只能认为是奇招，它们的真正用途并不是用于隐藏元素，所以并不推荐使用它们</p>\n<h2> 三、区别</h2>\n<p>关于<code>display: none</code>、<code>visibility: hidden</code>、<code>opacity: 0</code>的区别，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">display: none</th>\n<th style=\"text-align:left\">visibility: hidden</th>\n<th>opacity: 0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">页面中</td>\n<td style=\"text-align:left\">不存在</td>\n<td style=\"text-align:left\">存在</td>\n<td>存在</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">重排</td>\n<td style=\"text-align:left\">会</td>\n<td style=\"text-align:left\">不会</td>\n<td>不会</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">重绘</td>\n<td style=\"text-align:left\">会</td>\n<td style=\"text-align:left\">会</td>\n<td>不一定</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">自身绑定事件</td>\n<td style=\"text-align:left\">不触发</td>\n<td style=\"text-align:left\">不触发</td>\n<td>可触发</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">transition</td>\n<td style=\"text-align:left\">不支持</td>\n<td style=\"text-align:left\">支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">子元素可复原</td>\n<td style=\"text-align:left\">不能</td>\n<td style=\"text-align:left\">能</td>\n<td>不能</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">被遮挡的元素可触发事件</td>\n<td style=\"text-align:left\">能</td>\n<td style=\"text-align:left\">能</td>\n<td>不能</td>\n</tr>\n</tbody>\n</table>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.cnblogs.com/a-cat/p/9039962.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/a-cat/p/9039962.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "怎么理解回流跟重绘？什么场景下会触发？",
      "url": "https://www.h7ml.cn/posts/interview/css/layout_painting.html",
      "id": "https://www.h7ml.cn/posts/interview/css/layout_painting.html",
      "summary": "前端物语|面试物语-怎么理解回流跟重绘？什么场景下会触发？",
      "content_html": "<h1> 怎么理解回流跟重绘？什么场景下会触发？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1ed5d340-9cdc-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在<code>HTML</code>中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘：</p>\n<ul>\n<li>\n<p>回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置</p>\n</li>\n<li>\n<p>重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制</p>\n</li>\n</ul>\n<p>具体的浏览器解析渲染机制如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2b56a950-9cdc-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>\n<p>解析 HTML，生成 DOM 树，解析 CSS，生成 CSSOM 树</p>\n</li>\n<li>\n<p>将 DOM 树和 CSSOM 树结合，生成渲染树(Render Tree)</p>\n</li>\n<li>\n<p>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</p>\n</li>\n<li>\n<p>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</p>\n</li>\n<li>\n<p>Display:将像素发送给 GPU，展示在页面上</p>\n</li>\n</ul>\n<p>在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变</p>\n<p>当我们对 <code>DOM</code> 的修改引发了 <code>DOM</code>几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来</p>\n<p>当我们对 <code>DOM</code>的修改导致了样式的变化（<code>color</code>或<code>background-color</code>），却并未影响其几何属性时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了重绘</p>\n<h2> 二、如何触发</h2>\n<p>要想减少回流和重绘的次数，首先要了解回流和重绘是如何触发的</p>\n<h3> 回流触发时机</h3>\n<p>回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况：</p>\n<ul>\n<li>添加或删除可见的 DOM 元素</li>\n<li>元素的位置发生变化</li>\n<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>\n<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代</li>\n<li>页面一开始渲染的时候（这避免不了）</li>\n<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>\n</ul>\n<p>还有一些容易被忽略的操作：获取一些特定属性的值</p>\n<blockquote>\n<p>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</p>\n</blockquote>\n<p>这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流</p>\n<p>除此还包括<code>getComputedStyle</code>方法，原理是一样的</p>\n<h3> 重绘触发时机</h3>\n<p>触发回流一定会触发重绘</p>\n<p>可以把页面理解为一个黑板，黑板上有一朵画好的小花。现在我们要把这朵从左边移到了右边，那我们要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜色（重绘）</p>\n<p>除此之外还有一些其他引起重绘行为：</p>\n<ul>\n<li>\n<p>颜色的修改</p>\n</li>\n<li>\n<p>文本方向的修改</p>\n</li>\n<li>\n<p>阴影的修改</p>\n</li>\n</ul>\n<h3> 浏览器优化机制</h3>\n<p>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列</p>\n<p>当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的<code>offsetTop</code>等方法都会返回最新的数据</p>\n<p>因此浏览器不得不清空队列，触发回流重绘来返回正确的值</p>\n<h2> 三、如何减少</h2>\n<p>我们了解了如何触发回流和重绘的场景，下面给出避免回流的经验：</p>\n<ul>\n<li>如果想设定元素的样式，通过改变元素的 <code>class</code> 类名 (尽可能在 DOM 树的最里层)</li>\n<li>避免设置多项内联样式</li>\n<li>应用元素的动画，使用 <code>position</code> 属性的 <code>fixed</code> 值或 <code>absolute</code> 值(如前文示例所提)</li>\n<li>避免使用 <code>table</code> 布局，<code>table</code> 中每个元素的大小以及内容的改动，都会导致整个 <code>table</code> 的重新计算</li>\n<li>对于那些复杂的动画，对其设置 <code>position: fixed/absolute</code>，尽可能地使元素脱离文档流，从而减少对其他元素的影响</li>\n<li>使用 css3 硬件加速，可以让<code>transform</code>、<code>opacity</code>、<code>filters</code>这些动画不会引起回流重绘</li>\n<li>避免使用 CSS 的 <code>JavaScript</code> 表达式</li>\n</ul>\n<p>在使用 <code>JavaScript</code> 动态插入多个节点时, 可以使用<code>DocumentFragment</code>. 创建后一次插入. 就能避免多次的渲染性能</p>\n<p>但有时候，我们会无可避免地进行回流或者重绘，我们可以更好使用它们</p>\n<p>例如，多次修改一个把元素布局的时候，我们很可能会如下操作</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>每次循环都需要获取多次<code>offset</code>属性，比较糟糕，可以使用变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们还可避免改变样式，使用类名去合并样式</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用类名去合并样式</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>前者每次单独操作，都去触发一次渲染树更改（新浏览器不会），</p>\n<p>都去触发一次渲染树更改，从而导致相应的回流与重绘过程</p>\n<p>合并之后，等于我们将所有的更改一次性发出</p>\n<p>我们还可以通过通过设置元素属性<code>display: none</code>，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>离线操作后</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li>\n<p><a href=\"https://juejin.cn/post/6844903942137053192\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903942137053192</a></p>\n</li>\n<li>\n<p><a href=\"https://segmentfault.com/a/1190000017329980\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000017329980</a></p>\n</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-07T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "让 Chrome 支持小于 12px 的文字方式有哪些？区别？",
      "url": "https://www.h7ml.cn/posts/interview/css/less_12px.html",
      "id": "https://www.h7ml.cn/posts/interview/css/less_12px.html",
      "summary": "前端物语|面试物语-让 Chrome 支持小于 12px 的文字方式有哪些？区别？",
      "content_html": "<h1> 让 Chrome 支持小于 12px 的文字方式有哪些？区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/62945fd0-a334-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、背景</h2>\n<p>Chrome 中文版浏览器会默认设定页面的最小字号是 12px，英文版没有限制</p>\n<p>原由 Chrome 团队认为汉字小于 12px 就会增加识别难度</p>\n<ul>\n<li>中文版浏览器</li>\n</ul>\n<p>与网页语言无关，取决于用户在 Chrome 的设置里（chrome://settings/languages）把哪种语言设置为默认显示语言</p>\n<ul>\n<li>系统级最小字号</li>\n</ul>\n<p>浏览器默认设定页面的最小字号，用户可以前往 chrome://settings/fonts 根据需求更改</p>\n<p>而我们在实际项目中，不能奢求用户更改浏览器设置</p>\n<p>对于文本需要以更小的字号来显示，就需要用到一些小技巧</p>\n<h2> 二、解决方案</h2>\n<p>常见的解决方案有：</p>\n<ul>\n<li>zoom</li>\n<li>-webkit-transform:scale()</li>\n<li>-webkit-text-size-adjust:none</li>\n</ul>\n<h3> Zoom</h3>\n<p><code>zoom</code> 的字面意思是“变焦”，可以改变页面上元素的尺寸，属于真实尺寸</p>\n<p>其支持的值类型有：</p>\n<ul>\n<li>zoom:50%，表示缩小到原来的一半</li>\n<li>zoom:0.5，表示缩小到原来的一半</li>\n</ul>\n<p>使用 <code>zoom</code> 来”支持“ 12px 以下的字体</p>\n<p>代码如下：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>效果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d5243980-a334-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<blockquote>\n<p>需要注意的是，<code>Zoom</code> 并不是标准属性，需要考虑其兼容性</p>\n</blockquote>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3defe3c0-a343-11eb-85f6-6fac77c0c9b3.png\" alt=\"image.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>image.png</figcaption></figure>\n<h3> -webkit-transform:scale()</h3>\n<p>针对<code>chrome</code>浏览器,加<code>webkit</code>前缀，用<code>transform:scale()</code>这个属性进行放缩</p>\n<p>注意的是，使用<code>scale</code>属性只对可以定义宽高的元素生效，所以，下面代码中将<code>span</code>元素转为行内块元素</p>\n<p>实现代码如下：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>效果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d5243980-a334-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> -webkit-text-size-adjust:none</h3>\n<p>该属性用来设定文字大小是否根据设备(浏览器)来自动调整显示大小</p>\n<p>属性值：</p>\n<ul>\n<li>percentage：字体显示的大小；</li>\n<li>auto：默认，字体大小会根据设备/浏览器来自动调整；</li>\n<li>none:字体大小不会自动调整</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样设置之后会有一个问题，就是当你放大网页时，一般情况下字体也会随着变大，而设置了以上代码后，字体只会显示你当前设置的字体大小，不会随着网页放大而变大了</p>\n<p>所以，我们不建议全局应用该属性，而是单独对某一属性使用</p>\n<blockquote>\n<p>需要注意的是，自从<code>chrome 27</code>之后，就取消了对这个属性的支持。同时，该属性只对英文、数字生效，对中文不生效</p>\n</blockquote>\n<h2> 三、总结</h2>\n<p><code>Zoom</code> 非标属性，有兼容问题，缩放会改变了元素占据的空间大小，触发重排</p>\n<p><code>-webkit-transform:scale()</code> 大部分现代浏览器支持，并且对英文、数字、中文也能够生效，缩放不会改变了元素占据的空间大小，页面布局不会发生变化</p>\n<p><code>-webkit-text-size-adjust</code>对谷歌浏览器有版本要求，在 27 之后，就取消了该属性的支持，并且只对英文、数字生效</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-size-adjust\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-size-adjust</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-11T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "什么是响应式设计？响应式设计的基本原理是什么？如何做？",
      "url": "https://www.h7ml.cn/posts/interview/css/responsive_layout.html",
      "id": "https://www.h7ml.cn/posts/interview/css/responsive_layout.html",
      "summary": "前端物语|面试物语-什么是响应式设计？响应式设计的基本原理是什么？如何做？",
      "content_html": "<h1> 什么是响应式设计？响应式设计的基本原理是什么？如何做？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a57e2e40-9dba-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>响应式网站设计（Responsive Web design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整</p>\n<p>描述响应式界面最著名的一句话就是“Content is like water”</p>\n<p>大白话便是“如果将屏幕看作容器，那么内容就像水一样”</p>\n<p>响应式网站常见特点：</p>\n<ul>\n<li>\n<p>同时适配 PC + 平板 + 手机等</p>\n</li>\n<li>\n<p>标签导航在接近手持终端设备时改变为经典的抽屉式导航</p>\n</li>\n<li>\n<p>网站的布局会根据视口来调整模块的大小和位置</p>\n</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ae68be30-9dba-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、实现方式</h2>\n<p>响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有<code>meta</code>声明<code>viewport</code></p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>属性对应如下：</p>\n<ul>\n<li>\n<p>width=device-width: 是自适应手机屏幕的尺寸宽度</p>\n</li>\n<li>\n<p>maximum-scale:是缩放比例的最大值</p>\n</li>\n<li>\n<p>inital-scale:是缩放的初始化</p>\n</li>\n<li>\n<p>user-scalable:是用户的可以缩放的操作</p>\n</li>\n</ul>\n<p>实现响应式布局的方式有如下：</p>\n<ul>\n<li>媒体查询</li>\n<li>百分比</li>\n<li>vw/vh</li>\n<li>rem</li>\n</ul>\n<h3> 媒体查询</h3>\n<p><code>CSS3</code>中的增加了更多的媒体查询，就像<code>if</code>条件表达式一样，我们可以设置不同类型的媒体条件，并根据对应的条件，给相应符合条件的媒体调用相对应的样式表</p>\n<p>使用<code>@Media</code>查询，可以针对不同的媒体类型定义不同的样式，如：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当视口在 375px - 600px 之间，设置特定字体大小 18px</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局，比如我们为不同分辨率的屏幕，设置不同的背景图片</p>\n<p>比如给小屏幕手机设置@2x 图，为大屏幕手机设置@3x 图，通过媒体查询就能很方便的实现</p>\n<h3> 百分比</h3>\n<p>通过百分比单位 \" % \" 来实现响应式的效果</p>\n<p>比如当浏览器的宽度或者高度发生变化时，通过百分比单位，可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果</p>\n<p><code>height</code>、<code>width</code>属性的百分比依托于父标签的宽高，但是其他盒子属性则不完全依赖父元素：</p>\n<ul>\n<li>\n<p>子元素的 top/left 和 bottom/right 如果设置百分比，则相对于直接非 static 定位(默认定位)的父元素的高度/宽度</p>\n</li>\n<li>\n<p>子元素的 padding 如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的 width，而与父元素的 height 无关。</p>\n</li>\n<li>\n<p>子元素的 margin 如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的 width</p>\n</li>\n<li>\n<p>border-radius 不一样，如果设置 border-radius 为百分比，则是相对于自身的宽度</p>\n</li>\n</ul>\n<p>可以看到每个属性都使用百分比，会照成布局的复杂度，所以不建议使用百分比来实现响应式</p>\n<h3> vw/vh</h3>\n<p><code>vw</code>表示相对于视图窗口的宽度，<code>vh</code>表示相对于视图窗口高度。 任意层级元素，在使用<code>vw</code>单位的情况下，<code>1vw</code>都等于视图宽度的百分之一</p>\n<p>与百分比布局很相似，在以前文章提过与<code>%</code>的区别，这里就不再展开述说</p>\n<h3> rem</h3>\n<p>在以前也讲到，<code>rem</code>是相对于根元素<code>html</code>的<code>font-size</code>属性，默认情况下浏览器字体大小为<code>16px</code>，此时<code>1rem = 16px</code></p>\n<p>可以利用前面提到的媒体查询，针对不同设备分辨率改变<code>font-size</code>的值，如下：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为了更准确监听设备可视窗口变化，我们可以在<code>css</code>之前插入<code>script</code>标签，内容如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>无论设备可视窗口如何变化，始终设置<code>rem</code>为<code>width</code>的 1/10，实现了百分比布局</p>\n<p>除此之外，我们还可以利用主流<code>UI</code>框架，如：<code>element ui</code>、<code>antd</code>提供的栅格布局实现响应式</p>\n<h3> 小结</h3>\n<p>响应式设计实现通常会从以下几方面思考：</p>\n<ul>\n<li>弹性盒子（包括图片、表格、视频）和媒体查询等技术</li>\n<li>使用百分比布局创建流式布局的弹性 UI，同时使用媒体查询限制元素的尺寸和内容变更范围</li>\n<li>使用相对单位使得内容自适应调节</li>\n<li>选择断点，针对不同断点实现不同布局和内容展示</li>\n</ul>\n<h2> 三、总结</h2>\n<p>响应式布局优点可以看到：</p>\n<ul>\n<li>面对不同分辨率设备灵活性强</li>\n<li>能够快捷解决多设备显示适应问题</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>仅适用布局、信息、框架并不复杂的部门类型网站</li>\n<li>兼容各种设备工作量大，效率低下</li>\n<li>代码累赘，会出现隐藏无用的元素，加载时间加长</li>\n<li>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</li>\n<li>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/响应式网页设计</a></li>\n<li><a href=\"https://juejin.cn/post/6844904082751111176\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904082751111176</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-02T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "说说对 Css 预编语言的理解？有哪些区别?",
      "url": "https://www.h7ml.cn/posts/interview/css/sass_less_stylus.html",
      "id": "https://www.h7ml.cn/posts/interview/css/sass_less_stylus.html",
      "summary": "前端物语|面试物语-说说对 Css 预编语言的理解？有哪些区别?",
      "content_html": "<h1> 说说对 Css 预编语言的理解？有哪些区别?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/81cca1c0-a42c-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>Css</code> 作为一门标记性语言，语法相对简单，对使用者的要求较低，但同时也带来一些问题</p>\n<p>需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用，尤其对于非前端开发工程师来讲，往往会因为缺少 <code>Css</code> 编写经验而很难写出组织良好且易于维护的 <code>Css</code> 代码</p>\n<p><code>Css</code>预处理器便是针对上述问题的解决方案</p>\n<h4> 预处理语言</h4>\n<p>扩充了 <code>Css</code> 语言，增加了诸如变量、混合（mixin）、函数等功能，让 <code>Css</code> 更易维护、方便</p>\n<p>本质上，预处理是<code>Css</code>的超集</p>\n<p>包含一套自定义的语法及一个解析器，根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 <code>Css</code> 文件</p>\n<h2> 二、有哪些</h2>\n<p><code>Css</code>预编译语言在前端里面有三大优秀的预编处理器，分别是：</p>\n<ul>\n<li>sass</li>\n<li>less</li>\n<li>stylus</li>\n</ul>\n<h3> sass</h3>\n<p>2007 年诞生，最早也是最成熟的 <code>Css</code>预处理器，拥有 Ruby 社区的支持和 <code>Compass</code> 这一最强大的 <code>Css</code>框架，目前受 <code>LESS</code> 影响，已经进化到了全面兼容 <code>Css</code> 的 <code>Scss</code></p>\n<p>文件后缀名为<code>.sass</code>与<code>scss</code>，可以严格按照 sass 的缩进方式省去大括号和分号</p>\n<h3> less</h3>\n<p>2009 年出现，受<code>SASS</code>的影响较大，但又使用 <code>Css</code> 的语法，让大部分开发者和设计师更容易上手，在 <code>Ruby</code>社区之外支持者远超过 <code>SASS</code></p>\n<p>其缺点是比起 <code>SASS</code>来，可编程功能不够，不过优点是简单和兼容 <code>Css</code>，反过来也影响了 <code>SASS</code>演变到了<code>Scss</code> 的时代</p>\n<h3> stylus</h3>\n<p><code>Stylus</code>是一个<code>Css</code>的预处理框架，2010 年产生，来自 <code>Node.js</code>社区，主要用来给 <code>Node</code> 项目进行 <code>Css</code> 预处理支持</p>\n<p>所以<code>Stylus</code> 是一种新型语言，可以创建健壮的、动态的、富有表现力的<code>Css</code>。比较年轻，其本质上做的事情与<code>SASS/LESS</code>等类似</p>\n<h2> 三、区别</h2>\n<p>虽然各种预处理器功能强大，但使用最多的，还是以下特性：</p>\n<ul>\n<li>变量（variables）</li>\n<li>作用域（scope）</li>\n<li>代码混合（ mixins）</li>\n<li>嵌套（nested rules）</li>\n<li>代码模块化（Modules）</li>\n</ul>\n<p>因此，下面就展开这些方面的区别</p>\n<h3> 基本使用</h3>\n<p>less 和 scss</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>sass</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>stylus</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 嵌套</h3>\n<p>三者的嵌套语法都是一致的，甚至连引用父级选择器的标记 &amp; 也相同</p>\n<p>区别只是 Sass 和 Stylus 可以用没有大括号的方式书写</p>\n<p>less</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 变量</h3>\n<p>变量无疑为 Css 增加了一种有效的复用方式，减少了原来在 Css 中无法避免的重复「硬编码」</p>\n<p><code>less</code>声明的变量必须以<code>@</code>开头，后面紧跟变量名和变量值，而且变量名和变量值需要使用冒号<code>:</code>分隔开</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>sass</code>声明的变量跟<code>less</code>十分的相似，只是变量名前面使用<code>@</code>开头</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>stylus</code>声明的变量没有任何的限定，可以使用<code>$</code>开头，结尾的分号<code>;</code>可有可无，但变量与变量值之间需要使用<code>=</code></p>\n<p>在<code>stylus</code>中我们不建议使用<code>@</code>符号开头声明变量</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 作用域</h3>\n<p><code>Css</code> 预编译器把变量赋予作用域，也就是存在生命周期。就像 <code>js</code>一样，它会先从局部作用域查找变量，依次向上级作用域查找</p>\n<p><code>sass</code>中不存在全局变量</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>编译后</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>所以，在<code>sass</code>中最好不要定义相同的变量名</p>\n<p><code>less</code>与<code>stylus</code>的作用域跟<code>javascript</code>十分的相似，首先会查找局部定义的变量，如果没有找到，会像冒泡一样，一级一级往下查找，直到根为止</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>编译后：</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 混入</h3>\n<p>混入（mixin）应该说是预处理器最精髓的功能之一了，简单点来说，<code>Mixins</code>可以将一部分样式抽出，作为单独定义的模块，被很多选择器重复使用</p>\n<p>可以在<code>Mixins</code>中定义变量或者默认参数</p>\n<p>在<code>less</code>中，混合的用法是指将定义好的<code>ClassA</code>中引入另一个已经定义的<code>Class</code>，也能使用够传递参数，参数变量为<code>@</code>声明</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>编译后</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Sass</code>声明<code>mixins</code>时需要使用<code>@mixinn</code>，后面紧跟<code>mixin</code>的名，也可以设置参数，参数名为变量<code>$</code>声明的形式</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>stylus</code>中的混合和前两款<code>Css</code>预处理器语言的混合略有不同，他可以不使用任何符号，就是直接声明<code>Mixins</code>名，然后在定义参数和默认值之间用等号（=）来连接</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 代码模块化</h3>\n<p>模块化就是将<code>Css</code>代码分成一个个模块</p>\n<p><code>scss</code>、<code>less</code>、<code>stylus</code>三者的使用方法都如下所示</p>\n<div class=\"language-Css line-numbers-mode\" data-ext=\"Css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://jelly.jd.com/article/5dcb9c73641a030153732a89\" target=\"_blank\" rel=\"noopener noreferrer\">https://jelly.jd.com/article/5dcb9c73641a030153732a89</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/23382462\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/23382462</a></li>\n<li><a href=\"https://baike.baidu.com/item/Less/17570158\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/Less/17570158</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-11T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "如何实现单行／多行文本溢出的省略样式？",
      "url": "https://www.h7ml.cn/posts/interview/css/single_multi_line.html",
      "id": "https://www.h7ml.cn/posts/interview/css/single_multi_line.html",
      "summary": "前端物语|面试物语-如何实现单行／多行文本溢出的省略样式？",
      "content_html": "<h1> 如何实现单行／多行文本溢出的省略样式？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ada8d840-a0e9-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、前言</h2>\n<p>在日常开发展示页面，如果一段文本的数量过长，受制于元素宽度的因素，有可能不能完全显示，为了提高用户的使用体验，这个时候就需要我们把溢出的文本显示成省略号</p>\n<p>对于文本的溢出，我们可以分成两种形式：</p>\n<ul>\n<li>单行文本溢出</li>\n<li>多行文本溢出</li>\n</ul>\n<h2> 二、实现方式</h2>\n<h3> 单行文本溢出省略</h3>\n<p>理解也很简单，即文本在一行内显示，超出部分以省略号的形式展现</p>\n<p>实现方式也很简单，涉及的<code>css</code>属性有：</p>\n<ul>\n<li>text-overflow：规定当文本溢出时，显示省略符号来代表被修剪的文本</li>\n<li>white-space：设置文字在一行显示，不能换行</li>\n<li>overflow：文字长度超出限定宽度，则隐藏超出的内容</li>\n</ul>\n<p><code>overflow</code>设为<code>hidden</code>，普通情况用在块级元素的外层隐藏内部溢出元素，或者配合下面两个属性实现文本溢出省略</p>\n<p><code>white-space:nowrap</code>，作用是设置文本不换行，是<code>overflow:hidden</code>和<code>text-overflow：ellipsis</code>生效的基础</p>\n<p><code>text-overflow</code>属性值有如下：</p>\n<ul>\n<li>clip：当对象内文本溢出部分裁切掉</li>\n<li>ellipsis：当对象内文本溢出时显示省略标记（...）</li>\n</ul>\n<p><code>text-overflow</code>只有在设置了<code>overflow:hidden</code>和<code>white-space:nowrap</code>才能够生效的</p>\n<p>举个例子</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>效果如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bb3048e0-a0e9-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>可以看到，设置单行文本溢出较为简单，并且省略号显示的位置较好</p>\n<h3> 多行文本溢出省略</h3>\n<p>多行文本溢出的时候，我们可以分为两种情况：</p>\n<ul>\n<li>基于高度截断</li>\n<li>基于行数截断</li>\n</ul>\n<h4> 基于高度截断</h4>\n<h4> 伪元素 + 定位</h4>\n<p>核心的<code>css</code>代码结构如下：</p>\n<ul>\n<li>position: relative：为伪元素绝对定位</li>\n<li>overflow: hidden：文本溢出限定的宽度就隐藏内容）</li>\n<li>position: absolute：给省略号绝对定位</li>\n<li>line-height: 20px：结合元素高度,高度固定的情况下,设定行高, 控制显示行数</li>\n<li>height: 40px：设定当前元素高度</li>\n<li>::after {} ：设置省略号样式</li>\n</ul>\n<p>代码如下所示：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实现原理很好理解，就是通过伪元素绝对定位到行尾并遮住文字，再通过 <code>overflow: hidden</code> 隐藏多余文字</p>\n<p>这种实现具有以下优点：</p>\n<ul>\n<li>兼容性好，对各大主流浏览器有好的支持</li>\n<li>响应式截断，根据不同宽度做出调整</li>\n</ul>\n<p>一般文本存在英文的时候，可以设置<code>word-break: break-all</code>使一个单词能够在换行时进行拆分</p>\n<h4> 基于行数截断</h4>\n<p>纯<code>css</code>实现也非常简单，核心的<code>css</code>代码如下：</p>\n<ul>\n<li>-webkit-line-clamp: 2：用来限制在一个块元素显示的文本的行数，为了实现该效果，它需要组合其他的 WebKit 属性）</li>\n<li>display: -webkit-box：和 1 结合使用，将对象作为弹性伸缩盒子模型显示</li>\n<li>-webkit-box-orient: vertical：和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式</li>\n<li>overflow: hidden：文本溢出限定的宽度就隐藏内容</li>\n<li>text-overflow: ellipsis：多行文本的情况下，用省略号“…”隐藏溢出范围的文本</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，上述使用了<code>webkit</code>的<code>CSS</code>属性扩展，所以兼容浏览器范围是<code>PC</code>端的<code>webkit</code>内核的浏览器，由于移动端大多数是使用<code>webkit</code>，所以移动端常用该形式</p>\n<p>需要注意的是，如果文本为一段很长的英文或者数字，则需要添加<code>word-wrap: break-word</code>属性</p>\n<p>还能通过使用<code>javascript</code>实现配合<code>css</code>，实现代码如下所示：</p>\n<p>css 结构如下：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>javascript 代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li>\n<p><a href=\"https://www.zoo.team/article/text-overflow\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zoo.team/article/text-overflow</a></p>\n</li>\n<li>\n<p><a href=\"https://segmentfault.com/a/1190000017078153\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000017078153</a></p>\n</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-08T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "CSS 如何画一个三角形？原理是什么？",
      "url": "https://www.h7ml.cn/posts/interview/css/triangle.html",
      "id": "https://www.h7ml.cn/posts/interview/css/triangle.html",
      "summary": "前端物语|面试物语-CSS 如何画一个三角形？原理是什么？",
      "content_html": "<h1> CSS 如何画一个三角形？原理是什么？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bd310120-a279-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、前言</h2>\n<p>在前端开发的时候，我们有时候会需要用到一个三角形的形状，比如地址选择或者播放器里面播放按钮</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d6d8ff60-a279-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>通常情况下，我们会使用图片或者<code>svg</code>去完成三角形效果图，但如果单纯使用<code>css</code>如何完成一个三角形呢？</p>\n<p>实现过程似乎也并不困难，通过边框就可完成</p>\n<h2> 二、实现过程</h2>\n<p>在以前也讲过盒子模型，默认情况下是一个矩形，实现也很简单</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>效果如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e3f244e0-a279-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>将<code>border</code>设置<code>50px</code>，效果图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ee0b42b0-a279-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>白色区域则为<code>width</code>、<code>height</code>，这时候只需要你将白色区域部分宽高逐渐变小，最终变为 0，则变成如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2afaa030-a27a-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>这时候就已经能够看到 4 个不同颜色的三角形，如果需要下方三角形，只需要将上、左、右边框设置为 0 就可以得到下方的红色三角形</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2afaa030-a27a-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>但这种方式，虽然视觉上是实现了三角形，但实际上，隐藏的部分任然占据部分高度，需要将上方的宽度去掉</p>\n<p>最终实现代码如下：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果想要实现一个只有边框是空心的三角形，由于这里不能再使用<code>border</code>属性，所以最直接的方法是利用伪类新建一个小一点的三角形定位上去</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>效果图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/59f4d720-a27a-11eb-85f6-6fac77c0c9b3.png\" alt=\"i\" tabindex=\"0\" loading=\"lazy\"><figcaption>i</figcaption></figure>\n<p>伪类元素定位参照对象的内容区域宽高都为 0，则内容区域即可以理解成中心一点，所以伪元素相对中心这点定位</p>\n<p>将元素定位进行微调以及改变颜色，就能够完成下方效果图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/653a6e10-a27a-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>最终代码如下：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、原理分析</h2>\n<p>可以看到，边框是实现三角形的部分，边框实际上并不是一个直线，如果我们将四条边设置不同的颜色，将边框逐渐放大，可以得到每条边框都是一个梯形</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/78d4bd90-a27a-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>当分别取消边框的时候，发现下面几种情况：</p>\n<ul>\n<li>取消一条边的时候，与这条边相邻的两条边的接触部分会变成直的</li>\n<li>当仅有邻边时， 两个边会变成对分的三角</li>\n<li>当保留边没有其他接触时，极限情况所有东西都会消失</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/84586ef0-a27a-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>通过上图的变化规则，利用旋转、隐藏，以及设置内容宽高等属性，就能够实现其他类型的三角形</p>\n<p>如设置直角三角形，如上图倒数第三行实现过程，我们就能知道整个实现原理</p>\n<p>实现代码如下：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.cnblogs.com/echolun/p/11888612.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/echolun/p/11888612.html</a></li>\n<li><a href=\"https://juejin.cn/post/6844903567795421197\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903567795421197</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "如何使用 css 完成视差滚动效果?",
      "url": "https://www.h7ml.cn/posts/interview/css/visual_scrolling.html",
      "id": "https://www.h7ml.cn/posts/interview/css/visual_scrolling.html",
      "summary": "前端物语|面试物语-如何使用 css 完成视差滚动效果?",
      "content_html": "<h1> 如何使用 css 完成视差滚动效果?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1b2d33e0-a18d-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>视差滚动（Parallax Scrolling）是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验</p>\n<p>我们可以把网页解刨成：背景层、内容层、悬浮层</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/57c942a0-a1cc-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>当滚动鼠标滑轮的时候，各个图层以不同的速度移动，形成视觉差的效果</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e57ab280-a1dd-11eb-ab90-d9ae814b240d.png\" alt=\"image.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>image.png</figcaption></figure>\n<h2> 二、实现方式</h2>\n<p>使用<code>css</code>形式实现视觉差滚动效果的方式有：</p>\n<ul>\n<li>background-attachment</li>\n<li>transform:translate3D</li>\n</ul>\n<h3> background-attachment</h3>\n<p>作用是设置背景图像是否固定或者随着页面的其余部分滚动</p>\n<p>值分别有如下：</p>\n<ul>\n<li>scroll：默认值，背景图像会随着页面其余部分的滚动而移动</li>\n<li>fixed：当页面的其余部分滚动时，背景图像不会移动</li>\n<li>inherit：继承父元素 background-attachment 属性的值</li>\n</ul>\n<p>完成滚动视觉差就需要将<code>background-attachment</code>属性设置为<code>fixed</code>，让背景相对于视口固定。及时一个元素有滚动机制，背景也不会随着元素的内容而滚动</p>\n<p>也就是说，背景一开始就已经被固定在初始的位置</p>\n<p>核心的<code>css</code>代码如下：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>整体例子如下：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> transform:translate3D</h3>\n<p>同样，让我们先来看一下两个概念<code>transform</code>和<code>perspective</code>：</p>\n<ul>\n<li>transform: css3 属性，可以对元素进行变换(2d/3d)，包括平移 translate,旋转 rotate,缩放 scale,等等</li>\n<li>perspective: css3 属性，当元素涉及 3d 变换时，perspective 可以定义我们眼睛看到的 3d 立体效果，即空间感</li>\n</ul>\n<p><code>3D</code>视角示意图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/24f37dd0-a18d-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>举个例子：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>而这种方式实现视觉差动的原理如下：</p>\n<ul>\n<li>\n<p>容器设置上 transform-style: preserve-3d 和 perspective: xpx，那么处于这个容器的子元素就将位于 3D 空间中，</p>\n</li>\n<li>\n<p>子元素设置不同的 transform: translateZ()，这个时候，不同元素在 3D Z 轴方向距离屏幕（我们的眼睛）的距离也就不一样</p>\n</li>\n<li>\n<p>滚动滚动条，由于子元素设置了不同的 transform: translateZ()，那么他们滚动的上下距离 translateY 相对屏幕（我们的眼睛），也是不一样的，这就达到了滚动视差的效果</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://imweb.io/topic/5b73ef73a56e07401e48729d\" target=\"_blank\" rel=\"noopener noreferrer\">https://imweb.io/topic/5b73ef73a56e07401e48729d</a></li>\n<li><a href=\"https://juejin.cn/post/6844903654458146823#heading-5\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903654458146823#heading-5</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-11T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "说说你对工厂模式的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/design/Factory_Pattern.html",
      "id": "https://www.h7ml.cn/posts/interview/design/Factory_Pattern.html",
      "summary": "前端物语|面试物语-说说你对工厂模式的理解？应用场景？",
      "content_html": "<h1> 说说你对工厂模式的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/27a84d10-3bea-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>工厂模式是用来创建对象的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂</p>\n<p>其就像工厂一样重复的产生类似的产品，工厂模式只需要我们传入正确的参数，就能生产类似的产品</p>\n<p>举个例子：</p>\n<ul>\n<li>编程中，在一个 A 类中通过 new 的方式实例化了类 B，那么 A 类和 B 类之间就存在关联（耦合）</li>\n<li>后期因为需要修改了 B 类的代码和使用方式，比如构造函数中传入参数，那么 A 类也要跟着修改，一个类的依赖可能影响不大，但若有多个类依赖了 B 类，那么这个工作量将会相当的大，容易出现修改错误，也会产生很多的重复代码，这无疑是件非常痛苦的事；</li>\n<li>这种情况下，就需要将创建实例的工作从调用方（A 类）中分离，与调用方<strong>解耦</strong>，也就是使用工厂方法创建实例的工作封装起来（<strong>减少代码重复</strong>），由工厂管理对象的创建逻辑，调用方不需要知道具体的创建过程，只管使用，<strong>而降低调用者因为创建逻辑导致的错误</strong>；</li>\n</ul>\n<h2> 二、实现</h2>\n<p>工厂模式根据抽象程度的不同可以分为：</p>\n<ul>\n<li>简单工厂模式（Simple Factory）</li>\n<li>工厂方法模式（Factory Method）</li>\n<li>抽象工厂模式（Abstract Factory）</li>\n</ul>\n<h3> 简单工厂模式</h3>\n<p>简单工厂模式也叫静态工厂模式，用一个工厂对象创建同一类对象类的实例</p>\n<p>假设我们要开发一个公司岗位及其工作内容的录入信息，不同岗位的工作内容不一致</p>\n<p>代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Factory</code>就是一个简单工厂。当我们调用工厂函数时，只需要传递 name、age、career 就可以获取到包含用户工作内容的实例对象</p>\n<h3> 工厂方法模式</h3>\n<p>工厂方法模式跟简单工厂模式差不多，但是把具体的产品放到了工厂函数的<code>prototype</code>中</p>\n<p>这样一来，扩展产品种类就不必修改工厂函数了，和心累就变成抽象类，也可以随时重写某种具体的产品</p>\n<p>也就是相当于工厂总部不生产产品了，交给下辖分工厂进行生产；但是进入工厂之前，需要有个判断来验证你要生产的东西是否是属于我们工厂所生产范围，如果是，就丢给下辖工厂来进行生产</p>\n<p>如下代码：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>工厂方法关键核心代码是工厂里面的判断 this 是否属于工厂，也就是做了分支判断，这个工厂只做我能做的产品</p>\n<h3> 抽象工厂模式</h3>\n<p>上述简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建</p>\n<p>通俗点来讲就是：简单工厂和工厂方法模式的工作是生产产品，那么抽象工厂模式的工作就是生产工厂的</p>\n<p>由于<code>JavaScript</code>中并没有抽象类的概念，只能模拟，可以分成四部分：</p>\n<ul>\n<li>用于创建抽象类的函数</li>\n<li>抽象类</li>\n<li>具体类</li>\n<li>实例化具体类</li>\n</ul>\n<p>上面的例子中有<code>coder</code>、<code>hr</code>、<code>boss</code>、<code>driver</code>四种岗位，其中<code>coder</code>可能使用不同的开发语言进行开发，比如<code>JavaScript</code>、<code>Java</code>等等。那么这两种语言就是对应的类簇</p>\n<p>示例代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面代码中<code>CareerAbstractFactory</code>就是一个抽象工厂方法，该方法在参数中传递子类和父类，在方法体内部实现了子类对父类的继承</p>\n<h2> 三、应用场景</h2>\n<p>从上面可看到，简单简单工厂的优点就是我们只要传递正确的参数，就能获得所需的对象，而不需要关心其创建的具体细节</p>\n<p>应用场景也容易识别，有构造函数的地方，就应该考虑简单工厂，但是如果函数构建函数太多与复杂，会导致工厂函数变得复杂，所以不适合复杂的情况</p>\n<p>抽象工厂模式一般用于严格要求以面向对象思想进行开发的超大型项目中，我们一般常规的开发的话一般就是简单工厂和工厂方法模式会用的比较多一些</p>\n<p>综上，工厂模式适用场景如下：</p>\n<ul>\n<li>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li>\n<li>将 new 操作简单封装，遇到 new 的时候就应该考虑是否用工厂模式；</li>\n<li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.runoob.com/design-pattern/factory-pattern.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.runoob.com/design-pattern/factory-pattern.html</a></li>\n<li><a href=\"https://juejin.cn/post/6844903653774458888\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903653774458888</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/344119981\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/344119981</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-10T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "design"
      ]
    },
    {
      "title": "说说你对发布订阅、观察者模式的理解？区别？",
      "url": "https://www.h7ml.cn/posts/interview/design/Observer_Pattern.html",
      "id": "https://www.h7ml.cn/posts/interview/design/Observer_Pattern.html",
      "summary": "前端物语|面试物语-说说你对发布订阅、观察者模式的理解？区别？",
      "content_html": "<h1> 说说你对发布订阅、观察者模式的理解？区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/342739f0-3fb1-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、观察者模式</h2>\n<p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新</p>\n<p>观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d3a80020-3f7c-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>例如生活中，我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸</p>\n<p>报社和订报纸的客户就形成了一对多的依赖关系</p>\n<p>实现代码如下：</p>\n<p>被观察者模式</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>观察者：</p>\n<div class=\"language-h' line-numbers-mode\" data-ext=\"h'\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码中，观察者主动申请加入被观察者的列表，被观察者主动将观察者加入列表</p>\n<h2> 二、发布订阅模式</h2>\n<p>发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在</p>\n<p>同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e24d3cd0-3f7c-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>实现代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>发布者代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>订阅者代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码，发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责</p>\n<h2> 三、区别</h2>\n<p>两种设计模式思路是一样的，举个生活例子：</p>\n<ul>\n<li>观察者模式：某公司给自己员工发月饼发粽子，是由公司的行政部门发送的，这件事不适合交给第三方，原因是“公司”和“员工”是一个整体</li>\n<li>发布-订阅模式：某公司要给其他人发各种快递，因为“公司”和“其他人”是独立的，其唯一的桥梁是“快递”，所以这件事适合交给第三方快递公司解决</li>\n</ul>\n<p>上述过程中，如果公司自己去管理快递的配送，那公司就会变成一个快递公司，业务繁杂难以管理，影响公司自身的主营业务，因此使用何种模式需要考虑什么情况两者是需要耦合的</p>\n<p>两者区别如下图：</p>\n<figure><img src=\"https://files.mdnice.com/user/155/9141682c-7386-4f12-8412-fb17a1cd4bf6.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>\n<p>在观察者模式中，观察者是知道 Subject 的，Subject 一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</p>\n</li>\n<li>\n<p>在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。</p>\n</li>\n<li>\n<p>观察者模式大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/zh-hans/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/zh-hans/观察者模式</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/发布/订阅</a></li>\n<li><a href=\"https://www.cnblogs.com/onepixel/p/10806891.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/onepixel/p/10806891.html</a></li>\n<li><a href=\"https://juejin.cn/post/6978728619782701087\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6978728619782701087</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-23T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "design"
      ]
    },
    {
      "title": "说说你对代理模式的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/design/Proxy_Pattern.html",
      "id": "https://www.h7ml.cn/posts/interview/design/Proxy_Pattern.html",
      "summary": "前端物语|面试物语-说说你对代理模式的理解？应用场景？",
      "content_html": "<h1> 说说你对代理模式的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/899a6ef0-3d6a-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>代理模式（Proxy Pattern）是为一个对象提供一个代用品或占位符，以便控制对它的访问</p>\n<p>代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要时，提供一个替身对象来控制这个对象的访问，客户实际上访问的是替身对象</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/951c99b0-3d6a-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在生活中，代理模式的场景是十分常见的，例如我们现在如果有租房、买房的需求，更多的是去找链家等房屋中介机构，而不是直接寻找想卖房或出租房的人谈。此时，链家起到的作用就是代理的作用</p>\n<h2> 二、使用</h2>\n<p>在<code>ES6</code>中，存在<code>proxy</code>构建函数能够让我们轻松使用代理模式：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>关于<code>Proxy</code>的使用可以翻看以前的文章</p>\n<p>而按照功能来划分，<code>javascript</code>代理模式常用的有：</p>\n<ul>\n<li>\n<p>缓存代理</p>\n</li>\n<li>\n<p>虚拟代理</p>\n</li>\n</ul>\n<h3> 缓存代理</h3>\n<p>缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果</p>\n<p>如实现一个求积乘的函数，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>现在加入缓存代理，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当第二次调用 <code>proxyMult(1, 2, 3, 4)</code> 时，本体 <code>mult</code> 函数并没有被计算，<code>proxyMult</code> 直接返回了之前缓存好的计算结果</p>\n<h3> 虚拟代理</h3>\n<p>虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建</p>\n<p>常见的就是图片预加载功能：</p>\n<p>未使用代理模式如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>MyImage</code>对象除了负责给<code>img</code>节点设置<code>src</code>外，还要负责预加载图片，违反了面向对象设计的原则——单一职责原则</p>\n<p>上述过程<code>loding</code>则是耦合进<code>MyImage</code>对象里的，如果以后某个时候，我们不需要预加载显示 loading 这个功能了，就只能在<code>MyImage</code>对象里面改动代码</p>\n<p>使用代理模式，代码则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用代理模式后，图片本地对象负责往页面中创建一个<code>img</code>标签，并且提供一个对外的<code>setSrc</code>接口；</p>\n<p>代理对象负责在图片未加载完成之前，引入预加载的<code>loading</code>图，负责了图片预加载的功能</p>\n<p>上述并没有改变或者增加<code>MyImage</code>的接口，但是通过代理对象，实际上给系统添加了新的行为</p>\n<p>并且上述代理模式可以发现，代理和本体接口的一致性，如果有一天不需要预加载，那么就不需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了 <code>setSrc</code> 方法</p>\n<p>‘</p>\n<h2> 三、应用场景</h2>\n<p>现在的很多前端框架或者状态管理框架都使用代理模式，用与监听变量的变化</p>\n<p>使用代理模式代理对象的访问的方式，一般又被称为拦截器，比如我们在项目中经常使用 <code>Axios</code> 的实例来进行 HTTP 的请求，使用拦截器 <code>interceptor</code> 可以提前对 请求前的数据 服务器返回的数据进行一些预处理</p>\n<p>以及上述应用到的缓存代理和虚拟代理</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844903555036364814#heading-2\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903555036364814#heading-2</a></li>\n<li><a href=\"https://juejin.cn/post/6992510837403418654#heading-7\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6992510837403418654#heading-7</a></li>\n<li><a href=\"https://sothx.com/2021/06/26/proxy/\" target=\"_blank\" rel=\"noopener noreferrer\">https://sothx.com/2021/06/26/proxy/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-22T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "design"
      ]
    },
    {
      "title": "前端物语|面试物语-design",
      "url": "https://www.h7ml.cn/posts/interview/design/",
      "id": "https://www.h7ml.cn/posts/interview/design/",
      "summary": "说说你对工厂模式的理解？应用场景？ 说说你对发布订阅、观察者模式的理解？区别？ 说说你对代理模式的理解？应用场景？ 说说你对单例模式的理解？如何实现？ 说说你对策略模式的理解？应用场景？ 说说对设计模式的理解？常见的设计模式有哪些？",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/interview/design/Factory_Pattern\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对工厂模式的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/design/Observer_Pattern\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对发布订阅、观察者模式的理解？区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/design/Proxy_Pattern\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对代理模式的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/design/Singleton_Pattern\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对单例模式的理解？如何实现？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/design/Strategy_Pattern\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对策略模式的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/design/design\" target=\"_blank\" rel=\"noopener noreferrer\">说说对设计模式的理解？常见的设计模式有哪些？</a></li>\n</ul>\n",
      "date_published": "2023-03-23T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "design"
      ]
    },
    {
      "title": "说说你对单例模式的理解？如何实现？",
      "url": "https://www.h7ml.cn/posts/interview/design/Singleton_Pattern.html",
      "id": "https://www.h7ml.cn/posts/interview/design/Singleton_Pattern.html",
      "summary": "前端物语|面试物语-说说你对单例模式的理解？如何实现？",
      "content_html": "<h1> 说说你对单例模式的理解？如何实现？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7df7d830-3b2b-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>单例模式（Singleton Pattern）：创建型模式，提供了一种创建对象的最佳方式，这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建</p>\n<p>在应用程序运行期间，单例模式只会在全局作用域下创建一次实例对象，让所有需要调用的地方都共享这一单例对象，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fa7898d0-3b2c-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从定义上来看，全局变量好像就是单例模式，但是一般情况我们不认为全局变量是一个单例模式，原因是：</p>\n<ul>\n<li>全局命名污染</li>\n<li>不易维护，容易被重写覆盖</li>\n</ul>\n<h2> 二、实现</h2>\n<p>在<code>javascript</code>中，实现一个单例模式可以用一个变量来标志当前的类已经创建过对象，如果下次获取当前类的实例时，直接返回之前创建的对象即可，如下：</p>\n<div class=\"language-JS line-numbers-mode\" data-ext=\"JS\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用闭包也能够实现，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>也可以将上述的方法稍作修改，变成构造函数的形式，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、使用场景</h2>\n<p>在前端中，很多情况都是用到单例模式，例如页面存在一个模态框的时候，只有用户点击的时候才会创建，而不是加载完成之后再创建弹窗和隐藏，并且保证弹窗全局只有一个</p>\n<p>可以先创建一个通常的获取对象的方法，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建弹窗的代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述这种实现称为惰性单例，意图解决需要时才创建类实例对象</p>\n<p>并且<code>Vuex</code>、<code>redux</code>全局态管理库也应用单例模式的思想，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8be50f80-3b2b-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>现在很多第三方库都是单例模式，多次引用只会使用同一个对象，如<code>jquery</code>、<code>lodash</code>、<code>moment</code>...</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/zh-hans/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/zh-hans/单例模式</a></li>\n<li><a href=\"https://www.runoob.com/design-pattern/singleton-pattern.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.runoob.com/design-pattern/singleton-pattern.html</a></li>\n<li><a href=\"https://juejin.cn/post/6844903874210299912#heading-5\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903874210299912#heading-5</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-04T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "design"
      ]
    },
    {
      "title": "说说你对策略模式的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/design/Strategy_Pattern.html",
      "id": "https://www.h7ml.cn/posts/interview/design/Strategy_Pattern.html",
      "summary": "前端物语|面试物语-说说你对策略模式的理解？应用场景？",
      "content_html": "<h1> 说说你对策略模式的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e4aad950-3cb2-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>策略模式（Strategy Pattern）指的是定义一系列的算法，把它们一个个封装起来，目的就是将算法的使用与算法的实现分离开来</p>\n<p>一个基于策略模式的程序至少由两部分组成：</p>\n<ul>\n<li>策略类，策略类封装了具体的算法，并负责具体的计算过程</li>\n<li>环境类 Context，Context 接受客户的请求，随后 把请求委托给某一个策略类</li>\n</ul>\n<h2> 二、使用</h2>\n<p>举个例子，公司的年终奖是根据员工的工资和绩效来考核的，绩效为 A 的人，年终奖为工资的 4 倍，绩效为 B 的人，年终奖为工资的 3 倍，绩效为 C 的人，年终奖为工资的 2 倍</p>\n<p>若使用<code>if</code>来实现，代码则如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上述可有看到，函数内部包含过多<code>if...else</code>，并且后续改正的时候，需要在函数内部添加逻辑，违反了开放封闭原则</p>\n<p>而如果使用策略模式，就是先定义一系列算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码中，<code>obj</code>对应的是策略类，而<code>calculateBouns</code>对应上下通信类</p>\n<p>又比如实现一个表单校验的代码，常常会像如下写法：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码包含多处<code>if</code>语句，并且违反了开放封闭原则，如果应用中还有其他的表单，需要重复编写代码</p>\n<p>此处也可以使用策略模式进行重构校验，第一步确定不变的内容，即策略规则对象，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后找出变的地方，作为环境类<code>context</code>，负责接收用户的要求并委托给策略规则对象，如下<code>Validator</code>类：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过<code>validator.add</code>方法添加校验规则和错误信息提示，使用如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述通过策略模式完成表单的验证，并且可以随时调用，在修改表单验证规则的时候，也非常方便，通过传递参数即可调用</p>\n<h2> 三、应用场景</h2>\n<p>从上面可以看到，使用策略模式的优点有如下：</p>\n<ul>\n<li>策略模式利用组合，委托等技术和思想，有效的避免很多 if 条件语句</li>\n<li>策略模式提供了开放-封闭原则，使代码更容易理解和扩展</li>\n<li>策略模式中的代码可以复用</li>\n</ul>\n<p>策略模式不仅仅用来封装算法，在实际开发中，通常会把算法的含义扩散开来，使策略模式也可以用来封装 一系列的“业务规则”</p>\n<p>只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000021883055\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000021883055</a></li>\n<li><a href=\"https://juejin.cn/post/6844903504109109262\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903504109109262</a></li>\n<li><a href=\"https://juejin.cn/post/6844903751225081864\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903751225081864</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-11T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "design"
      ]
    },
    {
      "title": "说说对设计模式的理解？常见的设计模式有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/design/design.html",
      "id": "https://www.h7ml.cn/posts/interview/design/design.html",
      "summary": "前端物语|面试物语-说说对设计模式的理解？常见的设计模式有哪些？",
      "content_html": "<h1> 说说对设计模式的理解？常见的设计模式有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/065bc170-37ce-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在软件工程中，设计模式是对软件设计中普遍存在的各种问题所提出的解决方案</p>\n<p>设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案</p>\n<p>设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力</p>\n<p>因此，当我们遇到合适的场景时，我们可能会条件反射一样自然而然想到符合这种场景的设计模式</p>\n<p>比如，当系统中某个接口的结构已经无法满足我们现在的业务需求，但又不能改动这个接口，因为可能原来的系统很多功能都依赖于这个接口，改动接口会牵扯到太多文件</p>\n<p>因此应对这种场景，我们可以很快地想到可以用适配器模式来解决这个问题</p>\n<h2> 二、有哪些</h2>\n<p>常见的设计模式有：</p>\n<ul>\n<li>单例模式</li>\n<li>工厂模式</li>\n<li>策略模式</li>\n<li>代理模式</li>\n<li>中介者模式</li>\n<li>装饰者模式</li>\n<li>......</li>\n</ul>\n<h3> 单例模式</h3>\n<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象</p>\n<p>如下图的车，只有一辆，一旦借出去则不能再借给别人：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ea527aa0-37cd-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 工厂模式</h3>\n<p>工厂模式通常会分成 3 个角色：</p>\n<ul>\n<li>工厂角色-负责实现创建所有实例的内部逻辑.</li>\n<li>抽象产品角色-是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</li>\n<li>具体产品角色-是创建目标，所有创建的对象都充当这个角色的某个具体类的实例</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fadd1920-37cd-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 策略模式</h3>\n<p>策略模式，就是定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换</p>\n<p>至少分成两部分：</p>\n<ul>\n<li>策略类（可变），策略类封装了具体的算法，并负责具体的计算过程</li>\n<li>环境类（不变），接受客户的请求，随后将请求委托给某一个策略类</li>\n</ul>\n<h3> 代理模式</h3>\n<p>代理模式：为对象提供一个代用品或占位符，以便控制对它的访问</p>\n<p>例如实现图片懒加载的功能，先通过一张<code>loading</code>图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到<code>img</code>标签里面</p>\n<h3> 中介者模式</h3>\n<p>中介者模式的定义：通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可</p>\n<p>通过中介者模式可以解除对象与对象之间的紧耦合关系</p>\n<h3> 装饰者模式</h3>\n<p>装饰者模式的定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法</p>\n<p>通常运用在原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求</p>\n<h2> 三、总结</h2>\n<p>不断去学习设计模式，会对我们有着极大的帮助，主要如下：</p>\n<ul>\n<li>\n<p>从许多优秀的软件系统中总结出的成功的、能够实现可维护性、复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作</p>\n</li>\n<li>\n<p>设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂</p>\n</li>\n<li>\n<p>大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码</p>\n</li>\n<li>\n<p>合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统</p>\n</li>\n<li>\n<p>学习设计模式将有助于初学者更加深入地理解面向对象思想</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/设计模式_(计算机)</a></li>\n<li><a href=\"https://juejin.cn/post/6844903795017646094\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903795017646094</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000030850326\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000030850326</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "design"
      ]
    },
    {
      "title": "前端物语|面试物语-es6",
      "url": "https://www.h7ml.cn/posts/interview/es6/",
      "id": "https://www.h7ml.cn/posts/interview/es6/",
      "summary": "ES6 中数组新增了哪些扩展？ 你是怎么理解 ES6 中 Decorator 的？使用场景？ 对象新增了哪些扩展？ 你是怎么理解 ES6 中 Generator 的？使用场景？ 你是怎么理解 ES6 中 Module 的？使用场景？ 对象新增了哪些扩展？ 你是怎么理解 ES6 中 Promise 的？使用场景？ 你是怎么理解 ES6 中 Proxy 的？使用场景? 你是怎么理解 ES6 新增 Set、Map 两种数据结构的？ 说说 var、let、const 之间的区别",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/interview/es6/array\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 中数组新增了哪些扩展？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/es6/decorator\" target=\"_blank\" rel=\"noopener noreferrer\">你是怎么理解 ES6 中 Decorator 的？使用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/es6/function\" target=\"_blank\" rel=\"noopener noreferrer\">对象新增了哪些扩展？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/es6/generator\" target=\"_blank\" rel=\"noopener noreferrer\">你是怎么理解 ES6 中 Generator 的？使用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/es6/module\" target=\"_blank\" rel=\"noopener noreferrer\">你是怎么理解 ES6 中 Module 的？使用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/es6/object\" target=\"_blank\" rel=\"noopener noreferrer\">对象新增了哪些扩展？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/es6/promise\" target=\"_blank\" rel=\"noopener noreferrer\">你是怎么理解 ES6 中 Promise 的？使用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/es6/proxy\" target=\"_blank\" rel=\"noopener noreferrer\">你是怎么理解 ES6 中 Proxy 的？使用场景?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/es6/set_map\" target=\"_blank\" rel=\"noopener noreferrer\">你是怎么理解 ES6 新增 Set、Map 两种数据结构的？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/es6/var_let_const\" target=\"_blank\" rel=\"noopener noreferrer\">说说 var、let、const 之间的区别</a></li>\n</ul>\n",
      "date_published": "2023-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "es6"
      ]
    },
    {
      "title": "ES6 中数组新增了哪些扩展？",
      "url": "https://www.h7ml.cn/posts/interview/es6/array.html",
      "id": "https://www.h7ml.cn/posts/interview/es6/array.html",
      "summary": "前端物语|面试物语-ES6 中数组新增了哪些扩展？",
      "content_html": "<h1> ES6 中数组新增了哪些扩展？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a156b8d0-53c5-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、扩展运算符的应用</h2>\n<p>ES6 通过扩展元素符<code>...</code>，好比 <code>rest</code> 参数的逆运算，将一个数组转为用逗号分隔的参数序列</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>主要用于函数调用的时候，将一个数组变为参数序列</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以将某些数据结构转为数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>能够更简单实现数组复制</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>数组的合并也更为简洁了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组</p>\n<p>下面看个例子就清楚多了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>扩展运算符可以与解构赋值结合起来，用于生成数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以将字符串转为真正的数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、构造函数新增的方法</h2>\n<p>关于构造函数，数组新增的方法有如下：</p>\n<ul>\n<li>Array.from()</li>\n<li>Array.of()</li>\n</ul>\n<h3> Array.from()</h3>\n<p>将两类对象转为真正的数组：类似数组的对象和可遍历<code>（iterable）</code>的对象（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Array.of()</h3>\n<p>用于将一组值，转换为数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>没有参数的时候，返回一个空数组</p>\n<p>当参数只有一个的时候，实际上是指定数组的长度</p>\n<p>参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 三、实例对象新增的方法</h3>\n<p>关于数组实例对象新增的方法有如下：</p>\n<ul>\n<li>copyWithin()</li>\n<li>find()、findIndex()</li>\n<li>fill()</li>\n<li>entries()，keys()，values()</li>\n<li>includes()</li>\n<li>flat()，flatMap()</li>\n</ul>\n<h3> copyWithin()</h3>\n<p>将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</p>\n<p>参数如下：</p>\n<ul>\n<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>\n<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>\n<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> find()、findIndex()</h3>\n<p><code>find()</code>用于找出第一个符合条件的数组成员</p>\n<p>参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>findIndex</code>返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> fill()</h3>\n<p>使用给定值，填充一个数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，如果填充的类型为对象，则是浅拷贝</p>\n<h3> entries()，keys()，values()</h3>\n<p><code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> includes()</h3>\n<p>用于判断数组是否包含给定的值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>方法的第二个参数表示搜索的起始位置，默认为<code>0</code></p>\n<p>参数为负数则表示倒数的位置</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> flat()，flatMap()</h3>\n<p>将数组扁平化处理，返回一个新数组，对原数据没有影响</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为 1</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>flatMap()</code>方法对原数组的每个成员执行一个函数相当于执行<code>Array.prototype.map()</code>，然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>flatMap()</code>方法还可以有第二个参数，用来绑定遍历函数里面的<code>this</code></p>\n<h3> 四、数组的空位</h3>\n<p>数组的空位指，数组的某一个位置没有任何值</p>\n<p>ES6 则是明确将空位转为<code>undefined</code>，包括<code>Array.from</code>、扩展运算符、<code>copyWithin()</code>、<code>fill()</code>、<code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code></p>\n<p>建议大家在日常书写中，避免出现空位</p>\n<h3> 五、排序稳定性</h3>\n<p>将<code>sort()</code>默认设置为稳定的排序算法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>排序结果中，<code>straw</code>在<code>spork</code>的前面，跟原始顺序一致</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/array\" target=\"_blank\" rel=\"noopener noreferrer\">https://es6.ruanyifeng.com/#docs/array</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-26T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "es6"
      ]
    },
    {
      "title": "你是怎么理解 ES6 中 Decorator 的？使用场景？",
      "url": "https://www.h7ml.cn/posts/interview/es6/decorator.html",
      "id": "https://www.h7ml.cn/posts/interview/es6/decorator.html",
      "summary": "前端物语|面试物语-你是怎么理解 ES6 中 Decorator 的？使用场景？",
      "content_html": "<h1> 你是怎么理解 ES6 中 Decorator 的？使用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7df43560-5ba5-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、介绍</h2>\n<p>Decorator，即装饰器，从名字上很容易让我们联想到装饰者模式</p>\n<p>简单来讲，装饰者模式就是一种在不改变原类和使用继承的情况下，动态地扩展对象功能的设计理论。</p>\n<p><code>ES6</code>中<code>Decorator</code>功能亦如此，其本质也不是什么高大上的结构，就是一个普通的函数，用于扩展类属性和类方法</p>\n<p>这里定义一个士兵，这时候他什么装备都没有</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>定义一个得到 AK 装备的函数，即装饰器</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用该装饰器对士兵进行增强</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这时候士兵就有武器了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>上述代码虽然简单，但也能够清晰看到了使用<code>Decorator</code>两大优点：</p>\n<ul>\n<li>代码可读性变强了，装饰器命名相当于一个注释</li>\n<li>在不改变原有代码情况下，对原来功能进行扩展</li>\n</ul>\n<h2> 二、用法</h2>\n<p><code>Docorator</code>修饰对象为下面两种：</p>\n<ul>\n<li>类的装饰</li>\n<li>类属性的装饰</li>\n</ul>\n<h3> 类的装饰</h3>\n<p>当对类本身进行装饰的时候，能够接受一个参数，即类本身</p>\n<p>将装饰器行为进行分解，大家能够有个更深入的了解</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面<code>@testable</code>就是一个装饰器，<code>target</code>就是传入的类，即<code>MyTestableClass</code>，实现了为类添加静态属性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果想要传递参数，可以在装饰器外层再封装一层函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 类属性的装饰</h3>\n<p>当对类属性进行装饰的时候，能够接受三个参数：</p>\n<ul>\n<li>类的原型对象</li>\n<li>需要装饰的属性名</li>\n<li>装饰属性名的描述对象</li>\n</ul>\n<p>首先定义一个<code>readonly</code>装饰器</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用<code>readonly</code>装饰类的<code>name</code>方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>相当于以下调用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果一个方法有多个装饰器，就像洋葱一样，先从外到内进入，再由内到外执行</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>外层装饰器<code>@dec(1)</code>先进入，但是内层装饰器<code>@dec(2)</code>先执行</p>\n<h3> 注意</h3>\n<p>装饰器不能用于修饰函数，因为函数存在变量声明情况</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>编译阶段，变成下面</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>意图是执行后<code>counter</code>等于 1，但是实际上结果是<code>counter</code>等于 0</p>\n<h2> 三、使用场景</h2>\n<p>基于<code>Decorator</code>强大的作用，我们能够完成各种场景的需求，下面简单列举几种：</p>\n<p>使用<code>react-redux</code>的时候，如果写成下面这种形式，既不雅观也很麻烦</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过装饰器就变得简洁多了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>将<code>mixins</code>，也可以写成装饰器，让使用更为简洁了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面再讲讲<code>core-decorators.js</code>几个常见的装饰器</p>\n<h4> @antobind</h4>\n<p><code>autobind</code>装饰器使得方法中的<code>this</code>对象，绑定原始对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> @readonly</h4>\n<p><code>readonly</code>装饰器使得属性或方法不可写</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> @deprecate</h4>\n<p><code>deprecate</code>或<code>deprecated</code>装饰器在控制台显示一条警告，表示该方法将废除</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/decorator\" target=\"_blank\" rel=\"noopener noreferrer\">https://es6.ruanyifeng.com/#docs/decorator</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-08T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "es6"
      ]
    },
    {
      "title": "对象新增了哪些扩展？",
      "url": "https://www.h7ml.cn/posts/interview/es6/function.html",
      "id": "https://www.h7ml.cn/posts/interview/es6/function.html",
      "summary": "前端物语|面试物语-对象新增了哪些扩展？",
      "content_html": "<h1> 对象新增了哪些扩展？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/54a04a10-5569-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、参数</h2>\n<p><code>ES6</code>允许为函数的参数设置默认值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>函数的形参是默认声明的，不能使用<code>let</code>或<code>const</code>再次声明</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>参数默认值可以与解构赋值的默认值结合起来使用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的<code>foo</code>函数，当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量<code>x</code>和<code>y</code>就不会生成，从而报错，这里设置默认值避免</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、属性</h2>\n<h3> 函数的 length 属性</h3>\n<p><code>length</code>将返回没有指定默认值的参数个数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>rest</code> 参数也不会计入<code>length</code>属性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> name 属性</h3>\n<p>返回该函数的函数名</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果将一个具名函数赋值给一个变量，则 <code>name</code>属性都返回这个具名函数原本的名字</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、作用域</h2>\n<p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域</p>\n<p>等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的</p>\n<p>下面例子中，<code>y=x</code>会形成一个单独作用域，<code>x</code>没有被定义，所以指向全局变量<code>x</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 四、严格模式</h2>\n<p>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 五、箭头函数</h2>\n<p>使用“箭头”（<code>=&gt;</code>）定义函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果返回对象，需要加括号将对象包裹</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>注意点：</p>\n<ul>\n<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li>\n<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li>\n<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替</li>\n<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/function\" target=\"_blank\" rel=\"noopener noreferrer\">https://es6.ruanyifeng.com/#docs/function</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "es6"
      ]
    },
    {
      "title": "你是怎么理解 ES6 中 Generator 的？使用场景？",
      "url": "https://www.h7ml.cn/posts/interview/es6/generator.html",
      "id": "https://www.h7ml.cn/posts/interview/es6/generator.html",
      "summary": "前端物语|面试物语-你是怎么理解 ES6 中 Generator 的？使用场景？",
      "content_html": "<h1> 你是怎么理解 ES6 中 Generator 的？使用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7db499b0-5947-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、介绍</h2>\n<p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p>\n<p>回顾下上文提到的解决异步的手段：</p>\n<ul>\n<li>回调函数</li>\n<li>promise</li>\n</ul>\n<p>那么，上文我们提到<code>promsie</code>已经是一种比较流行的解决异步方案，那么为什么还出现<code>Generator</code>？甚至<code>async/await</code>呢？</p>\n<p>该问题我们留在后面再进行分析，下面先认识下<code>Generator</code></p>\n<h3> Generator 函数</h3>\n<p>执行 <code>Generator</code> 函数会返回一个遍历器对象，可以依次遍历 <code>Generator</code> 函数内部的每一个状态</p>\n<p>形式上，<code>Generator</code>函数是一个普通函数，但是有两个特征：</p>\n<ul>\n<li><code>function</code>关键字与函数名之间有一个星号</li>\n<li>函数体内部使用<code>yield</code>表达式，定义不同的内部状态</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、使用</h2>\n<p><code>Generator</code> 函数会返回一个遍历器对象，即具有<code>Symbol.iterator</code>属性，并且返回给自己</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过<code>yield</code>关键字可以暂停<code>generator</code>函数返回的遍历器对象的状态</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述存在三个状态：<code>hello</code>、<code>world</code>、<code>return</code></p>\n<p>通过<code>next</code>方法才会遍历到下一个内部状态，其运行逻辑如下：</p>\n<ul>\n<li>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</li>\n<li>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式</li>\n<li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</li>\n<li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>done</code>用来判断是否存在下个状态，<code>value</code>对应状态值</p>\n<p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code></p>\n<p>通过调用<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>正因为<code>Generator</code>函数返回<code>Iterator</code>对象，因此我们还可以通过<code>for...of</code>进行遍历</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>原生对象没有遍历接口，通过<code>Generator</code>函数为它加上这个接口，就能使用<code>for...of</code>进行遍历了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、异步解决方案</h2>\n<p>回顾之前展开异步解决的方案：</p>\n<ul>\n<li>回调函数</li>\n<li>Promise 对象</li>\n<li>generator 函数</li>\n<li>async/await</li>\n</ul>\n<p>这里通过文件读取案例，将几种解决异步的方案进行一个比较：</p>\n<h3> 回调函数</h3>\n<p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，再调用这个函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>readFile</code>函数的第三个参数，就是回调函数，等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行</p>\n<h3> Promise</h3>\n<p><code>Promise</code>就是为了解决回调地狱而产生的，将回调函数的嵌套，改成链式调用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种链式操作形式，使异步任务的两段执行更清楚了，但是也存在了很明显的问题，代码变得冗杂了，语义化并不强</p>\n<h3> generator</h3>\n<p><code>yield</code>表达式可以暂停函数执行，<code>next</code>方法用于恢复函数执行，这使得<code>Generator</code>函数非常适合将异步任务同步化</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> async/await</h3>\n<p>将上面<code>Generator</code>函数改成<code>async/await</code>形式，更为简洁，语义化更强了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 区别</h3>\n<p>通过上述代码进行分析，将<code>promise</code>、<code>Generator</code>、<code>async/await</code>进行比较：</p>\n<ul>\n<li>\n<p><code>promise</code>和<code>async/await</code>是专门用于处理异步操作的</p>\n</li>\n<li>\n<p><code>Generator</code>并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署<code>Interator</code>接口...）</p>\n</li>\n<li>\n<p><code>promise</code>编写代码相比<code>Generator</code>、<code>async</code>更为复杂化，且可读性也稍差</p>\n</li>\n<li>\n<p><code>Generator</code>、<code>async</code>需要与<code>promise</code>对象搭配处理异步情况</p>\n</li>\n<li>\n<p><code>async</code>实质是<code>Generator</code>的语法糖，相当于会自动执行<code>Generator</code>函数</p>\n</li>\n<li>\n<p><code>async</code>使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案</p>\n</li>\n</ul>\n<h2> 四、使用场景</h2>\n<p><code>Generator</code>是异步解决的一种方案，最大特点则是将异步操作同步化表达出来</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>包括<code>redux-saga</code>中间件也充分利用了<code>Generator</code>特性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>还能利用<code>Generator</code>函数，在对象上实现<code>Iterator</code>接口</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/generator-async\" target=\"_blank\" rel=\"noopener noreferrer\">https://es6.ruanyifeng.com/#docs/generator-async</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-01T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "es6"
      ]
    },
    {
      "title": "你是怎么理解 ES6 中 Module 的？使用场景？",
      "url": "https://www.h7ml.cn/posts/interview/es6/module.html",
      "id": "https://www.h7ml.cn/posts/interview/es6/module.html",
      "summary": "前端物语|面试物语-你是怎么理解 ES6 中 Module 的？使用场景？",
      "content_html": "<h1> 你是怎么理解 ES6 中 Module 的？使用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b6d19be0-5adb-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、介绍</h2>\n<p>模块，（Module），是能够单独命名并独立地完成一定功能的程序语句的<strong>集合（即程序代码和数据结构的集合体）</strong>。</p>\n<p>两个基本的特征：外部特征和内部特征</p>\n<ul>\n<li>\n<p>外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能</p>\n</li>\n<li>\n<p>内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）</p>\n</li>\n</ul>\n<h3> 为什么需要模块化</h3>\n<ul>\n<li>代码抽象</li>\n<li>代码封装</li>\n<li>代码复用</li>\n<li>依赖管理</li>\n</ul>\n<p>如果没有模块化，我们代码会怎样？</p>\n<ul>\n<li>变量和方法不容易维护，容易污染全局作用域</li>\n<li>加载资源的方式通过 script 标签从上到下。</li>\n<li>依赖的环境主观逻辑偏重，代码较多就会比较复杂。</li>\n<li>大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃</li>\n</ul>\n<p>因此，需要一种将<code>JavaScript</code>程序模块化的机制，如</p>\n<ul>\n<li>CommonJs (典型代表：node.js 早期)</li>\n<li>AMD (典型代表：require.js)</li>\n<li>CMD (典型代表：sea.js)</li>\n</ul>\n<h3> AMD</h3>\n<p><code>Asynchronous ModuleDefinition</code>（AMD），异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行</p>\n<p>代表库为<code>require.js</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> CommonJs</h3>\n<p><code>CommonJS</code> 是一套 <code>Javascript</code> 模块规范，用于服务端</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其有如下特点：</p>\n<ul>\n<li>所有代码都运行在模块作用域，不会污染全局作用域</li>\n<li>模块是同步加载的，即只有加载完成，才能执行后面的操作</li>\n<li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li>\n<li><code>require</code>返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值</li>\n</ul>\n<p>既然存在了<code>AMD</code>以及<code>CommonJs</code>机制，<code>ES6</code>的<code>Module</code>又有什么不一样？</p>\n<p>ES6 在语言标准的层面上，实现了<code>Module</code>，即模块功能，完全可以取代 <code>CommonJS</code>和 <code>AMD</code>规范，成为浏览器和服务器通用的模块解决方案</p>\n<p><code>CommonJS</code> 和<code>AMD</code> 模块，都只能在运行时确定这些东西。比如，<code>CommonJS</code>模块就是对象，输入时必须查找对象属性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>ES6</code>设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码，只加载 3 个方法，其他方法不加载，即 <code>ES6</code> 可以在编译时就完成模块加载</p>\n<p>由于编译加载，使得静态分析成为可能。包括现在流行的<code>typeScript</code>也是依靠静态分析实现功能</p>\n<h2> 二、使用</h2>\n<p><code>ES6</code>模块内部自动采用了严格模式，这里就不展开严格模式的限制，毕竟这是<code>ES5</code>之前就已经规定好</p>\n<p>模块功能主要由两个命令构成：</p>\n<ul>\n<li><code>export</code>：用于规定模块的对外接口</li>\n<li><code>import</code>：用于输入其他模块提供的功能</li>\n</ul>\n<h3> export</h3>\n<p>一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出函数或类</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过<code>as</code>可以进行输出变量的重命名</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> import</h3>\n<p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同样如果想要输入变量起别名，通过<code>as</code>关键字</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>当加载整个模块的时候，需要用到星号<code>*</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不过建议即使能修改，但我们不建议。因为修改之后，我们很难差错</p>\n<p><code>import</code>后面我们常接着<code>from</code>关键字，<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果只有一个模块名，需要有配置文件，告诉引擎模块的位置</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在编译阶段，<code>import</code>会提升到整个模块的头部，首先执行</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>多次重复执行同样的导入，只会执行一次</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载</p>\n<p>如果不需要知道变量名或函数就完成加载，就要用到<code>export default</code>命令，为模块指定默认输出</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>加载该模块的时候，<code>import</code>命令可以为该函数指定任意名字</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 动态加载</h3>\n<p>允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势</p>\n<p>这个新功能允许您将<code>import()</code>作为函数调用，将其作为参数传递给模块的路径。 它返回一个 <code>promise</code>，它用一个模块对象来实现，让你可以访问该对象的导出</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 复合写法</h3>\n<p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同理能够搭配<code>as</code>、<code>*</code>搭配使用</p>\n<h2> 三、使用场景</h2>\n<p>如今，<code>ES6</code>模块化已经深入我们日常项目开发中，像<code>vue</code>、<code>react</code>项目搭建项目，组件化开发处处可见，其也是依赖模块化实现</p>\n<p><code>vue</code>组件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>react</code>组件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>包括完成一些复杂应用的时候，我们也可以拆分成各个模块</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://macsalvation.net/the-history-of-js-module/\" target=\"_blank\" rel=\"noopener noreferrer\">https://macsalvation.net/the-history-of-js-module/</a></li>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/module\" target=\"_blank\" rel=\"noopener noreferrer\">https://es6.ruanyifeng.com/#docs/module</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "es6"
      ]
    },
    {
      "title": "对象新增了哪些扩展？",
      "url": "https://www.h7ml.cn/posts/interview/es6/object.html",
      "id": "https://www.h7ml.cn/posts/interview/es6/object.html",
      "summary": "前端物语|面试物语- 对象新增了哪些扩展？",
      "content_html": "<h1> 对象新增了哪些扩展？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/4da4dd40-5427-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、属性的简写</h2>\n<p>ES6 中，当对象键名与对应值名相等的时候，可以进行简写</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>方法也能够进行简写</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在函数内作为返回值，也会变得方便很多</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：简写的对象方法不能用作构造函数，否则会报错</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、属性名表达式</h2>\n<p>ES6 允许字面量定义对象时，将表达式放在括号内</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>表达式还可以用于定义方法名</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，属性名表达式与简洁表示法，不能同时使用，会报错</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、super 关键字</h2>\n<p><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 四、扩展运算符的应用</h2>\n<p>在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：解构赋值必须是最后一个参数，否则会报错</p>\n<p>解构赋值是浅拷贝</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对象的扩展运算符等同于使用<code>Object.assign()</code>方法</p>\n<h2> 五、属性的遍历</h2>\n<p>ES6 一共有 5 种方法可以遍历对象的属性。</p>\n<ul>\n<li>\n<p>for...in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</p>\n</li>\n<li>\n<p>Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名</p>\n</li>\n<li>\n<p>Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名</p>\n</li>\n<li>\n<p>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名</p>\n</li>\n<li>\n<p>Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</p>\n</li>\n</ul>\n<p>上述遍历，都遵守同样的属性遍历的次序规则：</p>\n<ul>\n<li>首先遍历所有数值键，按照数值升序排列</li>\n<li>其次遍历所有字符串键，按照加入时间升序排列</li>\n<li>最后遍历所有 Symbol 键，按照加入时间升序排</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 六、对象新增的方法</h2>\n<p>关于对象新增的方法，分别有以下：</p>\n<ul>\n<li><a href=\"http://Object.is\" target=\"_blank\" rel=\"noopener noreferrer\">Object.is</a>()</li>\n<li>Object.assign()</li>\n<li>Object.getOwnPropertyDescriptors()</li>\n<li>Object.setPrototypeOf()，Object.getPrototypeOf()</li>\n<li>Object.keys()，Object.values()，Object.entries()</li>\n<li>Object.fromEntries()</li>\n</ul>\n<h3> <a href=\"http://Object.is\" target=\"_blank\" rel=\"noopener noreferrer\">Object.is</a>()</h3>\n<p>严格判断两个值是否相等，与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Object.assign()</h3>\n<p><code>Object.assign()</code>方法用于对象的合并，将源对象<code>source</code>的所有可枚举属性，复制到目标对象<code>target</code></p>\n<p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：<code>Object.assign()</code>方法是浅拷贝，遇到同名属性会进行替换</p>\n<h3> Object.getOwnPropertyDescriptors()</h3>\n<p>返回指定对象所有自身属性（非继承属性）的描述对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Object.setPrototypeOf()</h3>\n<p><code>Object.setPrototypeOf</code>方法用来设置一个对象的原型对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Object.getPrototypeOf()</h3>\n<p>用于读取一个对象的原型对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> Object.keys()</h3>\n<p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Object.values()</h3>\n<p>返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Object.entries()</h3>\n<p>返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Object.fromEntries()</h3>\n<p>用于将一个键值对数组转为对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/object\" target=\"_blank\" rel=\"noopener noreferrer\">https://es6.ruanyifeng.com/#docs/object</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "es6"
      ]
    },
    {
      "title": "你是怎么理解 ES6 中 Promise 的？使用场景？",
      "url": "https://www.h7ml.cn/posts/interview/es6/promise.html",
      "id": "https://www.h7ml.cn/posts/interview/es6/promise.html",
      "summary": "前端物语|面试物语-你是怎么理解 ES6 中 Promise 的？使用场景？",
      "content_html": "<h1> 你是怎么理解 ES6 中 Promise 的？使用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f033b160-5811-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、介绍</h2>\n<p><code>Promise</code>，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大</p>\n<p>在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>阅读上面代码，是不是很难受，上述形成了经典的回调地狱</p>\n<p>现在通过<code>Promise</code>的改写上面的代码</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>瞬间感受到<code>promise</code>解决异步操作的优点：</p>\n<ul>\n<li>链式操作减低了编码难度</li>\n<li>代码可读性明显增强</li>\n</ul>\n<p>下面我们正式来认识<code>promise</code>：</p>\n<h3> 状态</h3>\n<p><code>promise</code>对象仅有三种状态</p>\n<ul>\n<li><code>pending</code>（进行中）</li>\n<li><code>fulfilled</code>（已成功）</li>\n<li><code>rejected</code>（已失败）</li>\n</ul>\n<h3> 特点</h3>\n<ul>\n<li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li>\n<li>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</li>\n</ul>\n<h3> 流程</h3>\n<p>认真阅读下图，我们能够轻松了解<code>promise</code>整个流程</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1b02ae90-58a9-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、用法</h2>\n<p><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code></p>\n<ul>\n<li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”</li>\n<li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”</li>\n</ul>\n<h3> 实例方法</h3>\n<p><code>Promise</code>构建出来的实例存在以下方法：</p>\n<ul>\n<li>then()</li>\n<li>catch()</li>\n<li>finally()</li>\n</ul>\n<h4> then()</h4>\n<p><code>then</code>是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</p>\n<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例，也就是<code>promise</code>能链式书写的原因</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> catch</h4>\n<p><code>catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Promise</code>对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>一般来说，使用<code>catch</code>方法代替<code>then()</code>第二个参数</p>\n<p><code>Promise</code>对象抛出的错误不会传递到外层代码，即不会有任何反应</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程</p>\n<p><code>catch()</code>方法之中，还能再抛出错误，通过后面<code>catch</code>方法捕获到</p>\n<h4> finally()</h4>\n<p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 构造函数方法</h3>\n<p><code>Promise</code>构造函数存在以下方法：</p>\n<ul>\n<li>all()</li>\n<li>race()</li>\n<li>allSettled()</li>\n<li>resolve()</li>\n<li>reject()</li>\n<li>try()</li>\n</ul>\n<h3> all()</h3>\n<p><code>Promise.all()</code>方法用于将多个 <code>Promise</code>实例，包装成一个新的 <code>Promise</code>实例</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>接受一个数组（迭代对象）作为参数，数组成员都应为<code>Promise</code>实例</p>\n<p>实例<code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分为两种：</p>\n<ul>\n<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</li>\n<li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数</li>\n</ul>\n<p>注意，如果作为参数的 <code>Promise</code> 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> race()</h3>\n<p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变</p>\n<p>率先改变的 Promise 实例的返回值则传递给<code>p</code>的回调函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> allSettled()</h3>\n<p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</p>\n<p>只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> resolve()</h4>\n<p>将现有对象转为 <code>Promise</code>对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>参数可以分成四种情况，分别如下：</p>\n<ul>\n<li>参数是一个 Promise 实例，<code>promise.resolve</code>将不做任何修改、原封不动地返回这个实例</li>\n<li>参数是一个<code>thenable</code>对象，<code>promise.resolve</code>会将这个对象转为 <code>Promise</code>对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法</li>\n<li>参数不是具有<code>then()</code>方法的对象，或根本就不是对象，<code>Promise.resolve()</code>会返回一个新的 Promise 对象，状态为<code>resolved</code></li>\n<li>没有参数时，直接返回一个<code>resolved</code>状态的 Promise 对象</li>\n</ul>\n<h4> reject()</h4>\n<p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Promise.reject()</code>方法的参数，会原封不动地变成后续方法的参数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、使用场景</h2>\n<p>将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过链式操作，将多个渲染数据分别给个<code>then</code>，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过<code>all()</code>实现多个请求合并在一起，汇总所有请求结果，只需设置一个<code>loading</code>即可</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过<code>race</code>可以设置图片请求超时</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener noreferrer\">https://es6.ruanyifeng.com/#docs/promise</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-13T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "es6"
      ]
    },
    {
      "title": "你是怎么理解 ES6 中 Proxy 的？使用场景?",
      "url": "https://www.h7ml.cn/posts/interview/es6/proxy.html",
      "id": "https://www.h7ml.cn/posts/interview/es6/proxy.html",
      "summary": "前端物语|面试物语-你是怎么理解 ES6 中 Proxy 的？使用场景?",
      "content_html": "<h1> 你是怎么理解 ES6 中 Proxy 的？使用场景?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6f656e30-59f5-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、介绍</h2>\n<p><strong>定义：</strong> 用于定义基本操作的自定义行为</p>\n<p><strong>本质：</strong> 修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程<code>(meta programming)</code></p>\n<p>元编程（Metaprogramming，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作</p>\n<p>一段代码来理解</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这段程序每执行一次能帮我们生成一个名为<code>program</code>的文件，文件内容为 1024 行<code>echo</code>，如果我们手动来写 1024 行代码，效率显然低效</p>\n<ul>\n<li>元编程优点：与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译</li>\n</ul>\n<p><code>Proxy</code> 亦是如此，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）</p>\n<h2> 二、用法</h2>\n<p><code>Proxy</code>为 构造函数，用来生成 <code>Proxy</code>实例</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 参数</h3>\n<p><code>target</code>表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理））</p>\n<p><code>handler</code>通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>p</code> 的行为</p>\n<h3> handler 解析</h3>\n<p>关于<code>handler</code>拦截属性，有如下：</p>\n<ul>\n<li>get(target,propKey,receiver)：拦截对象属性的读取</li>\n<li>set(target,propKey,value,receiver)：拦截对象属性的设置</li>\n<li>has(target,propKey)：拦截<code>propKey in proxy</code>的操作，返回一个布尔值</li>\n<li>deleteProperty(target,propKey)：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值</li>\n<li>ownKeys(target)：拦截<code>Object.keys(proxy)</code>、<code>for...in</code>等循环，返回一个数组</li>\n<li>getOwnPropertyDescriptor(target, propKey)：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象</li>\n<li>defineProperty(target, propKey, propDesc)：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>，返回一个布尔值</li>\n<li>preventExtensions(target)：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值</li>\n<li>getPrototypeOf(target)：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象</li>\n<li>isExtensible(target)：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值</li>\n<li>setPrototypeOf(target, proto)：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值</li>\n<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作</li>\n<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作</li>\n</ul>\n<h3> Reflect</h3>\n<p>若需要在<code>Proxy</code>内部调用对象的默认行为，建议使用<code>Reflect</code>，其是<code>ES6</code>中操作对象而提供的新 <code>API</code></p>\n<p>基本特点：</p>\n<ul>\n<li>只要<code>Proxy</code>对象具有的代理方法，<code>Reflect</code>对象全部具有，以静态方法的形式存在</li>\n<li>修改某些<code>Object</code>方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回<code>false</code>）</li>\n<li>让<code>Object</code>操作都变成函数行为</li>\n</ul>\n<p>下面我们介绍<code>proxy</code>几种用法：</p>\n<h3> get()</h3>\n<p><code>get</code>接受三个参数，依次为目标对象、属性名和 <code>proxy</code> 实例本身，最后一个参数可选</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>get</code>能够对数组增删改查进行拦截，下面是试下你数组读取负数的索引</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则会报错</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> set()</h3>\n<p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 <code>Proxy</code> 实例本身</p>\n<p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果目标对象自身的某个属性，不可写且不可配置，那么<code>set</code>方法将不起作用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> deleteProperty()</h3>\n<p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错</p>\n<h3> 取消代理</h3>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 三、使用场景</h2>\n<p><code>Proxy</code>其功能非常类似于设计模式中的代理模式，常用功能如下：</p>\n<ul>\n<li>拦截和监视外部对对象的访问</li>\n<li>降低函数或类的复杂度</li>\n<li>在复杂操作前对操作进行校验或对所需资源进行管理</li>\n</ul>\n<p>使用 <code>Proxy</code> 保障数据类型的准确性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>声明了一个私有的 <code>apiKey</code>，便于 <code>api</code> 这个对象内部的方法调用，但不希望从外部也能够访问 <code>api._apiKey</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>还能通过使用<code>Proxy</code>实现观察者模式</p>\n<p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行</p>\n<p><code>observable</code>函数返回一个原始对象的 <code>Proxy</code> 代理，拦截赋值操作，触发充当观察者的各个函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>观察者函数都放进<code>Set</code>集合，当修改<code>obj</code>的值，在会<code>set</code>函数中拦截，自动执行<code>Set</code>所有的观察者</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/proxy\" target=\"_blank\" rel=\"noopener noreferrer\">https://es6.ruanyifeng.com/#docs/proxy</a></li>\n<li><a href=\"https://vue3js.cn/es6\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn/es6</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-18T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "es6"
      ]
    },
    {
      "title": "你是怎么理解 ES6 新增 Set、Map 两种数据结构的？",
      "url": "https://www.h7ml.cn/posts/interview/es6/set_map.html",
      "id": "https://www.h7ml.cn/posts/interview/es6/set_map.html",
      "summary": "前端物语|面试物语-你是怎么理解 ES6 新增 Set、Map 两种数据结构的？",
      "content_html": "<h1> 你是怎么理解 ES6 新增 Set、Map 两种数据结构的？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2b947d00-560c-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>如果要用一句来描述，我们可以说</p>\n<p><code>Set</code>是一种叫做集合的数据结构，<code>Map</code>是一种叫做字典的数据结构</p>\n<p>什么是集合？什么又是字典？</p>\n<ul>\n<li>\n<p>集合<br>\n是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合</p>\n</li>\n<li>\n<p>字典<br>\n是一些元素的集合。每个元素有一个称作 key 的域，不同元素的 key 各不相同</p>\n</li>\n</ul>\n<p>区别？</p>\n<ul>\n<li>共同点：集合、字典都可以存储不重复的值</li>\n<li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li>\n</ul>\n<h2> 一、Set</h2>\n<p><code>Set</code>是<code>es6</code>新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合</p>\n<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 增删改查</h3>\n<p><code>Set</code>的实例关于增删改查的方法：</p>\n<ul>\n<li>\n<p>add()</p>\n</li>\n<li>\n<p>delete()</p>\n</li>\n<li>\n<p>has()</p>\n</li>\n<li>\n<p>clear()</p>\n</li>\n</ul>\n<h3> add()</h3>\n<p>添加某个值，返回 <code>Set</code> 结构本身</p>\n<p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> delete()</h3>\n<p>删除某个值，返回一个布尔值，表示删除是否成功</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> has()</h3>\n<p>返回一个布尔值，判断该值是否为<code>Set</code>的成员</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> clear()</h3>\n<p>清除所有成员，没有返回值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 遍历</h3>\n<p><code>Set</code>实例遍历的方法有如下：</p>\n<p>关于遍历的方法，有如下：</p>\n<ul>\n<li>keys()：返回键名的遍历器</li>\n<li>values()：返回键值的遍历器</li>\n<li>entries()：返回键值对的遍历器</li>\n<li>forEach()：使用回调函数遍历每个成员</li>\n</ul>\n<p><code>Set</code>的遍历顺序就是插入顺序</p>\n<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>forEach()</code>用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的<code>forEach</code>方法有第二个参数，用于绑定处理函数的<code>this</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>扩展运算符和<code>Set</code> 结构相结合实现数组或字符串去重</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实现并集、交集、和差集</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、Map</h2>\n<p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p>\n<p><code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 增删改查</h3>\n<p><code>Map</code> 结构的实例针对增删改查有以下属性和操作方法：</p>\n<ul>\n<li>size 属性</li>\n<li>set()</li>\n<li>get()</li>\n<li>has()</li>\n<li>delete()</li>\n<li>clear()</li>\n</ul>\n<h3> size</h3>\n<p><code>size</code>属性返回 Map 结构的成员总数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> set()</h3>\n<p>设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构</p>\n<p>如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键</p>\n<p>同时返回的是当前<code>Map</code>对象，可采用链式写法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> get()</h3>\n<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> has()</h3>\n<p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> delete()</h3>\n<p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> clear()</h3>\n<p><code>clear</code>方法清除所有成员，没有返回值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 遍历</h3>\n<p><code>Map</code>结构原生提供三个遍历器生成函数和一个遍历方法：</p>\n<ul>\n<li>keys()：返回键名的遍历器</li>\n<li>values()：返回键值的遍历器</li>\n<li>entries()：返回所有成员的遍历器</li>\n<li>forEach()：遍历 Map 的所有成员</li>\n</ul>\n<p>遍历顺序就是插入顺序</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、WeakSet 和 WeakMap</h2>\n<h3> WeakSet</h3>\n<p>创建<code>WeakSet</code>实例</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>WeakSet</code>可以接受一个具有 <code>Iterable</code>接口的对象作为参数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在<code>API</code>中<code>WeakSet</code>与<code>Set</code>有两个区别：</p>\n<ul>\n<li>没有遍历操作的<code>API</code></li>\n<li>没有<code>size</code>属性</li>\n</ul>\n<p><code>WeakSet</code>只能成员只能是引用类型，而不能是其他类型的值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>WeakSet</code>里面的引用只要在外部消失，它在 <code>WeakSet</code>里面的引用就会自动消失</p>\n<h3> WeakMap</h3>\n<p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合</p>\n<p>在<code>API</code>中<code>WeakMap</code>与<code>Map</code>有两个区别：</p>\n<ul>\n<li>没有遍历操作的<code>API</code></li>\n<li>没有<code>clear</code>清空方法</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>WeakMap</code>的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用</p>\n<p>举个场景例子：</p>\n<p>在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构，当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：<code>WeakMap</code> 弱引用的只是键名，而不是键值。键值依然是正常引用</p>\n<p>下面代码中，键值<code>obj</code>会在<code>WeakMap</code>产生新的引用，当你修改<code>obj</code>不会影响到内部</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/set-map\" target=\"_blank\" rel=\"noopener noreferrer\">https://es6.ruanyifeng.com/#docs/set-map</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-22T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "es6"
      ]
    },
    {
      "title": "说说 var、let、const 之间的区别",
      "url": "https://www.h7ml.cn/posts/interview/es6/var_let_const.html",
      "id": "https://www.h7ml.cn/posts/interview/es6/var_let_const.html",
      "summary": "前端物语|面试物语-说说 var、let、const 之间的区别",
      "content_html": "<h1> 说说 var、let、const 之间的区别</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d2aba2e0-50f7-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、var</h2>\n<p>在 ES5 中，顶层对象的属性和全局变量是等价的，用<code>var</code>声明的变量既是全局变量，也是顶层变量</p>\n<p>注意：顶层对象，在浏览器环境指的是<code>window</code>对象，在 <code>Node</code> 指的是<code>global</code>对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用<code>var</code>声明的变量存在变量提升的情况</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在编译阶段，编译器会将其变成以下执行</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用<code>var</code>，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在函数中使用使用<code>var</code>声明变量时候，该变量是局部的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>而如果在函数内不使用<code>var</code>，该变量是全局的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、let</h2>\n<p><code>let</code>是<code>ES6</code>新增的命令，用来声明变量</p>\n<p>用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不存在变量提升</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这表示在声明它之前，变量<code>a</code>是不存在的，这时如果用到它，就会抛出一个错误</p>\n<p>只要块级作用域内存在<code>let</code>命令，这个区域就不再受外部影响</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用<code>let</code>声明变量前，该变量都不可用，也就是大家常说的“暂时性死区”</p>\n<p>最后，<code>let</code>不允许在相同作用域中重复声明</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意的是相同作用域，下面这种情况是不会报错的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>因此，我们不能在函数内部重新声明参数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、const</h2>\n<p><code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果之前用<code>var</code>或<code>let</code>声明过变量，再用<code>const</code>声明同样会报错</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>const</code>实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动</p>\n<p>对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量</p>\n<p>对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的，并不能确保改变量的结构不变</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其它情况，<code>const</code>与<code>let</code>一致</p>\n<h2> 四、区别</h2>\n<p><code>var</code>、<code>let</code>、<code>const</code>三者区别可以围绕下面五点展开：</p>\n<ul>\n<li>变量提升</li>\n<li>暂时性死区</li>\n<li>块级作用域</li>\n<li>重复声明</li>\n<li>修改声明的变量</li>\n<li>使用</li>\n</ul>\n<h3> 变量提升</h3>\n<p><code>var</code>声明的变量存在变量提升，即变量可以在声明之前调用，值为<code>undefined</code></p>\n<p><code>let</code>和<code>const</code>不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 暂时性死区</h3>\n<p><code>var</code>不存在暂时性死区</p>\n<p><code>let</code>和<code>const</code>存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 块级作用域</h3>\n<p><code>var</code>不存在块级作用域</p>\n<p><code>let</code>和<code>const</code>存在块级作用域</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 重复声明</h3>\n<p><code>var</code>允许重复声明变量</p>\n<p><code>let</code>和<code>const</code>在同一作用域不允许重复声明变量</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 修改声明的变量</h3>\n<p><code>var</code>和<code>let</code>可以</p>\n<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 使用</h3>\n<p>能用<code>const</code>的情况尽量使用<code>const</code>，其他情况下大多数使用<code>let</code>，避免使用<code>var</code></p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener noreferrer\">https://es6.ruanyifeng.com/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-11T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "es6"
      ]
    },
    {
      "title": "说说你对 Git 的理解？",
      "url": "https://www.h7ml.cn/posts/interview/git/Git.html",
      "id": "https://www.h7ml.cn/posts/interview/git/Git.html",
      "summary": "前端物语|面试物语-说说你对 Git 的理解？",
      "content_html": "<h1> 说说你对 Git 的理解？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/213eba50-f79c-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>git，是一个分布式版本控制软件，最初目的是为更好地管理<code>Linux</code>内核开发而设计</p>\n<p>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/29240f40-f79c-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>项目开始，只有一个原始版仓库，别的机器可以<code>clone</code>这个原始版本库，那么所有<code>clone</code>的机器，它们的版本库其实都是一样的，并没有主次之分</p>\n<p>所以在实现团队协作的时候，只要有一台电脑充当服务器的角色，其他每个人都从这个“服务器”仓库<code>clone</code>一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交</p>\n<p><code>github</code>实际就可以充当这个服务器角色，其是一个开源协作社区，提供<code>Git</code>仓库托管服务，既可以让别人参与你的开源项目，也可以参与别人的开源项目</p>\n<h2> 二、工作原理</h2>\n<p>当我们通过<code>git init</code>创建或者<code>git clone</code>一个项目的时候，项目目录会隐藏一个<code>.git</code>子目录，其作用是用来跟踪管理版本库的</p>\n<p><code>Git</code> 中所有数据在存储前都计算校验和，然后以校验和来引用，所以在我们修改或者删除文件的时候，<code>git</code>能够知道</p>\n<p><code>Git</code>用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）， 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来，如下：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>当我们修改文件的时候，<code>git</code>就会修改文件的状态，可以通过<code>git status</code>进行查询，状态情况如下：</p>\n<ul>\n<li>已修改（modified）：表示修改了文件，但还没保存到数据库中。</li>\n<li>已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>\n<li>已提交（committed）：表示数据已经安全的保存在本地数据库中。</li>\n</ul>\n<p>文件状态对应的，不同状态的文件在<code>Git</code>中处于不同的工作区域，主要分成了四部分：</p>\n<ul>\n<li>工作区：相当于本地写代码的区域，如 git clone 一个项目到本地，相当于本地克隆了远程仓库项目的一个副本</li>\n<li>暂存区：暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中</li>\n<li>本地仓库：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库</li>\n<li>远程仓库：远程的仓库，如 github</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3273c9a0-f79c-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、命令</h2>\n<p>从上图可以看到，<code>git</code>日常简单的使用就只有上图 6 个命令：</p>\n<ul>\n<li>add</li>\n<li>commit</li>\n<li>push</li>\n<li>pull</li>\n<li>clone</li>\n<li>checkout</li>\n</ul>\n<p>但实际上还有很多命令，如果想要熟练使用，还有 60 个多命令，通过这些命令的配合使用，能够提高个人工作效率和团队协助能力</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/Git\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/Git</a></li>\n<li><a href=\"https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-28T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "git"
      ]
    },
    {
      "title": "说说 Git 中 HEAD、工作树和索引之间的区别？",
      "url": "https://www.h7ml.cn/posts/interview/git/HEAD_tree_index.html",
      "id": "https://www.h7ml.cn/posts/interview/git/HEAD_tree_index.html",
      "summary": "前端物语|面试物语-说说 Git 中 HEAD、工作树和索引之间的区别？",
      "content_html": "<h1> 说说 Git 中 HEAD、工作树和索引之间的区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2de056a0-fa40-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、HEAD</h2>\n<p>在<code>git</code>中，可以存在很多分支，其本质上是一个指向<code>commit</code>对象的可变指针，而<code>Head</code>是一个特别的指针，是一个指向你正在工作中的本地分支的指针</p>\n<p>简单来讲，就是你现在在哪儿，HEAD 就指向哪儿</p>\n<p>例如当前我们处于<code>master</code>分支，所以<code>HEAD</code>这个指针指向了<code>master</code>分支指针</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/36cb0da0-fa40-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>然后通过调用<code>git checkout test</code>切换到<code>test</code>分支，那么<code>HEAD</code>则指向<code>test</code>分支，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3e86ba80-fa40-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>但我们在<code>test</code>分支再一次<code>commit</code>信息的时候，<code>HEAD</code>指针仍然指向了<code>test</code>分支指针，而<code>test</code>分支指针已经指向了最新创建的提交，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/439839b0-fa66-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>这个<code>HEAD</code>存储的位置就在<code>.git/HEAD</code>目录中，查看信息可以看到<code>HEAD</code>指向了另一个文件</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个文件的内容是一串哈希码，而这个哈希码正是<code>master</code>分支上最新的提交所对应的哈希码</p>\n<p>所以，当我们切换分支的时候，<code>HEAD</code>指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</p>\n<p>所以，HEAD 指针 ——–&gt; 分支指针 ——–&gt; 最新提交</p>\n<h2> 二、工作树和索引</h2>\n<p>在<code>Git</code>管理下，大家实际操作的目录被称为工作树，也就是工作区域</p>\n<p>在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域，也被称为暂存区域</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/46e5ac40-fa40-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p><code>Git</code>在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库</p>\n<p>因此，要提交文件，首先需要把文件加入到索引区域中。</p>\n<p>所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交</p>\n<h2> 三、区别</h2>\n<p>从所在的位置来看：</p>\n<ul>\n<li>\n<p>HEAD 指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交</p>\n</li>\n<li>\n<p>工作树是查看和编辑的（源）文件的实际内容</p>\n</li>\n<li>\n<p>索引是放置你想要提交给 git 仓库文件的地方，如工作树的代码通过 git add 则添加到 git 索引中，通过 git commit 则将索引区域的文件提交到 git 仓库中</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://backlog.com/git-tutorial/cn/intro/intro1_4.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://backlog.com/git-tutorial/cn/intro/intro1_4.html</a></li>\n<li><a href=\"https://juejin.cn/post/6844903598522908686\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903598522908686</a></li>\n<li><a href=\"https://www.zsythink.net/archives/3412\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zsythink.net/archives/3412</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-01T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "git"
      ]
    },
    {
      "title": "前端物语|面试物语-git",
      "url": "https://www.h7ml.cn/posts/interview/git/",
      "id": "https://www.h7ml.cn/posts/interview/git/",
      "summary": "说说你对 Git 的理解？ 说说 Git 中 HEAD、工作树和索引之间的区别？ 说说你对版本管理的理解？常用的版本管理工具有哪些？ 说说 Git 常用的命令有哪些？ ,- 说说 Git 中 fork, clone,branch 这三个概念，有什么区别? [ 说说你对 git rebase 和 git merge 的理解？区别？](https://www.h7ml.cn/posts/interview/git/gitRebase_ gitMerge) [ 说说对 git pull 和 git fetch 的理解？有什么区别？](https://www.h7ml.cn/posts/interview/git/git_pull _git_fetch) [ 说说你对 git reset 和 git revert 的理解？区别？](https://www.h7ml.cn/posts/interview/git/git_reset_ git_revert) 说说你对 git stash 的理解？应用场景？",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/interview/git/Git\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 Git 的理解？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/git/HEAD_tree_index\" target=\"_blank\" rel=\"noopener noreferrer\">说说 Git 中 HEAD、工作树和索引之间的区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/git/Version_control\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对版本管理的理解？常用的版本管理工具有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/git/command\" target=\"_blank\" rel=\"noopener noreferrer\">说说 Git 常用的命令有哪些？</a> ,- <a href=\"https://www.h7ml.cn/posts/interview/git/fork_clone_branch\" target=\"_blank\" rel=\"noopener noreferrer\">说说 Git 中 fork, clone,branch 这三个概念，有什么区别?</a></li>\n<li>[ 说说你对 git rebase 和 git merge 的理解？区别？](<a href=\"https://www.h7ml.cn/posts/interview/git/gitRebase_\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/posts/interview/git/gitRebase_</a> gitMerge)</li>\n<li>[ 说说对 git pull 和 git fetch 的理解？有什么区别？](<a href=\"https://www.h7ml.cn/posts/interview/git/git_pull\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/posts/interview/git/git_pull</a> _git_fetch)</li>\n<li>[ 说说你对 git reset 和 git revert 的理解？区别？](<a href=\"https://www.h7ml.cn/posts/interview/git/git_reset_\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/posts/interview/git/git_reset_</a> git_revert)</li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/git/git_stash\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 git stash 的理解？应用场景？</a></li>\n</ul>\n",
      "date_published": "2023-03-23T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "git"
      ]
    },
    {
      "title": "说说你对版本管理的理解？常用的版本管理工具有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/git/Version_control.html",
      "id": "https://www.h7ml.cn/posts/interview/git/Version_control.html",
      "summary": "前端物语|面试物语-说说你对版本管理的理解？常用的版本管理工具有哪些？",
      "content_html": "<h1> 说说你对版本管理的理解？常用的版本管理工具有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f0e8a2d0-f5ac-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>版本控制（Version control），是维护工程蓝图的标准作法，能追踪工程蓝图从诞生一直到定案的过程。此外，版本控制也是一种软件工程技巧，借此能在软件开发的过程中，确保由不同人所编辑的同一程序文件都得到同步</p>\n<p>透过文档控制，能记录任何工程项目内各个模块的改动历程，并为每次改动编上序号</p>\n<p>一种简单的版本控制形式如下：赋给图的初版一个版本等级“A”。当做了第一次改变后，版本等级改为“B”，以此类推</p>\n<p>版本控制能提供项目的设计者，将设计恢复到之前任一状态的选择权</p>\n<p>简言之，你的修改只要提到到版本控制系统，基本都可以找回，版本控制系统就像一台时光机器，可以让你回到任何一个时间点</p>\n<h2> 二、有哪些</h2>\n<p>版本控制系统在当今的软件开发中，被认为是理所当然的配备工具之一，根据类别可以分成：</p>\n<ul>\n<li>本地版本控制系统</li>\n<li>集中式版本控制系统</li>\n<li>分布式版本控制系统</li>\n</ul>\n<h3> 本地版本控制系统</h3>\n<p>结构如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c545ded0-f5ad-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>优点：</p>\n<ul>\n<li>简单，很多系统中都有内置</li>\n<li>适合管理文本，如系统配置</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>其不支持远程操作，因此并不适合多人版本开发</li>\n</ul>\n<h3> 集中式版本控制系统</h3>\n<p>结构如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8b4b3040-f5ad-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>优点：</p>\n<ul>\n<li>适合多人团队协作开发</li>\n<li>代码集中化管理</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>单点故障</li>\n<li>必须联网，无法单机工作</li>\n</ul>\n<p>代表工具有<code>SVN</code>、<code>CVS</code>：</p>\n<h3> SVN</h3>\n<p><code>TortoiseSVN</code>是一款非常易于使用的跨平台的 版本控制/版本控制/源代码控制软件</p>\n<h3> CVS</h3>\n<p><code>CVS</code>是版本控制系统，是源配置管理（SCM）的重要组成部分。使用它，您可以记录源文件和文档的历史记录</p>\n<p>老牌的版本控制系统，它是基于客户端/服务器的行为使得其可容纳多用户，构成网络也很方便</p>\n<p>这一特性使得<code>CVS</code>成为位于不同地点的人同时处理数据文件（特别是程序的源代码）时的首选</p>\n<h4> 分布式版本控制系统</h4>\n<p>结构如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/4301a260-f5ad-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>优点：</p>\n<ul>\n<li>适合多人团队协作开发</li>\n<li>代码集中化管理</li>\n<li>可以离线工作</li>\n<li>每个计算机都是一个完整仓库</li>\n</ul>\n<p>分布式版本管理系统每个计算机都有一个完整的仓库，可本地提交，可以做到离线工作，则不用像集中管理那样因为断网情况而无法工作</p>\n<p>代表工具为<code>Git</code>、<code>HG</code>：</p>\n<h3> Git</h3>\n<p><code>Git</code>是目前世界上最先进的分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务</p>\n<p>特性：易于学习，占用内存小，具有闪电般快速的性能</p>\n<p>使用<code>Git</code>和<code>Gitlab</code>搭建版本控制环境是现在互联网公司最流行的版本控制方式</p>\n<h3> HG</h3>\n<p><code>Mercurial</code>是一个免费的分布式源代码管理工具。它可以有效地处理任何规模的项目，并提供简单直观的界面</p>\n<p><code>Mercurial</code>是一种轻量级分布式版本控制系统，采用 <code>Python</code>语言实现，易于学习和使用，扩展性强</p>\n<h2> 三、总结</h2>\n<p>版本控制系统的优点如下：</p>\n<ul>\n<li>记录文件所有历史变化，这是版本控制系统的基本能力</li>\n<li>随时恢复到任意时间点，历史记录功能使我们不怕改错代码了</li>\n<li>支持多功能并行开发，通常版本控制系统都支持分支，保证了并行开发的可行</li>\n<li>多人协作并行开发，对于多人协作项目，支持多人协作开发的版本管理将事半功倍</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://pm.readthedocs.io/vcs/understanding.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://pm.readthedocs.io/vcs/understanding.html</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/版本控制</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-28T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "git"
      ]
    },
    {
      "title": "说说 Git 常用的命令有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/git/command.html",
      "id": "https://www.h7ml.cn/posts/interview/git/command.html",
      "summary": "前端物语|面试物语-说说 Git 常用的命令有哪些？",
      "content_html": "<h1> 说说 Git 常用的命令有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f66b3290-f7af-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、前言</h2>\n<p><code>git</code>的操作可以通过命令的形式如执行，日常使用就如下图 6 个命令即可</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fe150520-f7af-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>实际上，如果想要熟练使用，超过 60 多个命令需要了解，下面则介绍下常见的的<code>git</code>命令</p>\n<h2> 二、有哪些</h2>\n<h2> 配置</h2>\n<p><code>Git</code>自带一个 <code>git config</code> 的工具来帮助设置控制 <code>Git</code>外观和行为的配置变量，在我们安装完<code>git</code>之后，第一件事就是设置你的用户名和邮件地址</p>\n<p>后续每一个提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改</p>\n<p>设置提交代码时的用户信息命令如下：</p>\n<ul>\n<li>git config [--global] <a href=\"http://user.name\" target=\"_blank\" rel=\"noopener noreferrer\">user.name</a> \"[name]\"</li>\n<li>git config [--global] user.email \"[email address]\"</li>\n</ul>\n<h3> 启动</h3>\n<p>一个<code>git</code>项目的初始有两个途径，分别是：</p>\n<ul>\n<li>git init [project-name]：创建或在当前目录初始化一个 git 代码库</li>\n<li>git clone url：下载一个项目和它的整个代码历史</li>\n</ul>\n<h3> 日常基本操作</h3>\n<p>在日常工作中，代码常用的基本操作如下：</p>\n<ul>\n<li>git init 初始化仓库，默认为 master 分支</li>\n<li>git add . 提交全部文件修改到缓存区</li>\n<li>git add &lt;具体某个文件路径+全名&gt; 提交某些文件到缓存区</li>\n<li>git diff 查看当前代码 add 后，会 add 哪些内容</li>\n<li>git diff --staged 查看现在 commit 提交后，会提交哪些内容</li>\n<li>git status 查看当前分支状态</li>\n<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</li>\n<li>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某个分支合并</li>\n<li>git commit -m \"&lt;注释&gt;\" 提交代码到本地仓库，并写提交注释</li>\n<li>git commit -v 提交时显示所有 diff 信息</li>\n<li>git commit --amend [file1] [file2] 重做上一次 commit，并包括指定文件的新变化</li>\n</ul>\n<p>关于提交信息的格式，可以遵循以下的规则：</p>\n<ul>\n<li>feat: 新特性，添加功能</li>\n<li>fix: 修改 bug</li>\n<li>refactor: 代码重构</li>\n<li>docs: 文档修改</li>\n<li>style: 代码格式修改, 注意不是 css 修改</li>\n<li>test: 测试用例修改</li>\n<li>chore: 其他修改, 比如构建流程, 依赖管理</li>\n</ul>\n<h3> 分支操作</h3>\n<ul>\n<li>git branch 查看本地所有分支</li>\n<li>git branch -r 查看远程所有分支</li>\n<li>git branch -a 查看本地和远程所有分支</li>\n<li>git merge &lt;分支名&gt; 合并分支</li>\n<li>git merge --abort 合并分支出现冲突时，取消合并，一切回到合并前的状态</li>\n<li>git branch &lt;新分支名&gt; 基于当前分支，新建一个分支</li>\n<li>git checkout --orphan &lt;新分支名&gt; 新建一个空分支（会保留之前分支的所有文件）</li>\n<li>git branch -D &lt;分支名&gt; 删除本地某个分支</li>\n<li>git push &lt;远程库名&gt; :&lt;分支名&gt; 删除远程某个分支</li>\n<li>git branch &lt;新分支名称&gt; &lt;提交 ID&gt; 从提交历史恢复某个删掉的某个分支</li>\n<li>git branch -m &lt;原分支名&gt; &lt;新分支名&gt; 分支更名</li>\n<li>git checkout &lt;分支名&gt; 切换到本地某个分支</li>\n<li>git checkout &lt;远程库名&gt;/&lt;分支名&gt; 切换到线上某个分支</li>\n<li>git checkout -b &lt;新分支名&gt; 把基于当前分支新建分支，并切换为这个分支</li>\n</ul>\n<h3> 远程同步</h3>\n<p>远程操作常见的命令：</p>\n<ul>\n<li>git fetch [remote] 下载远程仓库的所有变动</li>\n<li>git remote -v 显示所有远程仓库</li>\n<li>git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并</li>\n<li>git fetch 获取线上最新版信息记录，不合并</li>\n<li>git push [remote] [branch] 上传本地指定分支到远程仓库</li>\n<li>git push [remote] --force 强行推送当前分支到远程仓库，即使有冲突</li>\n<li>git push [remote] --all 推送所有分支到远程仓库</li>\n</ul>\n<h3> 撤销</h3>\n<ul>\n<li>\n<p>git checkout [file] 恢复暂存区的指定文件到工作区</p>\n</li>\n<li>\n<p>git checkout [commit] [file] 恢复某个 commit 的指定文件到暂存区和工作区</p>\n</li>\n<li>\n<p>git checkout . 恢复暂存区的所有文件到工作区</p>\n</li>\n<li>\n<p>git reset [commit] 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</p>\n</li>\n<li>\n<p>git reset --hard 重置暂存区与工作区，与上一次 commit 保持一致</p>\n</li>\n<li>\n<p>git reset [file] 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</p>\n</li>\n<li>\n<p>git revert [commit] 后者的所有变化都将被前者抵消，并且应用到当前分支</p>\n</li>\n</ul>\n<blockquote>\n<p><code>reset</code>：真实硬性回滚，目标版本后面的提交记录全部丢失了</p>\n<p><code>revert</code>：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有</p>\n</blockquote>\n<h3> 存储操作</h3>\n<p>你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作，但又不想提交这些杂乱的代码，这时候可以将代码进行存储</p>\n<ul>\n<li>\n<p>git stash 暂时将未提交的变化移除</p>\n</li>\n<li>\n<p>git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏</p>\n</li>\n<li>\n<p>git stash list 查看所有储藏中的工作</p>\n</li>\n<li>\n<p>git stash apply &lt;储藏的名称&gt; 取出储藏中对应的工作状态进行恢复，不会删除储藏</p>\n</li>\n<li>\n<p>git stash clear 清空所有储藏中的工作</p>\n</li>\n<li>\n<p>git stash drop &lt;储藏的名称&gt; 删除对应的某个储藏</p>\n</li>\n</ul>\n<h2> 三、总结</h2>\n<p><code>git</code>常用命令速查表如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/0a10f3c0-f7b0-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li>\n<p><a href=\"https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p>\n</li>\n<li>\n<p><a href=\"https://segmentfault.com/a/1190000017875714\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000017875714</a></p>\n</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-25T02:16:04.564Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "git"
      ]
    },
    {
      "title": "说说 git 发生冲突的场景？如何解决？",
      "url": "https://www.h7ml.cn/posts/interview/git/conflict.html",
      "id": "https://www.h7ml.cn/posts/interview/git/conflict.html",
      "summary": "前端物语|面试物语-说说 git 发生冲突的场景？如何解决？",
      "content_html": "<h1> 说说 git 发生冲突的场景？如何解决？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8aeccc40-fdb3-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>一般情况下，出现分支的场景有如下：</p>\n<ul>\n<li>多个分支代码合并到一个分支时</li>\n<li>多个分支向同一个远端分支推送</li>\n</ul>\n<p>具体情况就是，多个分支修改了同一个文件（任何地方）或者多个分支修改了同一个文件的名称</p>\n<p>如果两个分支中分别修改了不同文件中的部分，是不会产生冲突，直接合并即可</p>\n<p>应用在命令中，就是<code>push</code>、<code>pull</code>、<code>stash</code>、<code>rebase</code>等命令下都有可能产生冲突情况，从本质上来讲，都是<code>merge</code>和<code>patch</code>（应用补丁）时产生冲突</p>\n<h2> 二、分析</h2>\n<p>在本地主分值<code>master</code>创建一个<code>a.txt</code>文件，文件起始位置写上<code>master commit</code>，如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/959ade20-fdb3-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>然后提交到仓库：</p>\n<ul>\n<li>git add a.txt</li>\n<li>git commit -m 'master first commit'</li>\n</ul>\n<p>创建一个新的分支<code>featurel1</code>分支，并进行切换，如下：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>然后修改<code>a.txt</code>文件首行文字为 <code>featurel commit</code>，然后添加到暂存区，并开始进行提交到仓库：</p>\n<ul>\n<li>git add a.txt</li>\n<li>git commit -m 'featurel first change'</li>\n</ul>\n<p>然后通过<code>git checkout master</code>切换到主分支，通过<code>git merge</code>进行合并，发现不会冲突</p>\n<p>此时<code>a.txt</code>文件的内容变成<code>featurel commit</code>，没有出现冲突情况，这是因为<code>git</code>在内部发生了快速合并</p>\n<blockquote>\n<p>如果当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前”(fast forward)操作</p>\n<p>git 不创建任何新的提交(commit)，只是将当前分支指向合并进来的分支</p>\n</blockquote>\n<p>如果此时切换到<code>featurel</code>分支，将文件的内容修改成<code>featrue second commit</code>，然后提交到本地仓库</p>\n<p>然后切换到主分支，如果此时在<code>a.txt</code>文件再次修改，修改成<code>mastet second commit</code>，然后再次提交到本地仓库</p>\n<p>此时，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a05488c0-fdb3-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>这种情况下，无法执行快速合并，只能试图把各自的修改合并起来，但这种合并就可能会有冲突</p>\n<p>现在通过<code>git merge featurel</code>进行分支合并，如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b0991d90-fdb3-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从冲突信息可以看到，<code>a.txt</code>发生冲突，必须手动解决冲突之后再提交</p>\n<p>而<code>git status</code>同样可以告知我们冲突的文件：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c5823430-fdb3-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>打开<code>a.txt</code>文件，可以看到如下内容：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ce7a0a90-fdb3-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p><code>git</code>用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容：</p>\n<ul>\n<li>&lt;&lt;&lt;&lt;&lt;&lt;&lt; 和 ======= 之间的区域就是当前更改的内容</li>\n<li>======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 之间的区域就是传入进来更改的内容</li>\n</ul>\n<p>现在要做的事情就是将冲突的内容进行更改，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，<code>Git</code>就会将它们标记为冲突已解决然后再提交：</p>\n<ul>\n<li>git add a.txt</li>\n<li>git commit -m \"conflict fixed\"</li>\n</ul>\n<p>此时<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d7421e60-fdb3-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>使用<code>git log</code>命令可以看到合并的信息：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e0dfd1b0-fdb3-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、总结</h2>\n<p>当<code>Git</code>无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成</p>\n<p>解决冲突就是把<code>Git</code>合并失败的文件手动编辑为我们希望的内容，再提交</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/896043488029600/900004111093344\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.liaoxuefeng.com/wiki/896043488029600/900004111093344</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-23T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "git"
      ]
    },
    {
      "title": "说说 Git 中 fork, clone,branch 这三个概念，有什么区别?",
      "url": "https://www.h7ml.cn/posts/interview/git/fork_clone_branch.html",
      "id": "https://www.h7ml.cn/posts/interview/git/fork_clone_branch.html",
      "summary": "前端物语|面试物语-说说 Git 中 fork, clone,branch 这三个概念，有什么区别?",
      "content_html": "<h1> 说说 Git 中 fork, clone,branch 这三个概念，有什么区别?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9c4eb9a0-f7ad-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<h3> fork</h3>\n<p><code>fork</code>，英语翻译过来就是叉子，动词形式则是分叉，如下图，从左到右，一条直线变成多条直线</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ad04ade0-f7ad-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>转到<code>git</code>仓库中，<code>fork</code>则可以代表分叉、克隆 出一个（仓库的）新拷贝</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b4b31450-f7ad-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>包含了原来的仓库（即 upstream repository，上游仓库）所有内容，如分支、Tag、提交</p>\n<p>如果想将你的修改合并到原项目中时，可以通过的 Pull Request 把你的提交贡献回 原仓库</p>\n<h3> clone</h3>\n<p><code>clone</code>，译为克隆，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</p>\n<p>执行<code>clone</code>命令后，会在当前目录下创建一个名为<code>xxx</code>的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝</p>\n<p>默认配置下远程 <code>Git</code> 仓库中的每一个文件的每一个版本都将被拉取下来</p>\n<h3> branch</h3>\n<p><code>branch</code>，译为分支，其作用简单而言就是开启另一个分支， 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线</p>\n<p><code>Git</code> 处理分支的方式十分轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷</p>\n<p>在我们开发中，默认只有一条<code>master</code>分支，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7fa8e9c0-f923-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>通过<code>git branch</code>可以创建一个分支，但并不会自动切换到新分支中去</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/89efd560-f923-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>通过<code>git checkout</code>可以切换到另一个<code>testing</code>分支</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/91d1cef0-f923-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、如何使用</h2>\n<h3> fork</h3>\n<p>当你在<code>github</code>发现感兴趣开源项目的时候，可以通过点击<code>github</code>仓库中右上角<code>fork</code>标识的按钮，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bc4c4510-f7ad-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>点击这个操作后会将这个仓库的文件、提交历史、issues 和其余东西的仓库复制到自己的<code>github</code>仓库中，而你本地仓库是不会存在任何更改</p>\n<p>然后你就可以通过<code>git clone</code>对你这个复制的远程仓库进行克隆</p>\n<p>后续更改任何东西都可以在本地完成，如<code>git add</code>、<code>git commit</code>一系列的操作，然后通过<code>push</code>命令推到自己的远程仓库</p>\n<p>如果希望对方接受你的修改，可以通过发送<code>pull requests</code>给对方，如果对方接受。则会将你的修改内容更新到仓库中</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c5265a40-f7ad-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>整体流程如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ced8ce10-f7ad-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> clone</h3>\n<p>在<code>github</code>中，开源项目右侧存在<code>code</code>按钮，点击后则会显示开源项目<code>url</code>信息，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d8685090-f7ad-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>通过<code>git clone xxx</code>则能完成远程项目的下载</p>\n<h3> branch</h3>\n<p>可通过<code>git branch</code>进行查看当前的分支状态，</p>\n<p>如果给了<code>--list</code>，或者没有非选项参数，现有的分支将被列出；当前的分支将以绿色突出显示，并标有星号</p>\n<p>以及通过<code>git branch</code>创建一个新的分支出来</p>\n<h2> 三、区别</h2>\n<p>其三者区别如下：</p>\n<ul>\n<li>fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”</li>\n<li>clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓</li>\n<li>branch 特征与 fork 很类似，fork 得到的是一个新的、自己的代码仓，而 branch 得到的是一个代码仓的一个新分支</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93\" target=\"_blank\" rel=\"noopener noreferrer\">https://git-scm.com/book/zh/v2/Git-基础-获取-Git-仓库</a></li>\n<li><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B\" target=\"_blank\" rel=\"noopener noreferrer\">https://git-scm.com/book/zh/v2/Git-分支-分支简介</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-06T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "git"
      ]
    },
    {
      "title": "说说你对 git rebase 和 git merge 的理解？区别？",
      "url": "https://www.h7ml.cn/posts/interview/git/gitRebase_%20gitMerge.html",
      "id": "https://www.h7ml.cn/posts/interview/git/gitRebase_%20gitMerge.html",
      "summary": "前端物语|面试物语-说说你对 git rebase 和 git merge 的理解？区别？",
      "content_html": "<h1> 说说你对 git rebase 和 git merge 的理解？区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/77590970-fdd4-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>在使用 <code>git</code> 进行版本管理的项目中，当完成一个特性的开发并将其合并到 <code>master</code> 分支时，会有两种方式：</p>\n<ul>\n<li>git merge</li>\n<li>git rebase</li>\n</ul>\n<p><code>git rebase</code> 与 <code>git merge</code>都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同</p>\n<p>用法上两者也十分的简单：</p>\n<h3> git merge</h3>\n<p>将当前分支合并到指定分支，命令用法如下：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> git rebase</h3>\n<p>将当前分支移植到指定分支或指定<code>commit</code>之上，用法如下：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>常见的参数有<code>--continue</code>，用于解决冲突之后，继续执行<code>rebase</code></p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 二、分析</h2>\n<h3> git merge</h3>\n<p>通过<code>git merge</code>将当前分支与<code>xxx</code>分支合并，产生的新的<code>commit</code>对象有两个父节点</p>\n<p>如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并</p>\n<p>举个例子，<code>bugfix</code>分支是从<code>master</code>分支分叉出来的，如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/88410a30-fdd4-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>合并<code>bugfix</code>分支到<code>master</code>分支时，如果<code>master</code>分支的状态没有被更改过，即 <code>bugfix</code>分支的历史记录包含<code>master</code>分支所有的历史记录</p>\n<p>所以通过把<code>master</code>分支的位置移动到<code>bugfix</code>的最新分支上，就完成合并</p>\n<p>如果<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/929eb220-fdd4-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>这时候使用<code>git merge</code>的时候，会生成一个新的提交，并且<code>master</code>分支的<code>HEAD</code>会移动到新的分支上，如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9fdfa3e0-fdd4-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照</p>\n<h3> git rebase</h3>\n<p>同样，<code>master</code>分支的历史记录在创建<code>bugfix</code>分支后又有新的提交，如下情况：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ab2d5120-fdd4-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>通过<code>git rebase</code>，会变成如下情况：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b72aed70-fdd4-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在移交过程中，如果发生冲突，需要修改各自的冲突，如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c9ba0e80-fdd4-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p><code>rebase</code>之后，<code>master</code>的<code>HEAD</code>位置不变。因此，要合并<code>master</code>分支和<code>bugfix</code>分支</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/dc660660-fdd4-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从上面可以看到，<code>rebase</code>会找到不同的分支的最近共同祖先，如上图的<code>B</code></p>\n<p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交<code>X</code>和<code>Y</code>也没有被销毁，只是简单地不能再被访问或者使用）</p>\n<p>然后将当前分支指向目标最新位置<code>D</code>, 然后将之前另存为临时文件的修改依序应用</p>\n<h2> 三、区别</h2>\n<p>从上面可以看到，<code>merge</code>和<code>rebasea</code>都是合并历史记录，但是各自特性不同：</p>\n<h3> merge</h3>\n<p>通过<code>merge</code>合并分支会新增一个<code>merge commit</code>，然后将两个分支的历史联系起来</p>\n<p>其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂</p>\n<h3> rebase</h3>\n<p><code>rebase</code>会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交</p>\n<p>主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 <code>git merge</code>所需的不必要的合并提交</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/361182707\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/361182707</a></li>\n<li><a href=\"https://yuweijun.github.io/git-zh/1-git-branching.html#_rebasing\" target=\"_blank\" rel=\"noopener noreferrer\">https://yuweijun.github.io/git-zh/1-git-branching.html#_rebasing</a></li>\n<li><a href=\"https://backlog.com/git-tutorial/cn/stepup/stepup1_4.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://backlog.com/git-tutorial/cn/stepup/stepup1_4.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-01T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "git"
      ]
    },
    {
      "title": "说说对 git pull 和 git fetch 的理解？有什么区别？",
      "url": "https://www.h7ml.cn/posts/interview/git/git_pull%20_git_fetch.html",
      "id": "https://www.h7ml.cn/posts/interview/git/git_pull%20_git_fetch.html",
      "summary": "前端物语|面试物语-说说对 git pull 和 git fetch 的理解？有什么区别？",
      "content_html": "<h1> 说说对 git pull 和 git fetch 的理解？有什么区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/cc90c050-fac2-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>先回顾两个命令的定义</p>\n<ul>\n<li>git fetch 命令用于从另一个存储库下载对象和引用</li>\n<li>git pull 命令用于从另一个存储库或本地分支获取并集成(整合)</li>\n</ul>\n<p>再来看一次<code>git</code>的工作流程图，如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d523ba60-fac2-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>可以看到，<code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中</p>\n<p>而<code>git pull</code> 则是将远程主机的最新内容拉下来后直接合并，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决</p>\n<p>在我们本地的<code>git</code>文件中对应也存储了<code>git</code>本地仓库分支的<code>commit ID</code>和 跟踪的远程分支的<code>commit ID</code>，对应文件如下：</p>\n<ul>\n<li>.git/refs/head/[本地分支]</li>\n<li>.git/refs/remotes/[正在跟踪的分支]</li>\n</ul>\n<p>使用 <code>git fetch</code>更新代码，本地的库中<code>master</code>的<code>commitID</code>不变</p>\n<p>但是与<code>git</code>上面关联的那个<code>orign/master</code>的<code>commit ID</code>发生改变</p>\n<p>这时候我们本地相当于存储了两个代码的版本号，我们还要通过<code>merge</code>去合并这两个不同的代码版本</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fd23ff70-fb12-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>也就是<code>fetch</code>的时候本地的<code>master</code>没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地<code>merge</code>合并这两个版本号的代码</p>\n<p>相比之下，使用<code>git pull</code>就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/091b8140-fb13-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、用法</h2>\n<p>一般远端仓库里有新的内容更新，当我们需要把新内容下载的时候，就使用到<code>git pull</code>或者<code>git fetch</code>命令</p>\n<h3> fetch</h3>\n<p>用法如下：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>例如从远程的<code>origin</code>仓库的<code>master</code>分支下载代码到本地并新建一个<code>temp</code>分支</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果上述没有冒号，则表示将远程<code>origin</code>仓库的<code>master</code>分支拉取下来到本地当前分支</p>\n<p>这里<code>git fetch</code>不会进行合并，执行后需要手动执行<code>git merge</code>合并，如下：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> pull</h3>\n<p>两者的用法十分相似，<code>pull</code>用法如下：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>例如将远程主机<code>origin</code>的<code>master</code>分支拉取过来，与本地的<code>branchtest</code>分支合并，命令如下：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>同样如果上述没有冒号，则表示将远程<code>origin</code>仓库的<code>master</code>分支拉取下来与本地当前分支合并</p>\n<h2> 三、区别</h2>\n<p>相同点：</p>\n<ul>\n<li>在作用上他们的功能是大致相同的，都是起到了更新代码的作用</li>\n</ul>\n<p>不同点：</p>\n<ul>\n<li>git pull 是相当于从远程仓库获取最新版本，然后再与本地分支 merge，即 git pull = git fetch + git merge</li>\n<li>相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/123370920\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/123370920</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017030384\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000017030384</a></li>\n<li><a href=\"https://juejin.cn/post/6844903921794859021\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903921794859021</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-08T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "git"
      ]
    },
    {
      "title": "说说你对 git reset 和 git revert 的理解？区别？",
      "url": "https://www.h7ml.cn/posts/interview/git/git_reset_%20git_revert.html",
      "id": "https://www.h7ml.cn/posts/interview/git/git_reset_%20git_revert.html",
      "summary": "前端物语|面试物语-说说你对 git reset 和 git revert 的理解？区别？",
      "content_html": "<h1> 说说你对 git reset 和 git revert 的理解？区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/046b4440-ff74-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<h3> git reset</h3>\n<p><code>reset</code>用于回退版本，可以遗弃不再使用的提交</p>\n<p>执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ab4d0c00-ff72-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> git revert</h3>\n<p>在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bd12c290-ff72-11eb-991d-334fd31f0201.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、如何用</h2>\n<h3> git reset</h3>\n<p>当没有指定<code>ID</code>的时候，默认使用<code>HEAD</code>，如果指定<code>ID</code>，那么就是基于指向<code>ID</code>去变动暂存区或工作区的内容</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>日志<code>ID</code>可以通过查询，可以<code>git log</code>进行查询，如下：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>常见命令如下：</p>\n<ul>\n<li>\n<p>--mixed（默认）：默认的时候，只有暂存区变化</p>\n</li>\n<li>\n<p>--hard 参数：如果使用 --hard 参数，那么工作区也会变化</p>\n</li>\n<li>\n<p>--soft：如果使用 --soft 参数，那么暂存区和工作区都不会变化</p>\n</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/225b41e0-ff73-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> git revert</h3>\n<p>跟<code>git reset</code>用法基本一致，<code>git revert</code> 撤销某次操作，此次操作之前和之后的 <code>commit</code>和<code>history</code>都会保留，并且把这次撤销，作为一次最新的提交，如下：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果撤销前一个版本，可以通过如下命令：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>撤销前前一次，如下：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 三、区别</h2>\n<p>撤销（revert）被设计为撤销公开的提交（比如已经 push）的安全方式，<code>git reset</code>被设计为重设本地更改</p>\n<p>因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销</p>\n<p>两者主要区别如下：</p>\n<ul>\n<li>git revert 是用一次新的 commit 来回滚之前的 commit，git reset 是直接删除指定的 commit</li>\n<li>git reset 是把 HEAD 向后移动了一下，而 git revert 是 HEAD 继续前进，只是新的 commit 的内容和要 revert 的内容正好相反，能够抵消要被 revert 的内容</li>\n<li>在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别</li>\n</ul>\n<blockquote>\n<p>git revert 是用一次逆向的 commit“中和”之前的提交，因此日后合并老的 branch 时，之前提交合并的代码仍然存在，导致不能够重新合并</p>\n<p>但是 git reset 是之间把某些 commit 在某个 branch 上删除，因而和老的 branch 再次 merge 时，这些被回滚的 commit 应该还会被引入</p>\n</blockquote>\n<ul>\n<li>如果回退分支的代码以后还需要的情况则使用<code>git revert</code>， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用<code>git reset</code></li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844903542931587086\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903542931587086</a></li>\n<li><a href=\"https://marklodato.github.io/visual-git-guide/index-zh-cn.html#reset\" target=\"_blank\" rel=\"noopener noreferrer\">https://marklodato.github.io/visual-git-guide/index-zh-cn.html#reset</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-08T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "git"
      ]
    },
    {
      "title": "说说你对 git stash 的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/git/git_stash.html",
      "id": "https://www.h7ml.cn/posts/interview/git/git_stash.html",
      "summary": "前端物语|面试物语-说说你对git stash 的理解？应用场景？",
      "content_html": "<h1> 说说你对 git stash 的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/83ddf210-fd6f-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>stash，译为存放，在 git 中，可以理解为保存当前工作进度，会把暂存区和工作区的改动进行保存，这些修改会保存在一个栈上</p>\n<p>后续你可以在任何时候任何分支重新将某次的修改推出来，重新应用这些更改的代码</p>\n<p>默认情况下，<code>git stash</code>会缓存下列状态的文件：</p>\n<ul>\n<li>添加到暂存区的修改（staged changes）</li>\n<li>Git 跟踪的但并未添加到暂存区的修改（unstaged changes）</li>\n</ul>\n<p>但以下状态的文件不会缓存：</p>\n<ul>\n<li>在工作目录中新的文件（untracked files）</li>\n<li>被忽略的文件（ignored files）</li>\n</ul>\n<p>如果想要上述的文件都被缓存，可以使用<code>-u</code>或者<code>--include-untracked</code>可以工作目录新的文件，使用<code>-a</code>或者<code>--all</code>命令可以当前目录下的所有修改</p>\n<h2> 二、如何使用</h2>\n<p>关于<code>git stash</code>常见的命令如下：</p>\n<ul>\n<li>\n<p>git stash</p>\n</li>\n<li>\n<p>git stash save</p>\n</li>\n<li>\n<p>git stash list</p>\n</li>\n<li>\n<p>git stash pop</p>\n</li>\n<li>\n<p>git stash apply</p>\n</li>\n<li>\n<p>git stash show</p>\n</li>\n<li>\n<p>git stash drop</p>\n</li>\n<li>\n<p>git stash clear</p>\n</li>\n</ul>\n<h3> git stash</h3>\n<p>保存当前工作进度，会把暂存区和工作区的改动保存起来</p>\n<h3> git stash save</h3>\n<p><code>git stash save</code>可以用于存储修改.并且将<code>git</code>的工作状态切回到<code>HEAD</code>也就是上一次合法提交上</p>\n<p>如果给定具体的文件路径,<code>git stash</code>只会处理路径下的文件.其他的文件不会被存储，其存在一些参数：</p>\n<ul>\n<li>\n<p>--keep-index 或者 -k 只会存储为加入 git 管理的文件</p>\n</li>\n<li>\n<p>--include-untracked 为追踪的文件也会被缓存,当前的工作空间会被恢复为完全清空的状态</p>\n</li>\n<li>\n<p>-a 或者 --all 命令可以当前目录下的所有修改，包括被 git 忽略的文件</p>\n</li>\n</ul>\n<h3> git stash list</h3>\n<p>显示保存进度的列表。也就意味着，<code>git stash</code>命令可以多次执行，当多次使用<code>git stash</code>命令后，栈里会充满未提交的代码，如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/50216dd0-fccf-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>其中，<code>stash@{0}</code>、<code>stash@{1}</code>就是当前<code>stash</code>的名称</p>\n<h3> git stash pop</h3>\n<p><code>git stash pop</code> 从栈中读取最近一次保存的内容，也就是栈顶的<code>stash</code>会恢复到工作区</p>\n<p>也可以通过 <code>git stash pop</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p>\n<p>如果从<code>stash</code>中恢复的内容和当前目录中的内容发生了冲突，则需要手动修复冲突或者创建新的分支来解决冲突</p>\n<h3> git stash apply</h3>\n<p>将堆栈中的内容应用到当前目录，不同于<code>git stash pop</code>，该命令不会将内容从堆栈中删除</p>\n<p>也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况</p>\n<p>同样，可以通过<code>git stash apply</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p>\n<h3> git stash show</h3>\n<p>查看堆栈中最新保存的<code>stash</code>和当前目录的差异</p>\n<p>通过使用<code>git stash show -p</code>查看详细的不同</p>\n<p>通过使用<code>git stash show stash@{1}</code>查看指定的<code>stash</code>和当前目录差异</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/458620a0-fccf-11eb-bc6f-3f06e1491664.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> git stash drop</h3>\n<p><code>git stash drop</code> + <code>stash</code>名称表示从堆栈中移除某个指定的 stash</p>\n<h3> git stash clear</h3>\n<p>删除所有存储的进度</p>\n<h2> 三、应用场景</h2>\n<p>当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支或者拉下远端的代码去做一点别的事情</p>\n<p>但是你创建一次未完成的代码的<code>commit</code>提交，这时候就可以使用<code>git stash</code></p>\n<p>例如以下场景：</p>\n<p>当你的开发进行到一半,但是代码还不想进行提交 ,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过<code>git pull</code>解决</p>\n<p>但是如果可能发生冲突怎么办.直接<code>git pull</code>会拒绝覆盖当前的修改，这时候就可以依次使用下述的命令：</p>\n<ul>\n<li>git stash</li>\n<li>git pull</li>\n<li>git stash pop</li>\n</ul>\n<p>或者当你开发到一半，现在要修改别的分支问题的时候，你也可以使用<code>git stash</code>缓存当前区域的代码</p>\n<ul>\n<li>git stash：保存开发到一半的代码</li>\n<li>git commit -m '修改问题'</li>\n<li>git stash pop：将代码追加到最新的提交之后</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "git"
      ]
    },
    {
      "title": "说说 HTTP1.0/1.1/2.0 的区别?",
      "url": "https://www.h7ml.cn/posts/interview/http/1.0_1.1_2.0.html",
      "id": "https://www.h7ml.cn/posts/interview/http/1.0_1.1_2.0.html",
      "summary": "前端物语|面试物语-说说 HTTP1.0/1.1/2.0 的区别?",
      "content_html": "<h1> 说说 HTTP1.0/1.1/2.0 的区别?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e167a580-b93a-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、HTTP1.0</h2>\n<p><code>HTTP</code>协议的第二个版本，第一个在通讯中指定版本号的 HTTP 协议版本</p>\n<p><code>HTTP 1.0</code> 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个<code>TCP</code>连接</p>\n<p>服务器完成请求处理后立即断开<code>TCP</code>连接，服务器不跟踪每个客户也不记录过去的请求</p>\n<p>简单来讲，每次与服务器交互，都需要新开一个连接</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/efff4da0-b93a-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>例如，解析<code>html</code>文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接</p>\n<p>最终导致，一个<code>html</code>文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接</p>\n<p>这种形式明显造成了性能上的缺陷</p>\n<p>如果需要建立长连接，需要设置一个非标准的 Connection 字段 <code>Connection: keep-alive</code></p>\n<h2> 二、HTTP1.1</h2>\n<p>在<code>HTTP1.1</code>中，默认支持长连接（<code>Connection: keep-alive</code>），即在一个 TCP 连接上可以传送多个<code>HTTP</code>请求和响应，减少了建立和关闭连接的消耗和延迟</p>\n<p>建立一次连接，多次请求均由这个连接完成</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/22db2b90-b93b-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>这样，在加载<code>html</code>文件的时候，文件中多个请求和响应就可以在一个连接中传输</p>\n<p>同时，<code>HTTP 1.1</code>还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间</p>\n<p>同时，<code>HTTP1.1</code>在<code>HTTP1.0</code>的基础上，增加更多的请求头和响应头来完善的功能，如下：</p>\n<ul>\n<li>引入了更多的缓存控制策略，如 If-Unmodified-Since, If-Match, If-None-Match 等缓存头来控制缓存策略</li>\n<li>引入 range，允许值请求资源某个部分</li>\n<li>引入 host，实现了在一台 WEB 服务器上可以在同一个 IP 地址和端口号上使用不同的主机名来创建多个虚拟 WEB 站点</li>\n</ul>\n<p>并且还添加了其他的请求方法：<code>put</code>、<code>delete</code>、<code>options</code>...</p>\n<h2> 三、HTTP2.0</h2>\n<p>而<code>HTTP2.0</code>在相比之前版本，性能上有很大的提升，如添加了一个特性：</p>\n<ul>\n<li>多路复用</li>\n<li>二进制分帧</li>\n<li>首部压缩</li>\n<li>服务器推送</li>\n</ul>\n<h3> 多路复用</h3>\n<p><code>HTTP/2</code> 复用<code>TCP</code>连接，在一个连接里，客户端和浏览器都可以<strong>同时</strong>发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/313f1980-b93b-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>上图中，可以看到第四步中<code>css</code>、<code>js</code>资源是同时发送到服务端</p>\n<h3> 二进制分帧</h3>\n<p>帧是<code>HTTP2</code>通信中最小单位信息</p>\n<p><code>HTTP/2</code> 采用二进制格式传输数据，而非 <code>HTTP 1.x</code>的文本格式，解析起来更高效</p>\n<p>将请求和响应数据分割为更小的帧，并且它们采用二进制编码</p>\n<p><code>HTTP2</code>中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流</p>\n<p>每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件</p>\n<h3> 首部压缩</h3>\n<p><code>HTTP/2</code>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送</p>\n<p>首部表在<code>HTTP/2</code>的连接存续期内始终存在，由客户端和服务器共同渐进地更新</p>\n<p>例如：下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3c536740-b93b-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 服务器推送</h3>\n<p><code>HTTP2</code>引入服务器推送，允许服务端推送资源给客户端</p>\n<p>服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源</p>\n<p>免得客户端再次创建连接发送请求到服务器端获取</p>\n<p>这种方式非常合适加载静态资源</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/47130550-b93b-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 四、总结</h2>\n<p>HTTP1.0：</p>\n<ul>\n<li>浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接</li>\n</ul>\n<p>HTTP1.1：</p>\n<ul>\n<li>引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用</li>\n<li>在同一个 TCP 连接里面，客户端可以同时发送多个请求</li>\n<li>虽然允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着</li>\n<li>新增了一些请求方法</li>\n<li>新增了一些请求头和响应头</li>\n</ul>\n<p>HTTP2.0：</p>\n<ul>\n<li>采用二进制格式而非文本格式</li>\n<li>完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行</li>\n<li>使用报头压缩，降低开销</li>\n<li>服务器推送</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#HTTP/1.0\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/超文本传输协议#HTTP/1.0</a></li>\n<li><a href=\"https://www.jianshu.com/p/52d86558ca57\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/52d86558ca57</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000016496448\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000016496448</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26559480\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/26559480</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-02T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "http"
      ]
    },
    {
      "title": "如何理解 CDN？说说实现原理？",
      "url": "https://www.h7ml.cn/posts/interview/http/CDN.html",
      "id": "https://www.h7ml.cn/posts/interview/http/CDN.html",
      "summary": "前端物语|面试物语-如何理解 CDN？说说实现原理？",
      "content_html": "<h1> 如何理解 CDN？说说实现原理？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/437ae0f0-b86b-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>CDN (全称 Content Delivery Network)，即内容分发网络</p>\n<p>构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。<code>CDN</code> 的关键技术主要有内容存储和分发技术</p>\n<p>简单来讲，<code>CDN</code>就是根据用户位置分配最近的资源</p>\n<p>于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫<strong>边缘节点</strong>，其实就是缓存了源站内容的代理服务器。如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/4f0289f0-b86b-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、原理分析</h2>\n<p>在没有应用<code>CDN</code>时，我们使用域名访问某一个站点时的路径为</p>\n<blockquote>\n<p>用户提交域名 → 浏览器对域名进行解释 →<code>DNS</code> 解析得到目的主机的 IP 地址 → 根据 IP 地址访问发出请求 → 得到请求数据并回复</p>\n</blockquote>\n<p>应用<code>CDN</code>后，<code>DNS</code> 返回的不再是 <code>IP</code> 地址，而是一个<code>CNAME</code>(Canonical Name ) 别名记录，指向<code>CDN</code>的全局负载均衡</p>\n<p><code>CNAME</code>实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是<code>CDN</code>实现的关键</p>\n<h4> 负载均衡系统</h4>\n<p>由于没有返回<code>IP</code>地址，于是本地<code>DNS</code>会向负载均衡系统再发送请求 ，则进入到<code>CDN</code>的全局负载均衡系统进行智能调度：</p>\n<ul>\n<li>\n<p>看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点</p>\n</li>\n<li>\n<p>看用户所在的运营商网络，找相同网络的边缘节点</p>\n</li>\n<li>\n<p>检查边缘节点的负载情况，找负载较轻的节点</p>\n</li>\n<li>\n<p>其他，比如节点的“健康状况”、服务能力、带宽、响应时间等</p>\n</li>\n</ul>\n<p>结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问<code>CDN</code>的缓存代理</p>\n<p>整体流程如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/588d7890-b86b-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h4> 缓存代理</h4>\n<p>缓存系统是 <code>CDN</code>的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源</p>\n<p>其中有两个衡量<code>CDN</code>服务质量的指标：</p>\n<ul>\n<li>命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比</li>\n<li>回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比</li>\n</ul>\n<p>缓存系统也可以划分出层次，分成一级缓存节点和二级缓存节点。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户</p>\n<p>回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源</p>\n<p>现在的商业 <code>CDN</code>命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上</p>\n<h2> 三、总结</h2>\n<p><code>CDN</code> 目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度</p>\n<p><code>CDN</code> 构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速</p>\n<p>通过<code>CDN</code>的负载均衡系统，智能调度边缘节点提供服务，相当于<code>CDN</code>服务的大脑，而缓存系统相当于<code>CDN</code>的心脏，缓存命中直接返回给用户，否则回源</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/內容傳遞網路</a></li>\n<li><a href=\"https://juejin.cn/post/6844903890706661389#heading-5\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903890706661389#heading-5</a></li>\n<li><a href=\"https://blog.csdn.net/lxx309707872/article/details/109078783\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/lxx309707872/article/details/109078783</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-31T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "http"
      ]
    },
    {
      "title": "DNS 协议 是什么？说说 DNS 完整的查询过程?",
      "url": "https://www.h7ml.cn/posts/interview/http/DNS.html",
      "id": "https://www.h7ml.cn/posts/interview/http/DNS.html",
      "summary": "前端物语|面试物语-DNS 协议 是什么？说说 DNS 完整的查询过程?",
      "content_html": "<h1> DNS 协议 是什么？说说 DNS 完整的查询过程?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/88081710-b78f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器</p>\n<p>简单来讲，<code>DNS</code>相当于一个翻译官，负责将域名翻译成<code>ip</code>地址</p>\n<ul>\n<li>IP 地址：一长串能够唯一地标记网络上的计算机的数字</li>\n<li>域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/965a03a0-b78f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、域名</h2>\n<p>域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名...</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9f112780-b78f-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>例如<code>www.xxx.com</code>，<code>www</code>为三级域名、<code>xxx</code>为二级域名、<code>com</code>为顶级域名，系统为用户做了兼容，域名末尾的根域名<code>.</code>一般不需要输入</p>\n<p>在域名的每一层都会有一个域名服务器，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f40e0090-b7a4-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>除此之外，还有电脑默认的本地域名服务器</p>\n<h2> 三、查询方式</h2>\n<p>DNS 查询的方式有两种：</p>\n<ul>\n<li>递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a73be9e0-b78f-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b023e1c0-b78f-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 四、域名缓存</h2>\n<p>在域名服务器解析的时候，使用缓存保存域名和<code>IP</code>地址的映射</p>\n<p>计算机中<code>DNS</code>的记录也分成了两种缓存方式：</p>\n<ul>\n<li>浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗</li>\n<li>操作系统缓存：操作系统的缓存其实是用户自己配置的 <code>hosts</code> 文件</li>\n</ul>\n<h2> 五、查询过程</h2>\n<p>解析域名的过程如下：</p>\n<ul>\n<li>\n<p>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</p>\n</li>\n<li>\n<p>若没有命中，则继续搜索操作系统的 DNS 缓存</p>\n</li>\n<li>\n<p>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</p>\n</li>\n<li>\n<p>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询</p>\n<ul>\n<li>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</li>\n<li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li>\n<li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li>\n</ul>\n</li>\n<li>\n<p>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p>\n</li>\n<li>\n<p>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起</p>\n</li>\n<li>\n<p>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起</p>\n</li>\n</ul>\n<p>流程如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bec3c740-b78f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/域名系统</a></li>\n<li><a href=\"https://www.cnblogs.com/jmilkfan-fanguiju/p/12789677.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/jmilkfan-fanguiju/p/12789677.html</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000039039275\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000039039275</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-07T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "http"
      ]
    },
    {
      "title": "说一下 GET 和 POST 的区别？",
      "url": "https://www.h7ml.cn/posts/interview/http/GET_POST.html",
      "id": "https://www.h7ml.cn/posts/interview/http/GET_POST.html",
      "summary": "前端物语|面试物语-说一下 GET 和 POST 的区别？",
      "content_html": "<h1> 说一下 GET 和 POST 的区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6e8d19e0-bc3d-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>GET</code>和<code>POST</code>，两者是<code>HTTP</code>协议中发送请求的方法</p>\n<h4> GET</h4>\n<p><code>GET</code>方法请求一个指定资源的表示形式，使用 GET 的请求应该只被用于获取数据</p>\n<h4> POST</h4>\n<p><code>POST</code>方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或<strong>副作用</strong></p>\n<p>本质上都是<code>TCP</code>链接，并无差别</p>\n<p>但是由于<code>HTTP</code>的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别</p>\n<h2> 二、区别</h2>\n<p>从<code>w3schools</code>得到的标准答案的区别如下：</p>\n<ul>\n<li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</li>\n<li>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</li>\n<li>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。</li>\n<li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</li>\n<li>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</li>\n<li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。</li>\n<li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</li>\n<li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</li>\n<li>GET 参数通过 URL 传递，POST 放在 Request body 中</li>\n</ul>\n<h3> 参数位置</h3>\n<p>貌似从上面看到<code>GET</code>与<code>POST</code>请求区别非常大，但两者实质并没有区别</p>\n<p>无论 <code>GET</code>还是 <code>POST</code>，用的都是同一个传输层协议，所以在传输上没有区别</p>\n<p>当不携带参数的时候，两者最大的区别为第一行方法名不同</p>\n<blockquote>\n<p>POST /uri HTTP/1.1 \\r\\n</p>\n<p>GET /uri HTTP/1.1 \\r\\n</p>\n</blockquote>\n<p>当携带参数的时候，我们都知道<code>GET</code>请求是放在<code>url</code>中，<code>POST</code>则放在<code>body</code>中</p>\n<p><code>GET</code> 方法简约版报文是这样的</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>POST</code>方法简约版报文是这样的</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：这里只是约定，并不属于<code>HTTP</code>规范，相反的，我们可以在<code>POST</code>请求中<code>url</code>中写入参数，或者<code>GET</code>请求中的<code>body</code>携带参数</p>\n<h3> 参数长度</h3>\n<p><code>HTTP</code>协议没有<code>Body</code>和 <code>URL</code> 的长度限制，对 <code>URL</code>限制的大多是浏览器和服务器的原因</p>\n<p><code>IE</code>对<code>URL</code>长度的限制是 2083 字节(2K+35)。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持</p>\n<p>这里限制的是整个<code>URL</code>长度，而不仅仅是参数值的长度</p>\n<p>服务器处理长<code>URL</code> 要消耗比较多的资源，为了性能和安全考虑，会给 <code>URL</code> 长度加限制</p>\n<h3> 安全</h3>\n<p><code>POST</code>比<code>GET</code> 安全，因为数据在地址栏上不可见</p>\n<p>然而，从传输的角度来说，他们都是不安全的，因为<code>HTTP</code> 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文</p>\n<p>只有使用<code>HTTPS</code>才能加密安全</p>\n<h3> 数据包</h3>\n<p>对于<code>GET</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应 200（返回数据）</p>\n<p>对于<code>POST</code>，浏览器先发送<code>header</code>，服务器响应 100 <code>continue</code>，浏览器再发送<code>data</code>，服务器响应 200 ok</p>\n<p>并不是所有浏览器都会在<code>POST</code>中发送两次包，<code>Firefox</code>就只发送一次</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd</a></li>\n<li><a href=\"https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/</a></li>\n<li><a href=\"https://www.w3school.com.cn/tags/html_ref_httpmethods.asp\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.w3school.com.cn/tags/html_ref_httpmethods.asp</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-02T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "http"
      ]
    },
    {
      "title": "为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？",
      "url": "https://www.h7ml.cn/posts/interview/http/HTTPS.html",
      "id": "https://www.h7ml.cn/posts/interview/http/HTTPS.html",
      "summary": "前端物语|面试物语-为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？",
      "content_html": "<h1> 为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b5512250-b2ff-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、安全特性</h2>\n<p>在上篇文章中，我们了解到<code>HTTP</code>在通信过程中，存在以下问题：</p>\n<ul>\n<li>通信使用明文（不加密），内容可能被窃听</li>\n<li>不验证通信方的身份，因此有可能遭遇伪装</li>\n</ul>\n<p>而<code>HTTPS</code>的出现正是解决这些问题，<code>HTTPS</code>是建立在<code>SSL</code>之上，其安全性由<code>SSL</code>来保证</p>\n<p>在采用<code>SSL</code>后，<code>HTTP</code>就拥有了<code>HTTPS</code>的加密、证书和完整性保护这些功能</p>\n<blockquote>\n<p>SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议</p>\n</blockquote>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/cb559400-b2ff-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、如何做</h2>\n<p><code>SSL</code>的实现这些功能主要依赖于三种手段：</p>\n<ul>\n<li>对称加密：采用协商的密钥对数据加密</li>\n<li>非对称加密：实现身份认证和密钥协商</li>\n<li>摘要算法：验证信息的完整性</li>\n<li>数字签名：身份验证</li>\n</ul>\n<h3> 对称加密</h3>\n<p>对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e3f040f0-b2ff-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 非对称加密</h3>\n<p>非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密</p>\n<p>公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d9603e60-b2ff-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 混合加密</h3>\n<p>在<code>HTTPS</code>通信过程中，采用的是对称加密+非对称加密，也就是混合加密</p>\n<p>在对称加密中讲到，如果能够保证了密钥的安全，那整个通信过程就可以说具有了机密性</p>\n<p>而<code>HTTPS</code>采用非对称加密解决秘钥交换的问题</p>\n<p>具体做法是发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f375f290-b2ff-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信</p>\n<h4> 举个例子</h4>\n<p>网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文</p>\n<p>上述的方法解决了数据加密，在网络传输过程中，数据有可能被篡改，并且黑客可以伪造身份发布公钥，如果你获取到假的公钥，那么混合加密也并无多大用处，你的数据扔被黑客解决</p>\n<p>因此，在上述加密的基础上仍需加上完整性、身份验证的特性，来实现真正的安全，实现这一功能则是摘要算法</p>\n<h3> 摘要算法</h3>\n<p>实现完整性的手段主要是摘要算法，也就是常说的散列函数、哈希函数</p>\n<p>可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/12798da0-b300-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性</p>\n<p>比如，你发了条消息：“转账 1000 元”，然后再加上一个 SHA-2 的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/023790e0-b300-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 数字签名</h3>\n<p>数字签名能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名</p>\n<p>原理其实很简单，就是用私钥加密，公钥解密</p>\n<p>签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/21aa6880-b300-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥</p>\n<p>这时候就需要一个第三方，就是证书验证机构</p>\n<h3> CA 验证机构</h3>\n<p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场</p>\n<p>CA 对公钥的签名认证要求包括序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”</p>\n<p>流程如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/395648a0-b300-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>服务器的运营人员向数字证书认证机构提出公开密钥的申请</li>\n<li>数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名</li>\n<li>然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起</li>\n<li>服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信</li>\n</ul>\n<p>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，则证明：</p>\n<ul>\n<li>认证服务器的公开密钥的是真实有效的数字证书认证机构</li>\n<li>服务器的公开密钥是值得信赖的</li>\n</ul>\n<h2> 三、总结</h2>\n<p>可以看到，<code>HTTPS</code>与<code>HTTP</code>虽然只差一个<code>SSL</code>，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下：</p>\n<ul>\n<li>机密性：混合算法</li>\n<li>完整性：摘要算法</li>\n<li>身份认证：数字签名</li>\n<li>不可否定：数字签名</li>\n</ul>\n<p>同时引入第三方证书机构，确保公开秘钥的安全性</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/100657391\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/100657391</a></li>\n<li><a href=\"https://juejin.cn/post/6844903830987997197#heading-7\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903830987997197#heading-7</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1748862\" target=\"_blank\" rel=\"noopener noreferrer\">https://cloud.tencent.com/developer/article/1748862</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "http"
      ]
    },
    {
      "title": "什么是 HTTP? HTTP 和 HTTPS 的区别?",
      "url": "https://www.h7ml.cn/posts/interview/http/HTTP_HTTPS.html",
      "id": "https://www.h7ml.cn/posts/interview/http/HTTP_HTTPS.html",
      "summary": "前端物语|面试物语-什么是 HTTP? HTTP 和 HTTPS 的区别?",
      "content_html": "<h1> 什么是 HTTP? HTTP 和 HTTPS 的区别?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f50c71f0-b20b-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、HTTP</h2>\n<p><code>HTTP</code> (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fda119b0-b20b-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在计算机和网络世界有，存在不同的协议，如广播协议、寻址协议、路由协议等等......</p>\n<p>而<code>HTTP</code>是一个传输协议，即将数据由 A 传到 B 或将 B 传输到 A，并且 A 与 B 之间能够存放很多第三方，如： A&lt;=&gt;X&lt;=&gt;Y&lt;=&gt;Z&lt;=&gt;B</p>\n<p>传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如 HTML 文件, 图片文件, 查询结果等超文本，能够被上层应用识别</p>\n<p>在实际应用中，<code>HTTP</code>常被用于在<code>Web</code>浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密</p>\n<p>特点如下：</p>\n<ul>\n<li>\n<p>支持客户/服务器模式</p>\n</li>\n<li>\n<p>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快</p>\n</li>\n<li>\n<p>灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记</p>\n</li>\n<li>\n<p>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间</p>\n</li>\n<li>\n<p>无状态：HTTP 协议无法根据之前的状态进行本次的请求处理</p>\n</li>\n</ul>\n<h2> 二、HTTPS</h2>\n<p>在上述介绍<code>HTTP</code>中，了解到<code>HTTP</code>传递信息是以明文的形式发送内容，这并不安全。而<code>HTTPS</code>出现正是为了解决<code>HTTP</code>不安全的特性</p>\n<p>为了保证这些隐私数据能加密传输，让<code>HTTP</code>运行安全的<code>SSL/TLS</code>协议上，即 HTTPS = HTTP + SSL/TLS，通过 <code>SSL</code>证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密</p>\n<p><code>SSL</code> 协议位于<code>TCP/IP</code> 协议与各种应用层协议之间，浏览器和服务器在使用 <code>SSL</code> 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/078c50c0-b20c-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>流程图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/0e409fc0-b20c-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>首先客户端通过 URL 访问服务器建立 SSL 连接</li>\n<li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端</li>\n<li>客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级</li>\n<li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li>\n<li>服务器利用自己的私钥解密出会话密钥</li>\n<li>服务器利用会话密钥加密与客户端之间的通信</li>\n</ul>\n<h2> 三、区别</h2>\n<ul>\n<li>HTTPS 是 HTTP 协议的安全版本，HTTP 协议的数据传输是明文的，是不安全的，HTTPS 使用了 SSL/TLS 协议进行了加密处理，相对更安全</li>\n<li>HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP 是 80，HTTPS 是 443</li>\n<li>HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP</li>\n<li>HTTPS 需要 SSL，SSL 证书需要钱，功能越强大的证书费用越高</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.cnblogs.com/klb561/p/10289199.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/klb561/p/10289199.html</a></li>\n<li><a href=\"https://www.jianshu.com/p/205c0fc51c97\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/205c0fc51c97</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-31T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "http"
      ]
    },
    {
      "title": "如何理解 OSI 七层模型?",
      "url": "https://www.h7ml.cn/posts/interview/http/OSI.html",
      "id": "https://www.h7ml.cn/posts/interview/http/OSI.html",
      "summary": "前端物语|面试物语-如何理解 OSI 七层模型?",
      "content_html": "<h1> 如何理解 OSI 七层模型?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e2e1b910-b61e-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架</p>\n<p><code>OSI</code>将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰</p>\n<h2> 二、划分</h2>\n<p><code>OSI</code>主要划分了七层，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/eb1b2170-b61e-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 应用层</h3>\n<p>应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用</p>\n<p>该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 <code>DNS</code>，支持万维网应用的 <code>HTTP</code> 协议，电子邮件系统采用的 <code>SMTP</code>协议等</p>\n<p>在应用层交互的数据单元我们称之为报文</p>\n<h3> 表示层</h3>\n<p>表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 <code>OSI</code>参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务</p>\n<p>该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异</p>\n<h3> 会话层</h3>\n<p>会话层就是负责建立、管理和终止表示层实体之间的通信会话</p>\n<p>该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法</p>\n<h3> 传输层</h3>\n<p>传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题</p>\n<p>传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层</p>\n<p>其中，主要的传输层协议是<code>TCP</code>和<code>UDP</code></p>\n<h3> 网络层</h3>\n<p>两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网</p>\n<p>网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送</p>\n<p>在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层</p>\n<p>在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层</p>\n<h3> 数据链路层</h3>\n<p>数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议</p>\n<p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 <code>IP</code>数据报组装成帧，在两个相邻节点间的链路上传送帧</p>\n<p>每一帧的数据可以分成：报头<code>head</code>和数据<code>data</code>两部分:</p>\n<ul>\n<li>head 标明数据发送者、接受者、数据类型，如 MAC 地址</li>\n<li>data 存储了计算机之间交互的数据</li>\n</ul>\n<p>通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源</p>\n<h3> 物理层</h3>\n<p>作为<code>OSI</code> 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送</p>\n<p>该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）</p>\n<p>该层主要是和硬件有关，与软件关系不大</p>\n<h2> 三、传输过程</h2>\n<p>数据在各层之间的传输如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f3a89d40-b61e-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>应用层报文被传送到运输层</li>\n<li>在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用</li>\n<li>应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变</li>\n<li>运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报</li>\n<li>网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧</li>\n<li>在物理层数据帧被封装成比特流，之后通过传输介质传送到对端</li>\n<li>对端再一步步解开封装，获取到传送的数据</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/OSI模型</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/32059190\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/32059190</a></li>\n<li><a href=\"https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-18T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "http"
      ]
    },
    {
      "title": "前端物语|面试物语-http",
      "url": "https://www.h7ml.cn/posts/interview/http/",
      "id": "https://www.h7ml.cn/posts/interview/http/",
      "summary": "说说 HTTP1.0/1.1/2.0 的区别? 如何理解 CDN？说说实现原理？ DNS 协议 是什么？说说 DNS 完整的查询过程? 说一下 GET 和 POST 的区别？ 为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？ 什么是 HTTP? HTTP 和 HTTPS 的区别? 如何理解 OSI 七层模型? 如何理解 TCP/IP 协议? 如何理解 UDP 和 TCP? 区别? 应用场景? 说说对 WebSocket 的理解？应用场景？ 说说地址栏输入 URL 敲下回车后发生了什么? 说说 TCP 为什么需要三次握手和四次挥手？ 说说 HTTP 常见的请求头有哪些? 作用？ 说说 HTTP 常见的状态码有哪些，适用场景？",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/interview/http/1.0_1.1_2.0\" target=\"_blank\" rel=\"noopener noreferrer\">说说 HTTP1.0/1.1/2.0 的区别?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/http/CDN\" target=\"_blank\" rel=\"noopener noreferrer\">如何理解 CDN？说说实现原理？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/http/DNS\" target=\"_blank\" rel=\"noopener noreferrer\">DNS 协议 是什么？说说 DNS 完整的查询过程?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/http/GET_POST\" target=\"_blank\" rel=\"noopener noreferrer\">说一下 GET 和 POST 的区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/http/HTTPS\" target=\"_blank\" rel=\"noopener noreferrer\">为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/http/HTTP_HTTPS\" target=\"_blank\" rel=\"noopener noreferrer\">什么是 HTTP? HTTP 和 HTTPS 的区别?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/http/OSI\" target=\"_blank\" rel=\"noopener noreferrer\">如何理解 OSI 七层模型?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/http/TCP_IP\" target=\"_blank\" rel=\"noopener noreferrer\">如何理解 TCP/IP 协议?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/http/UDP_TCP\" target=\"_blank\" rel=\"noopener noreferrer\">如何理解 UDP 和 TCP? 区别? 应用场景?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/http/WebSocket\" target=\"_blank\" rel=\"noopener noreferrer\">说说对 WebSocket 的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/http/after_url\" target=\"_blank\" rel=\"noopener noreferrer\">说说地址栏输入 URL 敲下回车后发生了什么?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/http/handshakes_waves\" target=\"_blank\" rel=\"noopener noreferrer\">说说 TCP 为什么需要三次握手和四次挥手？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/http/headers\" target=\"_blank\" rel=\"noopener noreferrer\">说说 HTTP 常见的请求头有哪些? 作用？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/http/status\" target=\"_blank\" rel=\"noopener noreferrer\">说说 HTTP 常见的状态码有哪些，适用场景？</a></li>\n</ul>\n",
      "date_published": "2023-04-07T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "http"
      ]
    },
    {
      "title": "如何理解 TCP/IP 协议?",
      "url": "https://www.h7ml.cn/posts/interview/http/TCP_IP.html",
      "id": "https://www.h7ml.cn/posts/interview/http/TCP_IP.html",
      "summary": "前端物语|面试物语-如何理解 TCP/IP 协议?",
      "content_html": "<h1> 如何理解 TCP/IP 协议?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/4f69a930-b647-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>TCP/IP，<strong>传输控制协议</strong>/<strong>网际协议</strong>，是指能够在多个不同网络间实现信息传输的协议簇</p>\n<ul>\n<li>TCP（传输控制协议）</li>\n</ul>\n<p>一种面向连接的、可靠的、基于字节流的传输层通信协议</p>\n<ul>\n<li>IP（网际协议）</li>\n</ul>\n<p>用于封包交换数据网络的协议</p>\n<p>TCP/IP 协议不仅仅指的是<code>TCP</code>和<code>IP</code>两个协议，而是指一个由<code>FTP</code>、<code>SMTP</code>、<code>TCP</code>、<code>UDP</code>、<code>IP</code>等协议构成的协议簇，</p>\n<p>只是因为在<code>TCP/IP</code>协议中<code>TCP</code>协议和<code>IP</code>协议最具代表性，所以通称为 TCP/IP 协议族（英语：TCP/IP Protocol Suite，或 TCP/IP Protocols）</p>\n<h2> 二、划分</h2>\n<p>TCP/IP 协议族按层次分别了五层体系或者四层体系</p>\n<p>五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层</p>\n<p>五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层</p>\n<p>如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5bb93610-b647-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 五层体系</h3>\n<h4> 应用层</h4>\n<p><code>TCP/IP</code> 模型将 <code>OSI</code>参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务</p>\n<p>如：<code>FTP</code>、<code>Telnet</code>、<code>DNS</code>、<code>SMTP</code> 等</p>\n<h4> 传输层</h4>\n<p>该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能</p>\n<p>传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）</p>\n<p>其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输</p>\n<h4> 网络层</h4>\n<p>负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机</p>\n<p>在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送</p>\n<h4> 数据链路层</h4>\n<p>数据链路层在两个相邻节点传输数据时，将网络层交下来的 IP 数据报组装成帧，在两个相邻节点之间的链路上传送帧</p>\n<h4> 物理层</h4>\n<p>保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境</p>\n<h3> 四层体系</h3>\n<p>TCP/IP 的四层结构则如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>层次名称</th>\n<th>单位</th>\n<th>功 能</th>\n<th>协 议</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>网络接口层</td>\n<td>帧</td>\n<td>负责实际数据的传输，对应 OSI 参考模型的下两层</td>\n<td>HDLC（高级链路控制协议）PPP（点对点协议） SLIP（串行线路接口协议）</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>数据报</td>\n<td>负责网络间的寻址数据传输，对应 OSI 参考模型的第三层</td>\n<td>IP（网际协议） ICMP（网际控制消息协议）ARP（地址解析协议） RARP（反向地址解析协议）</td>\n</tr>\n<tr>\n<td>传输层</td>\n<td>报文段</td>\n<td>负责提供可靠的传输服务，对应 OSI 参考模型的第四层</td>\n<td>TCP（控制传输协议） UDP（用户数据报协议）</td>\n</tr>\n<tr>\n<td>应用层</td>\n<td></td>\n<td>负责实现一切与应用程序相关的功能，对应 OSI 参考模型的上三层</td>\n<td>FTP（文件传输协议） HTTP（超文本传输协议） DNS（域名服务器协议）SMTP（简单邮件传输协议）NFS（网络文件系统协议）</td>\n</tr>\n</tbody>\n</table>\n<h2> 三、总结</h2>\n<p>OSI 参考模型与 TCP/IP 参考模型区别如下：</p>\n<p>相同点：</p>\n<ul>\n<li>OSI 参考模型与 TCP/IP 参考模型都采用了层次结构</li>\n<li>都能够提供面向连接和无连接两种通信服务机制</li>\n</ul>\n<p>不同点：</p>\n<ul>\n<li>\n<p>OSI 采用的七层模型； TCP/IP 是四层或五层结构</p>\n</li>\n<li>\n<p>TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分</p>\n</li>\n<li>\n<p>OSI 参考模型虽然网络划分为七层，但实现起来较困难。TCP/IP 参考模型作为一种简化的分层结构是可以的</p>\n</li>\n<li>\n<p>TCP/IP 协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 <code>OSI</code> 设想中的应用程序维度的分层是无法实现的</p>\n</li>\n</ul>\n<p>三种模型对应关系如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3fbff4d0-b647-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/TCP/IP协议族</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/103162095\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/103162095</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000039204681\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000039204681</a></li>\n<li><a href=\"https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/\" target=\"_blank\" rel=\"noopener noreferrer\">https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "http"
      ]
    },
    {
      "title": "如何理解 UDP 和 TCP? 区别? 应用场景?",
      "url": "https://www.h7ml.cn/posts/interview/http/UDP_TCP.html",
      "id": "https://www.h7ml.cn/posts/interview/http/UDP_TCP.html",
      "summary": "前端物语|面试物语-如何理解 UDP 和 TCP? 区别? 应用场景?",
      "content_html": "<h1> 如何理解 UDP 和 TCP? 区别? 应用场景?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/85ad65b0-b393-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、UDP</h2>\n<p>UDP（User Datagram Protocol），用户数据包协议，是一个简单的<strong>面向数据报的通信协议</strong>，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层</p>\n<p>也就是说无论应用层交给<code>UDP</code>多长的报文，它统统发送，一次发送一个报文</p>\n<p>而对接收方，接到后直接去除首部，交给上面的应用层就完成任务</p>\n<p><code>UDP</code>报头包括 4 个字段，每个字段占用 2 个字节（即 16 个二进制位），标题短，开销小</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/928e5d20-b393-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>特点如下：</p>\n<ul>\n<li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务</li>\n<li>传输途中出现丢包，UDP 也不负责重发</li>\n<li>当包的到达顺序出现乱序时，UDP 没有纠正的功能。</li>\n<li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为</li>\n</ul>\n<h2> 二、TCP</h2>\n<p>TCP（Transmission Control Protocol），传输控制协议，是一种可靠、<strong>面向字节流的通信协议</strong>，把上面应用层交下来的数据看成无结构的字节流来发送</p>\n<p>可以想象成流水形式的，发送方 TCP 会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP 会根据当前网络的拥塞状态来确定每个报文段的大小</p>\n<p><code>TCP</code>报文首部有 20 个字节，额外开销大</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a0010d40-b393-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>特点如下：</p>\n<ul>\n<li>TCP 充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li>\n<li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li>\n<li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）</li>\n</ul>\n<h2> 三、区别</h2>\n<p><code>UDP</code>与<code>TCP</code>两者的都位于传输层，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a92bda80-b393-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>两者区别如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>可靠性</td>\n<td>可靠</td>\n<td>不可靠</td>\n</tr>\n<tr>\n<td>连接性</td>\n<td>面向连接</td>\n<td>无连接</td>\n</tr>\n<tr>\n<td>报文</td>\n<td>面向字节流</td>\n<td>面向报文</td>\n</tr>\n<tr>\n<td>效率</td>\n<td>传输效率低</td>\n<td>传输效率高</td>\n</tr>\n<tr>\n<td>双共性</td>\n<td>全双工</td>\n<td>一对一、一对多、多对一、多对多</td>\n</tr>\n<tr>\n<td>流量控制</td>\n<td>滑动窗口</td>\n<td>无</td>\n</tr>\n<tr>\n<td>拥塞控制</td>\n<td>慢开始、拥塞避免、快重传、快恢复</td>\n<td>无</td>\n</tr>\n<tr>\n<td>传输效率</td>\n<td>慢</td>\n<td>快</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>TCP 是面向连接的协议，建立连接 3 次握手、断开连接四次挥手，UDP 是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取</p>\n</li>\n<li>\n<p>TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方</p>\n</li>\n<li>\n<p>TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个 TCP 报文段传输后，在目的站重新装配。UDP 协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用</p>\n</li>\n<li>\n<p>TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信</p>\n</li>\n</ul>\n<p>两者应用场景如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b6cdd800-b393-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>可以看到，TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而 UDP 适用场景为对效率要求高，对准确性要求低的场景</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org</a></li>\n<li><a href=\"https://www.shangmayuan.com/a/a1e3ceb218284cefb95de7fd.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.shangmayuan.com/a/a1e3ceb218284cefb95de7fd.html</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000021815671\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000021815671</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-03T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "http"
      ]
    },
    {
      "title": "说说对 WebSocket 的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/http/WebSocket.html",
      "id": "https://www.h7ml.cn/posts/interview/http/WebSocket.html",
      "summary": "前端物语|面试物语-说说对 WebSocket 的理解？应用场景？",
      "content_html": "<h1> 说说对 WebSocket 的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a358a8c0-c0f1-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>WebSocket，是一种网络传输协议，位于<code>OSI</code>模型的应用层。可在单个<code>TCP</code>连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅</p>\n<p>客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ad386e20-c0f1-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从上图可见，<code>websocket</code>服务器与客户端通过握手连接，连接成功后，两者都能主动的向对方发送或接受数据</p>\n<p>而在<code>websocket</code>出现之前，开发实时<code>web</code>应用的方式为轮询</p>\n<p>不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果</p>\n<p>轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 <code>CPU</code>资源</p>\n<h2> 二、特点</h2>\n<h3> 全双工</h3>\n<p>通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合</p>\n<p>例如指 A→B 的同时 B→A ，是瞬时同步的</p>\n<h3> 二进制帧</h3>\n<p>采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比<code>http/2</code>，<code>WebSocket</code>更侧重于“实时通信”，而<code>HTTP/2</code> 更侧重于提高传输效率，所以两者的帧结构也有很大的区别</p>\n<p>不像 <code>HTTP/2</code> 那样定义流，也就不存在多路复用、优先级等特性</p>\n<p>自身就是全双工，也不需要服务器推送</p>\n<h3> 协议名</h3>\n<p>引入<code>ws</code>和<code>wss</code>分别代表明文和密文的<code>websocket</code>协议，且默认端口使用 80 或 443，几乎与<code>http</code>一致</p>\n<div class=\"language-http line-numbers-mode\" data-ext=\"http\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 握手</h3>\n<p><code>WebSocket</code>也要有一个握手过程，然后才能正式收发数据</p>\n<p>客户端发送数据格式如下：</p>\n<div class=\"language-http line-numbers-mode\" data-ext=\"http\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>Connection：必须设置 Upgrade，表示客户端希望连接升级</li>\n<li>Upgrade：必须设置 Websocket，表示希望升级到 Websocket 协议</li>\n<li>Sec-WebSocket-Key：客户端发送的一个 base64 编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept 应答，否则客户端会抛出错误，并关闭连接</li>\n<li>Sec-WebSocket-Version ：表示支持的 Websocket 版本</li>\n</ul>\n<p>服务端返回的数据格式：</p>\n<div class=\"language-http line-numbers-mode\" data-ext=\"http\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>HTTP/1.1 101 Switching Protocols：表示服务端接受 WebSocket 协议的客户端连接</li>\n<li>Sec-WebSocket-Accep：验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里“Sec-WebSocket-Key”的值，加上一个专用的 UUID，再计算摘要</li>\n</ul>\n<h3> 优点</h3>\n<ul>\n<li>较少的控制开销：数据包头部协议较小，不同于 http 每次请求需要携带完整的头部</li>\n<li>更强的实时性：相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少</li>\n<li>保持创连接状态：创建通信后，可省略状态信息，不同于 HTTP 每次请求需要携带身份验证</li>\n<li>更好的二进制支持：定义了二进制帧，更好处理二进制内容</li>\n<li>支持扩展：用户可以扩展 websocket 协议、实现部分自定义的子协议</li>\n<li>更好的压缩效果：Websocket 在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li>\n</ul>\n<h2> 二、应用场景</h2>\n<p>基于<code>websocket</code>的事实通信的特点，其存在的应用场景大概有：</p>\n<ul>\n<li>弹幕</li>\n<li>媒体聊天</li>\n<li>协同编辑</li>\n<li>基于位置的应用</li>\n<li>体育实况更新</li>\n<li>股票基金报价实时更新</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/WebSocket\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/WebSocket</a></li>\n<li><a href=\"https://www.oschina.net/translate/9-killer-uses-for-websockets\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.oschina.net/translate/9-killer-uses-for-websockets</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-02T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "http"
      ]
    },
    {
      "title": "说说地址栏输入 URL 敲下回车后发生了什么?",
      "url": "https://www.h7ml.cn/posts/interview/http/after_url.html",
      "id": "https://www.h7ml.cn/posts/interview/http/after_url.html",
      "summary": "前端物语|面试物语-说说地址栏输入 URL 敲下回车后发生了什么?",
      "content_html": "<h1> 说说地址栏输入 URL 敲下回车后发生了什么?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/11bf1f20-bdf4-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、简单分析</h2>\n<p>简单的分析，从输入 <code>URL</code>到回车后发生的行为如下：</p>\n<ul>\n<li>URL 解析</li>\n<li>DNS 查询</li>\n<li>TCP 连接</li>\n<li>HTTP 请求</li>\n<li>响应请求</li>\n<li>页面渲染</li>\n</ul>\n<h2> 二、详细分析</h2>\n<h3> URL 解析</h3>\n<p>首先判断你输入的是一个合法的<code>URL</code> 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作</p>\n<p><code>URL</code>的解析第过程中的第一步，一个<code>url</code>的结构解析如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/27a0c690-bdf4-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> DNS 查询</h3>\n<p>在之前文章中讲过<code>DNS</code>的查询，这里就不再讲述了</p>\n<p>整个查询过程如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/330fb770-bdf4-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>最终，获取到了域名对应的目标服务器<code>IP</code>地址</p>\n<h3> TCP 连接</h3>\n<p>在之前文章中，了解到<code>tcp</code>是一种面向有连接的传输层协议</p>\n<p>在确定目标服务器服务器的<code>IP</code>地址后，则经历三次握手建立<code>TCP</code>连接，流程如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ad750790-bdf4-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 发送 http 请求</h3>\n<p>当建立<code>tcp</code>连接之后，就可以在这基础上进行通信，浏览器发送 <code>http</code> 请求到目标服务器</p>\n<p>请求的内容包括：</p>\n<ul>\n<li>请求行</li>\n<li>请求头</li>\n<li>请求主体</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bbcb60f0-bdf4-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 响应请求</h3>\n<p>当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个<code>HTTP</code>响应消息，包括：</p>\n<ul>\n<li>状态行</li>\n<li>响应头</li>\n<li>响应正文</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c5fe0140-bdf4-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在服务器响应之后，由于现在<code>http</code>默认开始长连接<code>keep-alive</code>，当页面关闭之后，<code>tcp</code>链接则会经过四次挥手完成断开</p>\n<h3> 页面渲染</h3>\n<p>当浏览器接收到服务器响应的资源后，首先会对资源进行解析：</p>\n<ul>\n<li>查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储 cookie，解压 gzip，缓存资源等等</li>\n<li>查看响应头的 Content-Type 的值，根据不同的资源类型采用不同的解析方式</li>\n</ul>\n<p>关于页面的渲染过程如下：</p>\n<ul>\n<li>解析 HTML，构建 DOM 树</li>\n<li>解析 CSS ，生成 CSS 规则树</li>\n<li>合并 DOM 树和 CSS 规则，生成 render 树</li>\n<li>布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算</li>\n<li>绘制 render 树（ paint ），绘制页面像素信息</li>\n<li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/db7bddd0-bdf4-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://github.com/febobo/web-interview/issues/141\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/febobo/web-interview/issues/141</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/80551769\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/80551769</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-25T15:07:55.940Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "http"
      ]
    },
    {
      "title": "说说 TCP 为什么需要三次握手和四次挥手？",
      "url": "https://www.h7ml.cn/posts/interview/http/handshakes_waves.html",
      "id": "https://www.h7ml.cn/posts/interview/http/handshakes_waves.html",
      "summary": "前端物语|面试物语-说说TCP为什么需要三次握手和四次挥手？",
      "content_html": "<h1> 说说 TCP 为什么需要三次握手和四次挥手？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ef4696a0-beb9-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、三次握手</h2>\n<p>三次握手（Three-way Handshake）其实就是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包</p>\n<p>主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备</p>\n<p>过程如下：</p>\n<ul>\n<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态</li>\n<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1 作为 ACK 的值，此时服务器处于 SYN_RCVD 的状态</li>\n<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的 ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fb489fc0-beb9-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>上述每一次握手的作用如下：</p>\n<ul>\n<li>第一次握手：客户端发送网络包，服务端收到了这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>\n<li>第二次握手：服务端发包，客户端收到了这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常</li>\n<li>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常</li>\n</ul>\n<p>通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了</p>\n<h3> 为什么不是两次握手?</h3>\n<p>如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到</p>\n<p>并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源</p>\n<h2> 二、四次挥手</h2>\n<p><code>tcp</code>终止一个连接，需要经过四次挥手</p>\n<p>过程如下：</p>\n<ul>\n<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认</li>\n<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态</li>\n<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态</li>\n<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/0a3ebb90-beba-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 四次挥手原因</h3>\n<p>服务端在收到客户端断开连接<code>Fin</code>报文后，并不会立即关闭连接，而是先发送一个<code>ACK</code>包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送<code>FIN</code>报文断开连接，因此需要四次挥手</p>\n<h2> 三、总结</h2>\n<p>一个完整的三次握手四次挥手如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/65941490-beba-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/53374516\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/53374516</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000020610336\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000020610336</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "http"
      ]
    },
    {
      "title": "说说 HTTP 常见的请求头有哪些? 作用？",
      "url": "https://www.h7ml.cn/posts/interview/http/headers.html",
      "id": "https://www.h7ml.cn/posts/interview/http/headers.html",
      "summary": "前端物语|面试物语-说说 HTTP 常见的请求头有哪些? 作用？",
      "content_html": "<h1> 说说 HTTP 常见的请求头有哪些? 作用？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/964abb00-bc69-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>HTTP 头字段（HTTP header fields）,是指在超文本传输协议（HTTP）的请求和响应消息中的消息头部分</p>\n<p>它们定义了一个超文本传输协议事务中的操作参数</p>\n<p>HTTP 头部字段可以自己根据需要定义，因此可能在 <code>Web</code>服务器和浏览器上发现非标准的头字段</p>\n<p>下面是一个<code>HTTP</code>请求的请求头：</p>\n<div class=\"language-http line-numbers-mode\" data-ext=\"http\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、分类</h2>\n<p>常见的请求字段如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept</td>\n<td>能够接受的回应内容类型（Content-Types）</td>\n<td>Accept: text/plain</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>能够接受的字符集</td>\n<td>Accept-Charset: utf-8</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>能够接受的编码方式列表</td>\n<td>Accept-Encoding: gzip, deflate</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>能够接受的回应内容的自然语言列表</td>\n<td>Accept-Language: en-US</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>用于超文本传输协议的认证的认证信息</td>\n<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>\n</tr>\n<tr>\n<td>Cache-Control</td>\n<td>用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令</td>\n<td>Cache-Control: no-cache</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>该浏览器想要优先使用的连接类型</td>\n<td>Connection: keep-alive Connection: Upgrade</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议 Cookie</td>\n<td>Cookie: $Version=1; Skin=new;</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>以 八位字节数组 （8 位的字节）表示的请求体的长度</td>\n<td>Content-Length: 348</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>请求体的 多媒体类型</td>\n<td>Content-Type: application/x-www-form-urlencoded</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>发送该消息的日期和时间</td>\n<td>Date: Tue, 15 Nov 1994 08:12:31 GMT</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>表明客户端要求服务器做出特定的行为</td>\n<td>Expect: 100-continue</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号</td>\n<td>Host: <a href=\"http://en.wikipedia.org:80\" target=\"_blank\" rel=\"noopener noreferrer\">en.wikipedia.org:80</a> Host: <a href=\"http://en.wikipedia.org\" target=\"_blank\" rel=\"noopener noreferrer\">en.wikipedia.org</a></td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源</td>\n<td>If-Match: \"737060cd8c284d8af7ad3082f209582d\"</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>允许在对应的内容未被修改的情况下返回 304 未修改</td>\n<td>If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>允许在对应的内容未被修改的情况下返回 304 未修改</td>\n<td>If-None-Match: \"737060cd8c284d8af7ad3082f209582d\"</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体</td>\n<td>If-Range: \"737060cd8c284d8af7ad3082f209582d\"</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>仅请求某个实体的一部分</td>\n<td>Range: bytes=500-999</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>浏览器的浏览器身份标识字符串</td>\n<td>User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0</td>\n</tr>\n<tr>\n<td>Origin</td>\n<td>发起一个针对 跨来源资源共享 的请求</td>\n<td>Origin: <a href=\"http://www.example-social-network.com\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.example-social-network.com</a></td>\n</tr>\n</tbody>\n</table>\n<h2> 三、使用场景</h2>\n<p>通过配合请求头和响应头，可以满足一些场景的功能实现：</p>\n<h3> 协商缓存</h3>\n<p>协商缓存是利用的是<code>【Last-Modified，If-Modified-Since】</code>和<code>【ETag、If-None-Match】</code>这两对请求头响应头来管理的</p>\n<p><code>Last-Modified</code> 表示本地文件最后修改日期，浏览器会在 request header 加上<code>If-Modified-Since</code>（上次返回的<code>Last-Modified</code>的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来</p>\n<p><code>Etag</code>就像一个指纹，资源变化都会导致<code>ETag</code>变化，跟最后修改时间没有关系，<code>ETag</code>可以保证每一个资源是唯一的</p>\n<p><code>If-None-Match</code>的 header 会将上次返回的<code>Etag</code>发送给服务器，询问该资源的<code>Etag</code>是否有更新，有变动就会发送新的资源回来</p>\n<p>而强制缓存不需要发送请求到服务端，根据请求头<code>expires</code>和<code>cache-control</code>判断是否命中强缓存</p>\n<p>强制缓存与协商缓存的流程图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a4065b00-bc69-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 会话状态</h3>\n<p><code>cookie</code>，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据，通过响应头<code>set-cookie</code>决定</p>\n<p>作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 <code>Cookie</code>有效期、安全性、使用范围的可选属性组成</p>\n<p><code>Cookie</code> 主要用于以下三个方面：</p>\n<ul>\n<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>\n<li>个性化设置（如用户自定义设置、主题等）</li>\n<li>浏览器行为跟踪（如跟踪分析用户行为等</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/HTTP头字段</a></li>\n<li><a href=\"https://github.com/amandakelake/blog/issues/41\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/amandakelake/blog/issues/41</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-04T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "http"
      ]
    },
    {
      "title": "说说 HTTP 常见的状态码有哪些，适用场景？",
      "url": "https://www.h7ml.cn/posts/interview/http/status.html",
      "id": "https://www.h7ml.cn/posts/interview/http/status.html",
      "summary": "前端物语|面试物语-说说 HTTP 常见的状态码有哪些，适用场景？",
      "content_html": "<h1> 说说 HTTP 常见的状态码有哪些，适用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/038831d0-bbc9-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>HTTP 状态码（英语：HTTP Status Code），用以表示网页服务器超文本传输协议响应状态的 3 位数字代码</p>\n<p>它由 RFC 2616 规范定义的，并得到 <code>RFC 2518</code>、<code>RFC 2817</code>、<code>RFC 2295</code>、<code>RFC 2774</code>与 <code>RFC 4918</code>等规范扩展</p>\n<p>简单来讲，<code>http</code>状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态</p>\n<h2> 二、分类</h2>\n<p>状态码第一位数字决定了不同的响应状态，有如下：</p>\n<ul>\n<li>1 表示消息</li>\n<li>2 表示成功</li>\n<li>3 表示重定向</li>\n<li>4 表示请求错误</li>\n<li>5 表示服务器错误</li>\n</ul>\n<h3> 1xx</h3>\n<p>代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束</p>\n<p>常见的有：</p>\n<ul>\n<li>100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</li>\n<li>101：服务器根据客户端的请求切换协议，主要用于 websocket 或 http2 升级</li>\n</ul>\n<h3> 2xx</h3>\n<p>代表请求已成功被服务器接收、理解、并接受</p>\n<p>常见的有：</p>\n<ul>\n<li>\n<p>200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回</p>\n</li>\n<li>\n<p>201（已创建）：请求成功并且服务器创建了新的资源</p>\n</li>\n<li>\n<p>202（已创建）：服务器已经接收请求，但尚未处理</p>\n</li>\n<li>\n<p>203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源</p>\n</li>\n<li>\n<p>204（无内容）：服务器成功处理请求，但没有返回任何内容</p>\n</li>\n<li>\n<p>205（重置内容）：服务器成功处理请求，但没有返回任何内容</p>\n</li>\n<li>\n<p>206（部分内容）：服务器成功处理了部分请求</p>\n</li>\n</ul>\n<h3> 3xx</h3>\n<p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向</p>\n<p>常见的有：</p>\n<ul>\n<li>\n<p>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择</p>\n</li>\n<li>\n<p>301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</p>\n</li>\n<li>\n<p>302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</p>\n</li>\n<li>\n<p>303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</p>\n</li>\n<li>\n<p>305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理</p>\n</li>\n<li>\n<p>307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</p>\n</li>\n</ul>\n<h3> 4xx</h3>\n<p>代表了客户端看起来可能发生了错误，妨碍了服务器的处理</p>\n<p>常见的有：</p>\n<ul>\n<li>400（错误请求）： 服务器不理解请求的语法</li>\n<li>401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li>\n<li>403（禁止）： 服务器拒绝请求</li>\n<li>404（未找到）： 服务器找不到请求的网页</li>\n<li>405（方法禁用）： 禁用请求中指定的方法</li>\n<li>406（不接受）： 无法使用请求的内容特性响应请求的网页</li>\n<li>407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理</li>\n<li>408（请求超时）： 服务器等候请求时发生超时</li>\n</ul>\n<h3> 5xx</h3>\n<p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生</p>\n<p>常见的有：</p>\n<ul>\n<li>500（服务器内部错误）：服务器遇到错误，无法完成请求</li>\n<li>501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码</li>\n<li>502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应</li>\n<li>503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）</li>\n<li>504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li>\n<li>505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本</li>\n</ul>\n<h2> 三、适用场景</h2>\n<p>下面给出一些状态码的适用场景：</p>\n<ul>\n<li>\n<p>100：客户端在发送 POST 数据给服务器前，征询服务器情况，看服务器是否处理 POST 的数据，如果不处理，客户端则不上传 POST 数据，如果处理，则 POST 上传数据。常用于 POST 大数据传输</p>\n</li>\n<li>\n<p>206：一般用来做断点续传，或者是视频文件等大文件的加载</p>\n</li>\n<li>\n<p>301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用 301 就重定向到新的域名</p>\n</li>\n<li>\n<p>302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面</p>\n</li>\n<li>\n<p>304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分</p>\n</li>\n<li>\n<p>400：参数有误，请求无法被服务器识别</p>\n</li>\n<li>\n<p>403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网 IP 才能访问的时候则返回</p>\n</li>\n<li>\n<p>404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时</p>\n</li>\n<li>\n<p>503：服务器停机维护时，主动用 503 响应请求或 nginx 设置限速，超过限速，会返回 503</p>\n</li>\n<li>\n<p>504：网关超时</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/HTTP状态码</a></li>\n<li><a href=\"https://kebingzao.com/2018/10/05/http-status-code/\" target=\"_blank\" rel=\"noopener noreferrer\">https://kebingzao.com/2018/10/05/http-status-code/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "http"
      ]
    },
    {
      "title": "前端物语|面试物语-linux",
      "url": "https://www.h7ml.cn/posts/interview/linux/",
      "id": "https://www.h7ml.cn/posts/interview/linux/",
      "summary": "说说 linux 系统下 文件操作常用的命令有哪些？ --- 说说你对操作系统的理解？核心概念有哪些？ 说说你对 linux 用户管理的理解？相关的命令有哪些？ --- 说说你对输入输出重定向和管道的理解？应用场景？ 说说你对 shell 的理解？常见的命令？ 说说什么是进程？什么是线程？区别？ ---",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/interview/linux/file\" target=\"_blank\" rel=\"noopener noreferrer\">说说 linux 系统下 文件操作常用的命令有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/linux/key\" target=\"_blank\" rel=\"noopener noreferrer\">---</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/linux/linux\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对操作系统的理解？核心概念有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/linux/linux_users\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 linux 用户管理的理解？相关的命令有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/linux/performance\" target=\"_blank\" rel=\"noopener noreferrer\">---</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/linux/redirect_pipe\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对输入输出重定向和管道的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/linux/shell\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 shell 的理解？常见的命令？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/linux/thread_process\" target=\"_blank\" rel=\"noopener noreferrer\">说说什么是进程？什么是线程？区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/linux/vim\" target=\"_blank\" rel=\"noopener noreferrer\">---</a></li>\n</ul>\n",
      "date_published": "2023-04-04T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "linux"
      ]
    },
    {
      "title": "说说 linux 系统下 文件操作常用的命令有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/linux/file.html",
      "id": "https://www.h7ml.cn/posts/interview/linux/file.html",
      "summary": "前端物语|面试物语-说说 linux系统下 文件操作常用的命令有哪些？",
      "content_html": "<h1> 说说 linux 系统下 文件操作常用的命令有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6cb38ac0-03c1-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>Linux</code> 是一个开源的操作系统（OS），是一系列 Linux 内核基础上开发的操作系统的总称（常见的有 Ubuntu、centos）</p>\n<p>系统通常会包含以下 4 个主要部分</p>\n<ul>\n<li>内核</li>\n<li>shell</li>\n<li>文件系统</li>\n<li>应用程序</li>\n</ul>\n<p>文件系统是一个<strong>目录树的结构</strong>，文件系统结构从一个根目录开始，根目录下可以有任意多个文件和子目录，子目录中又可以有任意多个文件和子目录</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b71b64c0-03c1-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、文件操作</h2>\n<p>常见处理目录的命令如下：</p>\n<ul>\n<li>ls（英文全拼：list files）: 列出目录及文件名</li>\n<li>cd（英文全拼：change directory）：切换目录</li>\n<li>pwd（英文全拼：print work directory）：显示目前的目录</li>\n<li>mkdir（英文全拼：make directory）：创建一个新的目录</li>\n<li>rmdir（英文全拼：remove directory）：删除一个空的目录</li>\n<li>cp（英文全拼：copy file）: 复制文件或目录</li>\n<li>rm（英文全拼：remove）: 删除文件或目录</li>\n<li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>\n</ul>\n<h3> ls</h3>\n<p>列出目录文件，选项与参数：</p>\n<ul>\n<li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li>\n<li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li>\n<li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>\n</ul>\n<p>例如将家目录下的所有文件列出来(含属性与隐藏档)</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> cd</h3>\n<p>切换工作目录</p>\n<p>语法：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> pwd</h3>\n<p><code>pwd</code> 是 <code>Print Working Directory</code> 的缩写，也就是显示目前所在目录的命令。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>选项与参数：</p>\n<ul>\n<li>-P ：显示出确实的路径，而非使用连结 (link) 路径</li>\n</ul>\n<h3> mkdir</h3>\n<p>创建新目录</p>\n<p>语法：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>选项与参数：</p>\n<ul>\n<li>-m ：配置文件的权限</li>\n<li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来</li>\n</ul>\n<h3> rmdir (删除空的目录)</h3>\n<p>语法：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>选项与参数：</p>\n<ul>\n<li>-p ：连同上一级『空的』目录也一起删除</li>\n</ul>\n<h3> cp</h3>\n<p>即拷贝文件和目录</p>\n<p>语法：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>用法如下：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>常用参数如下：</p>\n<ul>\n<li><code>-r</code> 递归的拷贝，常用来拷贝一整个目录</li>\n</ul>\n<h3> rm (移除文件或目录)</h3>\n<p>语法：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>选项与参数：</p>\n<ul>\n<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>\n<li>-i ：互动模式，在删除前会询问使用者是否动作</li>\n<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！</li>\n</ul>\n<h3> mv (移动文件与目录，或修改名称)</h3>\n<p>语法：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>选项与参数：</p>\n<ul>\n<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>\n<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>\n<li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>\n</ul>\n<h3> ln</h3>\n<p><code>Linux</code> 文件的存储方式分为 3 个部分，文件名、文件内容以及权限，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过 <code>inode</code> 标识绑定到文件内容</p>\n<p><code>Linux</code> 下有两种链接类型：硬链接和软链接</p>\n<h4> 硬链接</h4>\n<p>使链接的两个文件共享同样文件内容，就是同样的 <code>inode</code> ，一旦文件 1 和文件 2 之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容</p>\n<p>语法：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c92e7800-03c1-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>删除文件 1 不会影响删除文件 2，对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上删除</p>\n<p>只有同时删除了两个文件后后，它们共同指向的文件内容才会消失。</p>\n<h4> 软链接</h4>\n<p>类似<code>window</code>系统的快捷方式</p>\n<p>使用方式：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d5a22eb0-03c1-11ec-8e64-91fdec0f05a1.png\" alt=\"\" loading=\"lazy\">其实 <code>file2</code> 只是 <code>file1</code> 的一个快捷方式，它指向的是 <code>file1</code> ，所以显示的是 <code>file1</code> 的内容，但其实 <code>file2</code> 的 <code>inode</code> 与 <code>file1</code> 并不相同</p>\n<p>如果</p>\n<p>删除了 <code>file2</code> 的话， <code>file1</code> 是不会受影响的，但如果删除 <code>file1</code> 的话， <code>file2</code> 就会变成死链接，因为指向的文件不见了</p>\n<h2> 三、文件查看</h2>\n<p>常见的文件内容查看有如下：</p>\n<ul>\n<li>cat 由第一行开始显示文件内容</li>\n<li>less 一页一页的显示文件内容</li>\n<li>head 只看头几行</li>\n<li>tail 只看尾巴几行</li>\n</ul>\n<h3> cat</h3>\n<p>由第一行开始显示文件内容</p>\n<p>语法：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>常见的选项与参数如下：</p>\n<ul>\n<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>\n<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同</li>\n</ul>\n<h3> less</h3>\n<p>一页一页翻动，以下实例输出/etc/man.config 文件的内容：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>less 运行时可以输入的命令有：</p>\n<ul>\n<li>空白键 ：向下翻动一页；</li>\n<li>[pagedown]：向下翻动一页；</li>\n<li>[pageup] ：向上翻动一页；</li>\n<li>/字串 ：向下搜寻『字串』的功能；</li>\n<li>?字串 ：向上搜寻『字串』的功能；</li>\n<li>n ：重复前一个搜寻 (与 / 或 ? 有关！)</li>\n<li>N ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li>\n<li>q ：离开 less 这个程序</li>\n</ul>\n<h3> head</h3>\n<p>取出文件前面几行</p>\n<p>语法：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>选项与参数：</p>\n<ul>\n<li>-n ：后面接数字，代表显示几行的意思</li>\n</ul>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> tail</h3>\n<p>取出文件后面几行</p>\n<p>语法：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>选项与参数：</p>\n<ul>\n<li>-n ：后面接数字，代表显示几行的意思</li>\n<li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c 才会结束 tail 的侦测</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.runoob.com/linux/linux-file-content-manage.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.runoob.com/linux/linux-file-content-manage.html</a></li>\n<li><a href=\"https://juejin.cn/post/6938385978004340744#heading-35\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6938385978004340744#heading-35</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Linux\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/Linux</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "linux"
      ]
    },
    {
      "title": "React 中的 key 有什么作用？",
      "url": "https://www.h7ml.cn/posts/interview/linux/key.html",
      "id": "https://www.h7ml.cn/posts/interview/linux/key.html",
      "summary": "前端物语|面试物语----",
      "content_html": "<hr>\n<p>icon: question description: 前端物语|面试物语-React 中的 key 有什么作用？ footer: <a href=\"https://beian.mit.gov.cn/\" target=\"blank\">浙 ICP 备 2021037683 号-2</a>React 中的 key 有什么作用？ order: 2 star: 2 date: 2023-02-24 author: h7ml image: <a href=\"https://www.h7ml.cn/logo.png\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/logo.png</a> banner: <a href=\"https://www.h7ml.cn/logo.png\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/logo.png</a> category:</p>\n<ul>\n<li>interview</li>\n<li>React tag:</li>\n<li>interview</li>\n<li>React shortTitle: 前端物语|面试物语-React 中的 key 有什么作用？ isOriginal: false head:\n<ul>\n<li>\n<ul>\n<li>meta</li>\n</ul>\n</li>\n<li>name: keywords content: React 中的 key 有什么作用？</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1> React 中的 key 有什么作用？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/31677360-dd69-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>首先，先给出<code>react</code>组件中进行列表渲染的一个示例：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后在输出就可以看到<code>react</code>所提示的警告信息：</p>\n<div class=\"language-tex line-numbers-mode\" data-ext=\"tex\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>根据意思就可以得到渲染列表的每一个子元素都应该需要一个唯一的<code>key</code>值</p>\n<p>在这里可以使用列表的<code>id</code>属性作为<code>key</code>值以解决上面这个警告</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、作用</h2>\n<p>跟<code>Vue</code>一样，<code>React</code> 也存在 <code>Diff</code>算法，而元素<code>key</code>属性的作用是用于判断元素是新创建的还是被移动的元素，从而减少不必要的元素渲染</p>\n<p>因此<code>key</code>的值需要为每一个元素赋予一个确定的标识</p>\n<p>如果列表数据渲染中，在数据后面插入一条数据，<code>key</code>作用并不大，如下：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>前面的元素在<code>diff</code>算法中，前面的元素由于是完全相同的，并不会产生删除创建操作，在最后一个比较的时候，则需要插入到新的<code>DOM</code>树中</p>\n<p>因此，在这种情况下，元素有无<code>key</code>属性意义并不大</p>\n<p>下面再来看看在前面插入数据时，使用<code>key</code>与不使用<code>key</code>的区别：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当拥有<code>key</code>的时候，<code>react</code>根据<code>key</code>属性匹配原有树上的子元素以及最新树上的子元素，像上述情况只需要将 000 元素插入到最前面位置</p>\n<p>当没有<code>key</code>的时候，所有的<code>li</code>标签都需要进行修改</p>\n<p>同样，并不是拥有<code>key</code>值代表性能越高，如果说只是文本内容改变了，不写<code>key</code>反而性能和效率更高</p>\n<p>主要是因为不写<code>key</code>是将所有的文本内容替换一下，节点不会发生变化</p>\n<p>而写<code>key</code>则涉及到了节点的增和删，发现旧<code>key</code>不存在了，则将其删除，新<code>key</code>在之前没有，则插入，这就增加性能的开销</p>\n<h2> 三、总结</h2>\n<p>良好使用<code>key</code>属性是性能优化的非常关键的一步，注意事项为：</p>\n<ul>\n<li>\n<p>key 应该是唯一的</p>\n</li>\n<li>\n<p>key 不要使用随机值（随机数在下一次 render 时，会重新生成一个数字）</p>\n</li>\n<li>\n<p>使用 index 作为 key 值，对性能没有优化</p>\n</li>\n</ul>\n<p><code>react</code>判断<code>key</code>的流程具体如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3b9afe10-dd69-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh-hans.reactjs.org/docs/lists-and-keys.html#gatsby-focus-wrapper\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh-hans.reactjs.org/docs/lists-and-keys.html#gatsby-focus-wrapper</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017511836\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000017511836</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-29T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "linux"
      ]
    },
    {
      "title": "说说你对操作系统的理解？核心概念有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/linux/linux.html",
      "id": "https://www.h7ml.cn/posts/interview/linux/linux.html",
      "summary": "前端物语|面试物语-说说你对操作系统的理解？核心概念有哪些？",
      "content_html": "<h1> 说说你对操作系统的理解？核心概念有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/0f06bf30-008a-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>操作系统（Operating System，缩写：OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石</p>\n<p>简单来讲，操作系统就是一种复杂的软件，相当于软件管家</p>\n<p>操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务，</p>\n<p>操作系统的类型非常多样，不同机器安装的操作系统可从简单到复杂，可从移动电话的嵌入式系统到超级电脑的大型操作系统，在计算机与用户之间起接口的作用，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/0ad1b850-009b-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>许多操作系统制造者对它涵盖范畴的定义也不尽一致，例如有些操作系统集成了图形用户界面，而有些仅使用命令行界面，将图形用户界面视为一种非必要的应用程序</p>\n<h2> 二、核心概念</h2>\n<p>操作系统的核心概念都是对具体物理硬件的抽象，主要有如下：</p>\n<ul>\n<li>\n<p>进程（线程）：进程（线程）是操作系统对 CPU 的抽象</p>\n</li>\n<li>\n<p>虚拟内存（地址空间）：虚拟内存是操作系统对物理内存的抽象</p>\n</li>\n<li>\n<p>文件：文件是操作系统对物理磁盘的抽象</p>\n</li>\n<li>\n<p>shell：它是一个程序，可从键盘获取命令并将其提供给操作系统以执行。</p>\n</li>\n<li>\n<p>GUI ：是一种用户界面，允许用户通过图形图标和音频指示符与电子设备进行交互</p>\n</li>\n<li>\n<p>计算机架构(computer architecture)： 在计算机工程中，计算机体系结构是描述计算机系统功能，组织和实现的一组规则和方法。它主要包括指令集、内存管理、I/O 和总线结构</p>\n</li>\n<li>\n<p>多处理系统(Computer multitasking)：是指计算机同时运行多个程序的能力</p>\n</li>\n<li>\n<p>程序计数器(Program counter)：程序计数器 是一个 CPU 中的寄存器，用于指示计算机在其程序序列中的位置</p>\n</li>\n<li>\n<p>多线程(multithreading)：是指从软件或者硬件上实现多个线程并发执行的技术</p>\n</li>\n<li>\n<p>CPU 核心(core)：它是 CPU 的大脑，它接收指令，并执行计算或运算以满足这些指令。一个 CPU 可以有多个内核</p>\n</li>\n<li>\n<p>图形处理器(Graphics Processing Unit)：又称显示核心、视觉处理器、显示芯片或绘图芯片</p>\n</li>\n<li>\n<p>缓存命中(cache hit)：当应用程序或软件请求数据时，会首先发生缓存命中</p>\n</li>\n<li>\n<p>RAM((Random Access Memory)：随机存取存储器，也叫主存，是与 CPU 直接交换数据的内部存储器</p>\n</li>\n<li>\n<p>ROM (Read Only Memory)：只读存储器是一种半导体存储器，其特性是一旦存储数据就无法改变或删除</p>\n</li>\n<li>\n<p>虚拟地址(virtual memory)： 虚拟内存是计算机系统内存管理的一种机制</p>\n</li>\n<li>\n<p>驱动程序(device driver)：设备驱动程序，简称驱动程序（driver），是一个允许高级别电脑软件与硬件交互的程序</p>\n</li>\n<li>\n<p>USB(Universal Serial Bus)：是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范</p>\n</li>\n<li>\n<p>地址空间(address space)：地址空间是内存中可供程序或进程使用的有效地址范</p>\n</li>\n<li>\n<p>进程间通信(interprocess communication)： 指至少两个进程或线程间传送数据或信号的一些技术或方法</p>\n</li>\n<li>\n<p>目录(directory)： 在计算机或相关设备中，一个目录或文件夹就是一个装有数字文件系统的虚拟容器</p>\n</li>\n<li>\n<p>路径(path name)： 路径是一种电脑文件或目录的名称的通用表现形式，它指向文件系统上的一个唯一位置。</p>\n</li>\n<li>\n<p>根目录(root directory)：根目录指的就是计算机系统中的顶层目录，比如 Windows 中的 C 盘和 D 盘，Linux 中的 /</p>\n</li>\n<li>\n<p>工作目录(Working directory)：它是一个计算机用语。用户在操作系统内所在的目录，用户可在此目录之下，用相对文件名访问文件。</p>\n</li>\n<li>\n<p>文件描述符(file descriptor)： 文件描述符是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念</p>\n</li>\n<li>\n<p>客户端(clients)：客户端是访问服务器提供的服务的计算机硬件或软件。</p>\n</li>\n<li>\n<p>服务端(servers)： 在计算中，服务器是为其他程序或设备提供功能的计算机程序或设备</p>\n</li>\n</ul>\n<h2> 三、总结</h2>\n<ul>\n<li>操作系统是管理计算机硬件与软件资源的程序，是计算机的基石</li>\n<li>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源</li>\n<li>操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项</li>\n<li>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.cnblogs.com/cxuanBlog/p/13297199.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/cxuanBlog/p/13297199.html</a></li>\n<li><a href=\"https://www.cnblogs.com/cxuanblog/p/12607608.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/cxuanblog/p/12607608.html</a></li>\n<li><a href=\"https://www.anvilliu.com/2021/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.anvilliu.com/2021/03/06/计算机操作系统——基本概念/</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "linux"
      ]
    },
    {
      "title": "说说你对 linux 用户管理的理解？相关的命令有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/linux/linux_users.html",
      "id": "https://www.h7ml.cn/posts/interview/linux/linux_users.html",
      "summary": "前端物语|面试物语-说说你对 linux 用户管理的理解？相关的命令有哪些？",
      "content_html": "<h1> 说说你对 linux 用户管理的理解？相关的命令有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8d8d9d70-0417-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>Linux 是一个多用户的系统，允许使用者在系统上通过规划不同类型、不同层级的用户，并公平地分配系统资源与工作环境</p>\n<p>而与 <code>Windows</code> 系统最大的不同， <code>Linux</code> 允许不同的用户同时登录主机，同时使用主机的资源</p>\n<p>既然是多用户的系统，那么最常见的问题就是权限，不同的用户对于不同的文件都应该有各自的权限</p>\n<p>例如，小 A 希望个人文件不被其他用户读取，而如果不对文件进行权限设置，共享了主机资源的小 B 也可以读取小 A 的个人文件，这是不合理的</p>\n<p>这里面涉及到用户与用户组的概念</p>\n<h2> 二、用户与用户组</h2>\n<p><code>Linux</code>以 “用户与用户组” 的概念，建立用户与文件权限之间的联系，保证系统能够充分考虑每个用户的隐私保护，很大程度上保障了 <code>Linux</code> 作为多用户系统的可行性</p>\n<p>从文件权限的角度出发，“用户与用户组” 引申为三个具体的对象：</p>\n<ul>\n<li><strong>文件所有者</strong></li>\n<li><strong>用户组成员</strong></li>\n<li><strong>其他人</strong></li>\n</ul>\n<p>每一个对象对某一个文件的持有权限是不同的</p>\n<h3> 文件所有者</h3>\n<p>当一个用户创建了一个文件，这个用户就是这个文件的文件所有者。文件所有者对文件拥有最高权限，同时排他性地拥有该文件</p>\n<p>除非文件所有者开放权限，否则其他人无法对文件执行查看、修改等操作</p>\n<h3> 用户组</h3>\n<p>将 “其他用户” 区分为用户组成员和其他人后，若文件所有者希望对部分用户开放权限，而对其他人继续保持私有，则只需要将这部分用户与文件所有者划入一个用户组</p>\n<p>这样，这部分用户就成了与文件所有者同组的用户组成员。用户可以对用户组成员开放文件权限，用户组成员则具备了查看、修改文件的权限，而对其他无关用户保持私有</p>\n<p>例如，团队成员之间保持文件资源共享，但对非团队成员保持私有，这就需要将文件所有者与团队成员用户划分为同一个用户组，再对用户组成员开放权限即可</p>\n<h3> 其他人</h3>\n<p>既与文件所有者没有任何联系的其他用户</p>\n<h3> 小结</h3>\n<p>户和用户组的对应关系是：一对一、多对一、一对多或多对多：</p>\n<ul>\n<li>一对一：某个用户可以是某个组的唯一成员</li>\n<li>多对一：多个用户可以是某个唯一的组的成员，不归属其它用户组</li>\n<li>一对多：某个用户可以是多个用户组的成员</li>\n<li>多对多：多个用户对应多个用户组，并且几个用户可以是归属相同的组</li>\n</ul>\n<h3> 拓展</h3>\n<p>当我们使用<code>ls -l</code>的时候，会列出当前目录的文件信息，如下：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>d：文件类型</li>\n<li>rwxr-xr-x：文件权限</li>\n<li>3 硬链接数或目录包含的文件数</li>\n<li>osmond：文件所有者</li>\n<li>4096：文件长度</li>\n<li>05-16 13:32：文件上次修改的事件和日期</li>\n<li>nobp：文件名</li>\n</ul>\n<p>下面主要看看文件权限分析，实际上是由 9 个字符组成，每 3 个一组：</p>\n<ul>\n<li>第一组控制文件<strong>所有者</strong>的访问权限</li>\n<li>第二组控制所有者<strong>所在用户组</strong>的其他成员的访问权限</li>\n<li>第三组控制<strong>系统其他用户</strong>的访问权限</li>\n</ul>\n<p><code>-</code>代表当前没有，<code>rwx</code>对应代表的意思如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9ac2cf60-0417-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 三、用户操作</h3>\n<p>用户相关的操作有如下：</p>\n<h3> 新增用户</h3>\n<p><code>useradd</code> 可以用来创建新用户，简要语法为：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>例如：</p>\n<p>添加一个一般用户</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>为添加的用户指定相应的用户组</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>创建一个系统用户</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>为新添加的用户指定/home 目录</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 设置密码</h2>\n<p>创建的用户还没有设置登录密码，需要利用<code>passwd</code>进行密码设置</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>option</code> 参数有如下：</p>\n<ul>\n<li>-d 删除密码</li>\n<li>-f 强迫用户下次登录时必须修改口令</li>\n<li>-w 口令要到期提前警告的天数</li>\n<li>-k 更新只能发送在过期之后</li>\n<li>-l 停止账号使用</li>\n<li>-S 显示密码信息</li>\n<li>-u 启用已被停止的账户</li>\n<li>-x 指定口令最长存活期</li>\n<li>-g 修改群组密码</li>\n<li>指定口令最短存活期</li>\n<li>-i 口令过期后多少天停用账户</li>\n</ul>\n<p>例如，修改用户密码</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>显示账号密码信息</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>删除用户密码</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 修改用户</h3>\n<p><code>chage</code> 命令用来修改与用户密码相关的过期信息，如密码失效日、密码最短保留天数、失效前警告天数等</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>常见的参数有：</p>\n<ul>\n<li>\n<p>-d：指定密码最后修改日期</p>\n</li>\n<li>\n<p>-E：密码到期的日期</p>\n</li>\n<li>\n<p>-l：列出用户以及密码的有效期</p>\n</li>\n<li>\n<p>-m：密码能够更改的最小天数</p>\n</li>\n<li>\n<p>-M：密码保持有效的最大天数</p>\n</li>\n</ul>\n<h3> 删除用户</h3>\n<p>userdel 命令用来删除用户的相关的所有数据。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>常见的参数有：</p>\n<ul>\n<li>-r：删除用户登入目录以及目录中所有文件</li>\n</ul>\n<p>例如删除用户账号</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>用户组相关的操作如下：</p>\n<h3> 新增用户组</h3>\n<p><code>groupadd</code>用于创建一个新的工作组，新工作组的信息将被添加到系统文件中</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>常见的参数有如下：</p>\n<ul>\n<li>-g：指定新建工作组的 id；</li>\n<li>-r：创建系统工作组，系统工作组的组 ID 小于 500</li>\n<li>-K：覆盖配置文件 \"/ect/login.defs\"</li>\n<li>-o：允许添加组 ID 号不唯一的工作组</li>\n<li>-f,--force: 如果指定的组已经存在，此选项将失明了仅以成功状态退出</li>\n</ul>\n<p>例如创建一个新的组，并添加组 ID。</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 修改用户</h3>\n<p><code>groupmod</code>命令用来修改 <code>group</code>相关的参数，例如群组识别码或者名称</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>常见的参数有：</p>\n<ul>\n<li>-g &lt;群组识别码&gt; 　设置欲使用的群组识别码</li>\n<li>-o 　重复使用群组识别码</li>\n<li>-n &lt;新群组名称&gt; 　设置欲使用的群组名</li>\n</ul>\n<p>例如修改组名：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 删除用户组</h3>\n<p><code>groupdel</code> 用于删除用户组，如果该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>日常工作通常会碰到只有<code>root</code>用户才有权限执行的操作，这就需要使用用户身份切换的命令：</p>\n<h3> su</h3>\n<p>用于变更为其他使用者的身份，除 <code>root</code> 外，需要键入该使用者的密码</p>\n<h3> sudo</h3>\n<p><code>sudo</code>命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行</p>\n<p>不是所有的用户都能执行 <code>sudo</code> 命令的，而是在 <code>/etc/sudoers</code> 文件内的用户才能执行这个命令</p>\n<p>例如<code>sudo</code>命令使用<code>ls</code>：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/37964411\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/37964411</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/105482468\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/105482468</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-02T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "linux"
      ]
    },
    {
      "title": "Vue3.0 性能提升主要是通过哪几方面体现的？",
      "url": "https://www.h7ml.cn/posts/interview/linux/performance.html",
      "id": "https://www.h7ml.cn/posts/interview/linux/performance.html",
      "summary": "前端物语|面试物语----",
      "content_html": "<hr>\n<p>icon: question description: 前端物语|面试物语-Vue3.0 性能提升主要是通过哪几方面体现的？ footer: <a href=\"https://beian.mit.gov.cn/\" target=\"blank\">浙 ICP 备 2021037683 号-2</a>Vue3.0 性能提升主要是通过哪几方面体现的？ order: 1 star: 1 date: 2023-02-24 author: h7ml image: <a href=\"https://www.h7ml.cn/logo.png\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/logo.png</a> banner: <a href=\"https://www.h7ml.cn/logo.png\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/logo.png</a> category:</p>\n<ul>\n<li>interview</li>\n<li>vue3 tag:</li>\n<li>interview</li>\n<li>vue3 shortTitle: 前端物语|面试物语-Vue3.0 性能提升主要是通过哪几方面体现的？ isOriginal: false head:\n<ul>\n<li>\n<ul>\n<li>meta</li>\n</ul>\n</li>\n<li>name: keywords content: Vue3.0 性能提升主要是通过哪几方面体现的？</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1> Vue3.0 性能提升主要是通过哪几方面体现的？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2aac1020-5ed0-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、编译阶段</h2>\n<p>回顾<code>Vue2</code>，我们知道每个组件实例都对应一个 <code>watcher</code> 实例，它会在组件渲染的过程中把用到的数据<code>property</code>记录为依赖，当依赖发生改变，触发<code>setter</code>，则会通知<code>watcher</code>，从而使关联的组件重新渲染</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/39066120-5ed0-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>试想一下，一个组件结构如下图</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 <code>diff</code> 和遍历其实都是不需要的，造成性能浪费</p>\n<p>因此，<code>Vue3</code>在编译阶段，做了进一步优化。主要有如下：</p>\n<ul>\n<li>diff 算法优化</li>\n<li>静态提升</li>\n<li>事件监听缓存</li>\n<li>SSR 优化</li>\n</ul>\n<h4> diff 算法优化</h4>\n<p><code>vue3</code>在<code>diff</code>算法中相比<code>vue2</code>增加了静态标记</p>\n<p>关于这个静态标记，其作用是为了会发生变化的地方添加一个<code>flag</code>标记，下次发生变化的时候直接找该地方进行比较</p>\n<p>下图这里，已经标记静态节点的<code>p</code>标签在<code>diff</code>过程中则不会比较，把性能进一步提高</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c732e150-5c58-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>关于静态类型枚举如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 静态提升</h4>\n<p><code>Vue3</code>中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用</p>\n<p>这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>没有做静态提升之前</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>做了静态提升之后</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>静态内容<code>_hoisted_1</code>被放置在<code>render</code> 函数外，每次渲染的时候只要取 <code>_hoisted_1</code> 即可</p>\n<p>同时 <code>_hoisted_1</code> 被打上了 <code>PatchFlag</code> ，静态标记值为 -1 ，特殊标志是负整数表示永远不会用于 Diff</p>\n<h4> 事件监听缓存</h4>\n<p>默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>没开启事件监听器缓存</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>开启事件侦听器缓存后</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述发现开启了缓存后，没有了静态标记。也就是说下次<code>diff</code>算法的时候直接使用</p>\n<h4> SSR 优化</h4>\n<p>当静态内容大到一定量级时候，会用<code>createStaticVNode</code>方法在客户端去生成一个 static node，这些静态<code>node</code>，会被直接<code>innerHtml</code>，就不需要创建对象，然后根据对象渲染</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>编译后</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、源码体积</h2>\n<p>相比<code>Vue2</code>，<code>Vue3</code>整体体积变小了，除了移出一些不常用的 API，再重要的是<code>Tree shanking</code></p>\n<p>任何一个函数，如<code>ref</code>、<code>reavtived</code>、<code>computed</code>等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、响应式系统</h2>\n<p><code>vue2</code>中采用 <code>defineProperty</code>来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加<code>getter</code>和<code>setter</code>，实现响应式</p>\n<p><code>vue3</code>采用<code>proxy</code>重写了响应式系统，因为<code>proxy</code>可以对整个对象进行监听，所以不需要深度遍历</p>\n<ul>\n<li>可以监听动态属性的添加</li>\n<li>可以监听到数组的索引和数组<code>length</code>属性</li>\n<li>可以监听删除属性</li>\n</ul>\n<p>关于这两个 API 具体的不同，我们下篇文章会进行一个更加详细的介绍</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6903171037211557895\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6903171037211557895</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-04T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "linux"
      ]
    },
    {
      "title": "说说你对输入输出重定向和管道的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/linux/redirect_pipe.html",
      "id": "https://www.h7ml.cn/posts/interview/linux/redirect_pipe.html",
      "summary": "前端物语|面试物语-说说你对输入输出重定向和管道的理解？应用场景？",
      "content_html": "<h1> 说说你对输入输出重定向和管道的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1036dde0-0634-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>linux</code>中有三种标准输入输出，分别是<code>STDIN</code>，<code>STDOUT</code>，<code>STDERR</code>，对应的数字是 0、1、2：</p>\n<ul>\n<li>STDIN 是标准输入，默认从键盘读取信息</li>\n<li>STDOUT 是标准输出，默认将输出结果输出至终端</li>\n<li>STDERR 是标准错误，默认将输出结果输出至终端</li>\n</ul>\n<p>对于任何<code>linux</code>命令的执行会有下面的过程：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1a57caf0-0634-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>一条命令的执行需要键盘等的标准输入，命令的执行和正确或错误，其中的每一个双向箭头就是一个通道，所以数据流可以流入到文件端（<strong>重定向或管道</strong>）</p>\n<p>简单来讲，重定向就是把本来要显示在终端的命令结果，输送到别的地方，分成：</p>\n<ul>\n<li>输入重定向：流出到屏幕如果命令所需的输入不是来自键盘，而是来自指定的文件</li>\n<li>输出重定向：命令的输出可以不显示在屏幕，而是写在指定的文件中</li>\n</ul>\n<p>管道就是把两个命令连接起来使用，一个命令的输出作为另一个命令的输入</p>\n<p>两者的区别在于：</p>\n<ul>\n<li>管道触发两个子进程，执行 | 两边的程序；而重定向是在一个进程内执行。</li>\n<li>管道两边都是 shell 命令</li>\n<li>重定向符号的右边只能是 Linux 文件</li>\n<li>重定向符号的优先级大于管道</li>\n</ul>\n<h2> 二、命令</h2>\n<p>重定向常见的命令符号有：</p>\n<ul>\n<li>&gt; ： 输出重定向到一个文件或设备 覆盖原来的文件</li>\n</ul>\n<blockquote>\n<p>如果该文件不存在，则新建一个文件</p>\n<p>如果该文件已经存在，会把文件内容覆盖</p>\n<p>这些操纵不会征用用户的确认</p>\n</blockquote>\n<ul>\n<li>&gt;&gt; ：输出重定向到一个文件或设备，但是是 追加原来的文件的末尾</li>\n<li>&lt; ：用于制定命令的输入</li>\n<li>&lt;&lt; ：从键盘的输入重定向为某个命令的输入</li>\n</ul>\n<blockquote>\n<p>以逐行输入的模式（回车键进行换行）</p>\n<p>所有输入的行都将在输入结束字符串之后发送给命令</p>\n</blockquote>\n<ul>\n<li>2&gt; 将一个标准错误输出重定向到一个文件或设备，会覆盖原来的文件</li>\n<li>2&gt;&gt; 将一个标准错误输出重定向到一个文件或设备，是追加到原来的文件</li>\n<li>2&gt;&amp;1：组合符号，将标准错误输出重定向到标准输出相同的地方</li>\n</ul>\n<blockquote>\n<p>1 就是代表标准输出</p>\n</blockquote>\n<ul>\n<li>&gt;&amp; 将一个标准错误输出重定向到一个文件或设备覆盖原来的文件</li>\n<li>|&amp; 将一个标准错误管道输出到另一个命令作为输入</li>\n</ul>\n<h2> 三、应用场景</h2>\n<p>将当前目录的文件输出重定向到<code>1.txt</code>文件中，并且会清空原有的<code>1.txt</code>的内容</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>或者以追加的形式，重定向输入到<code>1.txt</code>中</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>将标准错误输出到某个文件，可以如下：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过组合符号将两者结合一起，无论进程输出的信息是正确还是错误的信息，都会重定向到指定的文件里</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再者通过管道查询文件内容是否包含想要的信息：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>上述<code>cat test.txt</code>会将<code>test.txt</code>的内容作为标准输出，然后利用管道，将其作为<code>grep -n 'xxx'</code>命令的标准输入。</p>\n<h3> 参考文献</h3>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000020519335\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000020519335</a></li>\n<li><a href=\"https://murphypei.github.io/blog/2018/04/linux-redirect-pipe\" target=\"_blank\" rel=\"noopener noreferrer\">https://murphypei.github.io/blog/2018/04/linux-redirect-pipe</a></li>\n<li><a href=\"https://www.huaweicloud.com/articles/0fb70e8c724ae79f4fc8d676cd6160d3.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.huaweicloud.com/articles/0fb70e8c724ae79f4fc8d676cd6160d3.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-01T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "linux"
      ]
    },
    {
      "title": "说说你对 shell 的理解？常见的命令？",
      "url": "https://www.h7ml.cn/posts/interview/linux/shell.html",
      "id": "https://www.h7ml.cn/posts/interview/linux/shell.html",
      "summary": "前端物语|面试物语-说说你对 shell 的理解？常见的命令？",
      "content_html": "<h1> 说说你对 shell 的理解？常见的命令？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/71003620-0883-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>Shell</code>是一个由<code>c</code>语言编写的应用程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言</p>\n<p>它连接了用户和<code>Linux</code>内核，让用户能够更加高效、安全、低成本地使用 <code>Linux</code> 内核</p>\n<p>其本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序，它和 QQ、微信等其它软件没有什么区别，特殊的地方就是开机立马启动，并呈现在用户面前</p>\n<p>主要作用是接收用户输入的命令，并对命令进行处理，处理完毕后再将结果反馈给用户，比如输出到显示器、写入到文件等，同样能够调用和组织其他的应用程序，相当于一个领导者的身份，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/80db0ca0-0883-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>那么<code>shell</code>脚本就是多个 <code>Shell</code> 命令的组合并通过 <code>if</code> 条件分支控制或循环来组合运算，实现一些复杂功能，文件后缀名为<code>.sh</code></p>\n<p>常用的 <code>ls</code> 命令，它本身也是一个 <code>Shell</code> 脚本，通过执行这个 <code>Shell</code> 脚本可以列举当前目录下的文件列表，如下创建一个<code>hello.sh</code>脚本</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p>#!/bin/bash ：指定脚本要使用的 Shell 类型为 Bash</p>\n</li>\n<li>\n<p>ls、echo： 脚本文件的内容，表明我们执行 <a href=\"http://hello.sh\" target=\"_blank\" rel=\"noopener noreferrer\">hello.sh</a> 脚本时会列举出当前目录的文件列表并且会向控制台打印 `hello world</p>\n</li>\n</ul>\n<p>执行方式为<code>.hello.zsh</code></p>\n<h2> 二、种类</h2>\n<p><code>Linux</code> 的 <code>Shell</code> 种类众多，只要能给用户提供命令行环境的程序，常见的有：</p>\n<ul>\n<li>\n<p>Bourne Shell（sh），是目前所有 Shell 的祖先，被安装在几乎所有发源于 Unix 的操作系统上</p>\n</li>\n<li>\n<p>Bourne Again shell（bash） ，是 sh 的一个进阶版本，比 sh 更优秀， bash 是目前大多数 Linux 发行版以及 macOS 操作系统的默认 Shell</p>\n</li>\n<li>\n<p>C Shell（csh） ，它的语法类似 C 语言</p>\n</li>\n<li>\n<p>TENEX C Shell（tcsh） ，它是 csh 的优化版本</p>\n</li>\n<li>\n<p>Korn shell（ksh） ，一般在收费的 Unix 版本上比较多见</p>\n</li>\n<li>\n<p>Z Shell（zsh） ，它是一种比较新近的 Shell ，集 bash 、 ksh 和 tcsh 各家之大成</p>\n</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8e739440-0883-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>关于 <code>Shell</code> 的几个常见命令：</p>\n<ul>\n<li>ls：查看文件</li>\n<li>cd：切换工作目录</li>\n<li>pwd：显示用户当前目录</li>\n<li>mkdir：创建目录</li>\n<li>cp：拷贝</li>\n<li>rm：删除</li>\n<li>mv：移动</li>\n<li>du：显示目录所占用的磁盘空间</li>\n</ul>\n<h2> 三、命令</h2>\n<p><code>Shell</code> 并不是简单的堆砌命令，我们还可以在 <code>Shell</code> 中编程，这和使用 <code>C++</code>、<code>C#</code>、<code>Java</code>、<code>Python</code> 等常见的编程语言并没有什么两样。</p>\n<p>Shell 虽然没有 C++、Java、Python 等强大，但也支持了基本的编程元素，例如：</p>\n<ul>\n<li>if...else 选择结构，case...in 开关语句，for、while、until 循环；</li>\n<li>变量、数组、字符串、注释、加减乘除、逻辑运算等概念；</li>\n<li>函数，包括用户自定义的函数和内置函数（例如 printf、export、eval 等）</li>\n</ul>\n<p>下面以<code>bash</code>为例简单了解一下<code>shell</code>的基本使用</p>\n<h3> 变量</h3>\n<p><code>Bash</code> 没有数据类型的概念，所有的变量值都是字符串，可以保存一个数字、一个字符、一个字符串等等</p>\n<p>同时无需提前声明变量，给变量赋值会直接创建变量</p>\n<p>访问变量的语法形式为：<code>${var}</code> 和 <code>$var</code> 。</p>\n<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，所以推荐加花括号。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 条件控制</h3>\n<p>跟其它程序设计语言一样，Bash 中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在<code>[[ ]]</code>里的表达式</p>\n<p>跟其他语言一样，使用<code>if...else</code>进行表达，如果中括号里的表达式为真，那么<code>then</code>和<code>fi</code>之间的代码会被执行，如果则<code>else</code>和<code>fi</code>之间的代码会被执行</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>fi</code>标志着条件代码块的结束</p>\n<h3> 函数</h3>\n<p>bash 函数定义语法如下：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>函数定义时，function 关键字可有可无</li>\n<li>函数返回值 - return 返回函数返回值，返回值类型只能为整数（0-255）。如果不加 return 语句，shell 默认将以最后一条命令的运行结果，作为函数返回值</li>\n<li>函数返回值在调用该函数后通过 $? 来获得</li>\n<li>所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"http://c.biancheng.net/view/706.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://c.biancheng.net/view/706.html</a></li>\n<li><a href=\"https://juejin.cn/post/6930013333454061575\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6930013333454061575</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-04T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "linux"
      ]
    },
    {
      "title": "说说什么是进程？什么是线程？区别？",
      "url": "https://www.h7ml.cn/posts/interview/linux/thread_process.html",
      "id": "https://www.h7ml.cn/posts/interview/linux/thread_process.html",
      "summary": "前端物语|面试物语-说说什么是进程？什么是线程？区别？",
      "content_html": "<h1> 说说什么是进程？什么是线程？区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f414d8a0-02f6-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、进程</h2>\n<p>操作系统中最核心的概念就是进程，进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位</p>\n<p>操作系统的其他所有内容都是围绕着进程展开的，负责执行这些任务的是<code>CPU</code></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3ff146b0-02f6-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>进程是一种抽象的概念，从来没有统一的标准定义看，一般由程序、数据集合和进程控制块三部分组成：</p>\n<ul>\n<li>程序用于描述进程要完成的功能，是控制进程执行的指令集</li>\n<li>数据集合是程序在执行时所需要的数据和工作区</li>\n<li>程序控制块，包含进程的描述信息和控制信息，是进程存在的唯一标志</li>\n</ul>\n<h2> 二、线程</h2>\n<p><strong>线程</strong>（thread）是操作系统能够进行<strong>运算调度</strong>的最小单位，其是进程中的一个执行任务（控制单元），负责当前进程中程序的执行</p>\n<p>一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享同一块内存，线程之间可以共享对象、资源，如果有冲突或需要协同，还可以随时沟通以解决冲突或保持同步</p>\n<p>举个例子，假设你经营着一家物业管理公司。最初，业务量很小，事事都需要你亲力亲为。给老张家修完暖气管道，立马再去老李家换电灯泡——这叫单线程，所有的工作都得顺序执行</p>\n<p>后来业务拓展了，你雇佣了几个工人，这样，你的物业公司就可以同时为多户人家提供服务了——这叫多线程，你是主线程</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/63de34c0-02f6-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>但实际上，并不是线程越多，进程的工作效率越高，这是因为在一个进程内，不管你创建了多少线程，它们总是被限定在一颗<code>CPU</code>内，或者多核<code>CPU</code>的一个核内</p>\n<p>这意味着，多线程在宏观上是并行的，在微观上则是分时切换串行的，多线程编程无法充分发挥多核计算资源的优势</p>\n<p>这导致使用多线程做任务并行处理时，线程数量超过一定数值后，线程越多速度反倒越慢的原因</p>\n<h2> 三、区别</h2>\n<ul>\n<li>\n<p><strong>本质区别</strong>：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p>\n</li>\n<li>\n<p><strong>在开销方面</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</p>\n</li>\n<li>\n<p><strong>所处环境</strong>：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过 CPU 调度，在每个时间片中只有一个线程执行）</p>\n</li>\n<li>\n<p><strong>内存分配方面</strong>：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了 CPU 外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源</p>\n</li>\n<li>\n<p><strong>包含关系</strong>：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</p>\n</li>\n</ul>\n<p>举个例子：进程=火车，线程=车厢</p>\n<ul>\n<li>线程在进程下行进（单纯的车厢无法运行）</li>\n<li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li>\n<li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li>\n<li>同一进程下不同线程间数据很易共享（A 车厢换到 B 车厢很容易）</li>\n<li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li>\n<li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/106283969\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/106283969</a></li>\n<li><a href=\"https://blog.csdn.net/ThinkWAon/article/details/102021274\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/ThinkWAon/article/details/102021274</a></li>\n<li><a href=\"https://www.zhihu.com/question/25532384\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.zhihu.com/question/25532384</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-25T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "linux"
      ]
    },
    {
      "title": "说说 linux 系统下 文本编辑常用的命令有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/linux/vim.html",
      "id": "https://www.h7ml.cn/posts/interview/linux/vim.html",
      "summary": "前端物语|面试物语----",
      "content_html": "<hr>\n<p>icon: question description: 前端物语|面试物语-说说 linux 系统下 文本编辑常用的命令有哪些？ footer: <a href=\"https://beian.mit.gov.cn/\" target=\"blank\">浙 ICP 备 2021037683 号-2</a>说说 linux 系统下 文本编辑常用的命令有哪些？ order: 1 star: 1 date: 2023-02-24 author: h7ml image: <a href=\"https://www.h7ml.cn/logo.png\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/logo.png</a> banner: <a href=\"https://www.h7ml.cn/logo.png\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.h7ml.cn/logo.png</a> category:</p>\n<ul>\n<li>interview</li>\n<li>linux tag:</li>\n<li>interview</li>\n<li>linux shortTitle: 前端物语|面试物语-说说 linux 系统下 文本编辑常用的命令有哪些？ isOriginal: false head:\n<ul>\n<li>\n<ul>\n<li>meta</li>\n</ul>\n</li>\n<li>name: keywords content: 说说 linux 系统下 文本编辑常用的命令有哪些？</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1> 说说 linux 系统下 文本编辑常用的命令有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1062b8b0-049b-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>Vim</code>是从 <code>vi</code> 发展出来的一个文本编辑器，代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>\n<p>简单的来说， <code>vi</code> 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方</p>\n<p>而<code>vim</code>可以说是程序开发者的一项很好用的工具</p>\n<h2> 二、使用</h2>\n<p>基本上 vi/vim 共分为三种模式，分别是：</p>\n<ul>\n<li>命令模式（Command mode）</li>\n<li>输入模式（Insert mode）</li>\n<li>底线命令模式（Last line mode）</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/265a0080-03d6-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 命令模式</h3>\n<p><code>Vim</code> 的默认模式，在这个模式下，你不能输入文本，但是可以让我们在文本间移动，删除一行文本，复制黏贴文本，跳转到指定行，撤销操作，等等</p>\n<h4> 移动光标</h4>\n<p>常用的命令如下：</p>\n<ul>\n<li>h 向左移动一个字符</li>\n<li>j 向下移动一个字符</li>\n<li>k 向上移动一个字符</li>\n<li>i 向右移动一个字符</li>\n</ul>\n<p>或者使用方向键进行控制</p>\n<p>如果想要向下移动<code>n</code>行，可通过使用 \"nj\" 或 \"n↓\" 的组合按键</p>\n<h4> 搜索</h4>\n<p>常见的命令如下：</p>\n<ul>\n<li>\n<p>/word：向光标之下寻找一个名称为 word 的字符</p>\n</li>\n<li>\n<p>?word：向光标之上寻找一个字符串名称为 word 的字符串</p>\n</li>\n<li>\n<p>n：代表重复前一个搜寻的动作，即再次执行上一次的操作</p>\n</li>\n<li>\n<p>N：反向进行前一个搜索动作</p>\n</li>\n</ul>\n<h4> 删除、复制、粘贴</h4>\n<p>常用的命令如下：</p>\n<ul>\n<li>x：向后删除一个字符</li>\n<li>X：向前删除一个字符</li>\n<li>nc：n 为数字，连续向后删除 n 个字符</li>\n<li>dd：删除游标所在的那一整行</li>\n<li>d0：删除游标所在处，到该行的最前面一个字符</li>\n<li>d$删除游标所在处，到该行的最后一个字符</li>\n<li>ndd：除光标所在的向下 n 行</li>\n<li>yy：复制游标所在的那一行</li>\n<li>y0：复制光标所在的那个字符到该行行首的所有数据</li>\n<li>y$：复制光标所在的那个字符到该行行尾的所有数据</li>\n<li>p：已复制的数据在光标下一行贴上</li>\n<li>P：已复制的数据在光标上一行贴上</li>\n<li>nc：重复删除 n 行数据</li>\n</ul>\n<h3> 输入模式</h3>\n<p>命令模式通过输入大小写<code>i</code>、<code>a</code>、<code>o</code>可以切换到输入模式，如下：</p>\n<ul>\n<li>i：从目前光标所在处输入</li>\n<li>I：在目前所在行的第一个非空格符处开始输入</li>\n<li>a：从目前光标所在的下一个字符处开始输入</li>\n<li>A：从光标所在行的最后一个字符处开始输入</li>\n<li>o：在目前光标所在的下一行处输入新的一行</li>\n<li>O：目前光标所在的上一行处输入新的一行</li>\n</ul>\n<p>输入模式我们熟悉的文本编辑器的模式，就是可以输入任何你想输入的内容</p>\n<p>如果想从插入模式回到命令模式，使用按下键盘左上角的<code>ESC</code>键</p>\n<h3> 底线命令模式</h3>\n<p>这个模式下可以运行一些命令例如“退出”，“保存”，等动作，为了进入底线命令模式，首先要进入命令模式，再按下冒号键：</p>\n<p>常见的命令如下：</p>\n<ul>\n<li>w：将编辑的数据写入硬盘档案中</li>\n<li>w!：若文件属性为『只读』时，强制写入该档案</li>\n<li>q：未修改，直接退出</li>\n<li>q!：修改过但不存储</li>\n<li>wq：储存后离开</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.runoob.com/linux/linux-vim.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.runoob.com/linux/linux-vim.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-03T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "linux"
      ]
    },
    {
      "title": "前端物语|面试物语-typescript",
      "url": "https://www.h7ml.cn/posts/interview/typescript/",
      "id": "https://www.h7ml.cn/posts/interview/typescript/",
      "summary": "说说你对 TypeScript 中类的理解？应用场景？ 说说 typescript 的数据类型有哪些？ 说说你对 TypeScript 装饰器的理解？应用场景？ 说说你对 TypeScript 中枚举类型的理解？应用场景？ 说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？ 说说你对 TypeScript 中泛型的理解？应用场景？ 说说你对 TypeScript 中高级类型的理解？有哪些？ 说说你对 TypeScript 中接口的理解？应用场景？ 说说对 TypeScript 中命名空间与模块的理解？区别？ 说说如何在 React 项目中应用 TypeScript？ 说说你对 TypeScript 的理解？与 JavaScript 的区别？ 说说如何在 Vue 项目中应用 TypeScript？",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/interview/typescript/class\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 中类的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/typescript/data_type\" target=\"_blank\" rel=\"noopener noreferrer\">说说 typescript 的数据类型有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/typescript/decorator\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 装饰器的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/typescript/enum\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 中枚举类型的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/typescript/function\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/typescript/generic\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 中泛型的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/typescript/high_type\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 中高级类型的理解？有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/typescript/interface\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 中接口的理解？应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/typescript/namespace_module\" target=\"_blank\" rel=\"noopener noreferrer\">说说对 TypeScript 中命名空间与模块的理解？区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/typescript/react\" target=\"_blank\" rel=\"noopener noreferrer\">说说如何在 React 项目中应用 TypeScript？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/typescript/typescript_javascript\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 TypeScript 的理解？与 JavaScript 的区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/typescript/vue\" target=\"_blank\" rel=\"noopener noreferrer\">说说如何在 Vue 项目中应用 TypeScript？</a></li>\n</ul>\n",
      "date_published": "2023-04-07T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "typescript"
      ]
    },
    {
      "title": "说说你对 TypeScript 中类的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/typescript/class.html",
      "id": "https://www.h7ml.cn/posts/interview/typescript/class.html",
      "summary": "前端物语|面试物语-说说你对 TypeScript 中类的理解？应用场景？",
      "content_html": "<h1> 说说你对 TypeScript 中类的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e4c19060-0cb4-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础</p>\n<blockquote>\n<p>类是一种用户定义的引用数据类型，也称类类型</p>\n</blockquote>\n<p>传统的面向对象语言基本都是基于类的，<code>JavaScript</code> 基于原型的方式让开发者多了很多理解成本</p>\n<p>在 <code>ES6</code> 之后，<code>JavaScript</code> 拥有了 <code>class</code> 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多</p>\n<p>但是<code>JavaScript</code> 的<code>class</code>依然有一些特性还没有加入，比如修饰符和抽象类</p>\n<p><code>TypeScript</code> 的 <code>class</code> 支持面向对象的所有特性，比如 类、接口等</p>\n<h2> 二、使用方式</h2>\n<p>定义类的关键字为 <code>class</code>，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：</p>\n<ul>\n<li><strong>字段</strong> ： 字段是类里面声明的变量。字段表示对象的有关数据。</li>\n<li><strong>构造函数</strong>： 类实例化时调用，可以为类的对象分配内存。</li>\n<li><strong>方法</strong>： 方法为对象要执行的操作</li>\n</ul>\n<p>如下例子：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 继承</h3>\n<p>类的继承使用过<code>extends</code>的关键字</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Dog</code>是一个 派生类，它派生自 <code>Animal</code> 基类，派生类通常被称作子类，基类通常被称作 超类</p>\n<p><code>Dog</code>类继承了<code>Animal</code>类，因此实例<code>dog</code>也能够使用<code>Animal</code>类<code>move</code>方法</p>\n<p>同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写，通过<code>super</code>关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 修饰符</h3>\n<p>可以看到，上述的形式跟<code>ES6</code>十分的相似，<code>typescript</code>在此基础上添加了三种修饰符：</p>\n<ul>\n<li>公共 public：可以自由的访问类程序里定义的成员</li>\n<li>私有 private：只能够在该类的内部进行访问</li>\n<li>受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问</li>\n</ul>\n<h3> 私有修饰符</h3>\n<p>只能够在该类的内部进行访问，实例对象并不能够访问</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f57365f0-0cb4-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>并且继承该类的子类并不能访问，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/0072cc20-0cb5-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 受保护修饰符</h3>\n<p>跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/09e72580-0cb5-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>有一点不同的是 <code>protected</code> 成员在子类中仍然可以访问</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/137f81a0-0cb5-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>除了上述修饰符之外，还有只读<strong>修饰符</strong></p>\n<h4> 只读修饰符</h4>\n<p>通过<code>readonly</code>关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1e848d20-0cb5-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>除了实例属性之外，同样存在静态属性</p>\n<h3> 静态属性</h3>\n<p>这些属性存在于类本身上面而不是类的实例上，通过<code>static</code>进行定义，访问这些属性需要通过 类型.静态属性 的这种形式访问，如下所示：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述的类都能发现一个特点就是，都能够被实例化，在 <code>typescript</code>中，还存在一种抽象类</p>\n<h3> 抽象类</h3>\n<p>抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节</p>\n<p><code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种类并不能被实例化，通常需要我们创建子类去继承，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、应用场景</h2>\n<p>除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在 <code>React</code> 工程中是很常用的，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>由于组件需要传入 <code>props</code> 的类型 <code>Props</code> ，同时有需要设置默认 <code>props</code> 即 <code>defaultProps</code>，这时候更加适合使用<code>class</code>作为接口</p>\n<p>先声明一个类，这个类包含组件 <code>props</code> 所需的类型和初始值：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当我们需要传入 <code>props</code> 类型的时候直接将 <code>Props</code> 作为接口传入，此时 <code>Props</code> 的作用就是接口，而当需要我们设置<code>defaultProps</code>初始值的时候，我们只需要:</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>Props</code> 的实例就是 <code>defaultProps</code> 的初始值，这就是 <code>class</code>作为接口的实际应用，我们用一个 <code>class</code> 起到了接口和设置初始值两个作用，方便统一管理，减少了代码量</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.tslang.cn/docs/handbook/classes.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.tslang.cn/docs/handbook/classes.html</a></li>\n<li><a href=\"https://www.runoob.com/typescript/ts-class.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.runoob.com/typescript/ts-class.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "typescript"
      ]
    },
    {
      "title": "说说 typescript 的数据类型有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/typescript/data_type.html",
      "id": "https://www.h7ml.cn/posts/interview/typescript/data_type.html",
      "summary": "前端物语|面试物语-说说 typescript 的数据类型有哪些？",
      "content_html": "<h1> 说说 typescript 的数据类型有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d88f9450-0998-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>typescript</code> 和 <code>javascript</code>几乎一样，拥有相同的数据类型，另外在<code>javascript</code>基础上提供了更加实用的类型供开发使用</p>\n<p>在开发阶段，可以为明确的变量定义为某种类型，这样<code>typescript</code>就能在编译阶段进行类型检查，当类型不合符预期结果的时候则会出现错误提示</p>\n<h2> 二、有哪些</h2>\n<p><code>typescript</code> 的数据类型主要有如下：</p>\n<ul>\n<li>boolean（布尔类型）</li>\n<li>number（数字类型）</li>\n<li>string（字符串类型）</li>\n<li>array（数组类型）</li>\n<li>tuple（元组类型）</li>\n<li>enum（枚举类型）</li>\n<li>any（任意类型）</li>\n<li>null 和 undefined 类型</li>\n<li>void 类型</li>\n<li>never 类型</li>\n<li>object 对象类型</li>\n</ul>\n<h3> boolean</h3>\n<p>布尔类型</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> number</h3>\n<p>数字类型，和<code>javascript</code>一样，<code>typescript</code>的数值类型都是浮点数，可支持二进制、八进制、十进制和十六进制</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>进制表示：</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> string</h3>\n<p>字符串类型，和<code>JavaScript</code>一样，可以使用双引号（<code>\"</code>）或单引号（<code>'</code>）表示字符串</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>作为超集，当然也可以使用模版字符串``进行包裹，通过 ${} 嵌入变量</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> array</h3>\n<p>数组类型，跟<code>javascript</code>一致，通过<code>[]</code>进行包裹，有两种写法：</p>\n<p>方式一：元素类型后面接上 <code>[]</code></p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>方式二：使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> tuple</h3>\n<p>元祖类型，允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>赋值的类型、位置、个数需要和定义（生明）的类型、位置、个数一致</p>\n<h3> enum</h3>\n<p><code>enum</code>类型是对 JavaScript 标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> any</h3>\n<p>可以指定任何类型的值，在编程阶段还不清楚类型的变量指定一个类型，不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，这时候可以使用<code>any</code>类型</p>\n<p>使用<code>any</code>类型允许被赋值为任意类型，甚至可以调用其属性、方法</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定义存储各种类型数据的数组时，示例代码如下：</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> null 和 和 undefined</h3>\n<p>在<code>JavaScript</code> 中 <code>null</code>表示 \"什么都没有\"，是一个只有一个值的特殊类型，表示一个空对象引用，而<code>undefined</code>表示一个没有设置值的变量</p>\n<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型， 就是说你可以把 <code>null</code>和 <code>undefined</code>赋值给 <code>number</code>类型的变量</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但是<code>ts</code>配置了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自</p>\n<h3> void</h3>\n<p>用于标识方法返回值的类型，表示该方法没有返回值。</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> never</h3>\n<p><code>never</code>是其他类型 （包括<code>null</code>和 <code>undefined</code>）的子类型，可以赋值给任何类型，代表从不会出现的值</p>\n<p>但是没有类型是 never 的子类型，这意味着声明 <code>never</code> 的变量只能被 <code>never</code> 类型所赋值。</p>\n<p><code>never</code> 类型一般用来指定那些总是会抛出异常、无限循环</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> object</h3>\n<p>对象类型，非原始类型，常见的形式通过<code>{}</code>进行包裹</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、总结</h2>\n<p>和<code>javascript</code>基本一致，也分成：</p>\n<ul>\n<li>基本类型</li>\n<li>引用类型</li>\n</ul>\n<p>在基础类型上，<code>typescript</code>增添了<code>void</code>、<code>any</code>、<code>emum</code>等原始类型</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.tslang.cn/docs/handbook/basic-types.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.tslang.cn/docs/handbook/basic-types.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-25T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "typescript"
      ]
    },
    {
      "title": "说说你对 TypeScript 装饰器的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/typescript/decorator.html",
      "id": "https://www.h7ml.cn/posts/interview/typescript/decorator.html",
      "summary": "前端物语|面试物语-说说你对 TypeScript 装饰器的理解？应用场景？",
      "content_html": "<h1> 说说你对 TypeScript 装饰器的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f8905dd0-111c-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上</p>\n<p>是一种在不改变原类和使用继承的情况下，动态地扩展对象功能</p>\n<p>同样的，本质也不是什么高大上的结构，就是一个普通的函数，<code>@expression</code> 的形式其实是<code>Object.defineProperty</code>的语法糖</p>\n<p><code>expression</code>求值后必须也是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入</p>\n<h2> 二、使用方式</h2>\n<p>由于<code>typescript</code>是一个实验性特性，若要使用，需要在<code>tsconfig.json</code>文件启动，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>typescript</code>装饰器的使用和<code>javascript</code>基本一致</p>\n<p>类的装饰器可以装饰：</p>\n<ul>\n<li>\n<p>类</p>\n</li>\n<li>\n<p>方法/属性</p>\n</li>\n<li>\n<p>参数</p>\n</li>\n<li>\n<p>访问器</p>\n</li>\n</ul>\n<h3> 类装饰</h3>\n<p>例如声明一个函数 <code>addAge</code> 去给 Class 的属性 <code>age</code> 添加年龄.</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码，实际等同于以下形式：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>上述可以看到，当装饰器作为修饰类的时候，会把构造器传递进去。 <code>constructor.prototype.age</code> 就是在每一个实例化对象上面添加一个 <code>age</code> 属性</p>\n<h3> 方法/属性装饰</h3>\n<p>同样，装饰器可以用于修饰类的方法，这时候装饰器函数接收的参数变成了：</p>\n<ul>\n<li>target：对象的原型</li>\n<li>propertyKey：方法的名称</li>\n<li>descriptor：方法的属性描述符</li>\n</ul>\n<p>可以看到，这三个属性实际就是<code>Object.defineProperty</code>的三个参数，如果是类的属性，则没有传递第三个参数</p>\n<p>如下例子：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e96bc1b0-114d-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 参数装饰</h3>\n<p>接收 3 个参数，分别是：</p>\n<ul>\n<li>target ：当前对象的原型</li>\n<li>propertyKey ：参数的名称</li>\n<li>index：参数数组中的位置</li>\n</ul>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输入如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f2f32de0-114d-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 访问器装饰</h3>\n<p>使用起来方式与方法装饰一致，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 装饰器工厂</h3>\n<p>如果想要传递参数，使装饰器变成类似工厂函数，只需要在装饰器函数内部再函数一个函数即可，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 执行顺序</h3>\n<p>当多个装饰器应用于一个声明上，将由上至下依次对装饰器表达式求值，求值的结果会被当作函数，由下至上依次调用，例如如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、应用场景</h2>\n<p>可以看到，使用装饰器存在两个显著的优点：</p>\n<ul>\n<li>代码可读性变强了，装饰器命名相当于一个注释</li>\n<li>在不改变原有代码情况下，对原来功能进行扩展</li>\n</ul>\n<p>后面的使用场景中，借助装饰器的特性，除了提高可读性之后，针对已经存在的类，可以通过装饰器的特性，在不改变原有代码情况下，对原来功能进行扩展</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.tslang.cn/docs/handbook/decorators.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.tslang.cn/docs/handbook/decorators.html</a></li>\n<li><a href=\"https://juejin.cn/post/6844903876605280269#heading-5\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903876605280269#heading-5</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "typescript"
      ]
    },
    {
      "title": "说说你对 TypeScript 中枚举类型的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/typescript/enum.html",
      "id": "https://www.h7ml.cn/posts/interview/typescript/enum.html",
      "summary": "前端物语|面试物语-说说你对 TypeScript 中枚举类型的理解？应用场景？",
      "content_html": "<h1> 说说你对 TypeScript 中枚举类型的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/76173bf0-0b0c-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>枚举是一个被命名的整型常数的集合，用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型</p>\n<p>通俗来说，枚举就是一个对象的所有可能取值的集合</p>\n<p>在日常生活中也很常见，例如表示星期的 SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY、SATURDAY 就可以看成是一个枚举</p>\n<p>枚举的说明与结构和联合相似，其形式为：</p>\n<div class=\"language-txt line-numbers-mode\" data-ext=\"txt\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、使用</h2>\n<p>枚举的使用是通过<code>enum</code>关键字进行定义，形式如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>声明关键字为枚举类型的方式如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>类型可以分成：</p>\n<ul>\n<li>\n<p>数字枚举</p>\n</li>\n<li>\n<p>字符串枚举</p>\n</li>\n<li>\n<p>异构枚举</p>\n</li>\n</ul>\n<h3> 数字枚举</h3>\n<p>当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且默认从 0 开始依次累加:</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果我们将第一个值进行赋值后，后面的值也会根据前一个值进行累加 1：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 字符串枚举</h3>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果设定了一个变量为字符串之后，后续的字段也需要赋值字符串，否则报错：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 异构枚举</h3>\n<p>即将数字枚举和字符串枚举结合起来混合起来使用，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通常情况下我们很少会使用异构枚举</p>\n<h3> 本质</h3>\n<p>现在一个枚举的案例如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过编译后，<code>javascript</code>如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述代码可以看到， <code>Direction[Direction[\"Up\"] = 0] = \"Up\"</code>可以分成</p>\n<ul>\n<li>Direction[\"Up\"] = 0</li>\n<li>Direction[0] = \"Up\"</li>\n</ul>\n<p>所以定义枚举类型后，可以通过正反映射拿到对应的值，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>并且多处定义的枚举是可以进行合并操作，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>编译后，<code>js</code>代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，<code>Direction</code>对象属性回叠加</p>\n<h2> 三、应用场景</h2>\n<p>就拿回生活的例子，后端返回的字段使用 0 - 6 标记对应的日期，这时候就可以使用枚举可提高代码可读性，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>包括后端日常返回 0、1 等等状态的时候，我们都可以通过枚举去定义，这样可以提高代码的可读性，便于后续的维护</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%9E%9A%E4%B8%BE\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/枚举</a></li>\n<li><a href=\"https://www.jianshu.com/p/b9e1caa4dd98\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/b9e1caa4dd98</a></li>\n<li><a href=\"https://juejin.cn/post/6844904112669065224#heading-30\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904112669065224#heading-30</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-28T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "typescript"
      ]
    },
    {
      "title": "说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？",
      "url": "https://www.h7ml.cn/posts/interview/typescript/function.html",
      "id": "https://www.h7ml.cn/posts/interview/typescript/function.html",
      "summary": "前端物语|面试物语-说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？",
      "content_html": "<h1> 说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3f1c1390-0d42-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>函数是<code>JavaScript</code> 应用程序的基础，帮助我们实现抽象层、模拟类、信息隐藏和模块</p>\n<p>在<code>TypeScript</code> 里，虽然已经支持类、命名空间和模块，但函数仍然是主要定义行为的方式，<code>TypeScript</code> 为 <code>JavaScript</code> 函数添加了额外的功能，丰富了更多的应用场景</p>\n<p>函数类型在 <code>TypeScript</code> 类型系统中扮演着非常重要的角色，它们是可组合系统的核心构建块</p>\n<h2> 二、使用方式</h2>\n<p>跟<code>javascript</code> 定义函数十分相似，可以通过<code>funciton</code> 关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上<code>TypeScript</code> 编译器是能够通过类型推断到这个函数的类型，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/4b3415b0-0d42-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>当鼠标放置在第三行<code>add</code>函数名的时候，会出现完整的函数定义类型，通过<code>:</code> 的形式来定于参数类型，通过 <code>=&gt;</code> 连接参数和返回值类型</p>\n<p>当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当存在函数重载时，只能使用方式一的形式</p>\n<h3> 可选参数</h3>\n<p>当函数的参数可能是不存在的，只需要在参数后面加上 <code>?</code> 代表参数可能不存在，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这时候参数<code>b</code>可以是<code>number</code>类型或者<code>undefined</code>类型，即可以传一个<code>number</code>类型或者不传都可以</p>\n<h3> 剩余类型</h3>\n<p>剩余参数与<code>JavaScript</code>的语法类似，需要用 <code>...</code> 来表示剩余参数</p>\n<p>如果剩余参数 <code>rest</code> 是一个由<code>number</code>类型组成的数组，则如下表示：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 函数重载</h3>\n<p>允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力</p>\n<p>关于<code>typescript</code>函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 <code>|</code>操作符或者<code>?</code>操作符，把所有可能的输入类型全部包含进去，用于具体实现</p>\n<p>这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，<code>typescript</code>并不会真的将你的多个重名 <code>function</code>的函数体进行合并</p>\n<p>例如我们有一个 add 函数，它可以接收 <code>string</code>类型的参数进行拼接，也可以接收 <code>number</code> 类型的参数进行相加，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、区别</h2>\n<p>从上面可以看到：</p>\n<ul>\n<li>从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型</li>\n<li>typescript 在参数中，添加可选参数供使用者选择</li>\n<li>typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.tslang.cn/docs/handbook/functions.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.tslang.cn/docs/handbook/functions.html</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/函数重载</a></li>\n<li><a href=\"https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%87%8D%E8%BD%BD\" target=\"_blank\" rel=\"noopener noreferrer\">https://jkchao.github.io/typescript-book-chinese/typings/functions.html#重载</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "typescript"
      ]
    },
    {
      "title": "说说你对 TypeScript 中泛型的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/typescript/generic.html",
      "id": "https://www.h7ml.cn/posts/interview/typescript/generic.html",
      "summary": "前端物语|面试物语-说说你对 TypeScript 中泛型的理解？应用场景？",
      "content_html": "<h1> 说说你对 TypeScript 中泛型的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5bb5f1d0-0e17-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>泛型程序设计（generic programming）是程序设计语言的一种风格或范式</p>\n<p>泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型在<code>typescript</code>中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性</p>\n<p>假设我们用一个函数，它可接受一个 <code>number</code> 参数并返回一个<code>number</code> 参数，如下写法：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果我们打算接受一个 <code>string</code> 类型，然后再返回 <code>string</code>类型，则如下写法：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述两种编写方式，存在一个最明显的问题在于，代码重复度比较高</p>\n<p>虽然可以使用 <code>any</code>类型去替代，但这也并不是很好的方案，因为我们的目的是接收什么类型的参数返回什么类型的参数，即在运行时传入参数我们才能确定类型</p>\n<p>这种情况就可以使用泛型，如下所示：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，泛型给予开发者创造灵活、可重用代码的能力</p>\n<h2> 二、使用方式</h2>\n<p>泛型通过<code>&lt;&gt;</code>的形式进行表述，可以声明：</p>\n<ul>\n<li>\n<p>函数</p>\n</li>\n<li>\n<p>接口</p>\n</li>\n<li>\n<p>类</p>\n</li>\n</ul>\n<h3> 函数声明</h3>\n<p>声明函数的形式如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定义泛型的时候，可以一次定义<strong>多个类型参数</strong>，比如我们可以同时定义泛型 <code>T</code> 和 泛型 <code>U</code>：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 接口声明</h3>\n<p>声明接口的形式如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>那么当我们想传入一个 number 作为参数的时候，就可以这样声明函数:</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> </h3>\n<h3> 类声明</h3>\n<p>使用泛型声明类的时候，既可以作用于类本身，也可以作用与类的成员函数</p>\n<p>下面简单实现一个元素同类型的栈结构，如下所示：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用方式如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果上述只能传递 <code>string</code> 和 <code>number</code> 类型，这时候就可以使用 <code>&lt;T extends xx&gt;</code> 的方式猜实现<strong>约束泛型</strong>，如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/67d212a0-0e17-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>除了上述的形式，泛型更高级的使用如下：</p>\n<p>例如要设计一个函数，这个函数接受两个参数，一个参数为对象，另一个参数为对象上的属性，我们通过这两个参数返回这个属性的值</p>\n<p>这时候就设计到泛型的索引类型和约束类型共同实现</p>\n<h3> 索引类型、约束类型</h3>\n<p>索引类型 <code>keyof T</code> 把传入的对象的属性类型取出生成一个联合类型，这里的泛型 U 被约束在这个联合类型中，如下所示：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述为什么需要使用泛型约束，而不是直接定义第一个参数为 <code>object</code>类型，是因为默认情况 <code>object</code> 指的是<code>{}</code>，而我们接收的对象是各种各样的，一个泛型来表示传入的对象类型，比如 <code>T extends object</code></p>\n<p>使用如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/74fcbd40-0e17-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 多类型约束</h3>\n<p>例如如下需要实现两个接口的类型约束：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以创建一个接口继承上述两个接口，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>正确使用如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过泛型约束就可以达到多类型约束的目的</p>\n<h2> 三、应用场景</h2>\n<p>通过上面初步的了解，后述在编写 <code>typescript</code> 的时候，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性的时候，这种情况下就可以使用泛型</p>\n<p>灵活的使用泛型定义类型，是掌握<code>typescript</code> 必经之路</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.tslang.cn/docs/handbook/generics.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.tslang.cn/docs/handbook/generics.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "typescript"
      ]
    },
    {
      "title": "说说你对 TypeScript 中高级类型的理解？有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/typescript/high_type.html",
      "id": "https://www.h7ml.cn/posts/interview/typescript/high_type.html",
      "summary": "前端物语|面试物语-说说你对 TypeScript 中高级类型的理解？有哪些？",
      "content_html": "<h1> 说说你对 TypeScript 中高级类型的理解？有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bda521e0-1065-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>除了<code>string</code>、<code>number</code>、<code>boolean</code> 这种基础类型外，在 <code>typescript</code> 类型声明中还存在一些高级的类型应用</p>\n<p>这些高级类型，是<code>typescript</code>为了保证语言的灵活性，所使用的一些语言特性。这些特性有助于我们应对复杂多变的开发场景</p>\n<h2> 二、有哪些</h2>\n<p>常见的高级类型有如下：</p>\n<ul>\n<li>交叉类型</li>\n<li>联合类型</li>\n<li>类型别名</li>\n<li>类型索引</li>\n<li>类型约束</li>\n<li>映射类型</li>\n<li>条件类型</li>\n</ul>\n<h3> 交叉类型</h3>\n<p>通过 <code>&amp;</code> 将多个类型合并为一个类型，包含了所需的所有类型的特性，本质上是一种并的操作</p>\n<p>语法如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>适用于对象合并场景，如下将声明一个函数，将两个对象合并成一个对象并返回：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 联合类型</h3>\n<p>联合类型的语法规则和逻辑 “或” 的符号一致，表示其类型为连接的多个类型中的任意一个，本质上是一个交的关系</p>\n<p>语法如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>例如 <code>number</code> | <code>string</code> | <code>boolean</code> 的类型只能是这三个的一种，不能共存</p>\n<p>如下所示：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 类型别名</h3>\n<p>类型别名会给一个类型起个新名字，类型别名有时和接口很像，但是可以作用于原始值、联合类型、元组以及其它任何你需要手写的类型</p>\n<p>可以使用 <code>type SomeName = someValidTypeAnnotation</code>的语法来创建类型别名：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>此外类型别名可以是泛型:</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>也可以使用类型别名来在属性里引用自己：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，类型别名和接口使用十分相似，都可以描述一个对象或者函数</p>\n<p>两者最大的区别在于，<code>interface</code>只能用于定义对象类型，而 <code>type</code> 的声明方式除了对象之外还可以定义交叉、联合、原始类型等，类型声明的方式适用范围显然更加广泛</p>\n<h3> 类型索引</h3>\n<p><code>keyof</code> 类似于 <code>Object.keys</code> ，用于获取一个接口中 Key 的联合类型。</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 类型约束</h3>\n<p>通过关键字 <code>extend</code> 进行约束，不同于在 <code>class</code> 后使用 <code>extends</code> 的继承作用，泛型内使用的主要作用是对泛型加以约束</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>类型约束通常和类型索引一起使用，例如我们有一个方法专门用来获取对象的值，但是这个对象并不确定，我们就可以使用 <code>extends</code> 和 <code>keyof</code> 进行约束。</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 映射类型</h3>\n<p>通过 <code>in</code> 关键字做类型的映射，遍历已有接口的 <code>key</code> 或者是遍历联合类型，如下例子：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述的结构，可以分成这些步骤：</p>\n<ul>\n<li>keyof T：通过类型索引 keyof 的得到联合类型 'a' | 'b'</li>\n<li>P in keyof T 等同于 p in 'a' | 'b'，相当于执行了一次 forEach 的逻辑，遍历 'a' | 'b'</li>\n</ul>\n<p>所以最终<code>ReadOnlyObj</code>的接口为下述：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 条件类型</h3>\n<p>条件类型的语法规则和三元表达式一致，经常用于一些类型不确定的情况。</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>上面的意思就是，如果 T 是 U 的子集，就是类型 X，否则为类型 Y</p>\n<h2> 三、总结</h2>\n<p>可以看到，如果只是掌握了 <code>typeScript</code> 的一些基础类型，可能很难游刃有余的去使用 <code>typeScript</code>，需要了解一些<code>typescript</code>的高阶用法</p>\n<p>并且<code>typescript</code>在版本的迭代中新增了很多功能，需要不断学习与掌握</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.tslang.cn/docs/handbook/advanced-types.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.tslang.cn/docs/handbook/advanced-types.html</a></li>\n<li><a href=\"https://juejin.cn/post/6844904003604578312\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904003604578312</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/103846208\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/103846208</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-21T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "typescript"
      ]
    },
    {
      "title": "说说你对 TypeScript 中接口的理解？应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/typescript/interface.html",
      "id": "https://www.h7ml.cn/posts/interview/typescript/interface.html",
      "summary": "前端物语|面试物语-说说你对 TypeScript 中接口的理解？应用场景？",
      "content_html": "<h1> 说说你对 TypeScript 中接口的理解？应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/193389b0-0b2b-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><strong>接口</strong>是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的<strong>类</strong>去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法</p>\n<p>简单来讲，一个接口所描述的是一个对象相关的属性和方法，但并不提供具体创建此对象实例的方法</p>\n<p><code>typescript</code>的核心功能之一就是对类型做检测，虽然这种检测方式是“鸭式辨型法”，而接口的作用就是为为这些类型命名和为你的代码或第三方代码定义一个约定</p>\n<h2> 二、使用方式</h2>\n<p>接口定义如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>例如有一个函数，这个函数接受一个 <code>User</code> 对象，然后返回这个 <code>User</code> 对象的 <code>name</code> 属性:</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>可以看到，参数需要有一个<code>user</code>的<code>name</code>属性，可以通过接口描述<code>user</code>参数的结构</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这些属性并不一定全部实现，上述传入的对象必须拥有<code>name</code>和<code>age</code>属性，否则<code>typescript</code>在编译阶段会报错，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/25d3a790-0b2b-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>如果不想要<code>age</code>属性的话，这时候可以采用<strong>可选属性</strong>，如下表示：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这时候<code>age</code>属性则可以是<code>number</code>类型或者<code>undefined</code>类型</p>\n<p>有些时候，我们想要一个属性变成只读属性，在<code>typescript</code>只需要使用<code>readonly</code>声明，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当我们修改属性的时候，就会出现警告，如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2f6d3c30-0b2b-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>这是属性中有一个函数，可以如下表示：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果传递的对象不仅仅是上述的属性，这时候可以使用：</p>\n<ul>\n<li>类型推断</li>\n</ul>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>给接口添加字符串<strong>索引签名</strong></li>\n</ul>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>接口还能实现继承，如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/38a41760-0b2b-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>也可以继承多个，父类通过逗号隔开，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、应用场景</h2>\n<p>例如在<code>javascript</code>中定义一个函数，用来获取用户的姓名和年龄：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果多人开发的都需要用到这个函数的时候，如果没有注释，则可能出现各种运行时的错误，这时候就可以使用接口定义参数变量：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>包括后面讲到类的时候也会应用到接口</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.tslang.cn/docs/handbook/interfaces.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.tslang.cn/docs/handbook/interfaces.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-03T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "typescript"
      ]
    },
    {
      "title": "说说对 TypeScript 中命名空间与模块的理解？区别？",
      "url": "https://www.h7ml.cn/posts/interview/typescript/namespace_module.html",
      "id": "https://www.h7ml.cn/posts/interview/typescript/namespace_module.html",
      "summary": "前端物语|面试物语-说说对 TypeScript 中命名空间与模块的理解？区别？",
      "content_html": "<h1> 说说对 TypeScript 中命名空间与模块的理解？区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9378d760-137e-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、模块</h2>\n<p><code>TypeScript</code> 与<code>ECMAScript</code> 2015 一样，任何包含顶级 <code>import</code> 或者 <code>export</code> 的文件都被当成一个模块</p>\n<p>相反地，如果一个文件不带有顶级的<code>import</code>或者<code>export</code>声明，那么它的内容被视为全局可见的</p>\n<p>例如我们在在一个 <code>TypeScript</code> 工程下建立一个文件 <code>1.ts</code>，声明一个变量<code>a</code>，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>然后在另一个文件同样声明一个变量<code>a</code>，这时候会出现错误信息</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a239d970-137e-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>提示重复声明<code>a</code>变量，但是所处的空间是全局的</p>\n<p>如果需要解决这个问题，则通过<code>import</code>或者<code>export</code>引入模块系统即可，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在<code>typescript</code>中，<code>export</code>关键字可以导出变量或者类型，用法与<code>es6</code>模块一致，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过<code>import</code> 引入模块，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 二、命名空间</h2>\n<p>命名空间一个最明确的目的就是解决重名问题</p>\n<p>命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的</p>\n<p>这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中</p>\n<p><code>TypeScript</code> 中命名空间使用 <code>namespace</code> 来定义，语法格式如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上定义了一个命名空间 <code>SomeNameSpaceName</code>，如果我们需要在外部可以调用 <code>SomeNameSpaceName</code> 中的类和接口，则需要在类和接口添加 <code>export</code> 关键字</p>\n<p>使用方式如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>命名空间本质上是一个对象，作用是将一系列相关的全局变量组织到一个对象的属性，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>编译成<code>js</code>如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、区别</h2>\n<ul>\n<li>\n<p>命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象，使用起来十分容易。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中</p>\n</li>\n<li>\n<p>像命名空间一样，模块可以包含代码和声明。 不同的是模块可以声明它的依赖</p>\n</li>\n<li>\n<p>在正常的 TS 项目开发过程中并不建议用命名空间，但通常在通过 d.ts 文件标记 js 库类型的时候使用命名空间，主要作用是给编译器编写代码的时候参考使用</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.tslang.cn/docs/handbook/modules.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.tslang.cn/docs/handbook/modules.html</a></li>\n<li><a href=\"https://www.tslang.cn/docs/handbook/namespaces.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.tslang.cn/docs/handbook/namespaces.html</a></li>\n<li><a href=\"https://www.tslang.cn/docs/handbook/namespaces-and-modules.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.tslang.cn/docs/handbook/namespaces-and-modules.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-09T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "typescript"
      ]
    },
    {
      "title": "说说如何在 React 项目中应用 TypeScript？",
      "url": "https://www.h7ml.cn/posts/interview/typescript/react.html",
      "id": "https://www.h7ml.cn/posts/interview/typescript/react.html",
      "summary": "前端物语|面试物语-说说如何在 React 项目中应用 TypeScript？",
      "content_html": "<h1> 说说如何在 React 项目中应用 TypeScript？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a98974e0-13bc-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、前言</h2>\n<p>单独的使用 <code>TypeScript</code> 并不会导致学习成本很高，但是绝大部分前端开发者的项目都是依赖于框架的</p>\n<p>例如与 <code>Vue</code>、<code>React</code> 这些框架结合使用的时候，会有一定的门槛</p>\n<p>使用 <code>TypeScript</code> 编写 <code>React</code> 代码，除了需要 <code>TypeScript</code> 这个库之外，还需要安装 <code>@types/react</code>、<code>@types/react-dom</code></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>至于上述使用 <code>@types</code> 的库的原因在于，目前非常多的 <code>JavaScript</code> 库并没有提供自己关于 <code>TypeScript</code> 的声明文件</p>\n<p>所以，<code>ts</code> 并不知道这些库的类型以及对应导出的内容，这里 <code>@types</code> 实际就是社区中的 <code>DefinitelyTyped</code> 库，定义了目前市面上绝大多数的 <code>JavaScript</code> 库的声明</p>\n<p>所以下载相关的 <code>JavaScript</code> 对应的 <code>@types</code> 声明时，就能够使用使用该库对应的类型定义</p>\n<h2> 二、使用方式</h2>\n<p>在编写 <code>React</code> 项目的时候，最常见的使用的组件就是：</p>\n<ul>\n<li>无状态组件</li>\n<li>有状态组件</li>\n<li>受控组件</li>\n</ul>\n<h3> 无状态组件</h3>\n<p>主要作用是用于展示 <code>UI</code>，如果使用 <code>js</code> 声明，则如下所示：</p>\n<div class=\"language-jsx line-numbers-mode\" data-ext=\"jsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但这时候 <code>ts</code> 会出现报错提示，原因在于没有定义 <code>porps</code> 类型，这时候就可以使用 <code>interface</code> 接口去定义 <code>porps</code> 即可，如下：</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但是我们都知道 <code>props</code> 里面存在 <code>children</code> 属性，我们不可能每个 <code>porps</code> 接口里面定义多一个 <code>children</code>，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>更加规范的写法是使用 <code>React</code> 里面定义好的 <code>FC</code> 属性，里面已经定义好 <code>children</code> 类型，如下：</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p>React.FC 显式地定义了返回类型，其他方式是隐式推导的</p>\n</li>\n<li>\n<p>React.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全</p>\n</li>\n<li>\n<p>React.FC 为 children 提供了隐式的类型（ReactElement | null）</p>\n</li>\n</ul>\n<h3> 有状态组件</h3>\n<p>可以是一个类组件且存在 <code>props</code> 和 <code>state</code> 属性</p>\n<p>如果使用 <code>TypeScript</code> 声明则如下所示：</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述通过泛型对 <code>props</code>、<code>state</code> 进行类型定义，然后在使用的时候就可以在编译器中获取更好的智能提示</p>\n<p>关于 <code>Component</code> 泛型类的定义，可以参考下 React 的类型定义文件 <code>node_modules/@types/React/index.d.ts</code>，如下所示：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上述可以看到，<code>state</code> 属性也定义了可读类型，目的是为了防止直接调用 <code>this.state</code> 更新状态</p>\n<h3> 受控组件</h3>\n<p>受控组件的特性在于元素的内容通过组件的状态 <code>state</code> 进行控制</p>\n<p>由于组件内部的事件是合成事件，不等同于原生事件，</p>\n<p>例如一个 <code>input</code> 组件修改内部的状态，常见的定义的时候如下所示：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>常用 <code>Event</code> 事件对象类型：</p>\n<ul>\n<li>ClipboardEvent&lt;T = Element&gt; 剪贴板事件对象</li>\n<li>DragEvent&lt;T = Element&gt; 拖拽事件对象</li>\n<li>ChangeEvent&lt;T = Element&gt; Change 事件对象</li>\n<li>KeyboardEvent&lt;T = Element&gt; 键盘事件对象</li>\n<li>MouseEvent&lt;T = Element&gt; 鼠标事件对象</li>\n<li>TouchEvent&lt;T = Element&gt; 触摸事件对象</li>\n<li>WheelEvent&lt;T = Element&gt; 滚轮事件对象</li>\n<li>AnimationEvent&lt;T = Element&gt; 动画事件对象</li>\n<li>TransitionEvent&lt;T = Element&gt; 过渡事件对象</li>\n</ul>\n<p><code>T</code> 接收一个 <code>DOM</code> 元素类型</p>\n<h2> 三、总结</h2>\n<p>上述只是简单的在 <code>React</code> 项目使用 <code>TypeScript</code>，但在编写 <code>React</code> 项目的时候，还存在 <code>hooks</code>、默认参数、以及 <code>store</code> 等等......</p>\n<p><code>TypeScript</code> 在框架中使用的学习成本相对会更高，需要不断编写才能熟练</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6952696734078369828\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6952696734078369828</a></li>\n<li><a href=\"https://juejin.cn/post/6844903684422254606\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903684422254606</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-07T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "typescript"
      ]
    },
    {
      "title": "说说你对 TypeScript 的理解？与 JavaScript 的区别？",
      "url": "https://www.h7ml.cn/posts/interview/typescript/typescript_javascript.html",
      "id": "https://www.h7ml.cn/posts/interview/typescript/typescript_javascript.html",
      "summary": "前端物语|面试物语-说说你对 TypeScript 的理解？与 JavaScript 的区别？",
      "content_html": "<h1> 说说你对 TypeScript 的理解？与 JavaScript 的区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/58cd3580-0950-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>TypeScript</code> 是 <code>JavaScript</code> 的类型的超集，支持<code>ES6</code>语法，支持面向对象编程的概念，如类、接口、继承、泛型等</p>\n<blockquote>\n<p>超集，不得不说另外一个概念，子集，怎么理解这两个呢，举个例子，如果一个集合 A 里面的的所有元素集合 B 里面都存在，那么我们可以理解集合 B 是集合 A 的超集，集合 A 为集合 B 的子集</p>\n</blockquote>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/61c2c1f0-0950-11ec-a752-75723a64e8f5.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>其是一种静态类型检查的语言，提供了类型注解，在代码编译阶段就可以检查出数据类型的错误</p>\n<p>同时扩展了<code>JavaScript</code> 的语法，所以任何现有的<code>JavaScript</code> 程序可以不加改变的在 <code>TypeScript</code> 下工作</p>\n<p>为了保证兼容性，<code>TypeScript</code> 在编译阶段需要编译器编译成纯 <code>JavaScript</code> 来运行，是为大型应用之开发而设计的语言，如下：</p>\n<p><code>ts</code> 文件如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>编译文件后：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、特性</h2>\n<p><code>TypeScript</code> 的特性主要有如下：</p>\n<ul>\n<li><strong>类型批注和编译时类型检查</strong> ：在编译时批注变量类型</li>\n<li><strong>类型推断</strong>：ts 中没有批注变量类型会自动推断变量的类型</li>\n<li><strong>类型擦除</strong>：在编译过程中批注的内容和接口会在运行时利用工具擦除</li>\n<li><strong>接口</strong>：ts 中用接口来定义对象类型</li>\n<li><strong>枚举</strong>：用于取值被限定在一定范围内的场景</li>\n<li><strong>Mixin</strong>：可以接受任意类型的值</li>\n<li><strong>泛型编程</strong>：写代码时使用一些以后才指定的类型</li>\n<li><strong>名字空间</strong>：名字只在该区域内有效，其他区域可重复使用该名字而不冲突</li>\n<li><strong>元组</strong>：元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组</li>\n<li>...</li>\n</ul>\n<h3> 类型批注</h3>\n<p>通过类型批注提供在编译时启动类型检查的静态类型，这是可选的，而且可以忽略而使用 <code>JavaScript</code> 常规的动态类型</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对于基本类型的批注是 <code>number</code>、<code>bool</code> 和 <code>string</code>，而弱或动态类型的结构则是 <code>any</code> 类型</p>\n<h3> 类型推断</h3>\n<p>当类型没有给出时，TypeScript 编译器利用类型推断来推断类型，如下：</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>变量 <code>str</code> 被推断为字符串类型，这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时</p>\n<p>如果缺乏声明而不能推断出类型，那么它的类型被视作默认的动态 <code>any</code> 类型</p>\n<h3> 接口</h3>\n<p>接口简单来说就是用来描述对象的类型 数据的类型有 <code>number</code>、<code>null</code>、<code>string</code> 等数据格式，对象的类型就是用接口来描述的</p>\n<div class=\"language-tsx line-numbers-mode\" data-ext=\"tsx\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、区别</h2>\n<ul>\n<li>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法</li>\n<li>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译</li>\n<li>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js</li>\n<li>在编写 TypeScript 的文件的时候就会自动编译成 js 文件</li>\n</ul>\n<p>更多的区别如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6b544040-0950-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/140012915\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/140012915</a></li>\n<li><a href=\"https://www.jianshu.com/p/c8aaba6e8ce0\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/c8aaba6e8ce0</a></li>\n<li><a href=\"https://www.cnblogs.com/powertoolsteam/p/13500668.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/powertoolsteam/p/13500668.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-06T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "typescript"
      ]
    },
    {
      "title": "说说如何在 Vue 项目中应用 TypeScript？",
      "url": "https://www.h7ml.cn/posts/interview/typescript/vue.html",
      "id": "https://www.h7ml.cn/posts/interview/typescript/vue.html",
      "summary": "前端物语|面试物语-说说如何在 Vue 项目中应用 TypeScript？",
      "content_html": "<h1> 说说如何在 Vue 项目中应用 TypeScript？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/cc658c10-1565-11ec-8e64-91fdec0f05a1.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、前言</h2>\n<p>与 link 类似</p>\n<p>在<code>VUE</code>项目中应用<code>typescript</code>，我们需要引入一个库<code>vue-property-decorator</code>，</p>\n<p>其是基于<code>vue-class-component</code>库而来，这个库<code>vue</code>官方推出的一个支持使用<code>class</code>方式来开发<code>vue</code>单文件组件的库</p>\n<p>主要的功能如下：</p>\n<ul>\n<li>methods 可以直接声明为类的成员方法</li>\n<li>计算属性可以被声明为类的属性访问器</li>\n<li>初始化的 data 可以被声明为类属性</li>\n<li>data、render 以及所有的 Vue 生命周期钩子可以直接作为类的成员方法</li>\n<li>所有其他属性，需要放在装饰器中</li>\n</ul>\n<h2> 二、使用</h2>\n<p>vue-property-decorator 主要提供了多个装饰器和一个函数:</p>\n<ul>\n<li>@Prop</li>\n<li>@PropSync</li>\n<li>@Model</li>\n<li>@Watch</li>\n<li>@Provide</li>\n<li>@Inject</li>\n<li>@ProvideReactive</li>\n<li>@InjectReactive</li>\n<li>@Emit</li>\n<li>@Ref</li>\n<li>@Component (由 vue-class-component 提供)</li>\n<li>Mixins (由 vue-class-component 提供)</li>\n</ul>\n<h3> @Component</h3>\n<p><code>Component</code>装饰器它注明了此类为一个<code>Vue</code>组件，因此即使没有设置选项也不能省略</p>\n<p>如果需要定义比如 <code>name</code>、<code>components</code>、<code>filters</code>、<code>directives</code>以及自定义属性，就可以在<code>Component</code>装饰器中定义，如下：</p>\n<div class=\"language-vue line-numbers-mode\" data-ext=\"vue\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> computed、data、methods</h3>\n<p>这里取消了组件的 data 和 methods 属性，以往 data 返回对象中的属性、methods 中的方法需要直接定义在 Class 中，当做类的属性和方法</p>\n<div class=\"language-typescript line-numbers-mode\" data-ext=\"ts\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> @props</h3>\n<p>组件接收属性的装饰器，如下使用：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> @watch</h3>\n<p>实际就是<code>Vue</code>中的监听器，如下：</p>\n<div class=\"language-vue line-numbers-mode\" data-ext=\"vue\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> @emit</h3>\n<p><code>vue-property-decorator</code> 提供的 <code>@Emit</code> 装饰器就是代替<code>Vue</code>中的事件的触发<code>$emit</code>，如下：</p>\n<div class=\"language-TS line-numbers-mode\" data-ext=\"TS\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三 、总结</h2>\n<p>可以看到上述<code>typescript</code>版本的<code>vue class</code>的语法与平时<code>javascript</code>版本使用起来还是有很大的不同，多处用到<code>class</code>与装饰器，但实际上本质是一致的，只有不断编写才会得心应手</p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-28T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "typescript"
      ]
    },
    {
      "title": "vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？",
      "url": "https://www.h7ml.cn/posts/interview/vue/404.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/404.html",
      "summary": "前端物语|面试物语-vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？",
      "content_html": "<h1> vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/002c9320-4f3e-11eb-ab90-d9ae814b240d.png\" alt=\"image.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>image.png</figcaption></figure>\n<h2> 一、如何部署</h2>\n<p>前后端分离开发模式下，前后端是独立布署的，前端只需要将最后的构建物上传至目标服务器的<code>web</code>容器指定的静态目录下即可</p>\n<p>我们知道<code>vue</code>项目在构建后，是生成一系列的静态文件</p>\n<figure><img src=\"https://imgkr2.cn-bj.ufileos.com/b9d13e56-f859-4b4b-a9da-a703a34c2f5d.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=m1qDXRSFHrfXlnAtAlVhjoLKP70%3D&amp;Expires=1609927181\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>常规布署我们只需要将这个目录上传至目标服务器即可</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>让<code>web</code>容器跑起来，以<code>nginx</code>为例</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>配置完成记得重启<code>nginx</code></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>操作完后就可以在浏览器输入域名进行访问了</p>\n<p>当然上面只是提到最简单也是最直接的一种布署方式</p>\n<p>什么自动化，镜像，容器，流水线布署，本质也是将这套逻辑抽象，隔离，用程序来代替重复性的劳动，本文不展开</p>\n<h2> 二、404 问题</h2>\n<p>这是一个经典的问题，相信很多同学都有遇到过，那么你知道其真正的原因吗？</p>\n<p>我们先还原一下场景：</p>\n<ul>\n<li><code>vue</code>项目在本地时运行正常，但部署到服务器中，刷新页面，出现了 404 错误</li>\n</ul>\n<p>先定位一下，HTTP 404 错误意味着链接指向的资源不存在</p>\n<p>问题在于为什么不存在？且为什么只有<code>history</code>模式下会出现这个问题？</p>\n<h3> 为什么 history 模式下有问题</h3>\n<p><code>Vue</code>是属于单页应用（single-page application）</p>\n<p>而<code>SPA</code>是一种网络应用程序或网站的模型，所有用户交互是通过动态重写当前页面，前面我们也看到了，不管我们应用有多少页面，构建物都只会产出一个<code>index.html</code></p>\n<p>现在，我们回头来看一下我们的<code>nginx</code>配置</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以根据 <code>nginx</code> 配置得出，当我们在地址栏输入 <code>www.xxx.com</code> 时，这时会打开我们 <code>dist</code> 目录下的 <code>index.html</code> 文件，然后我们在跳转路由进入到 <code>www.xxx.com/login</code></p>\n<p>关键在这里，当我们在 <code>website.com/login</code> 页执行刷新操作，<code>nginx location</code> 是没有相关配置的，所以就会出现 404 的情况</p>\n<h3> 为什么 hash 模式下没有问题</h3>\n<p><code>router hash</code> 模式我们都知道是用符号#表示的，如 <code>website.com/#/login</code>, <code>hash</code> 的值为 <code>#/login</code></p>\n<p>它的特点在于：<code>hash</code> 虽然出现在 <code>URL</code> 中，但不会被包括在 <code>HTTP</code> 请求中，对服务端完全没有影响，因此改变 <code>hash</code> 不会重新加载页面</p>\n<p><code>hash</code> 模式下，仅 <code>hash</code> 符号之前的内容会被包含在请求中，如 <code>website.com/#/login</code> 只有 <code>website.com</code> 会被包含在请求中 ，因此对于服务端来说，即使没有配置<code>location</code>，也不会返回 404 错误</p>\n<h2> 解决方案</h2>\n<p>看到这里我相信大部分同学都能想到怎么解决问题了，</p>\n<p>产生问题的本质是因为我们的路由是通过 JS 来执行视图切换的，</p>\n<p>当我们进入到子路由时刷新页面，<code>web</code>容器没有相对应的页面此时会出现 404</p>\n<p>所以我们只需要配置将任意页面都重定向到 <code>index.html</code>，把路由交由前端处理</p>\n<p>对<code>nginx</code>配置文件<code>.conf</code>修改，添加<code>try_files $uri $uri/ /index.html;</code></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改完配置文件后记得配置的更新</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 <code>index.html</code> 文件</p>\n<p>为了避免这种情况，你应该在 <code>Vue</code> 应用里面覆盖所有的路由情况，然后在给出一个 404 页面</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于后端配置方案还有：<code>Apache</code>、<code>nodejs</code>等，思想是一致的，这里就不展开述说了</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844903872637632525\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903872637632525</a></li>\n<li><a href=\"https://vue-js.com/topic/5f8cf91d96b2cb0032c385c0\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue-js.com/topic/5f8cf91d96b2cb0032c385c0</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-11T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "前端物语|面试物语-vue",
      "url": "https://www.h7ml.cn/posts/interview/vue/",
      "id": "https://www.h7ml.cn/posts/interview/vue/",
      "summary": "vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？ Vue 项目中有封装过 axios 吗？主要是封装哪方面的？ 你了解 axios 的原理吗？有看过它的源码吗？ 双向数据绑定是什么 Vue 组件之间的通信方式都有哪些？ Vue 中组件和插件有什么区别？ Vue 项目中你是如何解决跨域的呢？ 为什么 data 属性是一个函数而不是一个对象？ 动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？ 你了解 vue 的 diff 算法吗？说说看 ,- 你是怎么处理 vue 项目中的错误的？ Vue 中的过滤器了解吗？过滤器的应用场景有哪些？ SPA 首屏加载速度慢的怎么解决？ v-if 和 v-for 的优先级是什么？ 说说你对 keep-alive 的理解是什么？ 你知道 vue 中 key 的原理吗？说说你对它的理解 请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？ 说说你对 vue 的 mixin 的理解，有什么应用场景？ Vue 常用的修饰符有哪些有什么应用场景 Vue 实例挂载的过程 Vue 中的$nextTick 有什么作用？ Vue.observable 你有了解过吗？说说看 vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？ v-show 和 v-if 有什么区别？使用场景分别是什么？ 你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢 SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？ 说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？ 什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路 vue3 有了解过吗？能说说跟 vue2 的区别吗？",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/404\" target=\"_blank\" rel=\"noopener noreferrer\"> vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/axios\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 项目中有封装过 axios 吗？主要是封装哪方面的？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/axiosCode\" target=\"_blank\" rel=\"noopener noreferrer\"> 你了解 axios 的原理吗？有看过它的源码吗？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/bind\" target=\"_blank\" rel=\"noopener noreferrer\"> 双向数据绑定是什么</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/communication\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 组件之间的通信方式都有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/components_plugin\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 中组件和插件有什么区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/cors\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 项目中你是如何解决跨域的呢？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/data\" target=\"_blank\" rel=\"noopener noreferrer\"> 为什么 data 属性是一个函数而不是一个对象？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/data_object_add_attrs\" target=\"_blank\" rel=\"noopener noreferrer\"> 动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/diff\" target=\"_blank\" rel=\"noopener noreferrer\"> 你了解 vue 的 diff 算法吗？说说看</a> ,- <a href=\"https://www.h7ml.cn/posts/interview/vue/error\" target=\"_blank\" rel=\"noopener noreferrer\"> 你是怎么处理 vue 项目中的错误的？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/filter\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 中的过滤器了解吗？过滤器的应用场景有哪些？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/first_page_time\" target=\"_blank\" rel=\"noopener noreferrer\"> SPA 首屏加载速度慢的怎么解决？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/if_for\" target=\"_blank\" rel=\"noopener noreferrer\"> v-if 和 v-for 的优先级是什么？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/keepalive\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对 keep-alive 的理解是什么？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/key\" target=\"_blank\" rel=\"noopener noreferrer\"> 你知道 vue 中 key 的原理吗？说说你对它的理解</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/lifecycle\" target=\"_blank\" rel=\"noopener noreferrer\"> 请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/mixin\" target=\"_blank\" rel=\"noopener noreferrer\"> 说说你对 vue 的 mixin 的理解，有什么应用场景？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/modifier\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 常用的修饰符有哪些有什么应用场景</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/new_vue\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 实例挂载的过程</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/nexttick\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue 中的$nextTick 有什么作用？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/observable\" target=\"_blank\" rel=\"noopener noreferrer\"> Vue.observable 你有了解过吗？说说看</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/permission\" target=\"_blank\" rel=\"noopener noreferrer\"> vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/show_if\" target=\"_blank\" rel=\"noopener noreferrer\"> v-show 和 v-if 有什么区别？使用场景分别是什么？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/spa\" target=\"_blank\" rel=\"noopener noreferrer\"> 你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/ssr\" target=\"_blank\" rel=\"noopener noreferrer\"> SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/structure\" target=\"_blank\" rel=\"noopener noreferrer\"> 说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/vnode\" target=\"_blank\" rel=\"noopener noreferrer\"> 什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue/vue3_vue2\" target=\"_blank\" rel=\"noopener noreferrer\"> vue3 有了解过吗？能说说跟 vue2 的区别吗？</a></li>\n</ul>\n",
      "date_published": "2023-04-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue"
      ]
    },
    {
      "title": "Vue 项目中有封装过 axios 吗？主要是封装哪方面的？",
      "url": "https://www.h7ml.cn/posts/interview/vue/axios.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/axios.html",
      "summary": "前端物语|面试物语-Vue 项目中有封装过 axios 吗？主要是封装哪方面的？",
      "content_html": "<h1> Vue 项目中有封装过 axios 吗？主要是封装哪方面的？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2bf1e460-45a7-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、axios 是什么</h2>\n<p><code>axios</code> 是一个轻量的 <code>HTTP</code>客户端</p>\n<p>基于 <code>XMLHttpRequest</code> 服务来执行 <code>HTTP</code> 请求，支持丰富的配置，支持 <code>Promise</code>，支持浏览器端和 <code>Node.js</code> 端。自<code>Vue</code>2.0 起，尤大宣布取消对 <code>vue-resource</code> 的官方推荐，转而推荐 <code>axios</code>。现在 <code>axios</code> 已经成为大部分 <code>Vue</code> 开发者的首选</p>\n<h3> 特性</h3>\n<ul>\n<li>从浏览器中创建 <code>XMLHttpRequests</code></li>\n<li>从 <code>node.js</code> 创建 <code>http</code>请求</li>\n<li>支持 <code>Promise</code> API</li>\n<li>拦截请求和响应</li>\n<li>转换请求数据和响应数据</li>\n<li>取消请求</li>\n<li>自动转换<code>JSON</code> 数据</li>\n<li>客户端支持防御<code>XSRF</code></li>\n</ul>\n<h3> 基本使用</h3>\n<p>安装</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>导入</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>发送请求</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>并发请求<code>axios.all([])</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、为什么要封装</h2>\n<p><code>axios</code> 的 API 很友好，你完全可以很轻松地在项目中直接使用。</p>\n<p>不过随着项目规模增大，如果每发起一次<code>HTTP</code>请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍</p>\n<p>这种重复劳动不仅浪费时间，而且让代码变得冗余不堪，难以维护。为了提高我们的代码质量，我们应该在项目中二次封装一下 <code>axios</code> 再使用</p>\n<p>举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果每个页面都发送类似的请求，都要写一堆的配置与错误处理，就显得过于繁琐了</p>\n<p>这时候我们就需要对<code>axios</code>进行二次封装，让使用更为便利</p>\n<h2> 三、如何封装</h2>\n<p>封装的同时，你需要和 后端协商好一些约定，请求头，状态码，请求超时时间.......</p>\n<p>设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分</p>\n<p>请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)</p>\n<p>状态码: 根据接口返回的不同<code>status</code> ， 来执行不同的业务，这块需要和后端约定好</p>\n<p>请求方法：根据<code>get</code>、<code>post</code>等方法进行一个再次封装，使用起来更为方便</p>\n<p>请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问</p>\n<p>响应拦截器： 这块就是根据 后端`返回来的状态码判定执行不同业务</p>\n<h3> 设置接口请求前缀</h3>\n<p>利用<code>node</code>环境变量来作判断，用来区分开发、测试、生产环境</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在本地调试的时候，还需要在<code>vue.config.js</code>文件中配置<code>devServer</code>实现代理转发，从而实现跨域</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 设置请求头与超时时间</h3>\n<p>大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，这里将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 封装请求方法</h3>\n<p>先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>把封装的方法放在一个<code>api.js</code>文件中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>页面中就能直接调用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样可以把<code>api</code>统一管理起来，以后维护修改只需要在<code>api.js</code>文件操作即可</p>\n<h3> 请求拦截器</h3>\n<p>请求拦截器可以在每个请求里加上 token，做了统一处理后维护起来也方便</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 响应拦截器</h3>\n<p>响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 小结</h3>\n<ul>\n<li>封装是编程中很有意义的手段，简单的<code>axios</code>封装，就可以让我们可以领略到它的魅力</li>\n<li>封装 <code>axios</code> 没有一个绝对的标准，只要你的封装可以满足你的项目需求，并且用起来方便，那就是一个好的封装方案</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.html.cn/qa/vue-js/20544.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.html.cn/qa/vue-js/20544.html</a></li>\n<li><a href=\"https://juejin.cn/post/6844904033782611976\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904033782611976</a></li>\n<li><a href=\"https://juejin.cn/post/6844903801451708429\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903801451708429</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-16T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "你了解 axios 的原理吗？有看过它的源码吗？",
      "url": "https://www.h7ml.cn/posts/interview/vue/axiosCode.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/axiosCode.html",
      "summary": "前端物语|面试物语-你了解 axios 的原理吗？有看过它的源码吗？",
      "content_html": "<h1> 你了解 axios 的原理吗？有看过它的源码吗？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/1564f7d0-4662-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、axios 的使用</h2>\n<p>关于<code>axios</code>的基本使用，上篇文章已经有所涉及，这里再稍微回顾下：</p>\n<p><strong>发送请求</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>请求拦截器</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>响应拦截器</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>取消请求</strong></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、实现一个简易版 axios</h2>\n<p>构建一个<code>Axios</code>构造函数，核心代码为<code>request</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>导出<code>axios</code>实例</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述就已经能够实现<code>axios({ })</code>这种方式的请求</p>\n<p>下面是来实现下<code>axios.method()</code>这种形式的请求</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>将<code>Axios.prototype</code>上的方法搬运到<code>request</code>上</p>\n<p>首先实现个工具类，实现将<code>b</code>方法混入到<code>a</code>，并且修改<code>this</code>指向</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改导出的方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>构建拦截器的构造函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实现<code>axios.interceptors.response.use</code>和<code>axios.interceptors.request.use</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>执行语句<code>axios.interceptors.response.use</code>和<code>axios.interceptors.request.use</code>的时候，实现获取<code>axios</code>实例上的<code>interceptors</code>对象，然后再获取<code>response</code>或<code>request</code>拦截器，再执行对应的拦截器的<code>use</code>方法</p>\n<p>把<code>Axios</code>上的方法和属性搬到<code>request</code>过去</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>现在<code>request</code>也有了<code>interceptors</code>对象，在发送请求的时候，会先获取<code>request</code>拦截器的<code>handlers</code>的方法来执行</p>\n<p>首先将执行<code>ajax</code>的请求封装成一个方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>获得<code>handlers</code>中的回调</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>chains</code>大概是<code>['fulfilled1','reject1','fulfilled2','reject2','this.sendAjax','undefined','fulfilled2','reject2','fulfilled1','reject1']</code>这种形式</p>\n<p>这样就能够成功实现一个简易版<code>axios</code></p>\n<h2> 三、源码分析</h2>\n<p>首先看看目录结构</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9d90eaa0-48b6-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p><code>axios</code>发送请求有很多实现的方法，实现入口文件为<code>axios.js</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>主要核心是 <code>Axios.prototype.request</code>，各种请求方式的调用实现都是在 <code>request</code> 内部实现的， 简单看下 <code>request</code> 的逻辑</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>request</code>入口参数为<code>config</code>，可以说<code>config</code>贯彻了<code>axios</code>的一生</p>\n<p><code>axios</code> 中的 <code>config</code>主要分布在这几个地方：</p>\n<ul>\n<li>默认配置 <code>defaults.js</code></li>\n<li><code>config.method</code>默认为 <code>get</code></li>\n<li>调用 <code>createInstance</code> 方法创建 <code>axios</code>实例，传入的<code>config</code></li>\n<li>直接或间接调用 <code>request</code> 方法，传入的 <code>config</code></li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从源码中，可以看到优先级：默认配置对象<code>default</code> &lt; <code>method:get</code> &lt; <code>Axios</code>的实例属性<code>this.default</code> &lt; <code>request</code>参数</p>\n<p>下面重点看看<code>request</code>方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>拦截器<code>interceptors</code>是在构建<code>axios</code>实例化的属性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>InterceptorManager</code>构造函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>请求拦截器方法是被 <code>unshift</code>到拦截器中，响应拦截器是被<code>push</code>到拦截器中的。最终它们会拼接上一个叫<code>dispatchRequest</code>的方法被后续的 <code>promise</code> 顺序执行</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再来看看<code>axios</code>是如何实现取消请求的，实现文件在<code>CancelToken.js</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实际上取消请求的操作是在 <code>xhr.js</code> 中也有响应的配合的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>巧妙的地方在 <code>CancelToken</code>中 <code>executor</code> 函数，通过<code>resolve</code>函数的传递与执行，控制<code>promise</code>的状态</p>\n<h3> 小结</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b1d2ebd0-48b6-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6856706569263677447#heading-4\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6856706569263677447#heading-4</a></li>\n<li><a href=\"https://juejin.cn/post/6844903907500490766\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903907500490766</a></li>\n<li><a href=\"https://github.com/axios/axios\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/axios/axios</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-14T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "双向数据绑定是什么",
      "url": "https://www.h7ml.cn/posts/interview/vue/bind.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/bind.html",
      "summary": "前端物语|面试物语-双向数据绑定是什么",
      "content_html": "<h1> 双向数据绑定是什么</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/cef7dcc0-3ac9-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、什么是双向绑定</h2>\n<p>我们先从单向绑定切入单向绑定非常简单，就是把<code>Model</code>绑定到<code>View</code>，当我们用<code>JavaScript</code>代码更新<code>Model</code>时，<code>View</code>就会自动更新双向绑定就很容易联想到了，在单向绑定的基础上，用户更新了<code>View</code>，<code>Model</code>的数据也自动被更新了，这种情况就是双向绑定举个栗子</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d65738d0-3ac9-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>当用户填写表单时，<code>View</code>的状态就被更新了，如果此时可以自动更新<code>Model</code>的状态，那就相当于我们把<code>Model</code>和<code>View</code>做了双向绑定关系图如下</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/dcc1d4a0-3ac9-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、双向绑定的原理是什么</h2>\n<p>我们都知道 <code>Vue</code> 是数据双向绑定的框架，双向绑定由三个重要部分构成</p>\n<ul>\n<li>数据层（Model）：应用的数据及业务逻辑</li>\n<li>视图层（View）：应用的展示效果，各类 UI 组件</li>\n<li>业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来</li>\n</ul>\n<p>而上面的这个分层的架构方案，可以用一个专业术语进行称呼：<code>MVVM</code>这里的控制层的核心功能便是 “数据双向绑定” 。自然，我们只需弄懂它是什么，便可以进一步了解数据绑定的原理</p>\n<h3> 理解 ViewModel</h3>\n<p>它的主要职责就是：</p>\n<ul>\n<li>数据变化后更新视图</li>\n<li>视图变化后更新数据</li>\n</ul>\n<p>当然，它还有两个主要部分组成</p>\n<ul>\n<li>监听器（Observer）：对所有数据的属性进行监听</li>\n<li>解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</li>\n</ul>\n<h3> 三、实现双向绑定</h3>\n<p>我们还是以<code>Vue</code>为例，先来看看<code>Vue</code>中的双向绑定流程是什么的</p>\n<ol>\n<li><code>new Vue()</code>首先执行初始化，对<code>data</code>执行响应化处理，这个过程发生<code>Observe</code>中</li>\n<li>同时对模板执行编译，找到其中动态绑定的数据，从<code>data</code>中获取并初始化视图，这个过程发生在<code>Compile</code>中</li>\n<li>同时定义⼀个更新函数和<code>Watcher</code>，将来对应数据变化时<code>Watcher</code>会调用更新函数</li>\n<li>由于<code>data</code>的某个<code>key</code>在⼀个视图中可能出现多次，所以每个<code>key</code>都需要⼀个管家<code>Dep</code>来管理多个<code>Watcher</code></li>\n<li>将来 data 中数据⼀旦发生变化，会首先找到对应的<code>Dep</code>，通知所有<code>Watcher</code>执行更新函数</li>\n</ol>\n<p>流程图如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e5369850-3ac9-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 实现</h3>\n<p>先来一个构造函数：执行初始化，对<code>data</code>执行响应化处理</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对<code>data</code>选项执行响应化具体操作</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 编译<code>Compile</code></h4>\n<p>对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f27e19c0-3ac9-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 依赖收集</h4>\n<p>视图中会用到<code>data</code>中某<code>key</code>，这称为依赖。同⼀个<code>key</code>可能出现多次，每次都需要收集出来用⼀个<code>Watcher</code>来维护它们，此过程称为依赖收集多个<code>Watcher</code>需要⼀个<code>Dep</code>来管理，需要更新时由<code>Dep</code>统⼀通知</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fa191f40-3ac9-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>实现思路</p>\n<ol>\n<li><code>defineReactive</code>时为每⼀个<code>key</code>创建⼀个<code>Dep</code>实例</li>\n<li>初始化视图时读取某个<code>key</code>，例如<code>name1</code>，创建⼀个<code>watcher1</code></li>\n<li>由于触发<code>name1</code>的<code>getter</code>方法，便将<code>watcher1</code>添加到<code>name1</code>对应的 Dep 中</li>\n<li>当<code>name1</code>更新，<code>setter</code>触发时，便可通过对应<code>Dep</code>通知其管理所有<code>Watcher</code>更新</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>声明<code>Dep</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建<code>watcher</code>时触发<code>getter</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>依赖收集，创建<code>Dep</code>实例</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1109527162256416\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.liaoxuefeng.com/wiki/1022910821149312/1109527162256416</a></li>\n<li><a href=\"https://juejin.cn/post/6844903942254510087#heading-9\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903942254510087#heading-9</a></li>\n</ul>\n<p>面试官 VUE 系列总进度：3／33</p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&amp;mid=2247484101&amp;idx=1&amp;sn=83b0983f0fca7d7c556e4cb0bff8c9b8&amp;chksm=fc10c093cb674985ef3bd2966f66fc28c5eb70b0037e4be1af4bf54fb6fa9571985abd31d52f&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 vue 的理解?</a><br>\n<a href=\"http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&amp;mid=2247484119&amp;idx=1&amp;sn=d171b28a00d42549d279498944a98519&amp;chksm=fc10c081cb6749976814aaeda6a6433db418223cec57edda7e15b9e5a0ca69ad549655639c61&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 SPA（单页应用）的理解?</a></p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-09T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "Vue 组件之间的通信方式都有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/vue/communication.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/communication.html",
      "summary": "前端物语|面试物语-Vue 组件之间的通信方式都有哪些？",
      "content_html": "<h1> Vue 组件之间的通信方式都有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7de50d20-3aca-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、组件间通信的概念</h2>\n<p>开始之前，我们把<strong>组件间通信</strong>这个词进行拆分</p>\n<ul>\n<li>组件</li>\n<li>通信</li>\n</ul>\n<p>都知道组件是<code>vue</code>最强大的功能之一，<code>vue</code>中每一个<code>.vue</code>我们都可以视之为一个组件通信指的是发送者通过某种媒体以某种格式来传递信息到收信者以达到某个目的。广义上，任何信息的交通都是通信<strong>组件间通信</strong>即指组件(<code>.vue</code>)通过某种方式来传递信息以达到某个目的举个栗子我们在使用<code>UI</code>框架中的<code>table</code>组件，可能会往<code>table</code>组件中传入某些数据，这个本质就形成了组件之间的通信</p>\n<h2> 二、组件间通信解决了什么</h2>\n<p>在古代，人们通过驿站、飞鸽传书、烽火报警、符号、语言、眼神、触碰等方式进行信息传递，到了今天，随着科技水平的飞速发展，通信基本完全利用有线或无线电完成，相继出现了有线电话、固定电话、无线电话、手机、互联网甚至视频电话等各种通信方式从上面这段话，我们可以看到通信的本质是信息同步，共享回到<code>vue</code>中，每个组件之间的都有独自的作用域，组件间的数据是无法共享的但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统</p>\n<h2> 二、组件间通信的分类</h2>\n<p>组件间通信的分类可以分成以下</p>\n<ul>\n<li>父子组件之间的通信</li>\n<li>兄弟组件之间的通信</li>\n<li>祖孙与后代组件之间的通信</li>\n<li>非关系组件间之间的通信</li>\n</ul>\n<p>关系图:</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/85b92400-3aca-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、组件间通信的方案</h2>\n<p>整理<code>vue</code>中 8 种常规的通信方案</p>\n<ol>\n<li>通过 props 传递</li>\n<li>通过 $emit 触发自定义事件</li>\n<li>使用 ref</li>\n<li>EventBus</li>\n<li>root</li>\n<li>attrs 与 listeners</li>\n<li>Provide 与 Inject</li>\n<li>Vuex</li>\n</ol>\n<h3> props 传递数据</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8f80a670-3aca-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>适用场景：父组件传递数据给子组件</li>\n<li>子组件设置<code>props</code>属性，定义接收父组件传递过来的参数</li>\n<li>父组件在使用子组件标签中通过字面量来传递值</li>\n</ul>\n<p><code>Children.vue</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Father.vue</code>组件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> $emit 触发自定义事件</h3>\n<ul>\n<li>适用场景：子组件传递数据给父组件</li>\n<li>子组件通过<code>$emit触发</code>自定义事件，<code>$emit</code>第二个参数为传递的数值</li>\n<li>父组件绑定监听器获取到子组件传递过来的参数</li>\n</ul>\n<p><code>Chilfen.vue</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>Father.vue</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> ref</h3>\n<ul>\n<li>父组件在使用子组件的时候设置<code>ref</code></li>\n<li>父组件通过设置子组件<code>ref</code>来获取数据</li>\n</ul>\n<p>父组件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> EventBus</h3>\n<ul>\n<li>使用场景：兄弟组件传值</li>\n<li>创建一个中央事件总线<code>EventBus</code></li>\n<li>兄弟组件通过<code>$emit</code>触发自定义事件，<code>$emit</code>第二个参数为传递的数值</li>\n<li>另一个兄弟组件通过<code>$on</code>监听自定义事件</li>\n</ul>\n<p><code>Bus.js</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Children1.vue</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>Children2.vue</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> &nbsp;root</h3>\n<ul>\n<li>通过共同祖辈<code>$parent</code>或者<code>$root</code>搭建通信桥连</li>\n</ul>\n<p>兄弟组件</p>\n<p><code>this.$parent.on('add',this.add)</code></p>\n<p>另一个兄弟组件</p>\n<p><code>this.$parent.emit('add')</code></p>\n<h3>  listeners</h3>\n<ul>\n<li>适用场景：祖先传递数据给子孙</li>\n<li>设置批量向下传属性<code>$attrs</code>和 <code>$listeners</code></li>\n<li>包含了父级作用域中不作为 <code>prop</code> 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。</li>\n<li>可以通过 <code>v-bind=\"$attrs\"</code> 传⼊内部组件</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> provide 与 inject</h3>\n<ul>\n<li>在祖先组件定义<code>provide</code>属性，返回传递的值</li>\n<li>在后代组件通过<code>inject</code>接收组件传递过来的值</li>\n</ul>\n<p>祖先组件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>后代组件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> <code>vuex</code></h3>\n<ul>\n<li>\n<p>适用场景: 复杂关系的组件数据传递</p>\n</li>\n<li>\n<p><code>Vuex</code>作用相当于一个用来存储共享变量的容器 <img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fa207cd0-3aca-11eb-ab90-d9ae814b240d.png\" alt=\"\" loading=\"lazy\"></p>\n</li>\n<li>\n<p><code>state</code>用来存放共享变量的地方</p>\n</li>\n<li>\n<p><code>getter</code>，可以增加一个<code>getter</code>派生状态，(相当于<code>store</code>中的计算属性），用来获得共享变量的值</p>\n</li>\n<li>\n<p><code>mutations</code>用来存放修改<code>state</code>的方法。</p>\n</li>\n<li>\n<p><code>actions</code>也是用来存放修改 state 的方法，不过<code>action</code>是在<code>mutations</code>的基础上进行。常用来做一些异步操作</p>\n</li>\n</ul>\n<h3> 小结</h3>\n<ul>\n<li>父子关系的组件数据传递选择 <code>props</code> &nbsp; 与 <code>$emit</code>进行传递，也可选择<code>ref</code></li>\n<li>兄弟关系的组件数据传递可选择<code>$bus</code>，其次可以选择<code>$parent</code>进行传递</li>\n<li>祖先与后代组件数据传递可选择<code>attrs</code>与<code>listeners</code>或者 <code>Provide</code>与 <code>Inject</code></li>\n<li>复杂关系的组件数据传递可以通过<code>vuex</code>存放共享的变量</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844903990052782094#heading-0\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903990052782094#heading-0</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%5C%E9%5C%80%5C%9A%5C%E4%5C%BF%5C%A1\" target=\"_blank\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/\\�\\�\\�\\�\\�\\�</a></li>\n<li><a href=\"https://vue3js.cn/docs/zh\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn/docs/zh</a></li>\n</ul>\n<p>面试官 VUE 系列总进度：5／33</p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&amp;mid=2247484101&amp;idx=1&amp;sn=83b0983f0fca7d7c556e4cb0bff8c9b8&amp;chksm=fc10c093cb674985ef3bd2966f66fc28c5eb70b0037e4be1af4bf54fb6fa9571985abd31d52f&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 vue 的理解?</a></p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&amp;mid=2247484119&amp;idx=1&amp;sn=d171b28a00d42549d279498944a98519&amp;chksm=fc10c081cb6749976814aaeda6a6433db418223cec57edda7e15b9e5a0ca69ad549655639c61&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 SPA（单页应用）的理解?</a></p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&amp;mid=2247484167&amp;idx=1&amp;sn=7b00b4333ab2722f25f12586b70667ca&amp;chksm=fc10c151cb6748476008dab2f4e6c6264f5d19678305955c85cec1b619e56e8f7457b7357fb9&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对双向绑定的理解?</a></p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&amp;mid=2247484176&amp;idx=1&amp;sn=5623421ed2678046ed9e438aadf6e26f&amp;chksm=fc10c146cb67485015f24f7e9f5862c4c685fc33485fe30e1b375a534b4031978439c554e0c0&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 Vue 生命周期的理解?</a></p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "Vue 中组件和插件有什么区别？",
      "url": "https://www.h7ml.cn/posts/interview/vue/components_plugin.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/components_plugin.html",
      "summary": "前端物语|面试物语-Vue 中组件和插件有什么区别？",
      "content_html": "<h1> Vue 中组件和插件有什么区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/683475e0-3acc-11eb-ab90-d9ae814b240d.png\" alt=\"image.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>image.png</figcaption></figure>\n<h2> 一、组件是什么</h2>\n<p>回顾以前对组件的定义：</p>\n<p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件</p>\n<p>组件的优势</p>\n<ul>\n<li>\n<p>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</p>\n</li>\n<li>\n<p>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</p>\n</li>\n<li>\n<p>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</p>\n</li>\n</ul>\n<h2> 二、插件是什么</h2>\n<p>插件通常用来为 <code>Vue</code> 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：</p>\n<ul>\n<li>添加全局方法或者属性。如: <code>vue-custom-element</code></li>\n<li>添加全局资源：指令/过滤器/过渡等。如 <code>vue-touch</code></li>\n<li>通过全局混入来添加一些组件选项。如<code>vue-router</code></li>\n<li>添加 <code>Vue</code> 实例方法，通过把它们添加到 <code>Vue.prototype</code> 上实现。</li>\n<li>一个库，提供自己的 <code>API</code>，同时提供上面提到的一个或多个功能。如<code>vue-router</code></li>\n</ul>\n<h2> 三、两者的区别</h2>\n<p>两者的区别主要表现在以下几个方面：</p>\n<ul>\n<li>编写形式</li>\n<li>注册形式</li>\n<li>使用场景</li>\n</ul>\n<h3> 编写形式</h3>\n<h4> 编写组件</h4>\n<p>编写一个组件，可以有很多方式，我们最常见的就是<code>vue</code>单文件的这种格式，每一个<code>.vue</code>文件我们都可以看成是一个组件</p>\n<p><code>vue</code>文件标准格式</p>\n<div class=\"language-vue line-numbers-mode\" data-ext=\"vue\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们还可以通过<code>template</code>属性来编写一个组件，如果组件内容多，我们可以在外部定义<code>template</code>组件内容，如果组件内容并不多，我们可直接写在<code>template</code>属性上</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 编写插件</h4>\n<p><code>vue</code>插件的实现应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 注册形式</h3>\n<h4> 组件注册</h4>\n<p><code>vue</code>组件注册主要分为全局注册与局部注册</p>\n<p>全局注册通过<code>Vue.component</code>方法，第一个参数为组件的名称，第二个参数为传入的配置项</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>局部注册只需在用到的地方通过<code>components</code>属性注册一个组件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 插件注册</h4>\n<p>插件的注册通过<code>Vue.use()</code>的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意的是：</p>\n<p>注册插件的时候，需要在调用 <code>new Vue()</code> 启动应用之前完成</p>\n<p><code>Vue.use</code>会自动阻止多次注册相同插件，只会注册一次</p>\n<h3> 使用场景</h3>\n<p>具体的其实在插件是什么章节已经表述了，这里在总结一下</p>\n<p>组件 <code>(Component)</code> 是用来构成你的 <code>App</code> 的业务模块，它的目标是 <code>App.vue</code></p>\n<p>插件 <code>(Plugin)</code> 是用来增强你的技术栈的功能模块，它的目标是 <code>Vue</code> 本身</p>\n<p>简单来说，插件就是指对<code>Vue</code>的功能的增强或补充</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://vue3js.cn/docs/zh\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn/docs/zh</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-05T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "Vue 项目中你是如何解决跨域的呢？",
      "url": "https://www.h7ml.cn/posts/interview/vue/cors.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/cors.html",
      "summary": "前端物语|面试物语-Vue 项目中你是如何解决跨域的呢？",
      "content_html": "<h1> Vue 项目中你是如何解决跨域的呢？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/db3045b0-4e31-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、跨域是什么</h2>\n<p>跨域本质是浏览器基于<strong>同源策略</strong>的一种安全手段</p>\n<p>同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能</p>\n<p>所谓同源（即指在同一个域）具有以下三个相同点</p>\n<ul>\n<li>协议相同（protocol）</li>\n<li>主机相同（host）</li>\n<li>端口相同（port）</li>\n</ul>\n<p>反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域</p>\n<blockquote>\n<p>一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用 postman 请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。</p>\n</blockquote>\n<h2> 二、如何解决</h2>\n<p>解决跨域的方法有很多，下面列举了三种：</p>\n<ul>\n<li>JSONP</li>\n<li>CORS</li>\n<li>Proxy</li>\n</ul>\n<p>而在<code>vue</code>项目中，我们主要针对<code>CORS</code>或<code>Proxy</code>这两种方案进行展开</p>\n<h3> CORS</h3>\n<p>CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的 HTTP 头组成，这些 HTTP 头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应</p>\n<p><code>CORS</code> 实现起来非常方便，只需要增加一些 <code>HTTP</code> 头，让服务器能声明允许的访问来源</p>\n<p>只要后端实现了 <code>CORS</code>，就实现了跨域</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/140deb80-4e32-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>以<code>koa</code>框架举例</p>\n<p>添加中间件，直接设置<code>Access-Control-Allow-Origin</code>响应头</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>ps: <code>Access-Control-Allow-Origin</code> 设置为*其实意义不大，可以说是形同虚设，实际应用中，上线前我们会将<code>Access-Control-Allow-Origin</code> 值设为我们目标<code>host</code></p>\n<h3> Proxy</h3>\n<p>代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击</p>\n<p><strong>方案一</strong></p>\n<p>如果是通过<code>vue-cli</code>脚手架工具搭建项目，我们可以通过<code>webpack</code>为我们起一个本地服务器作为请求的代理对象</p>\n<p>通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果 web 应用和接口服务器不在一起仍会跨域</p>\n<p>在<code>vue.config.js</code>文件，新增以下代码</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过<code>axios</code>发送请求中，配置请求的根路径</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>方案二</strong></p>\n<p>此外，还可通过服务端实现代理请求转发</p>\n<p>以<code>express</code>框架为例</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>方案三</strong></p>\n<p>通过配置<code>nginx</code>实现代理</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-25T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "为什么 data 属性是一个函数而不是一个对象？",
      "url": "https://www.h7ml.cn/posts/interview/vue/data.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/data.html",
      "summary": "前端物语|面试物语-为什么 data 属性是一个函数而不是一个对象？",
      "content_html": "<h1> 为什么 data 属性是一个函数而不是一个对象？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/83e51560-3acc-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、实例和组件定义 data 的区别</h2>\n<p><code>vue</code>实例的时候定义<code>data</code>属性既可以是一个对象，也可以是一个函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>组件中定义<code>data</code>属性，只能是一个函数</p>\n<p>如果为组件<code>data</code>直接定义为一个对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>则会得到警告信息</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8e6fc0c0-3acc-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>警告说明：返回的<code>data</code>应该是一个函数在每一个组件实例中</p>\n<h2> 二、组件 data 定义函数与对象的区别</h2>\n<p>上面讲到组件<code>data</code>必须是一个函数，不知道大家有没有思考过这是为什么呢？</p>\n<p>在我们定义好一个组件的时候，<code>vue</code>最终都会通过<code>Vue.extend()</code>构成组件实例</p>\n<p>这里我们模仿组件构造函数，定义<code>data</code>属性，采用对象的形式</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建两个组件实例</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改<code>componentA</code>组件<code>data</code>属性的值，<code>componentB</code>中的值也发生了改变</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>产生这样的原因这是两者共用了同一个内存地址，<code>componentA</code>修改的内容，同样对<code>componentB</code>产生了影响</p>\n<p>如果我们采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改<code>componentA</code>组件<code>data</code>属性的值，<code>componentB</code>中的值不受影响</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>vue</code>组件可能会有很多个实例，采用函数返回一个全新<code>data</code>形式，使每个实例对象的数据不会受到其他实例对象数据的污染</p>\n<h2> 三、原理分析</h2>\n<p>首先可以看看<code>vue</code>初始化<code>data</code>的代码，<code>data</code>的定义可以是函数也可以是对象</p>\n<p>源码位置：<code>/vue-dev/src/core/instance/state.js</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>data</code>既能是<code>object</code>也能是<code>function</code>，那为什么还会出现上文警告呢？</p>\n<p>别急，继续看下文</p>\n<p>组件在创建的时候，会进行选项的合并</p>\n<p>源码位置：<code>/vue-dev/src/core/util/options.js</code></p>\n<p>自定义组件会进入<code>mergeOptions</code>进行选项合并</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定义<code>data</code>会进行数据校验</p>\n<p>源码位置：<code>/vue-dev/src/core/instance/init.js</code></p>\n<p>这时候<code>vm</code>实例为<code>undefined</code>，进入<code>if</code>判断，若<code>data</code>类型不是<code>function</code>，则出现警告提示</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 四、结论</h3>\n<ul>\n<li>根实例对象<code>data</code>可以是对象也可以是函数（根实例是单例），不会产生数据污染情况</li>\n<li>组件实例对象<code>data</code>必须为函数，目的是为了防止多个组件实例对象之间共用一个<code>data</code>，产生数据污染。采用函数的形式，<code>initData</code>时会将其作为工厂函数都会返回全新<code>data</code>对象</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-09T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？",
      "url": "https://www.h7ml.cn/posts/interview/vue/data_object_add_attrs.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/data_object_add_attrs.html",
      "summary": "前端物语|面试物语-动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？",
      "content_html": "<h1> 动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a502dde0-3acc-11eb-ab90-d9ae814b240d.png\" alt=\"image.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>image.png</figcaption></figure>\n<h2> 一、直接添加属性的问题</h2>\n<p>我们从一个例子开始</p>\n<p>定义一个<code>p</code>标签，通过<code>v-for</code>指令进行遍历</p>\n<p>然后给<code>botton</code>标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实例化一个<code>vue</code>实例，定义<code>data</code>属性和<code>methods</code>方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>点击按钮，发现结果不及预期，数据虽然更新了（<code>console</code>打印出了新属性），但页面并没有更新</p>\n<h2> 二、原理分析</h2>\n<p>为什么产生上面的情况呢？</p>\n<p>下面来分析一下</p>\n<p><code>vue2</code>是用过<code>Object.defineProperty</code>实现数据响应式</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当我们访问<code>foo</code>属性或者设置<code>foo</code>值的时候都能够触发<code>setter</code>与<code>getter</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但是我们为<code>obj</code>添加新属性的时候，却无法触发事件属性的拦截</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>原因是一开始<code>obj</code>的<code>foo</code>属性被设成了响应式数据，而<code>bar</code>是后面新增的属性，并没有通过<code>Object.defineProperty</code>设置成响应式数据</p>\n<h2> 三、解决方案</h2>\n<p><code>Vue</code> 不允许在已经创建的实例上动态添加新的响应式属性</p>\n<p>若想实现数据与视图同步更新，可采取下面三种解决方案：</p>\n<ul>\n<li>Vue.set()</li>\n<li>Object.assign()</li>\n<li>$forcecUpdated()</li>\n</ul>\n<h3> Vue.set()</h3>\n<p>Vue.set( target, propertyName/index, value )</p>\n<p>参数</p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n<li><code>{any} value</code></li>\n</ul>\n<p>返回值：设置的值</p>\n<p>通过<code>Vue.set</code>向响应式对象中添加一个<code>property</code>，并确保这个新 <code>property</code>同样是响应式的，且触发视图更新</p>\n<p>关于<code>Vue.set</code>源码（省略了很多与本节不相关的代码）</p>\n<p>源码位置：<code>src\\core\\observer\\index.js</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里无非再次调用<code>defineReactive</code>方法，实现新增属性的响应式</p>\n<p>关于<code>defineReactive</code>方法，内部还是通过<code>Object.defineProperty</code>实现属性拦截</p>\n<p>大致代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Object.assign()</h3>\n<p>直接使用<code>Object.assign()</code>添加到对象的新属性不会触发更新</p>\n<p>应创建一个新的对象，合并原对象和混入对象的属性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> $forceUpdate</h3>\n<p>如果你发现你自己需要在 <code>Vue</code>中做一次强制更新，99.9% 的情况，是你在某个地方做错了事</p>\n<p><code>$forceUpdate</code>迫使<code>Vue</code> 实例重新渲染</p>\n<p>PS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>\n<h3> 小结</h3>\n<ul>\n<li>\n<p>如果为对象添加少量的新属性，可以直接采用<code>Vue.set()</code></p>\n</li>\n<li>\n<p>如果需要为新对象添加大量的新属性，则通过<code>Object.assign()</code>创建新对象</p>\n</li>\n<li>\n<p>如果你实在不知道怎么操作时，可采取<code>$forceUpdate()</code>进行强制刷新 (不建议)</p>\n</li>\n</ul>\n<p>PS：<code>vue3</code>是用过<code>proxy</code>实现数据响应式的，直接动态添加新属性仍可以实现数据响应式</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/api/#Vue-set\" target=\"_blank\" rel=\"noopener noreferrer\">https://cn.vuejs.org/v2/api/#Vue-set</a></li>\n<li><a href=\"https://vue3js.cn/docs/zh\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn/docs/zh</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-01T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "你了解 vue 的 diff 算法吗？说说看",
      "url": "https://www.h7ml.cn/posts/interview/vue/diff.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/diff.html",
      "summary": "前端物语|面试物语-你了解 vue 的 diff 算法吗？说说看",
      "content_html": "<h1> 你了解 vue 的 diff 算法吗？说说看</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5e858e30-4585-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>diff</code> 算法是一种通过同层的树节点进行比较的高效算法</p>\n<p>其有两个特点：</p>\n<ul>\n<li>比较只会在同层级进行, 不会跨层级比较</li>\n<li>在 diff 比较的过程中，循环从两边向中间比较</li>\n</ul>\n<p><code>diff</code> 算法在很多场景下都有应用，在 <code>vue</code> 中，作用于虚拟 <code>dom</code> 渲染成真实 <code>dom</code> 的新旧 <code>VNode</code> 节点比较</p>\n<h2> 二、比较方式</h2>\n<p><code>diff</code>整体策略为：深度优先，同层比较</p>\n<ol>\n<li>比较只会在同层级进行, 不会跨层级比较</li>\n</ol>\n<img src=\"https://static001.infoq.cn/resource/image/91/54/91e9c9519a11caa0c5bf70714383f054.png\" alt=\"img\" style=\"zoom:50%;\">\n<ol start=\"2\">\n<li>比较的过程中，循环从两边向中间收拢</li>\n</ol>\n<img src=\"https://static001.infoq.cn/resource/image/2d/ec/2dcd6ad5cf82c65b9cfc43a27ba1e4ec.png\" alt=\"img\" style=\"zoom:50%;\">\n<p>下面举个<code>vue</code>通过<code>diff</code>算法更新的例子：</p>\n<p>新旧<code>VNode</code>节点如下图所示：</p>\n<figure><img src=\"https://static001.infoq.cn/resource/image/80/6d/80dc339f73b186479e6d1fc18bfbf66d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>第一次循环后，发现旧节点 D 与新节点 D 相同，直接复用旧节点 D 作为<code>diff</code>后的第一个真实节点，同时旧节点<code>endIndex</code>移动到 C，新节点的 <code>startIndex</code> 移动到了 C</p>\n<figure><img src=\"https://static001.infoq.cn/resource/image/76/54/76032c78c8ef74047efd42c070e48854.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，<code>diff</code> 后创建了 C 的真实节点插入到第一次创建的 D 节点后面。同时旧节点的 <code>endIndex</code> 移动到了 B，新节点的 <code>startIndex</code> 移动到了 E</p>\n<figure><img src=\"https://static001.infoq.cn/resource/image/1c/d7/1c76e7489660188d35f0a38ea8c8ecd7.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>第三次循环中，发现 E 没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 <code>startIndex</code> 移动到了 A。旧节点的 <code>startIndex</code> 和 <code>endIndex</code> 都保持不动</p>\n<figure><img src=\"https://static001.infoq.cn/resource/image/4b/08/4b622c0d61673ec5474465d82305d308.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 <code>diff</code> 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 <code>startIndex</code> 移动到了 B，新节点的<code>startIndex</code> 移动到了 B</p>\n<figure><img src=\"https://static001.infoq.cn/resource/image/59/b4/5982417c3e0b2fa9ae940354a0e67ab4.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>第五次循环中，情形同第四次循环一样，因此 <code>diff</code> 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 <code>startIndex</code>移动到了 C，新节点的 startIndex 移动到了 F</p>\n<figure><img src=\"https://static001.infoq.cn/resource/image/16/86/16cf0ef90f6e19d26c0ddffeca067e86.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>新节点的 <code>startIndex</code> 已经大于 <code>endIndex</code> 了，需要创建 <code>newStartIdx</code> 和 <code>newEndIdx</code> 之间的所有节点，也就是节点 F，直接创建 F 节点对应的真实节点放到 B 节点后面</p>\n<figure><img src=\"https://static001.infoq.cn/resource/image/dc/ad/dc215b45682cf6c9cc4700a5425673ad.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、原理分析</h2>\n<p>当数据发生改变时，<code>set</code>方法会调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，订阅者就会调用<code>patch</code>给真实的<code>DOM</code>打补丁，更新相应的视图</p>\n<p>源码位置：src/core/vdom/patch.js</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>patch</code>函数前两个参数位为<code>oldVnode</code> 和 <code>Vnode</code> ，分别代表新的节点和之前的旧节点，主要做了四个判断：</p>\n<ul>\n<li>没有新节点，直接触发旧节点的<code>destory</code>钩子</li>\n<li>没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 <code>createElm</code></li>\n<li>旧节点和新节点自身一样，通过 <code>sameVnode</code> 判断节点是否一样，一样时，直接调用 <code>patchVnode</code>去处理这两个节点</li>\n<li>旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点</li>\n</ul>\n<p>下面主要讲的是<code>patchVnode</code>部分</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>patchVnode</code>主要做了几个判断：</p>\n<ul>\n<li>新节点是否是文本节点，如果是，则直接更新<code>dom</code>的文本内容为新节点的文本内容</li>\n<li>新节点和旧节点如果都有子节点，则处理比较更新子节点</li>\n<li>只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新<code>DOM</code>，并且添加进父节点</li>\n<li>只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把<code>DOM</code> 删除</li>\n</ul>\n<p>子节点不完全一致，则调用<code>updateChildren</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>while</code>循环主要处理了以下五种情景：</p>\n<ul>\n<li>当新老 <code>VNode</code> 节点的 <code>start</code> 相同时，直接 <code>patchVnode</code> ，同时新老 <code>VNode</code> 节点的开始索引都加 1</li>\n<li>当新老 <code>VNode</code> 节点的 <code>end</code>相同时，同样直接 <code>patchVnode</code> ，同时新老 <code>VNode</code> 节点的结束索引都减 1</li>\n<li>当老 <code>VNode</code> 节点的 <code>start</code> 和新 <code>VNode</code> 节点的 <code>end</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldEndVnode</code> 的后面，同时老 <code>VNode</code> 节点开始索引加 1，新 <code>VNode</code> 节点的结束索引减 1</li>\n<li>当老 <code>VNode</code> 节点的 <code>end</code> 和新 <code>VNode</code> 节点的 <code>start</code> 相同时，这时候在 <code>patchVnode</code> 后，还需要将当前真实 <code>dom</code> 节点移动到 <code>oldStartVnode</code> 的前面，同时老 <code>VNode</code> 节点结束索引减 1，新 <code>VNode</code> 节点的开始索引加 1</li>\n<li>如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：\n<ul>\n<li>从旧的 <code>VNode</code> 为 <code>key</code> 值，对应 <code>index</code> 序列为 <code>value</code> 值的哈希表中找到与 <code>newStartVnode</code> 一致 <code>key</code> 的旧的 <code>VNode</code> 节点，再进行<code>patchVnode</code>，同时将这个真实 <code>dom</code>移动到 <code>oldStartVnode</code> 对应的真实 <code>dom</code> 的前面</li>\n<li>调用 <code>createElm</code> 创建一个新的 <code>dom</code> 节点放到当前 <code>newStartIdx</code> 的位置</li>\n</ul>\n</li>\n</ul>\n<h3> 小结</h3>\n<ul>\n<li>当数据发生改变时，订阅者<code>watcher</code>就会调用<code>patch</code>给真实的<code>DOM</code>打补丁</li>\n<li>通过<code>isSameVnode</code>进行判断，相同则调用<code>patchVnode</code>方法</li>\n<li><code>patchVnode</code>做了以下操作：\n<ul>\n<li>找到对应的真实<code>dom</code>，称为<code>el</code></li>\n<li>如果都有都有文本节点且不相等，将<code>el</code>文本节点设置为<code>Vnode</code>的文本节点</li>\n<li>如果<code>oldVnode</code>有子节点而<code>VNode</code>没有，则删除<code>el</code>子节点</li>\n<li>如果<code>oldVnode</code>没有子节点而<code>VNode</code>有，则将<code>VNode</code>的子节点真实化后添加到<code>el</code></li>\n<li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点</li>\n</ul>\n</li>\n<li><code>updateChildren</code>主要做了以下操作：\n<ul>\n<li>设置新旧<code>VNode</code>的头尾指针</li>\n<li>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用<code>patchVnode</code>进行<code>patch</code>重复流程、调用<code>createElem</code>创建一个新节点，从哈希表寻找 <code>key</code>一致的<code>VNode</code> 节点再分情况操作</li>\n</ul>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6881907432541552648#heading-1\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6881907432541552648#heading-1</a></li>\n<li><a href=\"https://www.infoq.cn/article/udlcpkh4iqb0cr5wgy7f\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.infoq.cn/article/udlcpkh4iqb0cr5wgy7f</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-26T20:08:28.602Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "你有写过自定义指令吗？自定义指令的应用场景有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/vue/directive.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/directive.html",
      "summary": "前端物语|面试物语-你有写过自定义指令吗？自定义指令的应用场景有哪些？",
      "content_html": "<h1> 你有写过自定义指令吗？自定义指令的应用场景有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bd85a970-4345-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、什么是指令</h2>\n<p>开始之前我们先学习一下指令系统这个词</p>\n<p><strong>指令系统</strong>是计算机硬件的语言系统，也叫机器语言，它是系统程序员看到的计算机的主要属性。因此指令系统表征了计算机的基本功能决定了机器所要求的能力</p>\n<p>在<code>vue</code>中提供了一套为数据驱动视图更为方便的操作，这些操作被称为指令系统</p>\n<p>我们看到的<code>v-</code>开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能</p>\n<p>除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，<code>Vue</code> 也允许注册自定义指令</p>\n<p>指令使用的几种方式：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 二、如何实现</h3>\n<p>注册一个自定义指令有全局注册与局部注册</p>\n<p>全局注册主要是通过<code>Vue.directive</code>方法进行注册</p>\n<p><code>Vue.directive</code>第一个参数是指令的名字（不需要写上<code>v-</code>前缀），第二个参数可以是对象数据，也可以是一个指令函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>局部注册通过在组件<code>options</code>选项中设置<code>directive</code>属性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> property，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>自定义指令也像组件那样存在钩子函数：</p>\n<ul>\n<li>\n<p><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置</p>\n</li>\n<li>\n<p><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)</p>\n</li>\n<li>\n<p><code>update</code>：所在组件的 <code>VNode</code> 更新时调用，但是可能发生在其子 <code>VNode</code> 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新</p>\n</li>\n<li>\n<p><code>componentUpdated</code>：指令所在组件的 <code>VNode</code> 及其子 <code>VNode</code> 全部更新后调用</p>\n</li>\n<li>\n<p><code>unbind</code>：只调用一次，指令与元素解绑时调用</p>\n</li>\n</ul>\n<p>所有的钩子函数的参数都有以下：</p>\n<ul>\n<li><code>el</code>：指令所绑定的元素，可以用来直接操作 <code>DOM</code></li>\n<li><code>binding</code>：一个对象，包含以下 <code>property</code>：\n<ul>\n<li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li>\n<li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=\"1 + 1\"</code> 中，绑定值为 <code>2</code>。</li>\n<li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>\n<li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=\"1 + 1\"</code> 中，表达式为 <code>\"1 + 1\"</code>。</li>\n<li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>\"foo\"</code>。</li>\n<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code></li>\n</ul>\n</li>\n<li><code>vnode</code>：<code>Vue</code> 编译生成的虚拟节点</li>\n<li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用</li>\n</ul>\n<blockquote>\n<p>除了 <code>el</code> 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 <code>dataset</code> 来进行</p>\n</blockquote>\n<p>举个例子：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、应用场景</h2>\n<p>使用自定义指令可以满足我们日常一些场景，这里给出几个自定义指令的案例：</p>\n<ul>\n<li>表单防止重复提交</li>\n<li>图片懒加载</li>\n<li>一键 Copy 的功能</li>\n</ul>\n<h3> 表单防止重复提交</h3>\n<p>表单防止重复提交这种情况设置一个<code>v-throttle</code>自定义指令来实现</p>\n<p>举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 图片懒加载</h3>\n<p>设置一个<code>v-lazy</code>自定义指令完成图片懒加载</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 一键 Copy 的功能</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于自定义指令还有很多应用场景，如：拖拽指令、页面水印、权限校验等等应用场景</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://vue3js.cn/docs/zh\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn/docs/zh</a></li>\n<li><a href=\"https://juejin.cn/post/6844904197448531975#heading-5\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904197448531975#heading-5</a></li>\n<li><a href=\"https://www.cnblogs.com/chenwenhao/p/11924161.html#_label2\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/chenwenhao/p/11924161.html#_label2</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-17T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "你是怎么处理 vue 项目中的错误的？",
      "url": "https://www.h7ml.cn/posts/interview/vue/error.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/error.html",
      "summary": "前端物语|面试物语-你是怎么处理 vue 项目中的错误的？",
      "content_html": "<h1> 你是怎么处理 vue 项目中的错误的？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3cafe4f0-4fd9-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、错误类型</h2>\n<p>任何一个框架，对于错误的处理都是一种必备的能力</p>\n<p>在<code>Vue</code> 中，则是定义了一套对应的错误处理规则给到使用者，且在源代码级别，对部分必要的过程做了一定的错误处理。</p>\n<p>主要的错误来源包括：</p>\n<ul>\n<li>后端接口错误</li>\n<li>代码中本身逻辑错误</li>\n</ul>\n<h2> 二、如何处理</h2>\n<h3> 后端接口错误</h3>\n<p>通过<code>axios</code>的<code>interceptor</code>实现网络请求的<code>response</code>先进行一层拦截</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 代码逻辑问题</h3>\n<h4> 全局设置错误处理</h4>\n<p>设置全局错误处理函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>errorHandler</code>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 <code>Vue</code> 实例</p>\n<p>不过值得注意的是，在不同<code>Vue</code> 版本中，该全局 <code>API</code> 作用的范围会有所不同：</p>\n<blockquote>\n<p>从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 <code>undefined</code> 时，被捕获的错误会通过 <code>console.error</code> 输出而避免应用崩</p>\n</blockquote>\n<blockquote>\n<p>从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了</p>\n</blockquote>\n<blockquote>\n<p>从 2.6.0 起，这个钩子也会捕获 <code>v-on</code> DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理</p>\n</blockquote>\n<h4> 生命周期钩子</h4>\n<p><code>errorCaptured</code>是 2.5.0 新增的一个生命钩子函数，当捕获到一个来自子孙组件的错误时被调用</p>\n<p>基本类型</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播</p>\n<p>参考官网，错误传播规则如下：</p>\n<ul>\n<li>默认情况下，如果全局的 <code>config.errorHandler</code> 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报</li>\n<li>如果一个组件的继承或父级从属链路中存在多个 <code>errorCaptured</code> 钩子，则它们将会被相同的错误逐个唤起。</li>\n<li>如果此 <code>errorCaptured</code> 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 <code>config.errorHandler</code></li>\n<li>一个 <code>errorCaptured</code> 钩子能够返回 <code>false</code> 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 <code>errorCaptured</code> 钩子和全局的 <code>config.errorHandler</code></li>\n</ul>\n<p>下面来看个例子</p>\n<p>定义一个父组件<code>cat</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定义一个子组件<code>kitten</code>，其中<code>dontexist()</code>并没有定义，存在错误</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>页面中使用组件</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在父组件的<code>errorCaptured</code>则能够捕获到信息</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 三、源码分析</h3>\n<p>异常处理源码</p>\n<p>源码位置：/src/core/util/error.js</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 小结</h3>\n<ul>\n<li><code>handleError</code>在需要捕获异常的地方调用，首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用<code>errorCaptured</code> 方法，在遍历调用完所有 <code>errorCaptured</code> 方法或 <code>errorCaptured</code> 方法有报错时，调用 <code>globalHandleError</code> 方法</li>\n<li><code>globalHandleError</code>调用全局的 <code>errorHandler</code> 方法，再通过<code>logError</code>判断环境输出错误信息</li>\n<li><code>invokeWithErrorHandling</code>更好的处理异步错误信息</li>\n<li><code>logError</code>判断环境，选择不同的抛错方式。非生产环境下，调用<code>warn</code>方法处理错误</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li>\n<p><a href=\"https://juejin.cn/post/6844904096936230925\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904096936230925</a></p>\n</li>\n<li>\n<p><a href=\"https://segmentfault.com/a/1190000018606181\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000018606181</a></p>\n</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-05T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "Vue 中的过滤器了解吗？过滤器的应用场景有哪些？",
      "url": "https://www.h7ml.cn/posts/interview/vue/filter.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/filter.html",
      "summary": "前端物语|面试物语-Vue 中的过滤器了解吗？过滤器的应用场景有哪些？",
      "content_html": "<h1> Vue 中的过滤器了解吗？过滤器的应用场景有哪些？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fe68eea0-440f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>过滤器（<code>filter</code>）是输送介质管道上不可缺少的一种装置</p>\n<p>大白话，就是把一些不必要的东西过滤掉</p>\n<p>过滤器实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理，我们也可以理解其为一个纯函数</p>\n<p><code>Vue</code> 允许你自定义过滤器，可被用于一些常见的文本格式化</p>\n<p>ps: <code>Vue3</code>中已废弃<code>filter</code></p>\n<h2> 二、如何用</h2>\n<p><code>vue</code>中的过滤器可以用在两个地方：双花括号插值和 <code>v-bind</code> 表达式，过滤器应该被添加在 <code>JavaScript</code>表达式的尾部，由“管道”符号指示：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 定义 filter</h3>\n<p>在组件的选项中定义本地的过滤器</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定义全局过滤器：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：当全局过滤器和局部过滤器重名时，会采用局部过滤器</p>\n<p>过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，<code>capitalize</code> 过滤器函数将会收到 <code>message</code> 的值作为第一个参数</p>\n<p>过滤器可以串联：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在这个例子中，<code>filterA</code> 被定义为接收单个参数的过滤器函数，表达式 <code>message</code> 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 <code>filterB</code>，将 <code>filterA</code> 的结果传递到 <code>filterB</code> 中。</p>\n<p>过滤器是 <code>JavaScript</code>函数，因此可以接收参数：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这里，<code>filterA</code> 被定义为接收三个参数的过滤器函数。</p>\n<p>其中 <code>message</code> 的值作为第一个参数，普通字符串 <code>'arg1'</code> 作为第二个参数，表达式 <code>arg2</code> 的值作为第三个参数</p>\n<p>举个例子：</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 小结</h3>\n<ul>\n<li>部过滤器优先于全局过滤器被调用</li>\n<li>一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右</li>\n</ul>\n<h2> 三、应用场景</h2>\n<p>平时开发中，需要用到过滤器的地方有很多，比如单位转换、数字打点、文本格式化、时间格式化之类的等</p>\n<p>比如我们要实现将 30000 =&gt; 30,000，这时候我们就需要使用过滤器</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 四、原理分析</h2>\n<p>使用过滤器</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在模板编译阶段过滤器表达式将会被编译为过滤器函数，主要是用过<code>parseFilters</code>，我们放到最后讲</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>首先分析一下<code>_f</code>：</p>\n<p>_f 函数全名是：<code>resolveFilter</code>，这个函数的作用是从<code>this.$options.filters</code>中找出注册的过滤器并返回</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于<code>resolveFilter</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>内部直接调用<code>resolveAsset</code>，将<code>option</code>对象，类型，过滤器<code>id</code>，以及一个触发警告的标志作为参数传递，如果找到，则返回过滤器；</p>\n<p><code>resolveAsset</code>的代码如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面再来分析一下<code>_s</code>：</p>\n<p><code>_s</code> 函数的全称是 <code>toString</code>,过滤器处理后的结果会当作参数传递给 <code>toString</code>函数，最终 <code>toString</code>函数执行后的结果会保存到<code>Vnode</code>中的 text 属性中，渲染到视图中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最后，在分析下<code>parseFilters</code>，在模板编译阶段使用该函数阶段将模板过滤器解析为过滤器函数调用表达式</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 小结</h3>\n<ul>\n<li>在编译阶段通过<code>parseFilters</code>将过滤器编译成函数调用（串联过滤器则是一个嵌套的函数调用，前一个过滤器执行的结果是后一个过滤器函数的参数）</li>\n<li>编译后通过调用<code>resolveFilter</code>函数找到对应过滤器并返回结果</li>\n<li>执行结果作为参数传递给<code>toString</code>函数，而<code>toString</code>执行后，其结果会保存在<code>Vnode</code>的<code>text</code>属性中，渲染到视图</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://cn.vuejs.org/v2/guide/filters.html#ad\" target=\"_blank\" rel=\"noopener noreferrer\">https://cn.vuejs.org/v2/guide/filters.html#ad</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_42724176/article/details/105546684\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/weixin_42724176/article/details/105546684</a></li>\n<li><a href=\"https://vue3js.cn\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-12T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "SPA 首屏加载速度慢的怎么解决？",
      "url": "https://www.h7ml.cn/posts/interview/vue/first_page_time.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/first_page_time.html",
      "summary": "前端物语|面试物语-SPA首屏加载速度慢的怎么解决？",
      "content_html": "<h1> SPA 首屏加载速度慢的怎么解决？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/24617c00-3acc-11eb-ab90-d9ae814b240d.png\" alt=\"image.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>image.png</figcaption></figure>\n<h2> 一、什么是首屏加载</h2>\n<p>首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容</p>\n<p>首屏加载可以说是用户体验中<strong>最重要</strong>的环节</p>\n<h3> 关于计算首屏时间</h3>\n<p>利用<code>performance.timing</code>提供的数据：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2e2491a0-3acc-11eb-85f6-6fac77c0c9b3.png\" alt=\"image.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>image.png</figcaption></figure>\n<p>通过<code>DOMContentLoad</code>或者<code>performance</code>来计算出首屏时间</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、加载慢的原因</h2>\n<p>在页面渲染的过程，导致加载速度慢的因素可能如下：</p>\n<ul>\n<li>网络延时问题</li>\n<li>资源文件体积是否过大</li>\n<li>资源是否重复发送请求去加载了</li>\n<li>加载脚本的时候，渲染内容堵塞了</li>\n</ul>\n<h2> 三、解决方案</h2>\n<p>常见的几种 SPA 首屏优化方式</p>\n<ul>\n<li>减小入口文件积</li>\n<li>静态资源本地缓存</li>\n<li>UI 框架按需加载</li>\n<li>图片资源的压缩</li>\n<li>组件重复打包</li>\n<li>开启 GZip 压缩</li>\n<li>使用 SSR</li>\n</ul>\n<h3> 减小入口文件体积</h3>\n<p>常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/486cee90-3acc-11eb-ab90-d9ae814b240d.png\" alt=\"image.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>image.png</figcaption></figure>\n<p>在<code>vue-router</code>配置路由的时候，采用动态加载路由的形式</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件</p>\n<h3> 静态资源本地缓存</h3>\n<p>后端返回资源问题：</p>\n<ul>\n<li>\n<p>采用<code>HTTP</code>缓存，设置<code>Cache-Control</code>，<code>Last-Modified</code>，<code>Etag</code>等响应头</p>\n</li>\n<li>\n<p>采用<code>Service Worker</code>离线缓存</p>\n</li>\n</ul>\n<p>前端合理利用<code>localStorage</code></p>\n<h3> UI 框架按需加载</h3>\n<p>在日常使用<code>UI</code>框架，例如<code>element-UI</code>、或者<code>antd</code>，我们经常性直接引用整个<code>UI</code>库</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 组件重复打包</h3>\n<p>假设<code>A.js</code>文件是一个常用的库，现在有多个路由使用了<code>A.js</code>文件，这就造成了重复下载</p>\n<p>解决方案：在<code>webpack</code>的<code>config</code>文件中，修改<code>CommonsChunkPlugin</code>的配置</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>minChunks</code>为 3 表示会把使用 3 次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件</p>\n<h3> 图片资源的压缩</h3>\n<p>图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素</p>\n<p>对于所有的图片资源，我们可以进行适当的压缩</p>\n<p>对页面上使用到的<code>icon</code>，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻<code>http</code>请求压力。</p>\n<h3> 开启 GZip 压缩</h3>\n<p>拆完包之后，我们再用<code>gzip</code>做一下压缩 安装<code>compression-webpack-plugin</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在<code>vue.congig.js</code>中引入并修改<code>webpack</code>配置</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在服务器我们也要做相应的配置 如果发送请求的浏览器支持<code>gzip</code>，就发送给它<code>gzip</code>格式的文件 我的服务器是用<code>express</code>框架搭建的 只要安装一下<code>compression</code>就能使用</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 使用 SSR</h3>\n<p>SSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成 html 字符串，再发送到浏览器</p>\n<p>从头搭建一个服务端渲染是很复杂的，<code>vue</code>应用建议使用<code>Nuxt.js</code>实现服务端渲染</p>\n<h3> 小结</h3>\n<p>减少首屏渲染时间的方法有很多，总的来讲可以分成两大部分 ：资源加载优化 和 页面渲染优化</p>\n<p>下图是更为全面的首屏优化的方案</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/4fafe900-3acc-11eb-85f6-6fac77c0c9b3.png\" alt=\"image.png\" tabindex=\"0\" loading=\"lazy\"><figcaption>image.png</figcaption></figure>\n<p>大家可以根据自己项目的情况选择各种方式进行首屏渲染的优化</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/88639980?utm_source=wechat_session\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/88639980?utm_source=wechat_session</a></li>\n<li><a href=\"https://www.chengrang.com/how-browsers-work.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.chengrang.com/how-browsers-work.html</a></li>\n<li><a href=\"https://juejin.cn/post/6844904185264095246\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904185264095246</a></li>\n<li><a href=\"https://vue3js.cn/docs/zh\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn/docs/zh</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "v-if 和 v-for 的优先级是什么？",
      "url": "https://www.h7ml.cn/posts/interview/vue/if_for.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/if_for.html",
      "summary": "前端物语|面试物语-v-if 和 v-for 的优先级是什么？",
      "content_html": "<h1> v-if 和 v-for 的优先级是什么？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e8764810-3acb-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、作用</h2>\n<p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 <code>true</code>值的时候被渲染</p>\n<p><code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组或者对象，而 <code>item</code> 则是被迭代的数组元素的别名</p>\n<p>在 <code>v-for</code> 的时候，建议设置<code>key</code>值，并且保证每个<code>key</code>值是独一无二的，这便于<code>diff</code>算法进行优化</p>\n<p>两者在用法上</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、优先级</h2>\n<p><code>v-if</code>与<code>v-for</code>都是<code>vue</code>模板系统中的指令</p>\n<p>在<code>vue</code>模板编译的时候，会将指令系统转化成可执行的<code>render</code>函数</p>\n<h3> 示例</h3>\n<p>编写一个<code>p</code>标签，同时使用<code>v-if</code>与 <code>v-for</code></p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建<code>vue</code>实例，存放<code>isShow</code>与<code>items</code>数据</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>模板指令的代码都会生成在<code>render</code>函数中，通过<code>app.$options.render</code>就能得到渲染函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>_l</code>是<code>vue</code>的列表渲染函数，函数内部都会进行一次<code>if</code>判断</p>\n<p>初步得到结论：<code>v-for</code>优先级是比<code>v-if</code>高</p>\n<p>再将<code>v-for</code>与<code>v-if</code>置于不同标签</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再输出下<code>render</code>函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这时候我们可以看到，<code>v-for</code>与<code>v-if</code>作用在不同标签时候，是先进行判断，再进行列表的渲染</p>\n<p>我们再在查看下<code>vue</code>源码</p>\n<p>源码位置：<code>\\vue-dev\\src\\compiler\\codegen\\index.js</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在进行<code>if</code>判断的时候，<code>v-for</code>是比<code>v-if</code>先进行判断</p>\n<p>最终结论：<code>v-for</code>优先级比<code>v-if</code>高</p>\n<h2> 三、注意事项</h2>\n<ol>\n<li>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</li>\n<li>如果避免出现这种情况，则在外层嵌套<code>template</code>（页面渲染不生成<code>dom</code>节点），在这一层进行 v-if 判断，然后在内部进行 v-for 循环</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"3\">\n<li>如果条件出现在循环内部，可通过计算属性<code>computed</code>提前过滤掉那些不需要显示的项</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-10T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "说说你对 keep-alive 的理解是什么？",
      "url": "https://www.h7ml.cn/posts/interview/vue/keepalive.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/keepalive.html",
      "summary": "前端物语|面试物语-说说你对 keep-alive 的理解是什么？",
      "content_html": "<h1> 说说你对 keep-alive 的理解是什么？</h1>\n<figure><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9nSDMxdUY5VklpYlRaSXdpY3ZmUkR3STRiamRBVGlhVEpFZDNzamRoeTd3MDlVM0k5ZERjNUVVSUNFVk1WSVE2aDFYMjVpY1NRT3lraWFwWEpEUFM0VGJST0l3LzY0MA?x-oss-process=image/format,png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、Keep-alive 是什么</h2>\n<p><code>keep-alive</code>是<code>vue</code>中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染<code>DOM</code></p>\n<p><code>keep-alive</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们</p>\n<p><code>keep-alive</code>可以设置以下<code>props</code>属性：</p>\n<ul>\n<li>\n<p><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存</p>\n</li>\n<li>\n<p><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存</p>\n</li>\n<li>\n<p><code>max</code> - 数字。最多可以缓存多少组件实例</p>\n</li>\n</ul>\n<p>关于<code>keep-alive</code>的基本用法：</p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用<code>includes</code>和<code>exclude</code>：</p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>匹配首先检查组件自身的 <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的局部注册名称 (父组件 <code>components</code> 选项的键值)，匿名组件不能被匹配</p>\n<p>设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（<code>activated</code>与<code>deactivated</code>）：</p>\n<ul>\n<li>\n<p>首次进入组件时：<code>beforeRouteEnter</code> &gt; <code>beforeCreate</code> &gt; <code>created</code>&gt; <code>mounted</code> &gt; <code>activated</code> &gt; ... ... &gt; <code>beforeRouteLeave</code> &gt; <code>deactivated</code></p>\n</li>\n<li>\n<p>再次进入组件时：<code>beforeRouteEnter</code> &gt;<code>activated</code> &gt; ... ... &gt; <code>beforeRouteLeave</code> &gt; <code>deactivated</code></p>\n</li>\n</ul>\n<h2> 二、使用场景</h2>\n<p>使用原则：当我们在某些场景下不需要让页面重新加载时我们可以使用<code>keepalive</code></p>\n<p>举个栗子:</p>\n<p>当我们从<code>首页</code>–&gt;<code>列表页</code>–&gt;<code>商详页</code>–&gt;<code>再返回</code>，这时候列表页应该是需要<code>keep-alive</code></p>\n<p>从<code>首页</code>–&gt;<code>列表页</code>–&gt;<code>商详页</code>–&gt;<code>返回到列表页(需要缓存)</code>–&gt;<code>返回到首页(需要缓存)</code>–&gt;<code>再次进入列表页(不需要缓存)</code>，这时候可以按需来控制页面的<code>keep-alive</code></p>\n<p>在路由中设置<code>keepAlive</code>属性判断是否需要缓存</p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用<code>&lt;keep-alive&gt;</code></p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、原理分析</h2>\n<p><code>keep-alive</code>是<code>vue</code>中内置的一个组件</p>\n<p>源码位置：src/core/components/keep-alive.js</p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到该组件没有<code>template</code>，而是用了<code>render</code>，在组件渲染的时候会自动执行<code>render</code>函数</p>\n<p><code>this.cache</code>是一个对象，用来存储需要缓存的组件，它将以如下形式存储：</p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在组件销毁的时候执行<code>pruneCacheEntry</code>函数</p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在<code>mounted</code>钩子函数中观测 <code>include</code> 和 <code>exclude</code> 的变化，如下：</p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果<code>include</code> 或<code>exclude</code> 发生了变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行<code>pruneCache</code>函数，函数如下：</p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在该函数内对<code>this.cache</code>对象进行遍历，取出每一项的<code>name</code>值，用其与新的缓存规则进行匹配，如果匹配不上，则表示在新的缓存规则下该组件已经不需要被缓存，则调用<code>pruneCacheEntry</code>函数将其从<code>this.cache</code>对象剔除即可</p>\n<p>关于<code>keep-alive</code>的最强大缓存功能是在<code>render</code>函数中实现</p>\n<p>首先获取组件的<code>key</code>值：</p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>拿到<code>key</code>值后去<code>this.cache</code>对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存，如下：</p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>直接从缓存中拿 <code>vnode</code> 的组件实例，此时重新调整该组件<code>key</code>的顺序，将其从原来的地方删掉并重新放在<code>this.keys</code>中最后一个</p>\n<p><code>this.cache</code>对象中没有该<code>key</code>值的情况，如下：</p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>表明该组件还没有被缓存过，则以该组件的<code>key</code>为键，组件<code>vnode</code>为值，将其存入<code>this.cache</code>中，并且把<code>key</code>存入<code>this.keys</code>中</p>\n<p>此时再判断<code>this.keys</code>中缓存组件的数量是否超过了设置的最大缓存数量值<code>this.max</code>，如果超过了，则把第一个缓存组件删掉</p>\n<h2> 四、思考题：缓存后如何获取数据</h2>\n<p>解决方案可以有以下两种：</p>\n<ul>\n<li>\n<p>beforeRouteEnter</p>\n</li>\n<li>\n<p>actived</p>\n</li>\n</ul>\n<h3> beforeRouteEnter</h3>\n<p>每次组件渲染的时候，都会执行<code>beforeRouteEnter</code></p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> actived</h3>\n<p>在<code>keep-alive</code>缓存的组件被激活的时候，都会执行<code>actived</code>钩子</p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：服务器端渲染期间<code>avtived</code>不被调用</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.cnblogs.com/dhui/p/13589401.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/dhui/p/13589401.html</a></li>\n<li><a href=\"https://www.cnblogs.com/wangjiachen666/p/11497200.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/wangjiachen666/p/11497200.html</a></li>\n<li><a href=\"https://vue3js.cn/docs/zh\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn/docs/zh</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-13T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "你知道 vue 中 key 的原理吗？说说你对它的理解",
      "url": "https://www.h7ml.cn/posts/interview/vue/key.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/key.html",
      "summary": "前端物语|面试物语-你知道 vue 中 key 的原理吗？说说你对它的理解",
      "content_html": "<h1> 你知道 vue 中 key 的原理吗？说说你对它的理解</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bc6e9540-3f41-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、Key 是什么</h2>\n<p>开始之前，我们先还原两个实际工作场景</p>\n<ol>\n<li>当我们在使用<code>v-for</code>时，需要给单元加上<code>key</code></li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol start=\"2\">\n<li>用<code>+new Date()</code>生成的时间戳作为<code>key</code>，手动强制触发重新渲染</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>那么这背后的逻辑是什么，<code>key</code>的作用又是什么？</p>\n<p>一句话来讲</p>\n<blockquote>\n<p>key 是给每一个 vnode 的唯一 id，也是 diff 的一种优化策略，可以根据 key，更准确， 更快的找到对应的 vnode 节点</p>\n</blockquote>\n<h3> 场景背后的逻辑</h3>\n<p>当我们在使用<code>v-for</code>时，需要给单元加上<code>key</code></p>\n<ul>\n<li>\n<p>如果不用 key，Vue 会采用就地复地原则：最小化 element 的移动，并且会尝试尽最大程度在同适当的地方对相同类型的 element，做 patch 或者 reuse。</p>\n</li>\n<li>\n<p>如果使用了 key，Vue 会根据 keys 的顺序记录 element，曾经拥有了 key 的 element 如果不再出现的话，会被直接 remove 或者 destoryed</p>\n</li>\n</ul>\n<p>用<code>+new Date()</code>生成的时间戳作为<code>key</code>，手动强制触发重新渲染</p>\n<ul>\n<li>当拥有新值的 rerender 作为 key 时，拥有了新 key 的 Comp 出现了，那么旧 key Comp 会被移除，新 key Comp 触发渲染</li>\n</ul>\n<h2> 二、设置 key 与不设置 key 区别</h2>\n<p>举个例子：</p>\n<p>创建一个实例，2 秒后往<code>items</code>数组插入数据</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在不使用<code>key</code>的情况，<code>vue</code>会进行这样的操作：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c9da6790-3f41-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>分析下整体流程：</p>\n<ul>\n<li>比较 A，A，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li>\n<li>比较 B，B，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li>\n<li>比较 C，F，相同类型的节点，进行<code>patch</code>，数据不同，发生<code>dom</code>操作</li>\n<li>比较 D，C，相同类型的节点，进行<code>patch</code>，数据不同，发生<code>dom</code>操作</li>\n<li>比较 E，D，相同类型的节点，进行<code>patch</code>，数据不同，发生<code>dom</code>操作</li>\n<li>循环结束，将 E 插入到<code>DOM</code>中</li>\n</ul>\n<p>一共发生了 3 次更新，1 次插入操作</p>\n<p>在使用<code>key</code>的情况：<code>vue</code>会进行这样的操作：</p>\n<ul>\n<li>比较 A，A，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li>\n<li>比较 B，B，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li>\n<li>比较 C，F，不相同类型的节点\n<ul>\n<li>比较 E、E，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li>\n</ul>\n</li>\n<li>比较 D、D，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li>\n<li>比较 C、C，相同类型的节点，进行<code>patch</code>，但数据相同，不发生<code>dom</code>操作</li>\n<li>循环结束，将 F 插入到 C 之前</li>\n</ul>\n<p>一共发生了 0 次更新，1 次插入操作</p>\n<p>通过上面两个小例子，可见设置<code>key</code>能够大大减少对页面的<code>DOM</code>操作，提高了<code>diff</code>效率</p>\n<h3> 设置 key 值一定能提高 diff 效率吗？</h3>\n<p>其实不然，文档中也明确表示</p>\n<blockquote>\n<p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素</p>\n</blockquote>\n<p>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</p>\n<p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code>，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升</p>\n<h2> 三、原理分析</h2>\n<p>源码位置：core/vdom/patch.js</p>\n<p>这里判断是否为同一个<code>key</code>，首先判断的是<code>key</code>值是否相等如果没有设置<code>key</code>，那么<code>key</code>为<code>undefined</code>，这时候<code>undefined</code>是恒等于<code>undefined</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>updateChildren</code>方法中会对新旧<code>vnode</code>进行<code>diff</code>，然后将比对出的结果用来更新真实的<code>DOM</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844903826693029895\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903826693029895</a></li>\n<li><a href=\"https://juejin.cn/post/6844903985397104648\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903985397104648</a></li>\n<li><a href=\"https://vue3js.cn/docs/zh\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn/docs/zh</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-16T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？",
      "url": "https://www.h7ml.cn/posts/interview/vue/lifecycle.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/lifecycle.html",
      "summary": "前端物语|面试物语-请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？",
      "content_html": "<h1> 请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3a119e10-3aca-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、生命周期是什么</h2>\n<p>生命周期<code>（Life Cycle）</code>的概念应用很广泛，特别是在政治、经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”<code>（Cradle-to-Grave）</code>的整个过程在<code>Vue</code>中实例从创建到销毁的过程就是生命周期，即指从创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、卸载等一系列过程我们可以把组件比喻成工厂里面的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始工作 PS：在<code>Vue</code>生命周期钩子会自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对 <code>property</code> 和方法进行运算这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)</p>\n<h2> 二、生命周期有哪些</h2>\n<p>Vue 生命周期总共可以分为 8 个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">生命周期</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">beforeCreate</td>\n<td style=\"text-align:left\">组件实例被创建之初</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">created</td>\n<td style=\"text-align:left\">组件实例已经完全创建</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">beforeMount</td>\n<td style=\"text-align:left\">组件挂载之前</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">mounted</td>\n<td style=\"text-align:left\">组件挂载到实例上去之后</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">beforeUpdate</td>\n<td style=\"text-align:left\">组件数据发生变化，更新之前</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">updated</td>\n<td style=\"text-align:left\">组件数据更新之后</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">beforeDestroy</td>\n<td style=\"text-align:left\">组件实例销毁之前</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">destroyed</td>\n<td style=\"text-align:left\">组件实例销毁之后</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">activated</td>\n<td style=\"text-align:left\">keep-alive 缓存的组件激活时</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">deactivated</td>\n<td style=\"text-align:left\">keep-alive 缓存的组件停用时调用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">errorCaptured</td>\n<td style=\"text-align:left\">捕获一个来自子孙组件的错误时被调用</td>\n</tr>\n</tbody>\n</table>\n<h2> 三、生命周期整体流程</h2>\n<p><code>Vue</code>生命周期流程图</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/44114780-3aca-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h4> 具体分析</h4>\n<p><strong>beforeCreate -&gt; created</strong></p>\n<ul>\n<li>初始化<code>vue</code>实例，进行数据观测</li>\n</ul>\n<p><strong>created</strong></p>\n<ul>\n<li>完成数据观测，属性与方法的运算，<code>watch</code>、<code>event</code>事件回调的配置</li>\n<li>可调用<code>methods</code>中的方法，访问和修改 data 数据触发响应式渲染<code>dom</code>，可通过<code>computed</code>和<code>watch</code>完成数据计算</li>\n<li>此时<code>vm.$el</code> 并没有被创建</li>\n</ul>\n<p><strong>created -&gt; beforeMount</strong></p>\n<ul>\n<li>判断是否存在<code>el</code>选项，若不存在则停止编译，直到调用<code>vm.$mount(el)</code>才会继续编译</li>\n<li>优先级：<code>render</code> &gt; <code>template</code> &gt; <code>outerHTML</code></li>\n<li><code>vm.el</code>获取到的是挂载<code>DOM</code>的</li>\n</ul>\n<p><strong>beforeMount</strong></p>\n<ul>\n<li>在此阶段可获取到<code>vm.el</code></li>\n<li>此阶段<code>vm.el</code>虽已完成 DOM 初始化，但并未挂载在<code>el</code>选项上</li>\n</ul>\n<p><strong>beforeMount -&gt; mounted</strong></p>\n<ul>\n<li>此阶段<code>vm.el</code>完成挂载，<code>vm.$el</code>生成的<code>DOM</code>替换了<code>el</code>选项所对应的<code>DOM</code></li>\n</ul>\n<p><strong>mounted</strong></p>\n<ul>\n<li><code>vm.el</code>已完成<code>DOM</code>的挂载与渲染，此刻打印<code>vm.$el</code>，发现之前的挂载点及内容已被替换成新的 DOM</li>\n</ul>\n<p><strong>beforeUpdate</strong></p>\n<ul>\n<li>更新的数据必须是被渲染在模板上的（<code>el</code>、<code>template</code>、<code>render</code>之一）</li>\n<li>此时<code>view</code>层还未更新</li>\n<li>若在<code>beforeUpdate</code>中再次修改数据，不会再次触发更新方法</li>\n</ul>\n<p><strong>updated</strong></p>\n<ul>\n<li>完成<code>view</code>层的更新</li>\n<li>若在<code>updated</code>中再次修改数据，会再次触发更新方法（<code>beforeUpdate</code>、<code>updated</code>）</li>\n</ul>\n<p><strong>beforeDestroy</strong></p>\n<ul>\n<li>实例被销毁前调用，此时实例属性与方法仍可访问</li>\n</ul>\n<p><strong>destroyed</strong></p>\n<ul>\n<li>完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器</li>\n<li>并不能清除 DOM，仅仅销毁实例</li>\n</ul>\n<p><strong>使用场景分析</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">生命周期</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">beforeCreate</td>\n<td style=\"text-align:left\">执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">created</td>\n<td style=\"text-align:left\">组件初始化完毕，各种数据可以使用，常用于异步数据获取</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">beforeMount</td>\n<td style=\"text-align:left\">未执行渲染、更新，dom 未创建</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">mounted</td>\n<td style=\"text-align:left\">初始化结束，dom 已创建，可用于获取访问数据和 dom 元素</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">beforeUpdate</td>\n<td style=\"text-align:left\">更新前，可用于获取更新前各种状态</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">updated</td>\n<td style=\"text-align:left\">更新后，所有状态已是最新</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">beforeDestroy</td>\n<td style=\"text-align:left\">销毁前，可用于一些定时器或订阅的取消</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">destroyed</td>\n<td style=\"text-align:left\">组件已销毁，作用同上</td>\n</tr>\n</tbody>\n</table>\n<h2> 四、题外话：数据请求在 created 和 mouted 的区别</h2>\n<p><code>created</code>是在组件实例一旦创建完成的时候立刻调用，这时候页面<code>dom</code>节点并未生成；<code>mounted</code>是在页面<code>dom</code>节点渲染完毕之后就立刻执行的。触发时机上<code>created</code>是比<code>mounted</code>要更早的，两者的相同点：都能拿到实例对象的属性和方法。讨论这个问题本质就是触发的时机，放在<code>mounted</code>中的请求有可能导致页面闪动（因为此时页面<code>dom</code>结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在<code>created</code>生命周期当中。</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844903811094413320\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903811094413320</a></li>\n<li><a href=\"https://baike.baidu.com/\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/</a></li>\n<li><a href=\"http://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">http://cn.vuejs.org/</a></li>\n</ul>\n<p>面试官 VUE 系列总进度：4／33</p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&amp;mid=2247484101&amp;idx=1&amp;sn=83b0983f0fca7d7c556e4cb0bff8c9b8&amp;chksm=fc10c093cb674985ef3bd2966f66fc28c5eb70b0037e4be1af4bf54fb6fa9571985abd31d52f&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 vue 的理解?</a></p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&amp;mid=2247484119&amp;idx=1&amp;sn=d171b28a00d42549d279498944a98519&amp;chksm=fc10c081cb6749976814aaeda6a6433db418223cec57edda7e15b9e5a0ca69ad549655639c61&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 SPA（单页应用）的理解?</a></p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&amp;mid=2247484167&amp;idx=1&amp;sn=7b00b4333ab2722f25f12586b70667ca&amp;chksm=fc10c151cb6748476008dab2f4e6c6264f5d19678305955c85cec1b619e56e8f7457b7357fb9&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对双向绑定的理解?</a></p>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-06T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "说说你对 vue 的 mixin 的理解，有什么应用场景？",
      "url": "https://www.h7ml.cn/posts/interview/vue/mixin.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/mixin.html",
      "summary": "前端物语|面试物语-说说你对 vue 的 mixin 的理解，有什么应用场景？",
      "content_html": "<h1> 说说你对 vue 的 mixin 的理解，有什么应用场景？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8a739c90-3b7f-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、mixin 是什么</h2>\n<p><code>Mixin</code>是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问<code>mixin</code>类的方法而不必成为其子类</p>\n<p><code>Mixin</code>类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用又避免了多继承的复杂</p>\n<h3> Vue 中的 mixin</h3>\n<p>先来看一下官方定义</p>\n<blockquote>\n<p><code>mixin</code>（混入），提供了一种非常灵活的方式，来分发 <code>Vue</code> 组件中的可复用功能。</p>\n</blockquote>\n<p>本质其实就是一个<code>js</code>对象，它可以包含我们组件中任意功能选项，如<code>data</code>、<code>components</code>、<code>methods</code>、<code>created</code>、<code>computed</code>等等</p>\n<p>我们只要将共用的功能以对象的方式传入 <code>mixins</code>选项中，当组件使用 <code>mixins</code>对象时所有<code>mixins</code>对象的选项都将被混入该组件本身的选项中来</p>\n<p>在<code>Vue</code>中我们可以<strong>局部混入</strong>跟<strong>全局混入</strong></p>\n<h3> 局部混入</h3>\n<p>定义一个<code>mixin</code>对象，有组件<code>options</code>的<code>data</code>、<code>methods</code>属性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>组件通过<code>mixins</code>属性调用<code>mixin</code>对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>该组件在使用的时候，混合了<code>mixin</code>里面的方法，在自动执行<code>created</code>生命钩子，执行<code>hello</code>方法</p>\n<h3> 全局混入</h3>\n<p>通过<code>Vue.mixin()</code>进行全局的混入</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用全局混入需要特别注意，因为它会影响到每一个组件实例（包括第三方组件）</p>\n<p>PS：全局混入常用于插件的编写</p>\n<h3> 注意事项</h3>\n<p>当组件存在与<code>mixin</code>对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖<code>mixin</code>的选项</p>\n<p>但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行<code>mixin</code>的钩子，再执行组件的钩子</p>\n<h2> 二、使用场景</h2>\n<p>在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立</p>\n<p>这时，可以通过<code>Vue</code>的<code>mixin</code>功能将相同或者相似的代码提出来</p>\n<p>举个例子</p>\n<p>定义一个<code>modal</code>弹窗组件，内部通过<code>isShowing</code>来控制显示</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定义一个<code>tooltip</code>提示框，内部通过<code>isShowing</code>来控制显示</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过观察上面两个组件，发现两者的逻辑是相同，代码控制显示也是相同的，这时候<code>mixin</code>就派上用场了</p>\n<p>首先抽出共同代码，编写一个<code>mixin</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>两个组件在使用上，只需要引入<code>mixin</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过上面小小的例子，让我们知道了<code>Mixin</code>对于封装一些可复用的功能如此有趣、方便、实用</p>\n<h2> 三、源码分析</h2>\n<p>首先从<code>Vue.mixin</code>入手</p>\n<p>源码位置：/src/core/global-api/mixin.js</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>主要是调用<code>merOptions</code>方法</p>\n<p>源码位置：/src/core/util/options.js</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面的源码，我们得到以下几点：</p>\n<ul>\n<li>优先递归处理 <code>mixins</code></li>\n<li>先遍历合并<code>parent</code> 中的<code>key</code>，调用<code>mergeField</code>方法进行合并，然后保存在变量<code>options</code></li>\n<li>再遍历 <code>child</code>，合并补上 <code>parent</code> 中没有的<code>key</code>，调用<code>mergeField</code>方法进行合并，保存在变量<code>options</code></li>\n<li>通过 <code>mergeField</code> 函数进行了合并</li>\n</ul>\n<p>下面是关于<code>Vue</code>的几种类型的合并策略</p>\n<ul>\n<li>替换型</li>\n<li>合并型</li>\n<li>队列型</li>\n<li>叠加型</li>\n</ul>\n<h3> 替换型</h3>\n<p>替换型合并有<code>props</code>、<code>methods</code>、<code>inject</code>、<code>computed</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同名的<code>props</code>、<code>methods</code>、<code>inject</code>、<code>computed</code>会被后来者代替</p>\n<h3> 合并型</h3>\n<p>和并型合并有：<code>data</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>mergeData</code>函数遍历了要合并的 data 的所有属性，然后根据不同情况进行合并：</p>\n<ul>\n<li>当目标 data 对象不包含当前属性时，调用 <code>set</code> 方法进行合并（set 方法其实就是一些合并重新赋值的方法）</li>\n<li>当目标 data 对象包含当前属性并且当前值为纯对象时，递归合并当前对象值，这样做是为了防止对象存在新增属性</li>\n</ul>\n<h3> 队列性</h3>\n<p>队列性合并有：全部生命周期和<code>watch</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>生命周期钩子和<code>watch</code>被合并为一个数组，然后正序遍历一次执行</p>\n<h3> 叠加型</h3>\n<p>叠加型合并有：<code>component</code>、<code>directives</code>、<code>filters</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>叠加型主要是通过原型链进行层层的叠加</p>\n<h3> 小结</h3>\n<ul>\n<li>替换型策略有<code>props</code>、<code>methods</code>、<code>inject</code>、<code>computed</code>，就是将新的同名参数替代旧的参数</li>\n<li>合并型策略是<code>data</code>, 通过<code>set</code>方法进行合并和重新赋值</li>\n<li>队列型策略有生命周期函数和<code>watch</code>，原理是将函数存入一个数组，然后正序遍历依次执行</li>\n<li>叠加型有<code>component</code>、<code>directives</code>、<code>filters</code>，通过原型链进行层层的叠加</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/31018570\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/31018570</a></li>\n<li><a href=\"https://juejin.cn/post/6844904015495446536#heading-1\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904015495446536#heading-1</a></li>\n<li><a href=\"https://juejin.cn/post/6844903846775357453\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903846775357453</a></li>\n<li><a href=\"https://vue3js.cn/docs/zh\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn/docs/zh</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-13T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "Vue 常用的修饰符有哪些有什么应用场景",
      "url": "https://www.h7ml.cn/posts/interview/vue/modifier.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/modifier.html",
      "summary": "前端物语|面试物语-Vue 常用的修饰符有哪些有什么应用场景",
      "content_html": "<h1> Vue 常用的修饰符有哪些有什么应用场景</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8f718e30-42c0-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、修饰符是什么</h2>\n<p>在程序世界里，修饰符是用于限定类型以及类型成员的声明的一种符号</p>\n<p>在<code>Vue</code>中，修饰符处理了许多<code>DOM</code>事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理</p>\n<p><code>vue</code>中修饰符分为以下五种：</p>\n<ul>\n<li>表单修饰符</li>\n<li>事件修饰符</li>\n<li>鼠标按键修饰符</li>\n<li>键值修饰符</li>\n<li>v-bind 修饰符</li>\n</ul>\n<h2> 二、修饰符的作用</h2>\n<h3> 表单修饰符</h3>\n<p>在我们填写表单的时候用得最多的是<code>input</code>标签，指令用得最多的是<code>v-model</code></p>\n<p>关于表单的修饰符有如下：</p>\n<ul>\n<li>lazy</li>\n<li>trim</li>\n<li>number</li>\n</ul>\n<h4> lazy</h4>\n<p>在我们填完信息，光标离开标签的时候，才会将值赋予给<code>value</code>，也就是在<code>change</code>事件之后再进行信息同步</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> trim</h4>\n<p>自动过滤用户输入的首空格字符，而中间的空格不会过滤</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> number</h4>\n<p>自动将用户的输入值转为数值类型，但如果这个值无法被<code>parseFloat</code>解析，则会返回原来的值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 事件修饰符</h3>\n<p>事件修饰符是对事件捕获以及目标进行了处理，有如下修饰符：</p>\n<ul>\n<li>stop</li>\n<li>prevent</li>\n<li>self</li>\n<li>once</li>\n<li>capture</li>\n<li>passive</li>\n<li>native</li>\n</ul>\n<h4> stop</h4>\n<p>阻止了事件冒泡，相当于调用了<code>event.stopPropagation</code>方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> prevent</h4>\n<p>阻止了事件的默认行为，相当于调用了<code>event.preventDefault</code>方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> self</h4>\n<p>只当在 <code>event.target</code> 是当前元素自身时触发处理函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><blockquote>\n<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击</p>\n</blockquote>\n<h4> once</h4>\n<p>绑定了事件以后只能触发一次，第二次就不会触发</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> capture</h4>\n<p>使事件触发从包含这个元素的顶层开始往下触发</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> passive</h4>\n<p>在移动端，当我们在监听元素滚动事件的时候，会一直触发<code>onscroll</code>事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给<code>onscroll</code>事件整了一个<code>.lazy</code>修饰符</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用,因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。</p>\n<p><code>passive</code> 会告诉浏览器你不想阻止事件的默认行为</p>\n</blockquote>\n<h4> native</h4>\n<p>让组件变成像<code>html</code>内置标签那样监听根元素的原生事件，否则组件上使用 <code>v-on</code> 只会监听自定义事件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><blockquote>\n<p>使用.native 修饰符来操作普通 HTML 标签是会令事件失效的</p>\n</blockquote>\n<h3> 鼠标按钮修饰符</h3>\n<p>鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下：</p>\n<ul>\n<li>left 左键点击</li>\n<li>right 右键点击</li>\n<li>middle 中键点击</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 键盘修饰符</h3>\n<p>键盘修饰符是用来修饰键盘事件（<code>onkeyup</code>，<code>onkeydown</code>）的，有如下：</p>\n<p><code>keyCode</code>存在很多，但<code>vue</code>为我们提供了别名，分为以下两种：</p>\n<ul>\n<li>普通键（enter、tab、delete、space、esc、up...）</li>\n<li>系统修饰键（ctrl、alt、meta、shift...）</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>还可以通过以下方式自定义一些全局的键盘码别名</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> v-bind 修饰符</h3>\n<p>v-bind 修饰符主要是为属性进行操作，用来分别有如下：</p>\n<ul>\n<li>async</li>\n<li>prop</li>\n<li>camel</li>\n</ul>\n<h4> async</h4>\n<p>能对<code>props</code>进行一个双向绑定</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上这种方法相当于以下的简写</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用<code>async</code>需要注意以下两点：</p>\n<ul>\n<li>\n<p>使用<code>sync</code>的时候，子组件传递的事件名格式必须为<code>update:value</code>，其中<code>value</code>必须与子组件中<code>props</code>中声明的名称完全一致</p>\n</li>\n<li>\n<p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> 不能和表达式一起使用</p>\n</li>\n<li>\n<p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”{ title: doc.title }”</code>，是无法正常工作的</p>\n</li>\n</ul>\n<h4> props</h4>\n<p>设置自定义标签属性，避免暴露数据，防止污染 HTML 结构</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h4> camel</h4>\n<p>将命名变为驼峰命名法，如将<code>view-Box</code>属性名转换为 <code>viewBox</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 三、应用场景</h2>\n<p>根据每一个修饰符的功能，我们可以得到以下修饰符的应用场景：</p>\n<ul>\n<li>.stop：阻止事件冒泡</li>\n<li>.native：绑定原生事件</li>\n<li>.once：事件只执行一次</li>\n<li>.self ：将事件绑定在自身身上，相当于阻止事件冒泡</li>\n<li>.prevent：阻止默认事件</li>\n<li>.caption：用于事件捕获</li>\n<li>.once：只触发一次</li>\n<li>.keyCode：监听特定键盘按下</li>\n<li>.right：右键</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000016786254\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000016786254</a></li>\n<li><a href=\"https://vue3js.cn/docs/zh\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn/docs/zh</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-04T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "Vue 实例挂载的过程",
      "url": "https://www.h7ml.cn/posts/interview/vue/new_vue.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/new_vue.html",
      "summary": "前端物语|面试物语-Vue 实例挂载的过程",
      "content_html": "<h1> Vue 实例挂载的过程</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/63194810-3a09-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、思考</h2>\n<p>我们都听过知其然知其所以然这句话</p>\n<p>那么不知道大家是否思考过<code>new Vue()</code>这个过程中究竟做了些什么？</p>\n<p>过程中是如何完成数据的绑定，又是如何将数据渲染到视图的等等</p>\n<h2> 一、分析</h2>\n<p>首先找到<code>vue</code>的构造函数</p>\n<p>源码位置：src\\core\\instance\\index.js</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>options</code>是用户传递过来的配置项，如<code>data、methods</code>等常用的方法</p>\n<p><code>vue</code>构建函数调用<code>_init</code>方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>首先可以看<code>initMixin</code>方法，发现该方法在<code>Vue</code>原型上定义了<code>_init</code>方法</p>\n<p>源码位置：src\\core\\instance\\init.js</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>仔细阅读上面的代码，我们得到以下结论：</p>\n<ul>\n<li>\n<p>在调用<code>beforeCreate</code>之前，数据初始化并未完成，像<code>data</code>、<code>props</code>这些属性无法访问到</p>\n</li>\n<li>\n<p>到了<code>created</code>的时候，数据已经初始化完成，能够访问<code>data</code>、<code>props</code>这些属性，但这时候并未完成<code>dom</code>的挂载，因此无法访问到<code>dom</code>元素</p>\n</li>\n<li>\n<p>挂载方法是调用<code>vm.$mount</code>方法</p>\n</li>\n</ul>\n<p><code>initState</code>方法是完成<code>props/data/method/watch/methods</code>的初始化</p>\n<p>源码位置：src\\core\\instance\\state.js</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们和这里主要看初始化<code>data</code>的方法为<code>initData</code>，它与<code>initState</code>在同一文件上</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>仔细阅读上面的代码，我们可以得到以下结论：</p>\n<ul>\n<li>\n<p>初始化顺序：<code>props</code>、<code>methods</code>、<code>data</code></p>\n</li>\n<li>\n<p><code>data</code>定义的时候可选择函数形式或者对象形式（组件只能为函数形式）</p>\n</li>\n</ul>\n<p>关于数据响应式在这就不展开详细说明</p>\n<p>上文提到挂载方法是调用<code>vm.$mount</code>方法</p>\n<p>源码位置：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>阅读上面代码，我们能得到以下结论：</p>\n<ul>\n<li>\n<p>不要将根元素放到<code>body</code>或者<code>html</code>上</p>\n</li>\n<li>\n<p>可以在对象中定义<code>template/render</code>或者直接使用<code>template</code>、<code>el</code>表示元素选择器</p>\n</li>\n<li>\n<p>最终都会解析成<code>render</code>函数，调用<code>compileToFunctions</code>，会将<code>template</code>解析成<code>render</code>函数</p>\n</li>\n</ul>\n<p>对<code>template</code>的解析步骤大致分为以下几步：</p>\n<ul>\n<li>\n<p>将<code>html</code>文档片段解析成<code>ast</code>描述符</p>\n</li>\n<li>\n<p>将<code>ast</code>描述符解析成字符串</p>\n</li>\n<li>\n<p>生成<code>render</code>函数</p>\n</li>\n</ul>\n<p>生成<code>render</code>函数，挂载到<code>vm</code>上后，会再次调用<code>mount</code>方法</p>\n<p>源码位置：src\\platforms\\web\\runtime\\index.js</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>调用<code>mountComponent</code>渲染组件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>阅读上面代码，我们得到以下结论：</p>\n<ul>\n<li>会触发<code>beforeCreate</code>钩子</li>\n<li>定义<code>updateComponent</code>渲染页面视图的方法</li>\n<li>监听组件数据，一旦发生变化，触发<code>beforeUpdate</code>生命钩子</li>\n</ul>\n<p><code>updateComponent</code>方法主要执行在<code>vue</code>初始化时声明的<code>render</code>，<code>update</code>方法</p>\n<p><code>render</code>的作用主要是生成<code>vnode</code></p>\n<p>源码位置：src\\core\\instance\\render.js</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>_update</code>主要功能是调用<code>patch</code>，将<code>vnode</code>转换为真实<code>DOM</code>，并且更新到页面中</p>\n<p>源码位置：src\\core\\instance\\lifecycle.js</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、结论</h2>\n<ul>\n<li>\n<p><code>new Vue</code>的时候调用会调用<code>_init</code>方法</p>\n<ul>\n<li>定义 <code>$set</code>、<code>$get</code> 、<code>$delete</code>、<code>$watch</code> 等方法</li>\n<li>定义 <code>$on</code>、<code>$off</code>、<code>$emit</code>、<code>$off</code>等事件</li>\n<li>定义 <code>_update</code>、<code>$forceUpdate</code>、<code>$destroy</code>生命周期</li>\n</ul>\n</li>\n<li>\n<p>调用<code>$mount</code>进行页面的挂载</p>\n</li>\n<li>\n<p>挂载的时候主要是通过<code>mountComponent</code>方法</p>\n</li>\n<li>\n<p>定义<code>updateComponent</code>更新函数</p>\n</li>\n<li>\n<p>执行<code>render</code>生成虚拟<code>DOM</code></p>\n</li>\n<li>\n<p><code>_update</code>将虚拟<code>DOM</code>生成真实<code>DOM</code>结构，并且渲染到页面中</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.cnblogs.com/gerry2019/p/12001661.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/gerry2019/p/12001661.html</a></li>\n<li><a href=\"https://github.com/vuejs/vue/tree/dev/src/core/instance\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/vuejs/vue/tree/dev/src/core/instance</a></li>\n<li><a href=\"https://vue3js.cn\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-05T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "Vue 中的$nextTick 有什么作用？",
      "url": "https://www.h7ml.cn/posts/interview/vue/nexttick.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/nexttick.html",
      "summary": "前端物语|面试物语-Vue 中的$nextTick 有什么作用？",
      "content_html": "<h1> Vue 中的$nextTick 有什么作用？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/76484d30-3aba-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、NextTick 是什么</h2>\n<p>官方对其的定义</p>\n<blockquote>\n<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</p>\n</blockquote>\n<p>什么意思呢？</p>\n<p>我们可以理解成，<code>Vue</code> 在更新 <code>DOM</code> 时是异步执行的。当数据发生变化，<code>Vue</code>将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新</p>\n<p>举例一下</p>\n<p><code>Html</code>结构</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>构建一个<code>vue</code>实例</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改<code>message</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这时候想获取页面最新的<code>DOM</code>节点，却发现获取到的是旧值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这是因为<code>message</code>数据在发现变化的时候，<code>vue</code>并不会立刻去更新<code>Dom</code>，而是将修改数据的操作放在了一个异步操作队列中</p>\n<p>如果我们一直修改相同数据，异步操作队列还会进行去重</p>\n<p>等待同一事件循环中的所有数据变化完成之后，会将队列中的事件拿来进行处理，进行<code>DOM</code>的更新</p>\n<h4> 为什么要有 nexttick</h4>\n<p>举个例子</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果没有 <code>nextTick</code> 更新机制，那么 <code>num</code> 每次更新值都会触发视图更新(上面这段代码也就是会更新 10 万次视图)，有了<code>nextTick</code>机制，只需要更新一次，所以<code>nextTick</code>本质是一种优化策略</p>\n<h2> 二、使用场景</h2>\n<p>如果想要在修改数据后立刻得到更新后的<code>DOM</code>结构，可以使用<code>Vue.nextTick()</code></p>\n<p>第一个参数为：回调函数（可以获取最近的<code>DOM</code>结构）</p>\n<p>第二个参数为：执行函数上下文</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>组件内使用 <code>vm.$nextTick()</code> 实例方法只需要通过<code>this.$nextTick()</code>，并且回调函数中的 <code>this</code> 将自动绑定到当前的 <code>Vue</code> 实例上</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>$nextTick()</code> 会返回一个 <code>Promise</code> 对象，可以是用<code>async/await</code>完成相同作用的事情</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、实现原理</h2>\n<p>源码位置：<code>/src/core/util/next-tick.js</code></p>\n<p><code>callbacks</code>也就是异步操作队列</p>\n<p><code>callbacks</code>新增回调函数后又执行了<code>timerFunc</code>函数，<code>pending</code>是用来标识同一个时间只能执行一次</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>timerFunc</code>函数定义，这里是根据当前环境支持什么方法则确定调用哪个，分别有：</p>\n<p><code>Promise.then</code>、<code>MutationObserver</code>、<code>setImmediate</code>、<code>setTimeout</code></p>\n<p>通过上面任意一种方法，进行降级操作</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>无论是微任务还是宏任务，都会放到<code>flushCallbacks</code>使用</p>\n<p>这里将<code>callbacks</code>里面的函数复制一份，同时<code>callbacks</code>置空</p>\n<p>依次执行<code>callbacks</code>里面的函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>小结：</strong></p>\n<ol>\n<li>把回调函数放入 callbacks 等待执行</li>\n<li>将执行函数放到微任务或者宏任务中</li>\n<li>事件循环到了微任务或者宏任务，执行函数依次执行 callbacks 中的回调</li>\n</ol>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6844904147804749832\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904147804749832</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "Vue.observable 你有了解过吗？说说看",
      "url": "https://www.h7ml.cn/posts/interview/vue/observable.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/observable.html",
      "summary": "前端物语|面试物语-Vue.observable 你有了解过吗？说说看",
      "content_html": "<h1> Vue.observable 你有了解过吗？说说看</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/193782e0-3e7b-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、Observable 是什么</h2>\n<p><code>Observable</code> 翻译过来我们可以理解成<strong>可观察的</strong></p>\n<p>我们先来看一下其在<code>Vue</code>中的定义</p>\n<blockquote>\n<p><code>Vue.observable</code>，让一个对象变成响应式数据。<code>Vue</code> 内部会用它来处理 <code>data</code> 函数返回的对象</p>\n</blockquote>\n<p>返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>其作用等同于</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在 <code>Vue 2.x</code> 中，被传入的对象会直接被 <code>Vue.observable</code> 变更，它和被返回的对象是同一个对象</p>\n<p>在 <code>Vue 3.x</code> 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的</p>\n<h2> 二、使用场景</h2>\n<p>在非父子组件通信时，可以使用通常的<code>bus</code>或者使用<code>vuex</code>，但是实现的功能不是太复杂，而使用上面两个又有点繁琐。这时，<code>observable</code>就是一个很好的选择</p>\n<p>创建一个<code>js</code>文件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在<code>.vue</code>文件中直接使用即可</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、原理分析</h2>\n<p>源码位置：src\\core\\observer\\index.js</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Observer</code>类</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>walk</code>函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>defineReactive</code>方法</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_32682301/article/details/105419673\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/qq_32682301/article/details/105419673</a></li>\n<li><a href=\"https://wbbyouzi.com/archives/343\" target=\"_blank\" rel=\"noopener noreferrer\">https://wbbyouzi.com/archives/343</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-18T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？",
      "url": "https://www.h7ml.cn/posts/interview/vue/permission.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/permission.html",
      "summary": "前端物语|面试物语-vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？",
      "content_html": "<h1> vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/397e1fa0-4dad-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p>权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源</p>\n<p>而前端权限归根结底是请求的发起权，请求的发起可能有下面两种形式触发</p>\n<ul>\n<li>页面加载触发</li>\n<li>页面上的按钮点击触发</li>\n</ul>\n<p>总的来说，所有的请求发起都触发自前端路由或视图</p>\n<p>所以我们可以从这两方面入手，对触发权限的源头进行控制，最终要实现的目标是：</p>\n<ul>\n<li>\n<p>路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 <code>4xx</code> 提示页</p>\n</li>\n<li>\n<p>视图方面，用户只能看到自己有权浏览的内容和有权操作的控件</p>\n</li>\n<li>\n<p>最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截</p>\n</li>\n</ul>\n<h2> 二、如何做</h2>\n<p>前端权限控制可以分为四个方面：</p>\n<ul>\n<li>接口权限</li>\n<li>按钮权限</li>\n<li>菜单权限</li>\n<li>路由权限</li>\n</ul>\n<h3> 接口权限</h3>\n<p>接口权限目前一般采用<code>jwt</code>的形式来验证，没有通过的话一般返回<code>401</code>，跳转到登录页面重新进行登录</p>\n<p>登录完拿到<code>token</code>，将<code>token</code>存起来，通过<code>axios</code>请求拦截器进行拦截，每次请求的时候头部携带<code>token</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 路由权限控制</h3>\n<p><strong>方案一</strong></p>\n<p>初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种方式存在以下四种缺点：</p>\n<ul>\n<li>\n<p>加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。</p>\n</li>\n<li>\n<p>全局路由守卫里，每次路由跳转都要做权限判断。</p>\n</li>\n<li>\n<p>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</p>\n</li>\n<li>\n<p>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</p>\n</li>\n</ul>\n<p><strong>方案二</strong></p>\n<p>初始化的时候先挂载不需要权限控制的路由，比如登录页，404 等错误页。如果用户通过 URL 进行强制访问，则会直接进入 404，相当于从源头上做了控制</p>\n<p>登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用<code>addRoutes</code>添加路由</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限</p>\n<p>这种方式也存在了以下的缺点：</p>\n<ul>\n<li>全局路由守卫里，每次路由跳转都要做判断</li>\n<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>\n<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li>\n</ul>\n<h3> 菜单权限</h3>\n<p>菜单权限可以理解成将页面与理由进行解耦</p>\n<h4> 方案一</h4>\n<p>菜单与路由分离，菜单由后端返回</p>\n<p>前端定义路由信息</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>name</code>字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有<code>name</code>对应的字段，并且做唯一性校验</p>\n<p>全局路由守卫里做判断</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的<code>name</code>与路由的<code>name</code>是一一对应的，而后端返回的菜单就已经是经过权限过滤的</p>\n<p>如果根据路由<code>name</code>找不到对应的菜单，就表示用户有没权限访问</p>\n<p>如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过<code>addRoutes</code>动态挂载</p>\n<p>这种方式的缺点：</p>\n<ul>\n<li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用</li>\n<li>全局路由守卫里，每次路由跳转都要做判断</li>\n</ul>\n<h4> 方案二</h4>\n<p>菜单和路由都由后端返回</p>\n<p>前端统一定义路由组件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>后端路由组件返回以下格式</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在将后端返回路由通过<code>addRoutes</code>动态挂载之间，需要将数据处理一下，将<code>component</code>字段换为真正的组件</p>\n<p>如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理</p>\n<p>这种方法也会存在缺点：</p>\n<ul>\n<li>全局路由守卫里，每次路由跳转都要做判断</li>\n<li>前后端的配合要求更高</li>\n</ul>\n<h3> 按钮权限</h3>\n<h4> 方案一</h4>\n<p>按钮权限也可以用<code>v-if</code>判断</p>\n<p>但是如果页面过多，每个页面页面都要获取用户权限<code>role</code>和路由表里的<code>meta.btnPermissions</code>，然后再做判断</p>\n<p>这种方式就不展开举例了</p>\n<h4> 方案二</h4>\n<p>通过自定义指令进行按钮权限的判断</p>\n<p>首先配置路由</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>自定义权限鉴定指令</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在使用的按钮中只需要引用<code>v-has</code>指令</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 小结</h3>\n<p>关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离</p>\n<p>权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/b-D2eH1mLwL_FkaZwjueSw\" target=\"_blank\" rel=\"noopener noreferrer\">https://mp.weixin.qq.com/s/b-D2eH1mLwL_FkaZwjueSw</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000020887109\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000020887109</a></li>\n<li><a href=\"https://juejin.cn/post/6844903648057622536#heading-6\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903648057622536#heading-6</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-16T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "v-show 和 v-if 有什么区别？使用场景分别是什么？",
      "url": "https://www.h7ml.cn/posts/interview/vue/show_if.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/show_if.html",
      "summary": "前端物语|面试物语-v-show 和 v-if 有什么区别？使用场景分别是什么？",
      "content_html": "<h1> v-show 和 v-if 有什么区别？使用场景分别是什么？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d21c3c50-3acb-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、v-show 与 v-if 的共同点</h2>\n<p>我们都知道在 <code>vue</code> 中 <code>v-show</code> 与 <code>v-if</code> 的作用效果是相同的(不含 v-else)，都能控制元素在页面是否显示</p>\n<p>在用法上也是相同的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>当表达式为<code>true</code>的时候，都会占据页面的位置</li>\n<li>当表达式都为<code>false</code>时，都不会占据页面位置</li>\n</ul>\n<h2> 二、v-show 与 v-if 的区别</h2>\n<ul>\n<li>控制手段不同</li>\n<li>编译过程不同</li>\n<li>编译条件不同</li>\n</ul>\n<p>控制手段：<code>v-show</code>隐藏则是为该元素添加<code>css--display:none</code>，<code>dom</code>元素依旧还在。<code>v-if</code>显示隐藏是将<code>dom</code>元素整个添加或删除</p>\n<p>编译过程：<code>v-if</code>切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；<code>v-show</code>只是简单的基于 css 切换</p>\n<p>编译条件：<code>v-if</code>是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染</p>\n<ul>\n<li>\n<p><code>v-show</code> 由<code>false</code>变为<code>true</code>的时候不会触发组件的生命周期</p>\n</li>\n<li>\n<p><code>v-if</code>由<code>false</code>变为<code>true</code>的时候，触发组件的<code>beforeCreate</code>、<code>create</code>、<code>beforeMount</code>、<code>mounted</code>钩子，由<code>true</code>变为<code>false</code>的时候触发组件的<code>beforeDestory</code>、<code>destoryed</code>方法</p>\n</li>\n</ul>\n<p>性能消耗：<code>v-if</code>有更高的切换消耗；<code>v-show</code>有更高的初始渲染消耗；</p>\n<h2> 三、v-show 与 v-if 原理分析</h2>\n<p>具体解析流程这里不展开讲，大致流程如下</p>\n<ul>\n<li>将模板<code>template</code>转为<code>ast</code>结构的<code>JS</code>对象</li>\n<li>用<code>ast</code>得到的<code>JS</code>对象拼装<code>render</code>和<code>staticRenderFns</code>函数</li>\n<li><code>render</code>和<code>staticRenderFns</code>函数被调用后生成虚拟<code>VNODE</code>节点，该节点包含创建<code>DOM</code>节点所需信息</li>\n<li><code>vm.patch</code>函数通过虚拟<code>DOM</code>算法利用<code>VNODE</code>节点创建真实<code>DOM</code>节点</li>\n</ul>\n<h3> v-show 原理</h3>\n<p>不管初始条件是什么，元素总是会被渲染</p>\n<p>我们看一下在<code>vue</code>中是如何实现的</p>\n<p>代码很好理解，有<code>transition</code>就执行<code>transition</code>，没有就直接设置<code>display</code>属性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> v-if 原理</h3>\n<p><code>v-if</code>在实现上比<code>v-show</code>要复杂的多，因为还有<code>else</code> <code>else-if</code> 等条件需要处理，这里我们也只摘抄源码中处理 <code>v-if</code> 的一小部分</p>\n<p>返回一个<code>node</code>节点，<code>render</code>函数通过表达式的值来决定是否生成<code>DOM</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 四、v-show 与 v-if 的使用场景</h2>\n<p><code>v-if</code> 与 <code>v-show</code> 都能控制<code>dom</code>元素在页面的显示</p>\n<p><code>v-if</code> 相比 <code>v-show</code> 开销更大的（直接操作<code>dom</code>节点增加与删除）</p>\n<p>如果需要非常频繁地切换，则使用 v-show 较好</p>\n<p>如果在运行时条件很少改变，则使用 v-if 较好</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/7af8554d8f08\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.jianshu.com/p/7af8554d8f08</a></li>\n<li><a href=\"https://juejin.cn/post/6897948855904501768\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6897948855904501768</a></li>\n<li><a href=\"https://vue3js/docs/zh\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js/docs/zh</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-06T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢",
      "url": "https://www.h7ml.cn/posts/interview/vue/spa.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/spa.html",
      "summary": "前端物语|面试物语-你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢",
      "content_html": "<h1> 你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/cf6aa320-3ac6-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、什么是 SPA</h2>\n<p>SPA（single-page application），翻译过来就是单页应用<code>SPA</code>是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（<code>HTML</code>、<code>JavaScript</code>和<code>CSS</code>）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面举个例子来讲就是一个杯子，早上装的牛奶，中午装的是开水，晚上装的是茶，我们发现，变的始终是杯子里的内容，而杯子始终是那个杯子结构如下图</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/df14a5a0-3ac6-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>我们熟知的 JS 框架如<code>react</code>,<code>vue</code>,<code>angular</code>,<code>ember</code>都属于<code>SPA</code></p>\n<h2> 二、SPA 和 MPA 的区别</h2>\n<p>上面大家已经对单页面有所了解了，下面来讲讲多页应用 MPA（MultiPage-page application），翻译过来就是多页应用在<code>MPA</code>中，每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载<code>html</code>、<code>css</code>、<code>js</code>文件，公共文件则根据需求按需加载如下图</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/eeb13aa0-3ac6-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h4> 单页应用与多页应用的区别</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">单页面应用（SPA）</th>\n<th style=\"text-align:left\">多页面应用（MPA）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">组成</td>\n<td style=\"text-align:left\">一个主页面和多个页面片段</td>\n<td style=\"text-align:left\">多个主页面</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">刷新方式</td>\n<td style=\"text-align:left\">局部刷新</td>\n<td style=\"text-align:left\">整页刷新</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">url 模式</td>\n<td style=\"text-align:left\">哈希模式</td>\n<td style=\"text-align:left\">历史模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SEO 搜索引擎优化</td>\n<td style=\"text-align:left\">难实现，可使用 SSR 方式改善</td>\n<td style=\"text-align:left\">容易实现</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">数据传递</td>\n<td style=\"text-align:left\">容易</td>\n<td style=\"text-align:left\">通过 url、cookie、localStorage 等传递</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">页面切换</td>\n<td style=\"text-align:left\">速度快，用户体验良好</td>\n<td style=\"text-align:left\">切换加载资源，速度慢，用户体验差</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">维护成本</td>\n<td style=\"text-align:left\">相对容易</td>\n<td style=\"text-align:left\">相对复杂</td>\n</tr>\n</tbody>\n</table>\n<h4> 单页应用优缺点</h4>\n<p>优点：</p>\n<ul>\n<li>具有桌面应用的即时性、网站的可移植性和可访问性</li>\n<li>用户体验好、快，内容的改变不需要重新加载整个页面</li>\n<li>良好的前后端分离，分工更明确</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>不利于搜索引擎的抓取</li>\n<li>首次渲染速度相对较慢</li>\n<li></li>\n</ul>\n<h2> 三、实现一个 SPA</h2>\n<h4> 原理</h4>\n<ol>\n<li>监听地址栏中<code>hash</code>变化驱动界面变化</li>\n<li>用<code>pushsate</code>记录浏览器的历史，驱动界面发送变化</li>\n</ol>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fc95bf60-3ac6-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h4> 实现</h4>\n<h5> <code>hash</code> 模式</h5>\n<p>核心通过监听<code>url</code>中的<code>hash</code>来进行路由跳转</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> history 模式</h5>\n<p><code>history</code> 模式核心借用 <code>HTML5 history api</code>，<code>api</code> 提供了丰富的 <code>router</code> 相关属性先了解一个几个相关的 api</p>\n<ul>\n<li><code>history.pushState</code> 浏览器历史纪录添加记录</li>\n<li><code>history.replaceState</code>修改浏览器历史纪录中当前纪录</li>\n<li><code>history.popState</code> 当 <code>history</code> 发生变化时触发</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 四、题外话：如何给 SPA 做 SEO</h3>\n<p>下面给出基于<code>Vue</code>的<code>SPA</code>如何实现<code>SEO</code>的三种方式</p>\n<ol>\n<li><strong>SSR 服务端渲染</strong></li>\n</ol>\n<p>将组件或页面通过服务器生成 html，再返回给浏览器，如<code>nuxt.js</code></p>\n<ol start=\"2\">\n<li><strong>静态化</strong></li>\n</ol>\n<p>目前主流的静态化主要有两种：（1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中（2）另外一种是通过 WEB 服务器的 <code>URL Rewrite</code>的方式，它的原理是通过 web 服务器内部模块按一定规则将外部的 URL 请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现 URL 静态化的效果</p>\n<ol start=\"3\">\n<li><strong>使用<code>Phantomjs</code>针对爬虫处理</strong></li>\n</ol>\n<p>原理是通过<code>Nginx</code>配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个<code>node server</code>，再通过<code>PhantomJS</code>来解析完整的<code>HTML</code>，返回给爬虫。下面是大致流程图</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/25be6630-3ac7-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 参考文献</h3>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000019623624\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000019623624</a></li>\n<li><a href=\"https://juejin.cn/post/6844903512107663368\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844903512107663368</a></li>\n<li><a href=\"https://www.cnblogs.com/constantince/p/5586851.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/constantince/p/5586851.html</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-13T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？",
      "url": "https://www.h7ml.cn/posts/interview/vue/ssr.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/ssr.html",
      "summary": "前端物语|面试物语-SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？",
      "content_html": "<h1> SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/84bd83f0-4986-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>Server-Side Rendering</code> 我们称其为<code>SSR</code>，意为服务端渲染</p>\n<p>指由服务侧完成页面的 <code>HTML</code> 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程</p>\n<p>先来看看<code>Web</code>3 个阶段的发展史：</p>\n<ul>\n<li>传统服务端渲染 SSR</li>\n<li>单页面应用 SPA</li>\n<li>服务端渲染 SSR</li>\n</ul>\n<h3> <strong>传统 web 开发</strong></h3>\n<p>网页内容在服务端渲染完成，⼀次性传输到浏览器</p>\n<figure><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4d666b24e784fd09e565458c7753b54~tplv-k3u1fbpfcp-watermark.image\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>打开页面查看源码，浏览器拿到的是全部的<code>dom</code>结构</p>\n<h3> <strong>单页应用 SPA</strong></h3>\n<p>单页应用优秀的用户体验，使其逐渐成为主流，页面内容由<code>JS</code>渲染出来，这种方式称为客户端渲染</p>\n<figure><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e8e524a8e7d44cba73e0c3416690087~tplv-k3u1fbpfcp-watermark.image\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>打开页面查看源码，浏览器拿到的仅有宿主元素<code>#app</code>，并没有内容</p>\n<h3> 服务端渲染 SSR</h3>\n<p><code>SSR</code>解决方案，后端渲染出完整的首屏的<code>dom</code>结构返回，前端拿到的内容包括首屏及完整<code>spa</code>结构，应用激活后依然按照<code>spa</code>方式运行</p>\n<figure><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1604e7cfad7431f99920e8ab833bc37~tplv-k3u1fbpfcp-watermark.image\" alt=\"img\" tabindex=\"0\" loading=\"lazy\"><figcaption>img</figcaption></figure>\n<p>看完前端发展，我们再看看<code>Vue</code>官方对<code>SSR</code>的解释：</p>\n<blockquote>\n<p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记\"激活\"为客户端上完全可交互的应用程序</p>\n<p>服务器渲染的 Vue.js 应用程序也可以被认为是\"同构\"或\"通用\"，因为应用程序的大部分代码都可以在服务器和客户端上运行</p>\n</blockquote>\n<p>我们从上门解释得到以下结论：</p>\n<ul>\n<li><code>Vue SSR</code>是一个在<code>SPA</code>上进行改良的服务端渲染</li>\n<li>通过<code>Vue SSR</code>渲染的页面，需要在客户端激活才能实现交互</li>\n<li><code>Vue SSR</code>将包含两部分：服务端渲染的首屏，包含交互的<code>SPA</code></li>\n</ul>\n<h2> 二、解决了什么</h2>\n<p>SSR 主要解决了以下两种问题：</p>\n<ul>\n<li>seo：搜索引擎优先爬取页面<code>HTML</code>结构，使用<code>ssr</code>时，服务端已经生成了和业务想关联的<code>HTML</code>，有利于<code>seo</code></li>\n<li>首屏呈现渲染：用户无需等待页面所有<code>js</code>加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端）</li>\n</ul>\n<p>但是使用<code>SSR</code>同样存在以下的缺点：</p>\n<ul>\n<li>\n<p>复杂度：整个项目的复杂度</p>\n</li>\n<li>\n<p>库的支持性，代码兼容</p>\n</li>\n<li>\n<p>性能问题</p>\n<ul>\n<li>\n<p>每个请求都是<code>n</code>个实例的创建，不然会污染，消耗会变得很大</p>\n</li>\n<li>\n<p>缓存 <code>node serve</code>、 <code>nginx</code>判断当前用户有没有过期，如果没过期的话就缓存，用刚刚的结果。</p>\n</li>\n<li>\n<p>降级：监控<code>cpu</code>、内存占用过多，就<code>spa</code>，返回单个的壳</p>\n</li>\n</ul>\n</li>\n<li>\n<p>服务器负载变大，相对于前后端分离服务器只需要提供静态资源来说，服务器负载更大，所以要慎重使用</p>\n</li>\n</ul>\n<p>所以在我们选择是否使用<code>SSR</code>前，我们需要慎重问问自己这些问题：</p>\n<ol>\n<li>需要<code>SEO</code>的页面是否只是少数几个，这些是否可以使用预渲染（Prerender SPA Plugin）实现</li>\n<li>首屏的请求响应逻辑是否复杂，数据返回是否大量且缓慢</li>\n</ol>\n<h2> 三、如何实现</h2>\n<p>对于同构开发，我们依然使用<code>webpack</code>打包，我们要解决两个问题：服务端首屏渲染和客户端激活</p>\n<p>这里需要生成一个服务器<code>bundle</code>文件用于服务端首屏渲染和一个客户端<code>bundle</code>文件用于客户端激活</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9dcd12c0-4986-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>代码结构 除了两个不同入口之外，其他结构和之前<code>vue</code>应用完全相同</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>路由配置</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>主文件 main.js</p>\n<p>跟之前不同，主文件是负责创建<code>vue</code>实例的工厂，每次请求均会有独立的<code>vue</code>实例创建</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>编写服务端入口<code>src/entry-server.js</code></p>\n<p>它的任务是创建<code>Vue</code>实例并根据传入<code>url</code>指定首屏</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>编写客户端入口<code>entry-client.js</code></p>\n<p>客户端入口只需创建<code>vue</code>实例并执行挂载，这⼀步称为激活</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对<code>webpack</code>进行配置</p>\n<p>安装依赖</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>对<code>vue.config.js</code>进行配置</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对脚本进行配置，安装依赖</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>定义创建脚本<code>package.json</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>执行打包：npm run build</p>\n</blockquote>\n<p>最后修改宿主文件<code>/public/index.html</code></p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<!--vue-ssr-outlet-->   是服务端渲染入口位置，注意不能为了好看而在前后加空格\n</blockquote>\n<p>安装<code>vuex</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>创建<code>vuex</code>工厂函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在<code>main.js</code>文件中挂载<code>store</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>服务器端渲染的是应用程序的\"快照\"，如果应用依赖于⼀些异步数据，那么在开始渲染之前，需要先预取和解析好这些数据</p>\n<p>在<code>store</code>进行一步数据获取</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>组件中的数据预取逻辑</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>服务端数据预取，<code>entry-server.js</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>客户端在挂载到应用程序之前，<code>store</code> 就应该获取到状态，<code>entry-client.js</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>客户端数据预取处理，<code>main.js</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改服务器启动文件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 小结</h3>\n<ul>\n<li>使用<code>ssr</code>不存在单例模式，每次用户请求都会创建一个新的<code>vue</code>实例</li>\n<li>实现<code>ssr</code>需要实现服务端首屏渲染和客户端激活</li>\n<li>服务端异步获取数据<code>asyncData</code>可以分为首屏异步获取和切换组件获取\n<ul>\n<li>首屏异步获取数据，在服务端预渲染的时候就应该已经完成</li>\n<li>切换组件通过<code>mixin</code>混入，在<code>beforeMount</code>钩子完成数据获取</li>\n</ul>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6896007907050487816\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6896007907050487816</a></li>\n<li><a href=\"https://vue3js.cn/docs/zh\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn/docs/zh</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-15T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？",
      "url": "https://www.h7ml.cn/posts/interview/vue/structure.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/structure.html",
      "summary": "前端物语|面试物语-说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？",
      "content_html": "<h1> 说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b6cd6a60-4aba-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、为什么要划分</h2>\n<p>使用<code>vue</code>构建项目，项目结构清晰会提高开发效率，熟悉项目的各种配置同样会让开发效率更高</p>\n<p>在划分项目结构的时候，需要遵循一些基本的原则：</p>\n<ul>\n<li>文件夹和文件夹内部文件的语义一致性</li>\n<li>单一入口/出口</li>\n<li>就近原则，紧耦合的文件应该放到一起，且应以相对路径引用</li>\n<li>公共的文件应该以绝对路径的方式从根目录引用</li>\n<li><code>/src</code> 外的文件不应该被引入</li>\n</ul>\n<h3> 文件夹和文件夹内部文件的语义一致性</h3>\n<p>我们的目录结构都会有一个文件夹是按照路由模块来划分的，如<code>pages</code>文件夹，这个文件夹里面应该包含我们项目所有的路由模块，并且仅应该包含路由模块，而不应该有别的其他的非路由模块的文件夹</p>\n<p>这样做的好处在于一眼就从 <code>pages</code>文件夹看出这个项目的路由有哪些</p>\n<h3> 单一入口/出口</h3>\n<p>举个例子，在<code>pages</code>文件夹里面存在一个<code>seller</code>文件夹，这时候<code>seller</code> 文件夹应该作为一个独立的模块由外部引入，并且 <code>seller/index.js</code> 应该作为外部引入 seller 模块的唯一入口</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样做的好处在于，无论你的模块文件夹内部有多乱，外部引用的时候，都是从一个入口文件引入，这样就很好的实现了隔离，如果后续有重构需求，你就会发现这种方式的优点</p>\n<h3> 就近原则，紧耦合的文件应该放到一起，且应以相对路径引用</h3>\n<p>使用相对路径可以保证模块内部的独立性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>举个例子</p>\n<p>假设我们现在的 seller 目录是在 <code>src/pages/seller</code>，如果我们后续发生了路由变更，需要加一个层级，变成 <code>src/pages/user/seller</code>。</p>\n<p>如果我们采用第一种相对路径的方式，那就可以直接将整个文件夹拖过去就好，<code>seller</code> 文件夹内部不需要做任何变更。</p>\n<p>但是如果我们采用第二种绝对路径的方式，移动文件夹的同时，还需要对每个 <code>import</code> 的路径做修改</p>\n<h3> 公共的文件应该以绝对路径的方式从根目录引用</h3>\n<p>公共指的是多个路由模块共用，如一些公共的组件，我们可以放在<code>src/components</code>下</p>\n<p>在使用到的页面中，采用绝对路径的形式引用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同样的，如果我们需要对文件夹结构进行调整。将 <code>/src/components/input</code> 变成 <code>/src/components/new/input</code>，如果使用绝对路径，只需要全局搜索替换</p>\n<p>再加上绝对路径有全局的语义，相对路径有独立模块的语义</p>\n<h3> /src 外的文件不应该被引入</h3>\n<p><code>vue-cli</code>脚手架已经帮我们做了相关的约束了，正常我们的前端项目都会有个<code>src</code>文件夹，里面放着所有的项目需要的资源，<code>js</code>,<code>css</code>, <code>png</code>, <code>svg</code> 等等。<code>src</code> 外会放一些项目配置，依赖，环境等文件</p>\n<p>这样的好处是方便划分项目代码文件和配置文件</p>\n<h2> 二、目录结构</h2>\n<p>单页面目录结构</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>多页面目录结构</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 小结</h3>\n<p>项目的目录结构很重要，因为目录结构能体现很多东西，怎么规划目录结构可能每个人有自己的理解，但是按照一定的规范去进行目录的设计，能让项目整个架构看起来更为简洁，更加易用</p>\n<h2> 参考文献</h2>\n<ul>\n<li>\n<p><a href=\"https://juejin.cn/post/6844904129186234381#heading-0\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904129186234381#heading-0</a></p>\n</li>\n<li>\n<p><a href=\"https://zhuanlan.zhihu.com/p/89693668\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/89693668</a></p>\n</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-14T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路",
      "url": "https://www.h7ml.cn/posts/interview/vue/vnode.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/vnode.html",
      "summary": "前端物语|面试物语-什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路",
      "content_html": "<h1> 什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/770b9670-442c-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、什么是虚拟 DOM</h2>\n<p>虚拟 DOM （<code>Virtual DOM</code> ）这个概念相信大家都不陌生，从 <code>React</code> 到 <code>Vue</code> ，虚拟 <code>DOM</code> 为这两个框架都带来了跨平台的能力（<code>React-Native</code> 和 <code>Weex</code>）</p>\n<p>实际上它只是一层对真实<code>DOM</code>的抽象，以<code>JavaScript</code> 对象 (<code>VNode</code> 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上</p>\n<p>在<code>Javascript</code>对象中，虚拟<code>DOM</code> 表现为一个 <code>Object</code>对象。并且最少包含标签名 (<code>tag</code>)、属性 (<code>attrs</code>) 和子元素对象 (<code>children</code>) 三个属性，不同框架对这三个属性的名命可能会有差别</p>\n<p>创建虚拟<code>DOM</code>就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟<code>DOM</code>对象的节点与真实<code>DOM</code>的属性一一照应</p>\n<p>在<code>vue</code>中同样使用到了虚拟<code>DOM</code>技术</p>\n<p>定义真实<code>DOM</code></p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实例化<code>vue</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>观察<code>render</code>的<code>render</code>，我们能得到虚拟<code>DOM</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过<code>VNode</code>，<code>vue</code>可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过<code>diff</code>算法得出一些需要修改的最小单位,再更新视图，减少了<code>dom</code>操作，提高了性能</p>\n<h2> 二、为什么需要虚拟 DOM</h2>\n<p><code>DOM</code>是很慢的，其元素非常庞大，页面的性能问题，大部分都是由<code>DOM</code>操作引起的</p>\n<p>真实的<code>DOM</code>节点，哪怕一个最简单的<code>div</code>也包含着很多属性，可以打印出来直观感受一下： <img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/cc95c7f0-442c-11eb-ab90-d9ae814b240d.png\" alt=\"\" loading=\"lazy\"></p>\n<p>由此可见，操作<code>DOM</code>的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验</p>\n<p><strong>举个例子：</strong></p>\n<p>你用传统的原生<code>api</code>或<code>jQuery</code>去操作<code>DOM</code>时，浏览器会从构建<code>DOM</code>树开始从头到尾执行一遍流程</p>\n<p>当你在一次操作时，需要更新 10 个<code>DOM</code>节点，浏览器没这么智能，收到第一个更新<code>DOM</code>请求后，并不知道后续还有 9 次更新操作，因此会马上执行流程，最终执行 10 次流程</p>\n<p>而通过<code>VNode</code>，同样更新 10 个<code>DOM</code>节点，虚拟<code>DOM</code>不会立即操作<code>DOM</code>，而是将这 10 次更新的<code>diff</code>内容保存到本地的一个<code>js</code>对象中，最终将这个<code>js</code>对象一次性<code>attach</code>到<code>DOM</code>树上，避免大量的无谓计算</p>\n<blockquote>\n<p>很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI</p>\n</blockquote>\n<h2> 三、如何实现虚拟 DOM</h2>\n<p>首先可以看看<code>vue</code>中<code>VNode</code>的结构</p>\n<p>源码位置：src/core/vdom/vnode.js</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里对<code>VNode</code>进行稍微的说明：</p>\n<ul>\n<li>所有对象的 <code>context</code> 选项都指向了 <code>Vue</code> 实例</li>\n<li><code>elm</code> 属性则指向了其相对应的真实 <code>DOM</code> 节点</li>\n</ul>\n<p><code>vue</code>是通过<code>createElement</code>生成<code>VNode</code></p>\n<p>源码位置：src/core/vdom/create-element.js</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面可以看到<code>createElement</code> 方法实际上是对 <code>_createElement</code> 方法的封装，对参数的传入进行了判断</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到<code>_createElement</code>接收 5 个参数：</p>\n<ul>\n<li>\n<p><code>context</code> 表示 <code>VNode</code> 的上下文环境，是 <code>Component</code> 类型</p>\n</li>\n<li>\n<p>tag 表示标签，它可以是一个字符串，也可以是一个 <code>Component</code></p>\n</li>\n<li>\n<p><code>data</code> 表示 <code>VNode</code> 的数据，它是一个 <code>VNodeData</code> 类型</p>\n</li>\n<li>\n<p><code>children</code> 表示当前 <code>VNode</code>的子节点，它是任意类型的</p>\n</li>\n<li>\n<p><code>normalizationType</code> 表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 <code>render</code> 函数是编译生成的还是用户手写的</p>\n</li>\n</ul>\n<p>根据<code>normalizationType</code> 的类型，<code>children</code>会有不同的定义</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>simpleNormalizeChildren</code>方法调用场景是 <code>render</code> 函数是编译生成的</p>\n<p><code>normalizeChildren</code>方法调用场景分为下面两种：</p>\n<ul>\n<li><code>render</code> 函数是用户手写的</li>\n<li>编译 <code>slot</code>、<code>v-for</code> 的时候会产生嵌套数组</li>\n</ul>\n<p>无论是<code>simpleNormalizeChildren</code>还是<code>normalizeChildren</code>都是对<code>children</code>进行规范（使<code>children</code> 变成了一个类型为 <code>VNode</code> 的 <code>Array</code>），这里就不展开说了</p>\n<p>规范化<code>children</code>的源码位置在：src/core/vdom/helpers/normalzie-children.js</p>\n<p>在规范化<code>children</code>后，就去创建<code>VNode</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>createComponent</code>同样是创建<code>VNode</code></p>\n<p>源码位置：src/core/vdom/create-component.js</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>稍微提下<code>createComponent</code>生成<code>VNode</code>的三个关键流程：</p>\n<ul>\n<li>构造子类构造函数<code>Ctor</code></li>\n<li><code>installComponentHooks</code>安装组件钩子函数</li>\n<li>实例化 <code>vnode</code></li>\n</ul>\n<h3> 小结</h3>\n<p><code>createElement</code> 创建 <code>VNode</code> 的过程，每个 <code>VNode</code> 有 <code>children</code>，<code>children</code> 每个元素也是一个<code>VNode</code>，这样就形成了一个虚拟树结构，用于描述真实的<code>DOM</code>树结构</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/create-element.html#children-%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96\" target=\"_blank\" rel=\"noopener noreferrer\">https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/create-element.html#children-的规范化</a></li>\n<li><a href=\"https://juejin.cn/post/6876711874050818061\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6876711874050818061</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-09T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "vue3 有了解过吗？能说说跟 vue2 的区别吗？",
      "url": "https://www.h7ml.cn/posts/interview/vue/vue3_vue2.html",
      "id": "https://www.h7ml.cn/posts/interview/vue/vue3_vue2.html",
      "summary": "前端物语|面试物语-vue3 有了解过吗？能说说跟 vue2 的区别吗？",
      "content_html": "<h1> vue3 有了解过吗？能说说跟 vue2 的区别吗？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/774b6950-5087-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、Vue3 介绍</h2>\n<p>关于<code>vue3</code>的重构背景，尤大是这样说的：</p>\n<p>「Vue 新版本的理念成型于 2018 年末，当时 Vue 2 的代码库已经有两岁半了。比起通用软件的生命周期来这好像也没那么久，但在这段时期，前端世界已经今昔非比了</p>\n<p>在我们更新（和重写）Vue 的主要版本时，主要考虑两点因素：首先是新的 JavaScript 语言特性在主流浏览器中的受支持水平；其次是当前代码库中随时间推移而逐渐暴露出来的一些设计和架构问题」</p>\n<p>简要就是：</p>\n<ul>\n<li>利用新的语言特性(es6)</li>\n<li>解决架构问题</li>\n</ul>\n<h2> 哪些变化</h2>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9169a900-5087-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>从上图中，我们可以概览<code>Vue3</code>的新特性，如下：</p>\n<ul>\n<li>速度更快</li>\n<li>体积减少</li>\n<li>更易维护</li>\n<li>更接近原生</li>\n<li>更易使用</li>\n</ul>\n<h3> 速度更快</h3>\n<p><code>vue3</code>相比<code>vue2</code></p>\n<ul>\n<li>\n<p>重写了虚拟<code>Dom</code>实现</p>\n</li>\n<li>\n<p>编译模板的优化</p>\n</li>\n<li>\n<p>更高效的组件初始化</p>\n</li>\n<li>\n<p><code>undate</code>性能提高 1.3~2 倍</p>\n</li>\n<li>\n<p><code>SSR</code>速度提高了 2~3 倍</p>\n</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ac1d23d0-5087-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 体积更小</h3>\n<p>通过<code>webpack</code>的<code>tree-shaking</code>功能，可以将无用模块“剪辑”，仅打包需要的</p>\n<p>能够<code>tree-shaking</code>，有两大好处：</p>\n<ul>\n<li>\n<p>对开发人员，能够对<code>vue</code>实现更多其他的功能，而不必担忧整体体积过大</p>\n</li>\n<li>\n<p>对使用者，打包出来的包体积变小了</p>\n</li>\n</ul>\n<p><code>vue</code>可以开发出更多其他的功能，而不必担忧<code>vue</code>打包出来的整体体积过多</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c01af010-5087-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 更易维护</h3>\n<h4> compositon Api</h4>\n<ul>\n<li>可与现有的<code>Options API</code>一起使用</li>\n<li>灵活的逻辑组合与复用</li>\n<li><code>Vue3</code>模块可以和其他框架搭配使用</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c5c919b0-5087-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h4> 更好的 Typescript 支持</h4>\n<p><code>VUE3</code>是基于<code>typescipt</code>编写的，可以享受到自动的类型定义提示</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/cc688120-5087-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h4> 编译器重写</h4>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/fcd33800-5087-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 更接近原生</h3>\n<p>可以自定义渲染 API</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/0c7d88a0-5088-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 更易使用</h3>\n<p>响应式 <code>Api</code> 暴露出来</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/26070260-5088-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>轻松识别组件重新渲染原因</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/43b2fcb0-5088-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 二、Vue3 新增特性</h2>\n<p>Vue 3 中需要关注的一些新功能包括：</p>\n<ul>\n<li>framents</li>\n<li>Teleport</li>\n<li>composition Api</li>\n<li>createRenderer</li>\n</ul>\n<h3> framents</h3>\n<p>在 <code>Vue3.x</code> 中，组件现在支持有多个根节点</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Teleport</h3>\n<p><code>Teleport</code> 是一种能够将我们的模板移动到 <code>DOM</code> 中 <code>Vue app</code> 之外的其他位置的技术，就有点像哆啦 A 梦的“任意门”</p>\n<p>在<code>vue2</code>中，像 <code>modals</code>,<code>toast</code> 等这样的元素，如果我们嵌套在 <code>Vue</code> 的某个组件内部，那么处理嵌套组件的定位、<code>z-index</code> 和样式就会变得很困难</p>\n<p>通过<code>Teleport</code>，我们可以在组件的逻辑位置写模板代码，然后在 <code>Vue</code> 应用范围之外渲染它</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> createRenderer</h3>\n<p>通过<code>createRenderer</code>，我们能够构建自定义渲染器，我们能够将 <code>vue</code> 的开发模型扩展到其他平台</p>\n<p>我们可以将其生成在<code>canvas</code>画布上</p>\n<figure><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da4437845ec54eb3829313c92fc81afe~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>关于<code>createRenderer</code>，我们了解下基本使用，就不展开讲述了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> composition Api</h3>\n<p>composition Api，也就是组合式<code>api</code>，通过这种形式，我们能够更加容易维护我们的代码，将相同功能的变量进行一个集中式的管理</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5e0bfb70-5088-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>关于<code>compositon api</code>的使用，这里以下图展开</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6f67a590-5088-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>简单使用:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 三、非兼容变更</h3>\n<h3> Global API</h3>\n<ul>\n<li>全局 <code>Vue API</code> 已更改为使用应用程序实例</li>\n<li>全局和内部 <code>API</code> 已经被重构为可 <code>tree-shakable</code></li>\n</ul>\n<h3> 模板指令</h3>\n<ul>\n<li>组件上 <code>v-model</code> 用法已更改</li>\n<li><code>&lt;template v-for&gt;</code>和 非 <code>v-for</code>节点上<code>key</code>用法已更改</li>\n<li>在同一元素上使用的 <code>v-if</code> 和 <code>v-for</code> 优先级已更改</li>\n<li><code>v-bind=\"object\"</code> 现在排序敏感</li>\n<li><code>v-for</code> 中的 <code>ref</code> 不再注册 <code>ref</code> 数组</li>\n</ul>\n<h3> 组件</h3>\n<ul>\n<li>只能使用普通函数创建功能组件</li>\n<li><code>functional</code> 属性在单文件组件 <code>(SFC)</code></li>\n<li>异步组件现在需要 <code>defineAsyncComponent</code> 方法来创建</li>\n</ul>\n<h3> 渲染函数</h3>\n<ul>\n<li>渲染函数<code>API</code>改变</li>\n<li><code>$scopedSlots</code> property 已删除，所有插槽都通过 <code>$slots</code> 作为函数暴露</li>\n<li>自定义指令 API 已更改为与组件生命周期一致</li>\n<li>一些转换 <code>class</code> 被重命名了：\n<ul>\n<li><code>v-enter</code> -&gt; <code>v-enter-from</code></li>\n<li><code>v-leave</code> -&gt; <code>v-leave-from</code></li>\n</ul>\n</li>\n<li>组件 <code>watch</code> 选项和实例方法 <code>$watch</code>不再支持点分隔字符串路径，请改用计算函数作为参数</li>\n<li>在 <code>Vue 2.x</code> 中，应用根容器的 <code>outerHTML</code> 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。<code>VUE3.x</code> 现在使用应用程序容器的 <code>innerHTML</code>。</li>\n</ul>\n<h3> 其他小改变</h3>\n<ul>\n<li><code>destroyed</code> 生命周期选项被重命名为 <code>unmounted</code></li>\n<li><code>beforeDestroy</code> 生命周期选项被重命名为 <code>beforeUnmount</code></li>\n<li><code>[prop default</code>工厂函数不再有权访问 <code>this</code> 是上下文</li>\n<li>自定义指令 API 已更改为与组件生命周期一致</li>\n<li><code>data</code> 应始终声明为函数</li>\n<li>来自 <code>mixin</code> 的 <code>data</code> 选项现在可简单地合并</li>\n<li><code>attribute</code> 强制策略已更改</li>\n<li>一些过渡 <code>class</code> 被重命名</li>\n<li>组建 watch 选项和实例方法 <code>$watch</code>不再支持以点分隔的字符串路径。请改用计算属性函数作为参数。</li>\n<li><code>&lt;template&gt;</code> 没有特殊指令的标记 (<code>v-if/else-if/else</code>、<code>v-for</code> 或 <code>v-slot</code>) 现在被视为普通元素，并将生成原生的 <code>&lt;template&gt;</code> 元素，而不是渲染其内部内容。</li>\n<li>在<code>Vue 2.x</code> 中，应用根容器的 <code>outerHTML</code> 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。<code>Vue 3.x</code> 现在使用应用容器的 <code>innerHTML</code>，这意味着容器本身不再被视为模板的一部分。</li>\n</ul>\n<h3> 移除 API</h3>\n<ul>\n<li><code>keyCode</code> 支持作为 <code>v-on</code> 的修饰符</li>\n<li><code>$on</code>，<code>$off</code>和<code>$once</code> 实例方法</li>\n<li>过滤<code>filter</code></li>\n<li>内联模板 <code>attribute</code></li>\n<li><code>$destroy</code> 实例方法。用户不应再手动管理单个<code>Vue</code> 组件的生命周期。</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://vue3js.cn/docs/zh/guide/migration/introduction.html#%E6%A8%A1%E6%9D%BF%E6%8C%87%E4%BB%A4\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn/docs/zh/guide/migration/introduction.html#模板指令</a></li>\n<li><a href=\"https://composition-api.vuejs.org/zh/#api-%E4%BB%8B%E7%BB%8D\" target=\"_blank\" rel=\"noopener noreferrer\">https://composition-api.vuejs.org/zh/#api-介绍</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-06T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue"
      ]
    },
    {
      "title": "前端物语|面试物语-vue3",
      "url": "https://www.h7ml.cn/posts/interview/vue3/",
      "id": "https://www.h7ml.cn/posts/interview/vue3/",
      "summary": "Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？ Vue3.0 的设计目标是什么？做了哪些优化 用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？ Vue3.0 性能提升主要是通过哪几方面体现的？ Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？ css 选择器有哪些？优先级？哪些属性可以继承？ 说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue3/composition\" target=\"_blank\" rel=\"noopener noreferrer\">Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue3/goal\" target=\"_blank\" rel=\"noopener noreferrer\">Vue3.0 的设计目标是什么？做了哪些优化</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue3/modal_component\" target=\"_blank\" rel=\"noopener noreferrer\">用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue3/performance\" target=\"_blank\" rel=\"noopener noreferrer\">Vue3.0 性能提升主要是通过哪几方面体现的？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue3/proxy\" target=\"_blank\" rel=\"noopener noreferrer\">Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue3/selector\" target=\"_blank\" rel=\"noopener noreferrer\">css 选择器有哪些？优先级？哪些属性可以继承？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/vue3/treeshaking\" target=\"_blank\" rel=\"noopener noreferrer\">说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？</a></li>\n</ul>\n",
      "date_published": "2023-03-29T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "vue3"
      ]
    },
    {
      "title": "Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？",
      "url": "https://www.h7ml.cn/posts/interview/vue3/composition.html",
      "id": "https://www.h7ml.cn/posts/interview/vue3/composition.html",
      "summary": "前端物语|面试物语-Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？",
      "content_html": "<h1> Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8d6dd7b0-6048-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 开始之前</h2>\n<p><code>Composition API</code> 可以说是<code>Vue3</code>的最大特点，那么为什么要推出<code>Composition Api</code>，解决了什么问题？</p>\n<p>通常使用<code>Vue2</code>开发的项目，普遍会存在以下问题：</p>\n<ul>\n<li>代码的可读性随着组件变大而变差</li>\n<li>每一种代码复用的方式，都存在缺点</li>\n<li>TypeScript 支持有限</li>\n</ul>\n<p>以上通过使用<code>Composition Api</code>都能迎刃而解</p>\n<h2> 正文</h2>\n<h3> 一、Options Api</h3>\n<p><code>Options API</code>，即大家常说的选项 API，即以<code>vue</code>为后缀的文件，通过定义<code>methods</code>，<code>computed</code>，<code>watch</code>，<code>data</code>等属性与方法，共同处理页面逻辑</p>\n<p>如下图：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9bf6d9d0-6048-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>可以看到<code>Options</code>代码编写方式，如果是组件状态，则写在<code>data</code>属性上，如果是方法，则写在<code>methods</code>属性上...</p>\n<p>用组件的选项 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组织逻辑在大多数情况下都有效</p>\n<p>然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解</p>\n<h3> 二、Composition Api</h3>\n<p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p>\n<p>即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/acee9200-6048-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 三、对比</h3>\n<p>下面对<code>Composition Api</code>与<code>Options Api</code>进行两大方面的比较</p>\n<ul>\n<li>逻辑组织</li>\n<li>逻辑复用</li>\n</ul>\n<h4> 逻辑组织</h4>\n<h5> Options API</h5>\n<p>假设一个组件是一个大型组件，其内部有很多处理逻辑关注点（对应下图不用颜色）</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/dc83d070-6048-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>可以看到，这种碎片化使得理解和维护复杂组件变得困难</p>\n<p>选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块</p>\n<h5> Compostion API</h5>\n<p>而<code>Compositon API</code>正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去</p>\n<p>下面举个简单例子，将处理<code>count</code>属性相关的代码放在同一个函数了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>组件上中使用<code>count</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再来一张图进行对比，可以很直观地感受到 <code>Composition API</code>在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e5804bc0-5c58-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h4> 逻辑复用</h4>\n<p>在<code>Vue2</code>中，我们是用过<code>mixin</code>去复用相同的逻辑</p>\n<p>下面举个例子，我们会另起一个<code>mixin.js</code>文件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后在组件中使用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用单个<code>mixin</code>似乎问题不大，但是当我们一个组件混入大量不同的 <code>mixins</code> 的时候</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>会存在两个非常明显的问题：</p>\n<ul>\n<li>命名冲突</li>\n<li>数据来源不清晰</li>\n</ul>\n<p>现在通过<code>Compositon API</code>这种方式改写上面的代码</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在组件中使用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题</p>\n<h3> 小结</h3>\n<ul>\n<li>在逻辑组织和逻辑复用方面，<code>Composition API</code>是优于<code>Options API</code></li>\n<li>因为<code>Composition API</code>几乎是函数，会有更好的类型推断。</li>\n<li><code>Composition API</code>对 <code>tree-shaking</code> 友好，代码也更容易压缩</li>\n<li><code>Composition API</code>中见不到<code>this</code>的使用，减少了<code>this</code>指向不明的情况</li>\n<li>如果是小型组件，可以继续使用<code>Options API</code>，也是十分友好的</li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-15T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue3"
      ]
    },
    {
      "title": "Vue3.0 的设计目标是什么？做了哪些优化",
      "url": "https://www.h7ml.cn/posts/interview/vue3/goal.html",
      "id": "https://www.h7ml.cn/posts/interview/vue3/goal.html",
      "summary": "前端物语|面试物语-Vue3.0 的设计目标是什么？做了哪些优化",
      "content_html": "<h1> Vue3.0 的设计目标是什么？做了哪些优化</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b93b49c0-5c58-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、设计目标</h2>\n<p>不以解决实际业务痛点的更新都是耍流氓，下面我们来列举一下<code>Vue3</code>之前我们或许会面临的问题</p>\n<ul>\n<li>\n<p>随着功能的增长，复杂组件的代码变得越来越难以维护</p>\n</li>\n<li>\n<p>缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制</p>\n</li>\n<li>\n<p>类型推断不够友好</p>\n</li>\n<li>\n<p><code>bundle</code>的时间太久了</p>\n</li>\n</ul>\n<p>而 <code>Vue3</code> 经过长达两三年时间的筹备，做了哪些事情？</p>\n<p>我们从结果反推</p>\n<ul>\n<li>更小</li>\n<li>更快</li>\n<li>TypeScript 支持</li>\n<li>API 设计一致性</li>\n<li>提高自身可维护性</li>\n<li>开放更多底层功能</li>\n</ul>\n<p>一句话概述，就是更小更快更友好了</p>\n<h3> 更小</h3>\n<p><code>Vue3</code>移除一些不常用的 <code>API</code></p>\n<p>引入<code>tree-shaking</code>，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了</p>\n<h3> 更快</h3>\n<p>主要体现在编译方面：</p>\n<ul>\n<li>diff 算法优化</li>\n<li>静态提升</li>\n<li>事件监听缓存</li>\n<li>SSR 优化</li>\n</ul>\n<p>下篇文章我们会进一步介绍</p>\n<h3> 更友好</h3>\n<p><code>vue3</code>在兼顾<code>vue2</code>的<code>options API</code>的同时还推出了<code>composition API</code>，大大增加了代码的逻辑组织和代码复用能力</p>\n<p>这里代码简单演示下：</p>\n<p>存在一个获取鼠标位置的函数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们只需要调用这个函数，即可获取<code>x</code>、<code>y</code>的坐标，完全不用关注实现过程</p>\n<p>试想一下，如果很多类似的第三方库，我们只需要调用即可，不必关注实现过程，开发效率大大提高</p>\n<p>同时，<code>VUE3</code>是基于<code>typescipt</code>编写的，可以享受到自动的类型定义提示</p>\n<h2> 三、优化方案</h2>\n<p><code>vue3</code>从很多层面都做了优化，可以分成三个方面：</p>\n<ul>\n<li>源码</li>\n<li>性能</li>\n<li>语法 API</li>\n</ul>\n<h3> 源码</h3>\n<p>源码可以从两个层面展开：</p>\n<ul>\n<li>源码管理</li>\n<li>TypeScript</li>\n</ul>\n<h4> 源码管理</h4>\n<p><code>vue3</code>整个源码是通过 <code>monorepo</code>的方式维护的，根据功能将不同的模块拆分到<code>packages</code>目录下面不同的子目录中</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d7c32520-5c58-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性</p>\n<p>另外一些 <code>package</code>（比如 <code>reactivity</code> 响应式库）是可以独立于 <code>Vue</code> 使用的，这样用户如果只想使用 <code>Vue3</code>的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 <code>Vue</code></p>\n<h4> TypeScript</h4>\n<p><code>Vue3</code>是基于<code>typeScript</code>编写的，提供了更好的类型检查，能支持复杂的类型推导</p>\n<h3> 性能</h3>\n<p><code>vue3</code>是从什么哪些方面对性能进行进一步优化呢？</p>\n<ul>\n<li>体积优化</li>\n<li>编译优化</li>\n<li>数据劫持优化</li>\n</ul>\n<p>这里讲述数据劫持：</p>\n<p>在<code>vue2</code>中，数据劫持是通过<code>Object.defineProperty</code>，这个 API 有一些缺陷，并不能检测对象属性的添加和删除</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>尽管<code>Vue</code>为了解决这个问题提供了 <code>set</code>和<code>delete</code>实例方法，但是对于用户来说，还是增加了一定的心智负担</p>\n<p>同时在面对嵌套层级比较深的情况下，就存在性能问题</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>相比之下，<code>vue3</code>是通过<code>proxy</code>监听整个对象，那么对于删除还是监听当然也能监听到</p>\n<p>同时<code>Proxy</code> 并不能监听到内部深层次的对象变化，而 <code>Vue3</code> 的处理方式是在<code>getter</code> 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归</p>\n<h3> 语法 API</h3>\n<p>这里当然说的就是<code>composition API</code>，其两大显著的优化：</p>\n<ul>\n<li>优化逻辑组织</li>\n<li>优化逻辑复用</li>\n</ul>\n<h4> 逻辑组织</h4>\n<p>一张图，我们可以很直观地感受到 <code>Composition API</code>在逻辑组织方面的优势</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e5804bc0-5c58-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>相同功能的代码编写在一块，而不像<code>options API</code>那样，各个功能的代码混成一块</p>\n<h4> 逻辑复用</h4>\n<p>在<code>vue2</code>中，我们是通过<code>mixin</code>实现功能混合，如果多个<code>mixin</code>混合，会存在两个非常明显的问题：命名冲突和数据来源不清晰</p>\n<p>而通过<code>composition</code>这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可</p>\n<p>同样是上文的获取鼠标位置的例子</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>组件使用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，整个数据来源清晰了，即使去编写更多的<code>hook</code>函数，也不会出现命名冲突的问题</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6850418112878575629#heading-5\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6850418112878575629#heading-5</a></li>\n<li><a href=\"https://vue3js.cn/docs/zh\" target=\"_blank\" rel=\"noopener noreferrer\">https://vue3js.cn/docs/zh</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-13T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue3"
      ]
    },
    {
      "title": "用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？",
      "url": "https://www.h7ml.cn/posts/interview/vue3/modal_component.html",
      "id": "https://www.h7ml.cn/posts/interview/vue3/modal_component.html",
      "summary": "前端物语|面试物语-用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？",
      "content_html": "<h1> 用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e294c660-6370-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、组件设计</h2>\n<p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式</p>\n<p>现在有一个场景，点击新增与编辑都弹框出来进行填写，功能上大同小异，可能只是标题内容或者是显示的主体内容稍微不同</p>\n<p>这时候就没必要写两个组件，只需要根据传入的参数不同，组件显示不同内容即可</p>\n<p>这样，下次开发相同界面程序时就可以写更少的代码，意义着更高的开发效率，更少的 <code>Bug</code>和更少的程序体积</p>\n<h2> 二、需求分析</h2>\n<p>实现一个<code>Modal</code>组件，首先确定需要完成的内容：</p>\n<ul>\n<li>\n<p>遮罩层</p>\n</li>\n<li>\n<p>标题内容</p>\n</li>\n<li>\n<p>主体内容</p>\n</li>\n<li>\n<p>确定和取消按钮</p>\n</li>\n</ul>\n<p>主体内容需要灵活，所以可以是字符串，也可以是一段 <code>html</code> 代码</p>\n<p>特点是它们在当前<code>vue</code>实例之外独立存在，通常挂载于<code>body</code>之上</p>\n<p>除了通过引入<code>import</code>的形式，我们还可通过<code>API</code>的形式进行组件的调用</p>\n<p>还可以包括配置全局样式、国际化、与<code>typeScript</code>结合</p>\n<h2> 三、实现流程</h2>\n<p>首先看看大致流程：</p>\n<ul>\n<li>\n<p>目录结构</p>\n</li>\n<li>\n<p>组件内容</p>\n</li>\n<li>\n<p>实现 API 形式</p>\n</li>\n<li>\n<p>事件处理</p>\n</li>\n<li>\n<p>其他完善</p>\n</li>\n</ul>\n<h3> 目录结构</h3>\n<p><code>Modal</code>组件相关的目录结构</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>因为 Modal 会被 <code>app.use(Modal)</code> 调用作为一个插件，所以都放在<code>plugins</code>目录下</p>\n<h3> 组件内容</h3>\n<p>首先实现<code>modal.vue</code>的主体显示内容大致如下</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>最外层上通过 Vue3 <code>Teleport</code> 内置组件进行包裹，其相当于传送门，将里面的内容传送至<code>body</code>之上</p>\n<p>并且从<code>DOM</code>结构上来看，把<code>modal</code>该有的内容（遮罩层、标题、内容、底部按钮）都实现了</p>\n<p>关于主体内容</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到根据传入<code>content</code>的类型不同，对应显示不同得到内容</p>\n<p>最常见的则是通过调用字符串和默认插槽的形式</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过 API 形式调用<code>Modal</code>组件的时候，<code>content</code>可以使用下面两种</p>\n<ul>\n<li>h 函数</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>JSX</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 实现 API 形式</h3>\n<p>那么组件如何实现<code>API</code>形式调用<code>Modal</code>组件呢？</p>\n<p>在<code>Vue2</code>中，我们可以借助<code>Vue</code>实例以及<code>Vue.extend</code>的方式获得组件实例，然后挂载到<code>body</code>上</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>虽然<code>Vue3</code>移除了<code>Vue.extend</code>方法，但可以通过<code>createVNode</code>实现</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在<code>Vue2</code>中，可以通过<code>this</code>的形式调用全局 API</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>而在 Vue3 的 <code>setup</code> 中已经没有 <code>this</code>概念了，需要调用<code>app.config.globalProperties</code>挂载到全局</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 事件处理</h3>\n<p>下面再看看看<code>Modal</code>组件内部是如何处理「确定」「取消」事件的，既然是<code>Vue3</code>，当然采用<code>Compositon API</code> 形式</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在上面代码中，可以看得到除了使用传统<code>emit</code>的形式使父组件监听，还可通过<code>_hub</code>属性中添加 <code>on-cancel</code>，<code>on-confirm</code>方法实现在<code>API</code>中进行监听</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面再来目睹下<code>_hub</code>是如何实现</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 其他完善</h3>\n<p>关于组件实现国际化、与<code>typsScript</code>结合，大家可以根据自身情况在此基础上进行更改</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000038928664\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000038928664</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-03T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue3"
      ]
    },
    {
      "title": "Vue3.0 性能提升主要是通过哪几方面体现的？",
      "url": "https://www.h7ml.cn/posts/interview/vue3/performance.html",
      "id": "https://www.h7ml.cn/posts/interview/vue3/performance.html",
      "summary": "前端物语|面试物语-Vue3.0 性能提升主要是通过哪几方面体现的？",
      "content_html": "<h1> Vue3.0 性能提升主要是通过哪几方面体现的？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/2aac1020-5ed0-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、编译阶段</h2>\n<p>回顾<code>Vue2</code>，我们知道每个组件实例都对应一个 <code>watcher</code> 实例，它会在组件渲染的过程中把用到的数据<code>property</code>记录为依赖，当依赖发生改变，触发<code>setter</code>，则会通知<code>watcher</code>，从而使关联的组件重新渲染</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/39066120-5ed0-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>试想一下，一个组件结构如下图</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 <code>diff</code> 和遍历其实都是不需要的，造成性能浪费</p>\n<p>因此，<code>Vue3</code>在编译阶段，做了进一步优化。主要有如下：</p>\n<ul>\n<li>diff 算法优化</li>\n<li>静态提升</li>\n<li>事件监听缓存</li>\n<li>SSR 优化</li>\n</ul>\n<h4> diff 算法优化</h4>\n<p><code>vue3</code>在<code>diff</code>算法中相比<code>vue2</code>增加了静态标记</p>\n<p>关于这个静态标记，其作用是为了会发生变化的地方添加一个<code>flag</code>标记，下次发生变化的时候直接找该地方进行比较</p>\n<p>下图这里，已经标记静态节点的<code>p</code>标签在<code>diff</code>过程中则不会比较，把性能进一步提高</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c732e150-5c58-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>关于静态类型枚举如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 静态提升</h4>\n<p><code>Vue3</code>中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用</p>\n<p>这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>没有做静态提升之前</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>做了静态提升之后</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>静态内容<code>_hoisted_1</code>被放置在<code>render</code> 函数外，每次渲染的时候只要取 <code>_hoisted_1</code> 即可</p>\n<p>同时 <code>_hoisted_1</code> 被打上了 <code>PatchFlag</code> ，静态标记值为 -1 ，特殊标志是负整数表示永远不会用于 Diff</p>\n<h4> 事件监听缓存</h4>\n<p>默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>没开启事件监听器缓存</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>开启事件侦听器缓存后</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述发现开启了缓存后，没有了静态标记。也就是说下次<code>diff</code>算法的时候直接使用</p>\n<h4> SSR 优化</h4>\n<p>当静态内容大到一定量级时候，会用<code>createStaticVNode</code>方法在客户端去生成一个 static node，这些静态<code>node</code>，会被直接<code>innerHtml</code>，就不需要创建对象，然后根据对象渲染</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>编译后</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、源码体积</h2>\n<p>相比<code>Vue2</code>，<code>Vue3</code>整体体积变小了，除了移出一些不常用的 API，再重要的是<code>Tree shanking</code></p>\n<p>任何一个函数，如<code>ref</code>、<code>reavtived</code>、<code>computed</code>等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、响应式系统</h2>\n<p><code>vue2</code>中采用 <code>defineProperty</code>来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加<code>getter</code>和<code>setter</code>，实现响应式</p>\n<p><code>vue3</code>采用<code>proxy</code>重写了响应式系统，因为<code>proxy</code>可以对整个对象进行监听，所以不需要深度遍历</p>\n<ul>\n<li>可以监听动态属性的添加</li>\n<li>可以监听到数组的索引和数组<code>length</code>属性</li>\n<li>可以监听删除属性</li>\n</ul>\n<p>关于这两个 API 具体的不同，我们下篇文章会进行一个更加详细的介绍</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://juejin.cn/post/6903171037211557895\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6903171037211557895</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-29T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue3"
      ]
    },
    {
      "title": "Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？",
      "url": "https://www.h7ml.cn/posts/interview/vue3/proxy.html",
      "id": "https://www.h7ml.cn/posts/interview/vue3/proxy.html",
      "summary": "前端物语|面试物语-Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？",
      "content_html": "<h1> Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/57aa5c80-5f7f-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、Object.defineProperty</h2>\n<p>定义：<code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象</p>\n<h5> 为什么能实现响应式</h5>\n<p>通过<code>defineProperty</code> 两个属性，<code>get</code>及<code>set</code></p>\n<ul>\n<li>get</li>\n</ul>\n<p>属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的 this 并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值</p>\n<ul>\n<li>set</li>\n</ul>\n<p>属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined</p>\n<p>下面通过代码展示：</p>\n<p>定义一个响应式函数<code>defineReactive</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>调用<code>defineReactive</code>，数据发生变化触发<code>update</code>方法，实现数据响应式</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在对象存在多个<code>key</code>情况下，需要进行遍历</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果存在嵌套对象的情况，还需要在<code>defineReactive</code>中进行递归</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当给<code>key</code>赋值为对象的时候，还需要在<code>set</code>属性中进行递归</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题</p>\n<p>现在对一个对象进行删除与添加属性操作，无法劫持到</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当我们对一个数组进行监听的时候，并不那么好使了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到数据的<code>api</code>无法劫持到，从而无法实现数据响应式，</p>\n<p>所以在<code>Vue2</code>中，增加了<code>set</code>、<code>delete</code> API，并且对数组<code>api</code>方法进行一个重写</p>\n<p>还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题</p>\n<h3> 小结</h3>\n<ul>\n<li>检测不到对象属性的添加和删除</li>\n<li>数组<code>API</code>方法无法监听到</li>\n<li>需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题</li>\n</ul>\n<h2> 二、proxy</h2>\n<p><code>Proxy</code>的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了</p>\n<p>在<code>ES6</code>系列中，我们详细讲解过<code>Proxy</code>的使用，就不再述说了</p>\n<p>下面通过代码进行展示：</p>\n<p>定义一个响应式方法<code>reactive</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>测试一下简单数据的操作，发现都能劫持</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再测试嵌套对象情况，这时候发现就不那么 OK 了</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果要解决，需要在<code>get</code>之上再进行一层代理</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、总结</h2>\n<p><code>Object.defineProperty</code>只能遍历对象属性进行劫持</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Proxy</code>直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Proxy</code>可以直接监听数组的变化（<code>push</code>、<code>shift</code>、<code>splice</code>）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Proxy</code>有多达 13 种拦截方法,不限于<code>apply</code>、<code>ownKeys</code>、<code>deleteProperty</code>、<code>has</code>等等，这是<code>Object.defineProperty</code>不具备的</p>\n<p>正因为<code>defineProperty</code>自身的缺陷，导致<code>Vue2</code>在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外<code>set</code>、<code>delete</code>方法）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Proxy</code> 不兼容 IE，也没有 <code>polyfill</code>, <code>defineProperty</code> 能支持到 IE9</p>\n<h3> 参考文献</h3>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-25T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue3"
      ]
    },
    {
      "title": "css 选择器有哪些？优先级？哪些属性可以继承？",
      "url": "https://www.h7ml.cn/posts/interview/vue3/selector.html",
      "id": "https://www.h7ml.cn/posts/interview/vue3/selector.html",
      "summary": "前端物语|面试物语-css 选择器有哪些？优先级？哪些属性可以继承？",
      "content_html": "<h1> css 选择器有哪些？优先级？哪些属性可以继承？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/f7dcd330-8fe1-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、选择器</h2>\n<p>CSS 选择器是 CSS 规则的第一部分</p>\n<p>它是元素和其他部分组合起来告诉浏览器哪个 HTML 元素应当是被选为应用规则中的 CSS 属性值的方式</p>\n<p>选择器所选择的元素，叫做“选择器的对象”</p>\n<p>我们从一个<code>Html</code>结构开始</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于<code>css</code>属性选择器常用的有：</p>\n<ul>\n<li>\n<p>id 选择器（#box），选择 id 为 box 的元素</p>\n</li>\n<li>\n<p>类选择器（.one），选择类名为 one 的所有元素</p>\n</li>\n<li>\n<p>标签选择器（div），选择标签为 div 的所有元素</p>\n</li>\n<li>\n<p>后代选择器（#box div），选择 id 为 box 元素内部所有的 div 元素</p>\n</li>\n<li>\n<p>子选择器（.one&gt;one_1），选择父元素为.one 的所有.one_1 的元素</p>\n</li>\n<li>\n<p>相邻同胞选择器（.one+.two），选择紧接在.one 之后的所有.two 元素</p>\n</li>\n<li>\n<p>群组选择器（div,p），选择 div、p 的所有元素</p>\n</li>\n</ul>\n<p>还有一些使用频率相对没那么多的选择器：</p>\n<ul>\n<li>伪类选择器</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>伪元素选择器</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>属性选择器</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在<code>CSS3</code>中新增的选择器有如下：</p>\n<ul>\n<li>层次选择器（p~ul），选择前面有 p 元素的每个 ul 元素</li>\n<li>伪类选择器</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>属性选择器</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、优先级</h2>\n<p>相信大家对<code>CSS</code>选择器的优先级都不陌生：</p>\n<blockquote>\n<p>内联 &gt; ID 选择器 &gt; 类选择器 &gt; 标签选择器</p>\n</blockquote>\n<p>到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p>\n<ul>\n<li>\n<p>如果存在内联样式，那么 A = 1, 否则 A = 0</p>\n</li>\n<li>\n<p>B 的值等于 ID 选择器出现的次数</p>\n</li>\n<li>\n<p>C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数</p>\n</li>\n<li>\n<p>D 的值等于 标签选择器 和 伪元素 出现的总次数</p>\n</li>\n</ul>\n<p>这里举个例子：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>套用上面的算法，依次求出 <code>A</code> <code>B</code> <code>C</code> <code>D</code> 的值：</p>\n<ul>\n<li>\n<p>因为没有内联样式 ，所以 A = 0</p>\n</li>\n<li>\n<p>ID 选择器总共出现了 1 次， B = 1</p>\n</li>\n<li>\n<p>类选择器出现了 1 次， 属性选择器出现了 0 次，伪类选择器出现 0 次，所以 C = (1 + 0 + 0) = 1</p>\n</li>\n<li>\n<p>标签选择器出现了 3 次， 伪元素出现了 0 次，所以 D = (3 + 0) = 3</p>\n</li>\n</ul>\n<p>上面算出的<code>A</code> 、 <code>B</code>、<code>C</code>、<code>D</code> 可以简记作：<code>(0, 1, 1, 3)</code></p>\n<p>知道了优先级是如何计算之后，就来看看比较规则：</p>\n<ul>\n<li>从左往右依次进行比较 ，较大者优先级更高</li>\n<li>如果相等，则继续往右移动一位进行比较</li>\n<li>如果 4 位全部相等，则后面的会覆盖前面的</li>\n</ul>\n<p>经过上面的优先级计算规则，我们知道内联样式的优先级最高，如果外部样式需要覆盖内联样式，就需要使用<code>!important</code></p>\n<h2> 三、继承属性</h2>\n<p>在<code>css</code>中，继承是指的是给父元素设置一些属性，后代元素会自动拥有这些属性</p>\n<p>关于继承属性，可以分成：</p>\n<ul>\n<li>字体系列属性</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>文本系列属性</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>元素可见性</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>表格布局属性</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>列表属性</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>引用</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>光标属性</li>\n</ul>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>继承中比较特殊的几点：</p>\n<ul>\n<li>\n<p>a 标签的字体颜色不能被继承</p>\n</li>\n<li>\n<p>h1-h6 标签字体的大下也是不能被继承的</p>\n</li>\n</ul>\n<h3> 无继承的属性</h3>\n<ul>\n<li>\n<p>display</p>\n</li>\n<li>\n<p>文本属性：vertical-align、text-decoration</p>\n</li>\n<li>\n<p>盒子模型的属性：宽度、高度、内外边距、边框等</p>\n</li>\n<li>\n<p>背景属性：背景图片、颜色、位置等</p>\n</li>\n<li>\n<p>定位属性：浮动、清除浮动、定位 position 等</p>\n</li>\n<li>\n<p>生成内容属性：content、counter-reset、counter-increment</p>\n</li>\n<li>\n<p>轮廓样式属性：outline-style、outline-width、outline-color、outline</p>\n</li>\n<li>\n<p>页面样式属性：size、page-break-before、page-break-after</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://www.html.cn/qa/css3/13444.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.html.cn/qa/css3/13444.html</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "css"
      ]
    },
    {
      "title": "说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？",
      "url": "https://www.h7ml.cn/posts/interview/vue3/treeshaking.html",
      "id": "https://www.h7ml.cn/posts/interview/vue3/treeshaking.html",
      "summary": "前端物语|面试物语-说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？",
      "content_html": "<h1> 说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5e8bf1d0-6097-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>Tree shaking</code> 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 <code>Dead code elimination</code></p>\n<p>简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码</p>\n<p>如果把代码打包比作制作蛋糕，传统的方式是把鸡蛋（带壳）全部丢进去搅拌，然后放入烤箱，最后把（没有用的）蛋壳全部挑选并剔除出去</p>\n<p>而<code>treeshaking</code>则是一开始就把有用的蛋白蛋黄（import）放入搅拌，最后直接作出蛋糕</p>\n<p>也就是说 ，<code>tree shaking</code> 其实是找出使用的代码</p>\n<p>在<code>Vue2</code>中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是<code>Vue</code>实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>而<code>Vue3</code>源码引入<code>tree shaking</code>特性，将全局 API 进行分块。如果您不使用其某些功能，它们将不会包含在您的基础包中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、如何做</h2>\n<p><code>Tree shaking</code>是基于<code>ES6</code>模板语法（<code>import</code>与<code>exports</code>），主要是借助<code>ES6</code>模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量</p>\n<p><code>Tree shaking</code>无非就是做了两件事：</p>\n<ul>\n<li>编译阶段利用<code>ES6 Module</code>判断哪些模块已经加载</li>\n<li>判断那些模块和变量未被使用或者引用，进而删除对应代码</li>\n</ul>\n<p>下面就来举个例子：</p>\n<p>通过脚手架<code>vue-cli</code>安装<code>Vue2</code>与<code>Vue3</code>项目</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> Vue2 项目</h3>\n<p>组件中使用<code>data</code>属性</p>\n<div class=\"language-vue line-numbers-mode\" data-ext=\"vue\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对项目进行打包，体积如下图</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/6bd2aff0-6097-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>为组件设置其他属性（<code>compted</code>、<code>watch</code>）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再一次打包，发现打包出来的体积并没有变化</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/7c29e260-6097-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> Vue3 项目</h3>\n<p>组件中简单使用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>将项目进行打包</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/95df0000-6097-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在组件中引入<code>computed</code>和<code>watch</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再次对项目进行打包，可以看到在引入<code>computer</code>和<code>watch</code>之后，项目整体体积变大了</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b36a7a00-6097-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、作用</h2>\n<p>通过<code>Tree shaking</code>，<code>Vue3</code>给我们带来的好处是：</p>\n<ul>\n<li>减少程序体积（更小）</li>\n<li>减少程序执行时间（更快）</li>\n<li>便于将来对程序架构进行优化（更友好）</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000038962700\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000038962700</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-27T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "vue3"
      ]
    },
    {
      "title": "说说 webpack 的热更新是如何做到的？原理是什么？",
      "url": "https://www.h7ml.cn/posts/interview/webpack/HMR.html",
      "id": "https://www.h7ml.cn/posts/interview/webpack/HMR.html",
      "summary": "前端物语|面试物语-说说 webpack 的热更新是如何做到的？原理是什么？",
      "content_html": "<h1> 说说 webpack 的热更新是如何做到的？原理是什么？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/a076da40-acd4-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 一、是什么</h3>\n<p><code>HMR</code>全称 <code>Hot Module Replacement</code>，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用</p>\n<p>例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失</p>\n<p>如果使用的是 <code>HMR</code>，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用</p>\n<p>在<code>webpack</code>中配置开启热模块也非常的简单，如下代码：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过上述这种配置，如果我们修改并保存<code>css</code>文件，确实能够以不刷新的形式更新到页面中</p>\n<p>但是，当我们修改并保存<code>js</code>文件之后，页面依旧自动刷新了，这里并没有触发热模块</p>\n<p>所以，<code>HMR</code>并不像 <code>Webpack</code> 的其他特性一样可以开箱即用，需要有一些额外的操作</p>\n<p>我们需要去指定哪些模块发生更新时进行<code>HRM</code>，如下代码：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、实现原理</h2>\n<p>首先来看看一张图，如下：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/adc05780-acd4-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<ul>\n<li>Webpack Compile：将 JS 源代码编译成 bundle.js</li>\n<li>HMR Server：用来将热更新的文件输出给 HMR Runtime</li>\n<li>Bundle Server：静态资源文件服务器，提供文件访问路径</li>\n<li>HMR Runtime：socket 服务器，会被注入到浏览器，更新文件的变化</li>\n<li>bundle.js：构建输出的文件</li>\n<li>在 HMR Runtime 和 HMR Server 之间建立 websocket，即图上 4 号线，用于实时更新文件变化</li>\n</ul>\n<p>上面图中，可以分成两个阶段：</p>\n<ul>\n<li>启动阶段为上图 1 - 2 - A - B</li>\n</ul>\n<p>在编写未经过<code>webpack</code>打包的源代码后，<code>Webpack Compile</code> 将源代码和 <code>HMR Runtime</code> 一起编译成 <code>bundle</code>文件，传输给<code>Bundle Server</code> 静态资源服务器</p>\n<ul>\n<li>更新阶段为上图 1 - 2 - 3 - 4</li>\n</ul>\n<p>当某一个文件或者模块发生变化时，<code>webpack</code>监听到文件变化对文件重新编译打包，编译生成唯一的<code>hash</code>值，这个<code>hash</code>值用来作为下一次热更新的标识</p>\n<p>根据变化的内容生成两个补丁文件：<code>manifest</code>（包含了 <code>hash</code> 和 <code>chundId</code>，用来说明变化的内容）和<code>chunk.js</code> 模块</p>\n<p>由于<code>socket</code>服务器在<code>HMR Runtime</code> 和 <code>HMR Server</code>之间建立 <code>websocket</code>链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的<code>hash</code>值，如下图的<code>h</code>属性，作为下一次热更细的标识</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/05a0edf0-ad4a-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在浏览器接受到这条消息之前，浏览器已经在上一次<code>socket</code> 消息中已经记住了此时的<code>hash</code> 标识，这时候我们会创建一个 <code>ajax</code> 去服务端请求获取到变化内容的 <code>manifest</code> 文件</p>\n<p><code>mainfest</code>文件包含重新<code>build</code>生成的<code>hash</code>值，以及变化的模块，对应上图的<code>c</code>属性</p>\n<p>浏览器根据 <code>manifest</code> 文件获取模块变化的内容，从而触发<code>render</code>流程，实现局部模块更新</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/0e7b7850-ad4a-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 三、总结</h2>\n<p>关于<code>webpack</code>热模块更新的总结如下：</p>\n<ul>\n<li>通过<code>webpack-dev-server</code>创建两个服务器：提供静态资源的服务（express）和 Socket 服务</li>\n<li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li>\n<li>socket server 是一个 websocket 的长连接，双方可以通信</li>\n<li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest 文件）和.js 文件（update chunk）</li>\n<li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li>\n<li>浏览器拿到两个新的文件后，通过 HMR runtime 机制，加载这两个文件，并且针对修改的模块进行更新</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/138446061\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/138446061</a></li>\n<li><a href=\"https://github.com/Jocs/jocs.github.io/issues/15\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Jocs/jocs.github.io/issues/15</a></li>\n<li><a href=\"https://juejin.cn/post/6844904134697549832\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/6844904134697549832</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-29T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "webpack"
      ]
    },
    {
      "title": "说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？",
      "url": "https://www.h7ml.cn/posts/interview/webpack/Loader_Plugin.html",
      "id": "https://www.h7ml.cn/posts/interview/webpack/Loader_Plugin.html",
      "summary": "前端物语|面试物语-说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？",
      "content_html": "<h1> 说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/93042280-a894-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、区别</h2>\n<p>前面两节我们有提到<code>Loader</code>与<code>Plugin</code>对应的概念，先来回顾下</p>\n<ul>\n<li>loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中</li>\n<li>plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事</li>\n</ul>\n<p>从整个运行时机上来看，如下图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9a04ec40-a7c2-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>可以看到，两者在运行时机上的区别：</p>\n<ul>\n<li>loader 运行在打包文件之前</li>\n<li>plugins 在整个编译周期都起作用</li>\n</ul>\n<p>在<code>Webpack</code> 运行的生命周期中会广播出许多事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过<code>Webpack</code>提供的 <code>API</code>改变输出结果</p>\n<p>对于<code>loader</code>，实质是一个转换器，将 A 文件进行编译形成 B 文件，操作的是文件，比如将<code>A.scss</code>或<code>A.less</code>转变为<code>B.css</code>，单纯的文件转换过程</p>\n<h2> 二、编写 loader</h2>\n<p>在编写 <code>loader</code> 前，我们首先需要了解 <code>loader</code> 的本质</p>\n<p>其本质为函数，函数中的 <code>this</code> 作为上下文会被 <code>webpack</code> 填充，因此我们不能将 <code>loader</code>设为一个箭头函数</p>\n<p>函数接受一个参数，为 <code>webpack</code> 传递给 <code>loader</code> 的文件源内容</p>\n<p>函数中 <code>this</code> 是由 <code>webpack</code> 提供的对象，能够获取当前 <code>loader</code> 所需要的各种信息</p>\n<p>函数中有异步操作或同步操作，异步操作通过 <code>this.callback</code> 返回，返回值要求为 <code>string</code> 或者 <code>Buffer</code></p>\n<p>代码如下所示：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>一般在编写<code>loader</code>的过程中，保持功能单一，避免做多种功能</p>\n<p>如<code>less</code>文件转换成 <code>css</code>文件也不是一步到位，而是 <code>less-loader</code>、<code>css-loader</code>、<code>style-loader</code>几个 <code>loader</code>的链式调用才能完成转换</p>\n<h2> 三、编写 plugin</h2>\n<p>由于<code>webpack</code>基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务</p>\n<p>在之前也了解过，<code>webpack</code>编译会创建两个核心对象：</p>\n<ul>\n<li>compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子</li>\n<li>compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建</li>\n</ul>\n<p>如果自己要实现<code>plugin</code>，也需要遵循一定的规范：</p>\n<ul>\n<li>插件必须是一个函数或者是一个包含 <code>apply</code> 方法的对象，这样才能访问<code>compiler</code>实例</li>\n<li>传给每个插件的 <code>compiler</code> 和 <code>compilation</code> 对象都是同一个引用，因此不建议修改</li>\n<li>异步的事件需要在插件处理完任务时调用回调函数通知 <code>Webpack</code> 进入下一个流程，不然会卡住</li>\n</ul>\n<p>实现<code>plugin</code>的模板如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 <code>emit</code> 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://webpack.docschina.org/api/loaders/\" target=\"_blank\" rel=\"noopener noreferrer\">https://webpack.docschina.org/api/loaders/</a></li>\n<li><a href=\"https://webpack.docschina.org/api/compiler-hooks/\" target=\"_blank\" rel=\"noopener noreferrer\">https://webpack.docschina.org/api/compiler-hooks/</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000039877943\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000039877943</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-07T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "webpack"
      ]
    },
    {
      "title": "说说 webpack 中常见的 Plugin？解决了什么问题？",
      "url": "https://www.h7ml.cn/posts/interview/webpack/Plugin.html",
      "id": "https://www.h7ml.cn/posts/interview/webpack/Plugin.html",
      "summary": "前端物语|面试物语-说说 webpack 中常见的 Plugin？解决了什么问题？",
      "content_html": "<h1> 说说 webpack 中常见的 Plugin？解决了什么问题？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8d3978a0-a7c2-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>Plugin</code>（Plug-in）是一种计算机应用程序，它和主应用程序互相交互，以提供特定的功能</p>\n<p>是一种遵循一定规范的应用程序接口编写出来的程序，只能运行在程序规定的系统下，因为其需要调用原纯净系统提供的函数库或者数据</p>\n<p><code>webpack</code>中的<code>plugin</code>也是如此，<code>plugin</code>赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 <code>webpack</code> 的不同阶段（钩子 / 生命周期），贯穿了<code>webpack</code>整个编译周期</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9a04ec40-a7c2-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>目的在于解决<code>loader</code> 无法实现的其他事</p>\n<h3> 配置方式</h3>\n<p>这里讲述文件的配置方式，一般情况，通过配置文件导出对象中<code>plugins</code>属性传入<code>new</code>实例对象。如下所示：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、特性</h2>\n<p>其本质是一个具有<code>apply</code>方法<code>javascript</code>对象</p>\n<p><code>apply</code> 方法会被 <code>webpack compiler</code>调用，并且在整个编译生命周期都可以访问 <code>compiler</code>对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>compiler hook</code> 的 <code>tap</code>方法的第一个参数，应是驼峰式命名的插件名称</p>\n<p>关于整个编译生命周期钩子，有如下：</p>\n<ul>\n<li>entry-option ：初始化 option</li>\n<li>run</li>\n<li>compile： 真正开始的编译，在创建 compilation 对象之前</li>\n<li>compilation ：生成好了 compilation 对象</li>\n<li>make 从 entry 开始递归分析依赖，准备对每个模块进行 build</li>\n<li>after-compile： 编译 build 过程结束</li>\n<li>emit ：在将内存中 assets 内容写到磁盘文件夹之前</li>\n<li>after-emit ：在将内存中 assets 内容写到磁盘文件夹之后</li>\n<li>done： 完成所有的编译过程</li>\n<li>failed： 编译失败的时候</li>\n</ul>\n<h2> 三、常见的 Plugin</h2>\n<p>常见的<code>plugin</code>有如图所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/bd749400-a7c2-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>下面介绍几个常用的插件用法：</p>\n<h3> HtmlWebpackPlugin</h3>\n<p>在打包结束后，⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的<code>js</code> 模块引⼊到该 <code>html</code> 中</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 <code>html</code> 模板中，可以通过 <code>&lt;%=htmlWebpackPlugin.options.XXX%&gt;</code> 的方式获取配置的值</p>\n<p>更多的配置可以自寻查找</p>\n<h3> clean-webpack-plugin</h3>\n<p>删除（清理）构建目录</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> mini-css-extract-plugin</h3>\n<p>提取 <code>CSS</code> 到一个单独的文件中</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> DefinePlugin</h3>\n<p>允许在编译时创建配置的全局对象，是一个<code>webpack</code>内置的插件，不需要安装</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这时候编译<code>template</code>模块的时候，就能通过下述形式获取全局对象</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> copy-webpack-plugin</h3>\n<p>复制文件或目录到执行区域，如<code>vue</code>的打包过程中，如果我们将一些文件放到<code>public</code>的目录下，那么这个目录会被复制到<code>dist</code>文件夹中</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>复制的规则在<code>patterns</code>属性中设置：</p>\n<ul>\n<li>\n<p>from：设置从哪一个源中开始复制</p>\n</li>\n<li>\n<p>to：复制到的位置，可以省略，会默认复制到打包的目录下</p>\n</li>\n<li>\n<p>globOptions：设置一些额外的选项，其中可以编写需要忽略的文件</p>\n</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://webpack.docschina.org/concepts/plugins/\" target=\"_blank\" rel=\"noopener noreferrer\">https://webpack.docschina.org/concepts/plugins/</a></li>\n<li><a href=\"https://baike.baidu.com/item/Plugin\" target=\"_blank\" rel=\"noopener noreferrer\">https://baike.baidu.com/item/Plugin</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000018695134\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000018695134</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-04-03T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "webpack"
      ]
    },
    {
      "title": "前端物语|面试物语-webpack",
      "url": "https://www.h7ml.cn/posts/interview/webpack/",
      "id": "https://www.h7ml.cn/posts/interview/webpack/",
      "summary": "说说 webpack 的热更新是如何做到的？原理是什么？ 说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？ 说说 webpack 中常见的 Plugin？解决了什么问题？ 与 webpack 类似的工具还有哪些？区别？ 说说 webpack 的构建流程? 如何提高 webpack 的构建速度？ 说说如何借助 webpack 来优化前端性能？ 说说 webpack proxy 工作原理？为什么能解决跨域? 说说你对 webpack 的理解？解决了什么问题？",
      "content_html": "<ul>\n<li><a href=\"https://www.h7ml.cn/posts/interview/webpack/HMR\" target=\"_blank\" rel=\"noopener noreferrer\">说说 webpack 的热更新是如何做到的？原理是什么？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/webpack/Loader_Plugin\" target=\"_blank\" rel=\"noopener noreferrer\">说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/webpack/Plugin\" target=\"_blank\" rel=\"noopener noreferrer\">说说 webpack 中常见的 Plugin？解决了什么问题？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/webpack/Rollup_Parcel_snowpack_Vite\" target=\"_blank\" rel=\"noopener noreferrer\">与 webpack 类似的工具还有哪些？区别？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/webpack/build_process\" target=\"_blank\" rel=\"noopener noreferrer\">说说 webpack 的构建流程?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/webpack/improve_build\" target=\"_blank\" rel=\"noopener noreferrer\">如何提高 webpack 的构建速度？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/webpack/performance\" target=\"_blank\" rel=\"noopener noreferrer\">说说如何借助 webpack 来优化前端性能？</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/webpack/proxy\" target=\"_blank\" rel=\"noopener noreferrer\">说说 webpack proxy 工作原理？为什么能解决跨域?</a></li>\n<li><a href=\"https://www.h7ml.cn/posts/interview/webpack/webpack\" target=\"_blank\" rel=\"noopener noreferrer\">说说你对 webpack 的理解？解决了什么问题？</a></li>\n</ul>\n",
      "date_published": "2023-04-03T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "webpack"
      ]
    },
    {
      "title": "与 webpack 类似的工具还有哪些？区别？",
      "url": "https://www.h7ml.cn/posts/interview/webpack/Rollup_Parcel_snowpack_Vite.html",
      "id": "https://www.h7ml.cn/posts/interview/webpack/Rollup_Parcel_snowpack_Vite.html",
      "summary": "前端物语|面试物语-与 webpack 类似的工具还有哪些？区别？",
      "content_html": "<h1> 与 webpack 类似的工具还有哪些？区别？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8ed8d520-b1a4-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、模块化工具</h2>\n<p>模块化是一种处理复杂系统分解为更好的可管理模块的方式</p>\n<p>可以用来分割，组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(<code>bundle</code>)</p>\n<p>在前端领域中，并非只有<code>webpack</code>这一款优秀的模块打包工具，还有其他类似的工具，例如<code>Rollup</code>、<code>Parcel</code>、<code>snowpack</code>，以及最近风头无两的<code>Vite</code></p>\n<p>通过这些模块打包工具，能够提高我们的开发效率，减少开发成本</p>\n<p>这里没有提及<code>gulp</code>、<code>grunt</code>是因为它们只是定义为构建工具，不能类比</p>\n<h3> Rollup</h3>\n<p><code>Rollup</code> 是一款 <code>ES Modules</code> 打包器，从作用上来看，<code>Rollup</code> 与 <code>Webpack</code> 非常类似。不过相比于 <code>Webpack</code>，<code>Rollup</code>要小巧的多</p>\n<p>现在很多我们熟知的库都都使用它进行打包，比如：<code>Vue</code>、<code>React</code>和<code>three.js</code>等</p>\n<p>举个例子：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后通过<code>rollup</code>进行打包</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>打包结果如下图<img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/8fe07830-b143-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" loading=\"lazy\"></p>\n<p>可以看到，代码非常简洁，完成不像<code>webpack</code>那样存在大量引导代码和模块函数</p>\n<p>并且<code>error</code>方法由于没有被使用，输出的结果中并无<code>error</code>方法，可以看到，<code>rollup</code>默认开始<code>Tree-shaking</code> 优化输出结果</p>\n<p>因此，可以看到<code>Rollup</code>的优点：</p>\n<ul>\n<li>代码效率更简洁、效率更高</li>\n<li>默认支持 Tree-shaking</li>\n</ul>\n<p>但缺点也十分明显，加载其他类型的资源文件或者支持导入 <code>CommonJS</code> 模块，又或是编译 <code>ES</code> 新特性，这些额外的需求 <code>Rollup</code>需要使用插件去完成</p>\n<p>综合来看，<code>rollup</code>并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用<code>CommonJs</code>方式导出成员，并且<code>rollup</code>不支持<code>HMR</code>，使开发效率降低</p>\n<p>但是在用于打包<code>JavaScript</code> 库时，<code>rollup</code>比 <code>webpack</code> 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略</p>\n<h3> Parcel</h3>\n<p>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序</p>\n<p><code>Parcel</code> 跟 <code>Webpack</code> 一样都支持以任意类型文件作为打包入口，但建议使用<code>HTML</code>文件作为入口，该<code>HTML</code>文件像平时一样正常编写代码、引用资源。如下所示：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>main.js 文件通过<code>ES Moudle</code>方法导入其他模块成员</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行之后，使用命令打包</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>执行命令后，<code>Parcel</code>不仅打包了应用，同时也启动了一个开发服务器，跟<code>webpack Dev Server</code>一样</p>\n<p>跟<code>webpack</code>类似，也支持模块热替换，但用法更简单</p>\n<p>同时，<code>Parcel</code>有个十分好用的功能：支持自动安装依赖，像<code>webpack</code>开发阶段突然使用安装某个第三方依赖，必然会终止<code>dev server</code>然后安装再启动。而<code>Parcel</code>则免了这繁琐的工作流程</p>\n<p>同时，<code>Parcel</code>能够零配置加载其他类型的资源文件，无须像<code>webpack</code>那样配置对应的<code>loader</code></p>\n<p>打包命令如下：</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>由于打包过程是多进程同时工作，构建速度会比<code>Webpack</code> 快，输出文件也会被压缩，并且样式代码也会被单独提取到单个文件中</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/ec17e7a0-b1a2-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>可以感受到，<code>Parcel</code>给开发者一种很大的自由度，只管去实现业务代码，其他事情用<code>Parcel</code>解决</p>\n<h3> Snowpack</h3>\n<p>Snowpack，是一种闪电般快速的前端构建工具，专为现代<code>Web</code>设计，较复杂的打包工具（如<code>Webpack</code>或<code>Parcel</code>）的替代方案，利用<code>JavaScript</code>的本机模块系统，避免不必要的工作并保持流畅的开发体验</p>\n<p>开发阶段，每次保存单个文件时，<code>Webpack</code>和<code>Parcel</code>都需要重新构建和重新打包应用程序的整个<code>bundle</code>。而<code>Snowpack</code>为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，<code>Snowpack</code>会重新构建该单个文件</p>\n<p>下图给出<code>webpack</code>与<code>snowpack</code>打包区别：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/79197830-b1a3-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在重新构建每次变更时没有任何的时间浪费，只需要在浏览器中进行 HMR 更新</p>\n<h3> Vite</h3>\n<p>vite ，是一种新型前端构建工具，能够显著提升前端开发体验</p>\n<p>它主要由两部分组成：</p>\n<ul>\n<li>一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新 HMR</li>\n<li>一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li>\n</ul>\n<p>其作用类似<code>webpack</code>+ <code>webpack-dev-server</code>，其特点如下：</p>\n<ul>\n<li>快速的冷启动</li>\n<li>即时的模块热更新</li>\n<li>真正的按需编译</li>\n</ul>\n<p><code>vite</code>会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快</p>\n<p>利用现代浏览器支持<code>ES Module</code>的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间</p>\n<p>原理图如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9f2eed30-b143-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在热模块<code>HMR</code>方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像<code>webpack</code>那样需要把该模块的相关依赖模块全部编译一次，效率更高</p>\n<h3> webpack</h3>\n<p>相比上述的模块化工具，<code>webpack</code>大而全，很多常用的功能做到开箱即用。有两大最核心的特点：<strong>一切皆模块</strong>和<strong>按需加载</strong></p>\n<p>与其他构建工具相比，有如下优势：</p>\n<ul>\n<li>智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容</li>\n<li>万物模块：对 js、css、图片等资源文件都支持打包</li>\n<li>开箱即用：HRM、Tree-shaking 等功能</li>\n<li>代码分割：可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间</li>\n<li>插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性</li>\n<li>易于调试：支持 SourceUrls 和 SourceMaps</li>\n<li>快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快</li>\n<li>生态环境好：社区更丰富，出现的问题更容易解决</li>\n</ul>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/95684686\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/95684686</a></li>\n<li><a href=\"https://cn.vitejs.dev/guide/\" target=\"_blank\" rel=\"noopener noreferrer\">https://cn.vitejs.dev/guide/</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000039370642\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000039370642</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-21T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "webpack"
      ]
    },
    {
      "title": "说说 webpack 的构建流程?",
      "url": "https://www.h7ml.cn/posts/interview/webpack/build_process.html",
      "id": "https://www.h7ml.cn/posts/interview/webpack/build_process.html",
      "summary": "前端物语|面试物语-说说 webpack 的构建流程?",
      "content_html": "<h1> 说说 webpack 的构建流程?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/96cf6840-a658-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、运行流程</h2>\n<p><code>webpack</code> 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来</p>\n<p>在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条<code>webpack</code>机制中，去改变<code>webpack</code>的运作，使得整个系统扩展性良好</p>\n<p>从启动到结束会依次执行以下三大步骤：</p>\n<ul>\n<li>初始化流程：从配置文件和 <code>Shell</code> 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</li>\n<li>编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li>\n<li>输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统</li>\n</ul>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/b566d400-a658-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 初始化流程</h3>\n<p>从配置文件和 <code>Shell</code> 语句中读取与合并参数，得出最终的参数</p>\n<p>配置文件默认下为<code>webpack.config.js</code>，也或者通过命令的形式指定配置文件，主要作用是用于激活<code>webpack</code>的加载项和插件</p>\n<p>关于文件配置内容分析，如下注释：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>webpack</code> 将 <code>webpack.config.js</code> 中的各个配置项拷贝到 <code>options</code> 对象中，并加载用户配置的 <code>plugins</code></p>\n<p>完成上述步骤之后，则开始初始化<code>Compiler</code>编译对象，该对象掌控者<code>webpack</code>声明周期，不执行具体的任务，只是进行一些调度工作</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Compiler</code> 对象继承自 <code>Tapable</code>，初始化时定义了很多钩子函数</p>\n<h3> 编译构建流程</h3>\n<p>根据配置中的 <code>entry</code> 找出所有的入口文件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>初始化完成后会调用<code>Compiler</code>的<code>run</code>来真正启动<code>webpack</code>编译构建流程，主要流程如下：</p>\n<ul>\n<li><code>compile</code> 开始编译</li>\n<li><code>make</code> 从入口点分析模块及其依赖的模块，创建这些模块对象</li>\n<li><code>build-module</code> 构建模块</li>\n<li><code>seal</code> 封装构建结果</li>\n<li><code>emit</code> 把各个 chunk 输出到结果文件</li>\n</ul>\n<h4> compile 编译</h4>\n<p>执行了<code>run</code>方法后，首先会触发<code>compile</code>，主要是构建一个<code>Compilation</code>对象</p>\n<p>该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象</p>\n<h4> make 编译模块</h4>\n<p>当完成了上述的<code>compilation</code>对象后，就开始从<code>Entry</code>入口文件开始读取，主要执行<code>_addModuleChain()</code>函数，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>过程如下：</p>\n<p><code>_addModuleChain</code>中接收参数<code>dependency</code>传入的入口依赖，使用对应的工厂函数<code>NormalModuleFactory.create</code>方法生成一个空的<code>module</code>对象</p>\n<p>回调中会把此<code>module</code>存入<code>compilation.modules</code>对象和<code>dependencies.module</code>对象中，由于是入口文件，也会存入<code>compilation.entries</code>中</p>\n<p>随后执行<code>buildModule</code>进入真正的构建模块<code>module</code>内容的过程</p>\n<h4> build module 完成模块编译</h4>\n<p>这里主要调用配置的<code>loaders</code>，将我们的模块转成标准的<code>JS</code>模块</p>\n<p>在用<code>Loader</code> 对一个模块转换完后，使用 <code>acorn</code> 解析转换后的内容，输出对应的抽象语法树（<code>AST</code>），以方便 <code>Webpack</code>后面对代码的分析</p>\n<p>从配置的入口模块开始，分析其 <code>AST</code>，当遇到<code>require</code>等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系</p>\n<h3> 输出流程</h3>\n<h4> seal 输出资源</h4>\n<p><code>seal</code>方法主要是要生成<code>chunks</code>，对<code>chunks</code>进行一系列的优化操作，并生成要输出的代码</p>\n<p><code>webpack</code> 中的 <code>chunk</code> ，可以理解为配置在 <code>entry</code> 中的模块，或者是动态引入的模块</p>\n<p>根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表</p>\n<h4> emit 输出完成</h4>\n<p>在确定好输出内容后，根据配置确定输出的路径和文件名</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 <code>Compiler</code> 开始生成文件前，钩子 <code>emit</code> 会被执行，这是我们修改最终文件的最后一个机会</p>\n<p>从而<code>webpack</code>整个打包过程则结束了</p>\n<h3> 小结</h3>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d77fc560-a658-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://github.com/Cosen95/blog/issues/48\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/Cosen95/blog/issues/48</a></li>\n<li><a href=\"https://developer.aliyun.com/article/61047\" target=\"_blank\" rel=\"noopener noreferrer\">https://developer.aliyun.com/article/61047</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-10T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "webpack"
      ]
    },
    {
      "title": "如何提高 webpack 的构建速度？",
      "url": "https://www.h7ml.cn/posts/interview/webpack/improve_build.html",
      "id": "https://www.h7ml.cn/posts/interview/webpack/improve_build.html",
      "summary": "前端物语|面试物语-如何提高 webpack 的构建速度？",
      "content_html": "<h1> 如何提高 webpack 的构建速度？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/3a1b8620-b01b-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、背景</h2>\n<p>随着我们的项目涉及到页面越来越多，功能和业务代码也会随着越多，相应的 <code>webpack</code> 的构建时间也会越来越久</p>\n<p>构建时间与我们日常开发效率密切相关，当我们本地开发启动 <code>devServer</code> 或者 <code>build</code> 的时候，如果时间过长，会大大降低我们的工作效率</p>\n<p>所以，优化<code>webpack</code> 构建速度是十分重要的环节</p>\n<h2> 二、如何优化</h2>\n<p>常见的提升构建速度的手段有如下：</p>\n<ul>\n<li>优化 loader 配置</li>\n<li>合理使用 resolve.extensions</li>\n<li>优化 resolve.modules</li>\n<li>优化 resolve.alias</li>\n<li>使用 DLLPlugin 插件</li>\n<li>使用 cache-loader</li>\n<li>terser 启动多线程</li>\n<li>合理使用 sourceMap</li>\n</ul>\n<h3> 优化 loader 配置</h3>\n<p>在使用<code>loader</code>时，可以通过配置<code>include</code>、<code>exclude</code>、<code>test</code>属性来匹配文件，接触<code>include</code>、<code>exclude</code>规定哪些匹配应用<code>loader</code></p>\n<p>如采用 ES6 的项目为例，在配置 <code>babel-loader</code>时，可以这样：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 合理使用 resolve.extensions</h3>\n<p>在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， <code>resolve</code>可以帮助<code>webpack</code>从每个 <code>require/import</code> 语句中，找到需要引入到合适的模块代码</p>\n<p>通过<code>resolve.extensions</code>是解析到文件时自动添加拓展名，默认情况如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找</p>\n<p>当我们配置的时候，则不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度</p>\n<h3> 优化 resolve.modules</h3>\n<p><code>resolve.modules</code> 用于配置 <code>webpack</code> 去哪些目录下寻找第三方模块。默认值为<code>['node_modules']</code>，所以默认会从<code>node_modules</code>中查找文件当安装的第三方模块都放在项目根目录下的 <code>./node_modules</code>目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 优化 resolve.alias</h3>\n<p><code>alias</code>给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是<code>./../../</code>的形式</p>\n<p>通过配置<code>alias</code>以减少查找过程</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 使用 DLLPlugin 插件</h3>\n<p><code>DLL</code>全称是 动态链接库，是为软件在 winodw 种实现共享函数库的一种实现方式，而 Webpack 也内置了 DLL 的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中</p>\n<p>使用步骤分成两部分：</p>\n<ul>\n<li>打包一个 DLL 库</li>\n<li>引入 DLL 库</li>\n</ul>\n<h4> 打包一个 DLL 库</h4>\n<p><code>webpack</code>内置了一个<code>DllPlugin</code>可以帮助我们打包一个 DLL 的库文件</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 引入 DLL 库</h4>\n<p>使用 <code>webpack</code> 自带的 <code>DllReferencePlugin</code> 插件对 <code>mainfest.json</code> 映射文件进行分析，获取要使用的<code>DLL</code>库</p>\n<p>然后再通过<code>AddAssetHtmlPlugin</code>插件，将我们打包的<code>DLL</code>库引入到<code>Html</code>模块中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 使用 cache-loader</h3>\n<p>在一些性能开销较大的 <code>loader</code>之前添加 <code>cache-loader</code>，以将结果缓存到磁盘里，显著提升二次构建速度</p>\n<p>保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 <code>loader</code> 使用此<code>loader</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> terser 启动多线程</h3>\n<p>使用多进程并行运行来提高构建速度</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 合理使用 sourceMap</h3>\n<p>打包生成 <code>sourceMap</code> 的时候，如果信息越详细，打包速度就会越慢。对应属性取值如下所示：</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/11647af0-b01d-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h3> 三、总结</h3>\n<p>可以看到，优化<code>webpack</code>构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://github.com/ly2011/blog/issues/44\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/ly2011/blog/issues/44</a></li>\n<li><a href=\"https://xie.infoq.cn/article/541418eb82a674741a0ad8865\" target=\"_blank\" rel=\"noopener noreferrer\">https://xie.infoq.cn/article/541418eb82a674741a0ad8865</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/139498741\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/139498741</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-13T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "webpack"
      ]
    },
    {
      "title": "说说如何借助 webpack 来优化前端性能？",
      "url": "https://www.h7ml.cn/posts/interview/webpack/performance.html",
      "id": "https://www.h7ml.cn/posts/interview/webpack/performance.html",
      "summary": "前端物语|面试物语-说说如何借助 webpack 来优化前端性能？",
      "content_html": "<h1> 说说如何借助 webpack 来优化前端性能？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/15e1ace0-aee4-11eb-ab90-d9ae814b240d.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、背景</h2>\n<p>随着前端的项目逐渐扩大，必然会带来的一个问题就是性能</p>\n<p>尤其在大型复杂的项目中，前端业务可能因为一个小小的数据依赖，导致整个页面卡顿甚至奔溃</p>\n<p>一般项目在完成后，会通过<code>webpack</code>进行打包，利用<code>webpack</code>对前端项目性能优化是一个十分重要的环节</p>\n<h2> 二、如何优化</h2>\n<p>通过<code>webpack</code>优化前端的手段有：</p>\n<ul>\n<li>JS 代码压缩</li>\n<li>CSS 代码压缩</li>\n<li>Html 文件代码压缩</li>\n<li>文件大小压缩</li>\n<li>图片压缩</li>\n<li>Tree Shaking</li>\n<li>代码分离</li>\n<li>内联 chunk</li>\n</ul>\n<h3> JS 代码压缩</h3>\n<p><code>terser</code>是一个<code>JavaScript</code>的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让<code>bundle</code>更小</p>\n<p>在<code>production</code>模式下，<code>webpack</code> 默认就是使用 <code>TerserPlugin</code> 来处理我们的代码的。如果想要自定义配置它，配置方法如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>属性介绍如下：</p>\n<ul>\n<li>extractComments：默认值为 true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释</li>\n<li>parallel：使用多进程并发运行提高构建的速度，默认值是 true，并发运行的默认数量： os.cpus().length - 1</li>\n<li>terserOptions：设置我们的 terser 相关的配置：</li>\n<li>compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为 true</li>\n<li>mangle：设置丑化相关的选项，可以直接设置为 true</li>\n<li>toplevel：底层变量是否进行转换</li>\n<li>keep_classnames：保留类的名称</li>\n<li>keep_fnames：保留函数的名称</li>\n</ul>\n<h3> CSS 代码压缩</h3>\n<p><code>CSS</code>压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等</p>\n<p>CSS 的压缩我们可以使用另外一个插件：<code>css-minimizer-webpack-plugin</code></p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>配置方法如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Html 文件代码压缩</h3>\n<p>使用<code>HtmlWebpackPlugin</code>插件来生成<code>HTML</code>的模板时候，通过配置属性<code>minify</code>进行<code>html</code>优化</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>设置了<code>minify</code>，实际会使用另一个插件<code>html-minifier-terser</code></p>\n<h3> 文件大小压缩</h3>\n<p>对文件的大小进行压缩，减少<code>http</code>传输过程中宽带的损耗</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 图片压缩</h3>\n<p>一般来说在打包之后，一些图片文件的大小是远远要比 <code>js</code> 或者 <code>css</code> 文件要来的大，所以图片压缩较为重要</p>\n<p>配置方法如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Tree Shaking</h3>\n<p><code>Tree Shaking</code> 是一个术语，在计算机中表示消除死代码，依赖于<code>ES Module</code>的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）</p>\n<p>在<code>webpack</code>实现<code>Trss shaking</code>有两种不同的方案：</p>\n<ul>\n<li>usedExports：通过标记某些函数是否被使用，之后通过 Terser 来进行优化的</li>\n<li>sideEffects：跳过整个模块/文件，直接查看该文件是否有副作用</li>\n</ul>\n<p>两种不同的配置方案， 有不同的效果</p>\n<h4> usedExports</h4>\n<p>配置方法也很简单，只需要将<code>usedExports</code>设为<code>true</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用之后，没被用上的代码在<code>webpack</code>打包中会加入<code>unused harmony export mul</code>注释，用来告知 <code>Terser</code> 在优化时，可以删除掉这段代码</p>\n<p>如下面<code>sum</code>函数没被用到，<code>webpack</code>打包会添加注释，<code>terser</code>在优化时，则将该函数去掉</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/21b2e200-aee4-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h4> sideEffects</h4>\n<p><code>sideEffects</code>用于告知<code>webpack compiler</code>哪些模块时有副作用，配置方法是在<code>package.json</code>中设置<code>sideEffects</code>属性</p>\n<p>如果<code>sideEffects</code>设置为 false，就是告知<code>webpack</code>可以安全的删除未用到的<code>exports</code></p>\n<p>如果有些文件需要保留，可以设置为数组的形式</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述都是关于<code>javascript</code>的<code>tree shaking</code>，<code>css</code>同样也能够实现<code>tree shaking</code></p>\n<h4> css tree shaking</h4>\n<p><code>css</code>进行<code>tree shaking</code>优化可以安装<code>PurgeCss</code>插件</p>\n<div class=\"language-cmd line-numbers-mode\" data-ext=\"cmd\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>paths：表示要检测哪些目录下的内容需要被分析，配合使用 glob</li>\n<li>默认情况下，Purgecss 会将我们的 html 标签的样式移除掉，如果我们希望保留，可以添加一个 safelist 的属性</li>\n</ul>\n<h3> 代码分离</h3>\n<p>将代码分离到不同的<code>bundle</code>中，之后我们可以按需加载，或者并行加载这些文件</p>\n<p>默认情况下，所有的<code>JavaScript</code>代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度</p>\n<p>代码分离可以分出出更小的<code>bundle</code>，以及控制资源加载优先级，提供代码的加载性能</p>\n<p>这里通过<code>splitChunksPlugin</code>来实现，该插件<code>webpack</code>已经默认安装和集成，只需要配置即可</p>\n<p>默认配置中，chunks 仅仅针对于异步（async）请求，我们可以设置为 initial 或者 all</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>splitChunks</code>主要属性有如下：</p>\n<ul>\n<li>Chunks，对同步代码还是异步代码进行处理</li>\n<li>minSize： 拆分包的大小, 至少为 minSize，如何包的大小不超过 minSize，这个包不会拆分</li>\n<li>maxSize： 将大于 maxSize 的包，拆分为不小于 minSize 的包</li>\n<li>minChunks：被引入的次数，默认是 1</li>\n</ul>\n<h3> 内联 chunk</h3>\n<p>可以通过<code>InlineChunkHtmlPlugin</code>插件将一些<code>chunk</code>的模块内联到<code>html</code>，如<code>runtime</code>的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 三、总结</h3>\n<p>关于<code>webpack</code>对前端性能的优化，可以通过文件体积大小入手，其次还可通过分包的形式、减少 http 请求次数等方式，实现对前端性能的优化</p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/139498741\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/139498741</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-18T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "webpack"
      ]
    },
    {
      "title": "说说 webpack proxy 工作原理？为什么能解决跨域?",
      "url": "https://www.h7ml.cn/posts/interview/webpack/proxy.html",
      "id": "https://www.h7ml.cn/posts/interview/webpack/proxy.html",
      "summary": "前端物语|面试物语-说说webpack proxy工作原理？为什么能解决跨域?",
      "content_html": "<h1> 说说 webpack proxy 工作原理？为什么能解决跨域?</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/5b871600-ace5-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、是什么</h2>\n<p><code>webpack proxy</code>，即<code>webpack</code>提供的代理服务</p>\n<p>基本行为就是接收客户端发送的请求后转发给其他服务器</p>\n<p>其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）</p>\n<p>想要实现代理首先需要一个中间服务器，<code>webpack</code>中提供服务器的工具为<code>webpack-dev-server</code></p>\n<h4> webpack-dev-server</h4>\n<p><code>webpack-dev-server</code>是 <code>webpack</code> 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起</p>\n<p>目的是为了提高开发者日常的开发效率，<strong>只适用在开发阶段</strong></p>\n<p>关于配置方面，在<code>webpack</code>配置对象属性中通过<code>devServer</code>属性提供，如下：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>devServetr</code>里面<code>proxy</code>则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配</p>\n<p>属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为<code>/api</code>，值为对应的代理匹配规则，对应如下：</p>\n<ul>\n<li>target：表示的是代理到的目标地址</li>\n<li>pathRewrite：默认情况下，我们的 /api-hy 也会被写入到 URL 中，如果希望删除，可以使用 pathRewrite</li>\n<li>secure：默认情况下不接收转发到 https 的服务器上，如果希望支持，可以设置为 false</li>\n<li>changeOrigin：它表示是否更新代理后请求的 headers 中 host 地址</li>\n</ul>\n<h2> 二、工作原理</h2>\n<p><code>proxy</code>工作原理实质上是利用<code>http-proxy-middleware</code> 这个<code>http</code>代理中间件，实现请求转发给其他服务器</p>\n<p>举个例子：</p>\n<p>在开发阶段，本地地址为<code>http://localhost:3000</code>，该浏览器发送一个前缀带有<code>/api</code>标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、跨域</h2>\n<p>在开发阶段， <code>webpack-dev-server</code> 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 <code>localhost</code>的一个端口上，而后端服务又是运行在另外一个地址上</p>\n<p>所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题</p>\n<p>通过设置<code>webpack proxy</code>实现代理请求后，相当于浏览器与服务端中添加一个代理者</p>\n<p>当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地</p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/65b5e5c0-ace5-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<p>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据</p>\n<p>注意：<strong>服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制</strong></p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://webpack.docschina.org/configuration/dev-server/#devserverproxy\" target=\"_blank\" rel=\"noopener noreferrer\">https://webpack.docschina.org/configuration/dev-server/#devserverproxy</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-02-24T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "webpack"
      ]
    },
    {
      "title": "说说你对 webpack 的理解？解决了什么问题？",
      "url": "https://www.h7ml.cn/posts/interview/webpack/webpack.html",
      "id": "https://www.h7ml.cn/posts/interview/webpack/webpack.html",
      "summary": "前端物语|面试物语-说说你对 webpack 的理解？解决了什么问题？",
      "content_html": "<h1> 说说你对 webpack 的理解？解决了什么问题？</h1>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/898ed570-a578-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h2> 一、背景</h2>\n<p><code>Webpack</code> 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源</p>\n<h4> 模块化</h4>\n<p>最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的<code>JS</code> 文件中</p>\n<p>约定每个文件是一个独立的模块，然后再将这些<code>js</code>文件引入到页面，一个<code>script</code>标签对应一个模块，然后调用模块化的成员</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题</p>\n<p>项目一旦变大，上述问题会尤其明显</p>\n<p>随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种方式也并没有解决第一种方式的依赖等问题</p>\n<p>再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过<code>script</code>标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦</p>\n<p>理想的解决方式是，在页面中引入一个<code>JS</code>入口文件，其余用到的模块可以通过代码控制，按需加载进来</p>\n<p>除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是<code>CommonJS</code>、<code>ES Modules</code></p>\n<h2> 二、问题</h2>\n<p>从后端渲染的<code>JSP</code>、<code>PHP</code>，到前端原生<code>JavaScript</code>，再到<code>jQuery</code>开发，再到目前的三大框架<code>Vue</code>、<code>React</code>、<code>Angular</code></p>\n<p>开发方式，也从<code>javascript</code>到后面的<code>es5</code>、<code>es6、7、8、9、10</code>，再到<code>typescript</code>，包括编写<code>CSS</code>的预处理器<code>less</code>、<code>scss</code>等</p>\n<p>现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题：</p>\n<ul>\n<li>需要通过模块化的方式来开发</li>\n<li>使用一些高级的特性来加快我们的开发效率或者安全性，比如通过 ES6+、TypeScript 开发脚本逻辑，通过 sass、less 等方式来编写 css 样式代码</li>\n<li>监听文件的变化来并且反映到浏览器上，提高开发的效率</li>\n<li>JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题</li>\n<li>开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化</li>\n</ul>\n<p>而<code>webpack</code>恰巧可以解决以上问题</p>\n<h2> 三、是什么</h2>\n<p><code>webpack</code> 是一个用于现代<code>JavaScript</code>应用程序的静态模块打包工具</p>\n<ul>\n<li>静态模块</li>\n</ul>\n<p>这里的静态模块指的是开发阶段，可以被 <code>webpack</code> 直接引用的资源（可以直接被获取打包进<code>bundle.js</code>的资源）</p>\n<p>当 <code>webpack</code>处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限<code>js</code>文件），并生成一个或多个 <code>bundle</code></p>\n<figure><img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/9ce194a0-a578-11eb-85f6-6fac77c0c9b3.png\" alt=\"\" tabindex=\"0\" loading=\"lazy\"><figcaption></figcaption></figure>\n<h4> <code>webpack</code>的能力</h4>\n<p><strong>编译代码能力</strong>，提高效率，解决浏览器兼容问题 <img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/c5c2d360-a592-11eb-ab90-d9ae814b240d.png\" alt=\"\" loading=\"lazy\"> <strong>模块整合能力</strong>，提高性能，可维护性，解决浏览器频繁请求文件的问题 <img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/d306d260-a592-11eb-ab90-d9ae814b240d.png\" alt=\"\" loading=\"lazy\"> <strong>万物皆可模块能力</strong>，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制 <img src=\"https://static.h7ml.cn/vitepress/assets/images/interview/e3c5a040-a592-11eb-ab90-d9ae814b240d.png\" alt=\"\" loading=\"lazy\"></p>\n<h2> 参考文献</h2>\n<ul>\n<li><a href=\"https://webpack.docschina.org/concepts/\" target=\"_blank\" rel=\"noopener noreferrer\">https://webpack.docschina.org/concepts/</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/267875652\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/267875652</a></li>\n</ul>\n",
      "image": "https://www.h7ml.cn/logo.png",
      "date_published": "2023-03-14T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "interview",
        "webpack"
      ]
    },
    {
      "title": "javascript 事件",
      "url": "https://www.h7ml.cn/posts/javascript/animation/",
      "id": "https://www.h7ml.cn/posts/javascript/animation/",
      "content_html": "",
      "date_published": "2022-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "JavaScript 拖拽效果-动画",
      "url": "https://www.h7ml.cn/posts/javascript/animation/%E6%8B%96%E6%8B%BD%E6%95%88%E6%9E%9C.html",
      "id": "https://www.h7ml.cn/posts/javascript/animation/%E6%8B%96%E6%8B%BD%E6%95%88%E6%9E%9C.html",
      "summary": "JavaScript 拖拽效果-动画 鼠标按下 onmousedown，onmousedown 里边鼠标移动 onmousemove，鼠标释放 onmouseup var oDiv = document.getElementById('box'); var disX = (disY = 0); oDiv.onmousedown = function (ev) { var ev = ev || event; disX = ev.offsetX; disY = ev.offsetY; document.onmousemove = function (ev) { var ev = ev || event; var l = ev.clientX - disX; var t = ev.clientY - disY; // 边界限定 if (l &lt;= 0) { l = 0; } else if (l &gt;= document.documentElement.clientWidth - oDiv.offsetWidth) { l = document.documentElement.clientWidth - oDiv.offsetWidth; } if (t &lt;= 0) { t = 0; } else if (t &gt;= document.documentElement.clientHeight - oDiv.offsetHeight) { t = document.documentElement.clientHeight - oDiv.offsetHeight; } // 吸附效果 /* if(l &lt;= 100){ l = 0; }else if(l &gt;= document.documentElement.clientWidth - oDiv.offsetWidth - 100){ l = document.documentElement.clientWidth - oDiv.offsetWidth; } if(t &lt;= 0){ t = 0; }else if(t &gt;= document.documentElement.clientHeight - oDiv.offsetHeight){ t = document.documentElement.clientHeight - oDiv.offsetHeight; } */ oDiv.style.left = l + 'px'; oDiv.style.top = t + 'px'; }; document.onmouseup = function () { this.onmousemove = null; this.onmouseup = null; }; };",
      "content_html": "<h1> JavaScript 拖拽效果-动画</h1>\n<p>鼠标按下 onmousedown，onmousedown 里边鼠标移动 onmousemove，鼠标释放 onmouseup</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript 碰撞检测-动画",
      "url": "https://www.h7ml.cn/posts/javascript/animation/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B.html",
      "id": "https://www.h7ml.cn/posts/javascript/animation/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B.html",
      "summary": "JavaScript 碰撞检测-动画 function konck(node1, node2) { var l1 = node1.offsetLeft; var r1 = node1.offsetLeft + node1.offsetWidth; var t1 = node1.offsetTop; var b1 = node1.offsetTop + node1.offsetHeight; var l2 = node2.offsetLeft; var r2 = node2.offsetLeft + node2.offsetWidth; var t2 = node2.offsetTop; var b2 = node2.offsetTop + node2.offsetHeight; if (l2 &gt; r1 || r2 &lt; l1 || t1 &gt; b2 || t2 &gt; b1) { return false; } else { return true; } }",
      "content_html": "<h1> JavaScript 碰撞检测-动画</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript 链式运动-动画",
      "url": "https://www.h7ml.cn/posts/javascript/animation/%E9%93%BE%E5%BC%8F%E8%BF%90%E5%8A%A8.html",
      "id": "https://www.h7ml.cn/posts/javascript/animation/%E9%93%BE%E5%BC%8F%E8%BF%90%E5%8A%A8.html",
      "summary": "JavaScript 链式运动-动画 缓动运动框架 每次的步长 = （总路程 - 当前位置） / 运动系数（6-10） function getStyle(el, attr) { return el.currentStyle ? el.currentStyle[attr] : getComputedStyle(el)[attr]; } function bufferMove(el, obj, fn) { // fn就是回调函数 clearInterval(el.timer); el.timer = setInterval(function () { var flag = true; // 判断是否所有属性都到达目标值，如果有一个属性没有到目标值，就将 flag 设置为 false。如果全部都到了目标值，那么 flag 就不会被改变为 false，就是初始 true for (var attr in obj) { // 判断 attr 是不是 opacity，是：采用一种获取办法，不是：采用之前的获取方法 if (attr == 'opacity') { var cur = Math.round(getStyle(el, attr) * 100); } else { var cur = parseInt(getStyle(el, attr)); } var step = (obj[attr] - cur) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); // if(cur == obj[attr]){ // clearInterval(el.timer); // } if (cur != obj[attr]) { // 如果有一个当前值，不等于目标值，说明没有全部执行完成 flag = false; } // 赋值时也分两种情况，一种是透明度，另一种是带有单位 px 的 if (attr == 'opacity') { el.style.opacity = (cur + step) / 100; el.style.filter = 'alpha(opacity=' + (cur + step) + ')'; } else { el.style[attr] = cur + step + 'px'; } } if (flag) { // 如果 flag 为假，说明没有全部属性达到目标值，那么不清除定时器，如果 flag 为 true 说明全部属性都达到了目标值，就清除定时器 clearInterval(el.timer); // fn &amp;&amp; fn(); // 回调函数的 this 指向 window，当该运动框架适用于元素集合时，this 执行导致报错 // if(fn) fn(); // 改 call 就是修改函数的调用时的 this 指向 if (fn) fn.call(el); } }, 20); }",
      "content_html": "<h1> JavaScript 链式运动-动画</h1>\n<p>缓动运动框架</p>\n<p>每次的步长 = （总路程 - 当前位置） / 运动系数（6-10）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "javascript 基本概念",
      "url": "https://www.h7ml.cn/posts/javascript/basic/",
      "id": "https://www.h7ml.cn/posts/javascript/basic/",
      "summary": "JavaScript 变量 JavaScript 严格模式及运算问题 JavaScript 数值转换 JavaScript 数据类型检测 JavaScript 运算符 JavaScript 语句 JavaScript 变量、作用域、内存",
      "content_html": "<ul>\n<li><a href=\"/posts/javascript/basic/basic.html\" target=\"blank\">JavaScript 变量</a></li>\n<li><a href=\"/posts/javascript/basic/strict.html\" target=\"blank\">JavaScript 严格模式及运算问题</a></li>\n<li><a href=\"/posts/javascript/basic/type-check.html\" target=\"blank\">JavaScript 数值转换</a></li>\n<li><a href=\"/posts/javascript/basic/types.html\" target=\"blank\">JavaScript 数据类型检测</a></li>\n<li><a href=\"/posts/javascript/basic/operator.html\" target=\"blank\">JavaScript 运算符</a></li>\n<li><a href=\"/posts/javascript/basic/statement.html\" target=\"blank\">JavaScript 语句</a></li>\n<li><a href=\"/posts/javascript/basic/variable.html\" target=\"blank\">JavaScript 变量、作用域、内存</a></li>\n</ul>\n",
      "date_published": "2022-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "JavaScript 变量",
      "url": "https://www.h7ml.cn/posts/javascript/basic/basic.html",
      "id": "https://www.h7ml.cn/posts/javascript/basic/basic.html",
      "summary": "JavaScript 变量 var 关键字 var message; // 默认 undefined",
      "content_html": "<h1> JavaScript 变量</h1>\n<h2> var 关键字</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>声明后可以改变类型，但不推荐</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>var 声明作用域，一个函数内部定义一个变量，在函数退出时被销毁</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在函数内定义变量时省略 var 操作符，可以创建一个全局变量：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"highlight-lines\"><br><div class=\"highlight-line\">&nbsp;</div><br><br><br><br></div><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定义多个变量</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>var 声明提升</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关键字声明的变量会自动提升到函数作用域顶部，相当于：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>反复多次使用 var 声明同一个变量也没有问题</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> let 声明</h2>\n<p>let 声明的范围是块作用域：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不能重复声明</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>块作用域没有重复声明则使用相同标识符则不会报错</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>两个关键字不能重复声明</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 暂时性死区</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 全局声明</h3>\n<p>let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">注意</p>\n<p>不过 let 声明还是在全局作用域中发生的，变量会在整个页面生命周期内续存。所以不要重复声明同一个变量，避免 SyntaxError</p>\n</div>\n<h3> 条件声明</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。但是 let 是块级作用域，所以检查不到之前是否声明过。</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>try/catch 语句或 typeof 操作符也不能解决</p>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> for 循环中的 let 声明</h3>\n<p>使用 var 时变量会渗透到外面</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>let 之后则不会，因为遇到 {} 就会形成作用域块</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>常见的异步循环问题</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在延迟定时器执行时，他是异步的，循环已经结束了，最后的值始终都是 5。</p>\n<p>使用 let 才是期望的值</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>每次迭代循环声明一个新的迭代变量，每个 setTimeout 引用的都是不同的变量实例。这种风格也适用于 for in、for of。</p>\n<h2> const 声明</h2>\n<p>const 的行为与 let 基本相同，但是他是常量，声明之后不能修改，尝试修改 const 声明的变量会导致运行时错误。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但是 const 声明只限制声明的<strong>引用</strong>：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果想让整个对象都不能修改，可以使用 <code>Object.freeze()</code></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 for 中 const 与 let 一样分别独立创建变量的实例，但是不能用 const 来迭代变量（因为变量 i 要自增）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">最佳实践</p>\n<p>不使用 var，const 优先，let 次之</p>\n</div>\n<h2> 函数声明提升与 var 声明提升</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>function</code>与<code>var</code>都存在变量提升，但<code>function</code>比<code>var</code>优先级高。上面的代码就相当于：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-01-11T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "JavaScript 运算符",
      "url": "https://www.h7ml.cn/posts/javascript/basic/operator.html",
      "id": "https://www.h7ml.cn/posts/javascript/basic/operator.html",
      "summary": "JavaScript 运算符 ECMAScript 中的操作符比较独特，包括字符串、数值、布尔值，甚至还有对象。应用给对象时通常会调用会调用valueOf()或toString()方法。 一元运算符 递增/递减 ++n; // 先自增 1，再运算 n++; // 先运算，再自增 1 --n; // n-- 同理 !n; // 转换为 Boolean 值",
      "content_html": "<h1> JavaScript 运算符</h1>\n<p>ECMAScript 中的操作符比较独特，包括字符串、数值、布尔值，甚至还有对象。应用给对象时通常会调用会调用<code>valueOf()</code>或<code>toString()</code>方法。</p>\n<h2> 一元运算符</h2>\n<h3> 递增/递减</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>操作符在前，先自递增/递减后再进行运算。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>操作符在后，先运算再进行自递增/递减。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 一个变量同时等于两个值</h3>\n<p>参考上面所说的，如果是对象，操作符会先调用 valueOf 取值，重写 valueOf 即可使 o == 1 且 o == 2</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 一元加和减</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 算术运算符</h2>\n<ul>\n<li>\n<p>+ 加法比较特殊</p>\n<ul>\n<li>两边都是数字时，做数学运算</li>\n<li>一边为字符串，进行字符串连接</li>\n<li>一边为对象类型 object，将对象使用 toString 方法转换为字符串，进行连接</li>\n</ul>\n</li>\n<li>\n<p>- * / % 只能数学运算 隐式用 Number 转换 不能转 ---&gt; NaN</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 比较运算符</h2>\n<ul>\n<li>大于 &gt;，小于 &lt;，大于等于 &gt;=，小于等于 &lt;=， 等于 ==，全等 =<mark>，不等于 !=，不全等 !</mark>。</li>\n<li>== 等于时：只需要值相等，不用管数据类型，实际上也是通过 Number 进行类型转换</li>\n<li>=== 全等时：不会进行数据类型转换 那么需要两边的数据类型和值都相等</li>\n<li>特例 undefined == null 为真（ js 真理）undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 逻辑运算符</h2>\n<ul>\n<li>非 ! 取反 非真为假 非假为真</li>\n<li>与 &amp;&amp; 与运算见假则假</li>\n<li>或 || 或运算见真则真</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 短路运算</h2>\n<ul>\n<li>短路与： 第一个值为 true 返回第二个值， 第一个值为 false，则返回第一个值</li>\n<li>短路或： 第一个值为 true 返回第一个值， 第一个值为 false，则返回第二个值</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三目运算符</h2>\n<ul>\n<li>方法: ? : ---&gt; 判断条件 ? 当条件为真时 返回的值 ： 当条件为假时返回的值</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 赋值运算符</h2>\n<ul>\n<li>= 赋值 += -= *= /= %=</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 隐式类型转换</h2>\n<ul>\n<li>+ - * / %</li>\n<li>+ 转换方式比较多</li>\n<li>- * / % 都是使用 Number 转数字 能转数字就运算 不能转数字就 NaN</li>\n</ul>\n<h2> 括号/逗号运算符</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>应用</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 指数运算符</h2>\n<ul>\n<li>ES2016 新增了一个指数运算符（**）</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 位操作符</h2>\n<ul>\n<li>\n<p>ECMAScript 中的所有数值都以 IEEE 754 64 位格式存储</p>\n</li>\n<li>\n<p>但位操作并不直接应用到 64 位表示，而是先把值转换为 32 位整数，位操作之后再把结果转换为 64 位。（所以只需要考虑 32 位）</p>\n</li>\n<li>\n<p>32 位，前面 31 位表示数值，32 位表示数值的符号，0 表示正，1 表示负。（称为符号位）</p>\n</li>\n<li>\n<p>正值以二进制格式存储，31 位都是 2 的幂。（第一位 2º，第二位 2¹，以此类推）</p>\n</li>\n</ul>\n<p>数值 18 用二进制来表示为 00000000000000000000000000010010（32 位数），前面的 0 可以省略 10010。</p>\n<p>10010 = (2^4 <em>1)+(2^3</em> 0)+(2^2 <em>0)+(2^1</em> 1)+(2^0 * 0) = 18</p>\n<ul>\n<li>负数以二补数（补码）储存\n<ol>\n<li>以绝对值的二进制表示（-18 先确定 18 的二进制）</li>\n<li>0 变成 1，1 变成 0（称为补数/补码）</li>\n<li>给结果加 1</li>\n</ol>\n</li>\n</ul>\n<p>按上述步骤表示 -18：</p>\n<p>第一步：表示绝对值 18</p>\n<p>0000 0000 0000 0000 0000 0000 0001 0010</p>\n<p>第二步：补码</p>\n<p>1111 1111 1111 1111 1111 1111 1110 1101</p>\n<p>第三部：给补数加 1</p>\n<p>1111 1111 1111 1111 1111 1111 1110 1110 （这就是 -18 的二进制表示）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出'-10010'，这个过程会求处二补数，然后符合逻辑的表示出来。ECMA 中存在无符号的整数，也就是说无符号的整数比有符号的范围更大，因为符号位可以用来表示数值。</p>\n<h3> 按位非</h3>\n<p>~ 来表示，作用是返回数值的补数。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样的结果比<code>-num1 - 1</code>结果更快，位操作符是在底层表示进行的。</p>\n<p>应用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>~a 反补减 1 得 -26，再~ 反补得到正 26 减 1 得到 25。</p>\n<h3> 按位与</h3>\n<p>&amp; 来表示，两个数的位 1 1 得 1，0 1 得 0， 0 0 得 0。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>25 = 0000 0000 0000 0000 0000 0000 0001 1001</p>\n<p>&nbsp;&nbsp;3 = 0000 0000 0000 0000 0000 0000 0000 0011</p>\n<p>只有都为 1 时二进制位才取 1</p>\n<p>0000 0000 0000 0000 0000 0000 0000 0001</p>\n<p>所以结果就是 1</p>\n<h3> 按位或</h3>\n<p>| 来表示，看懂了按位与那么按位或也是同理。有一个位为 1 则为 1，都为 0 时则为 0。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 按位异或</h3>\n<p>^ 来表示，它只有在一位是 1，一位是 0 时才会得 1。都是 0 或都是 1 则得 0。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>相同的两个值，按位异或比按位或得出的结果小 1</p>\n<h3> 左移</h3>\n<p>&lt;&lt; 表示，二进制位向左移动的位数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2 的二进制 10，向左移 5，补了 5 个 0,1000000 即为 64。</p>\n<p>但是左移会保留符号，-2 左移 5 得到 -64，并不是 64</p>\n<h3> 有符号右移</h3>\n<p>&gt;&gt; 表示，与左移同理，也会保留符号。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 无符号右移</h3>\n<p>&gt;&gt;&gt; 表示，</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-01-11T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "JavaScript 判断、循环语句",
      "url": "https://www.h7ml.cn/posts/javascript/basic/statement.html",
      "id": "https://www.h7ml.cn/posts/javascript/basic/statement.html",
      "summary": "JavaScript 判断、循环语句 if if (i &gt; 1) { alert('yes'); } else { alert('no'); }",
      "content_html": "<h1> JavaScript 判断、循环语句</h1>\n<h2> if</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果只有一条可以省略 {}，但容易导致错误，应该避免</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> do-while</h2>\n<ul>\n<li>语句最少执行一次</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> while</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> for</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> for in</h2>\n<ul>\n<li>遍历数组/对象</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> for of</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>break;停止循环</li>\n<li>continue;停止这次循环</li>\n</ul>\n<h2> with</h2>\n<ul>\n<li>改变代码块的作用域，查找变量会先找 obj 里面的</li>\n<li>大量使用 with 会导致性能下降，不建议使用（因为修改了作用域链）</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> switch</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 关键字与保留字</h2>\n<p>ECMA-262 第 6 版规定的所有关键字如下：</p>\n<p><code>break</code> <code>do</code> <code>in</code> <code>typeof</code> <code>case</code> <code>else</code> <code>instanceof</code> <code>var</code> <code>catch</code> <code>export</code> <code>new</code> <code>void</code> <code>class</code> <code>extends</code> <code>return</code> <code>while</code> <code>const</code> <code>finally</code> <code>super</code> <code>with</code> <code>continue</code> <code>for</code> <code>switch</code> <code>yield</code> <code>debugger</code> <code>function</code> <code>this</code> <code>default</code> <code>if</code> <code>throw</code> <code>delete</code> <code>import</code> <code>try</code></p>\n<p>始终保留：<code>enum</code></p>\n<p>严格模式下保留：</p>\n<p><code>implements</code> <code>package</code> <code>public</code> <code>interface</code> <code>protected</code> <code>static</code> <code>let</code> <code>private</code></p>\n<p>模块代码中保留：<code>await</code></p>\n<p>这些词汇不能用作标识符，但现在还可以用作对象的属性名。一般来说最好不要用</p>\n",
      "date_published": "2023-01-11T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "JavaScript 严格模式及运算问题",
      "url": "https://www.h7ml.cn/posts/javascript/basic/strict.html",
      "id": "https://www.h7ml.cn/posts/javascript/basic/strict.html",
      "summary": "JavaScript 严格模式及运算问题 严格模式 'use strict'; // 函数体 告诉支持 JavaScript 引擎切换到严格模式 // 这样写即使低版本的浏览器不支持严格模式也不会报错，他只是个字符串",
      "content_html": "<h1> JavaScript 严格模式及运算问题</h1>\n<h2> 严格模式</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol>\n<li>全局变量声明必须加 var。 必须先声明再使用。</li>\n<li>函数内重名属性</li>\n<li>arguments 对象不被允许修改，只会是传进来的数值</li>\n<li>fn.caller，arguments.callee 不可用</li>\n<li>函数本身不能使用 this 关键字</li>\n<li>eval() 里存在作用域</li>\n<li>新增保留字：implements，interface，let，package，private，protected，public，static，yield。</li>\n</ol>\n<h2> 运算的问题</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> JavaScript 在 HTML 中的引入</h2>\n<p>script 这个元素是由网景公司创造出来，最早在 Netscape Navigator 2 中实现。</p>\n<ul>\n<li>\n<p>charset：src 属性指定的代码字符集。大多数浏览器无视它的值。</p>\n</li>\n<li>\n<p>crossorigin：配置 CORS（跨域）设置，\"anonymous\"请求不设置凭据标志，\"use-credentials\"设置凭据标志，跨域请求会包含凭据。</p>\n</li>\n<li>\n<p>defer：脚本延迟到文档被解析和显示之后再执行! defer 属性只适用于外部脚本文件</p>\n</li>\n<li>\n<p>async：表示立即下载脚本，页面其他操作不影响! async 属性只适用于外部脚本文件</p>\n</li>\n<li>\n<p>integrity：验证子资源完整性。</p>\n</li>\n<li>\n<p>language：废弃。表示代码块中的脚本语言</p>\n</li>\n<li>\n<p>src：要执行的代码的外部文件</p>\n</li>\n<li>\n<p>type：代替 language，表示代码块中的 MIME 类型。默认\"text/javascript\"，实际上\"text/javascript\"和\"text/ecmascript\"已经废弃了。JavaScript 文件的 MIME 类型通常是\"application/x-javascript\"，不过给 type 属性这个值有可能导致脚本被忽略。<strong>如果这个值是 module，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字。</strong></p>\n</li>\n<li>\n<p>不能再任何地方出现<code>&lt;/script&gt;</code>，浏览器遇到<code>&lt;/script&gt;</code>时会认为这是结束的标签</p>\n</li>\n<li>\n<p>解决方法 通过转义字符 \\ 解决这个问题</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 异步脚本</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 推迟脚本</h3>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 动态脚本</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>统一动态脚本加载行为（不一定都支持 async 属性）：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"highlight-lines\"><br><br><div class=\"highlight-line\">&nbsp;</div><br></div><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>让浏览器预先加载 js 文件，js 动态加载 js 脚本浏览器并不知道，想要浏览器知道这个文件的存在可以在文档头部添加：</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-01-11T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "JavaScript 数值转换",
      "url": "https://www.h7ml.cn/posts/javascript/basic/type-check.html",
      "id": "https://www.h7ml.cn/posts/javascript/basic/type-check.html",
      "summary": "JavaScript 数值转换 数据类型 转换为 true 的值 转换为 false 的值 Boolean True False String 非空字符串 '' Number 非 0 数字 0 和 NaN Object 任何对象 null Undefined n/a（不适用） Undefined",
      "content_html": "<h1> JavaScript 数值转换</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据类型</th>\n<th style=\"text-align:center\">转换为 true 的值</th>\n<th style=\"text-align:center\">转换为 false 的值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">True</td>\n<td style=\"text-align:center\">False</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">String</td>\n<td style=\"text-align:center\">非空字符串</td>\n<td style=\"text-align:center\">''</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Number</td>\n<td style=\"text-align:center\">非 0 数字</td>\n<td style=\"text-align:center\">0 和 NaN</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Object</td>\n<td style=\"text-align:center\">任何对象</td>\n<td style=\"text-align:center\">null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Undefined</td>\n<td style=\"text-align:center\">n/a（不适用）</td>\n<td style=\"text-align:center\">Undefined</td>\n</tr>\n</tbody>\n</table>\n<h2> isNaN</h2>\n<ul>\n<li>不能被 number 转换为数字 ----&gt; true</li>\n<li>能被 number 转换为数字 ----&gt; false</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>isNaN 首先会调用对象的 valueOf() 方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 toString() 方法，并测试其返回值</p>\n<h2> isFinite</h2>\n<ul>\n<li>除 NaN 与 Infinity 都返回 true</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Number</h2>\n<ul>\n<li>转换为为数值 无法转换 ---&gt; NaN（不是一个数字）</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> parseInt</h2>\n<ul>\n<li>转换为整数\n<ul>\n<li>参数 1：要转换的变量</li>\n<li>参数 2：以什么进制来转换这个数值，默认 10 进制，0 也是 10 进制</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> parseFloat</h2>\n<ul>\n<li>转换为小数，只解析 10 进制，没有小数点或小数点后面都是 0 会返回整数</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> toString</h2>\n<ul>\n<li>转换为字符串 不能转换 null 和 undefined</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> String</h2>\n<ul>\n<li>转型函数 能转换 null 和 undefined</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>+'' 拼接也可以转换为 string</li>\n</ul>\n",
      "date_published": "2023-01-11T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "javascript 数据类型",
      "url": "https://www.h7ml.cn/posts/javascript/basic/types.html",
      "id": "https://www.h7ml.cn/posts/javascript/basic/types.html",
      "summary": "javascript 数据类型 温馨提示阅读[《JavaScript 高级程序设计（第 4 版）》](https://www.ituring.com.cn/book/2472)和各个大佬的文章所归纳的总结，**如有异议按你的理解为主** ::: JavaScript 中的数据类型分为基本数据类型和引用数据类型 基本类型 注: 基本数据类型也可以叫原始数据类型 在 ES2020 标准下的 JavaScript 一共有以下 7 种基本类型 undefined 未定义 null 空指针 boolean 布尔值 string 字符串 number 数值 symbol 独一无二的值 (ES6 引入) bigint 大整数 (ES2020 引入) 基本类型总结 基本类型仅保存原始值，不存在属性和方法 基本类型存储在 栈内存 中 保存基本类型的变量是 按值 (by value) 访问 的，操作的就是存储在变量中的实际值 复制基本类型时会创建该值的第二个副本 (独立使用，互不干扰)",
      "content_html": "<h1> javascript 数据类型</h1>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">温馨提示阅读[《JavaScript 高级程序设计（第 4 版）》](https://www.ituring.com.cn/book/2472)和各个大佬的文章所归纳的总结，**如有异议按你的理解为主** :::</p>\n<p><code>JavaScript</code> 中的数据类型分为基本数据类型和引用数据类型</p>\n<h2> 基本类型</h2>\n<blockquote>\n<p>注: 基本数据类型也可以叫原始数据类型</p>\n</blockquote>\n<p>在 <code>ES2020</code> 标准下的 <code>JavaScript</code> 一共有以下 7 种基本类型</p>\n<ul>\n<li><strong><code>undefined</code></strong> 未定义</li>\n<li><strong><code>null</code></strong> 空指针</li>\n<li><strong><code>boolean</code></strong> 布尔值</li>\n<li><strong><code>string</code></strong> 字符串</li>\n<li><strong><code>number</code></strong> 数值</li>\n<li><strong><code>symbol</code></strong> 独一无二的值 (<a href=\"https://es6.ruanyifeng.com/#docs/symbol\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 引入</a>)</li>\n<li><strong><code>bigint</code></strong> 大整数 (<a href=\"https://es6.ruanyifeng.com/#docs/number#BigInt-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\" target=\"_blank\" rel=\"noopener noreferrer\">ES2020 引入</a>)</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">基本类型总结</p>\n<ul>\n<li>基本类型仅保存原始值，不存在属性和方法</li>\n<li>基本类型存储在 <strong>栈内存</strong> 中</li>\n<li>保存基本类型的变量是 <strong>按值 (by value) 访问</strong> 的，操作的就是存储在变量中的实际值</li>\n<li>复制基本类型时会创建该值的第二个副本 (独立使用，互不干扰)</li>\n</ul>\n</div>\n</div>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">为什么原始值不存在属性和方法，但 'hello world'.toString() 可以正确执行为了方便操作原始值 `ECMAScript` 提供了 3 种特殊的引用类型：`Boolean` `Number` `String`，每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，在执行完后再销毁这个包装对象 :::</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 引用类型</h2>\n<p>在 <code>JavaScript</code> 中除了基本类型，其他的都是引用类型，常见的引用类型如下</p>\n<ul>\n<li><strong><code>Object</code></strong> 对象</li>\n<li><strong><code>Array</code></strong> 数组</li>\n<li><strong><code>Function</code></strong> 函数</li>\n<li><strong><code>Date</code></strong> 日期与时间</li>\n<li><strong><code>RegExp</code></strong> 正则表达式</li>\n<li><strong><code>Set</code></strong> 类似于数组但成员的值都是唯一的 (<a href=\"https://es6.ruanyifeng.com/#docs/set-map#Set\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 引入</a>)</li>\n<li><strong><code>WeakSet</code></strong> (<a href=\"https://es6.ruanyifeng.com/#docs/set-map#WeakSet\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 引入</a>)</li>\n<li><strong><code>Map</code></strong> 类似于对象也是键值对的集合 (<a href=\"https://es6.ruanyifeng.com/#docs/set-map#Map\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 引入</a>)</li>\n<li><strong><code>WeakMap</code></strong> (<a href=\"https://es6.ruanyifeng.com/#docs/set-map#WeakMap\" target=\"_blank\" rel=\"noopener noreferrer\">ES6 引入</a>)</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">引用类型总结</p>\n<ul>\n<li>因为 <code>JavaScript</code> 不允许直接访问内存位置(不能直接操作对象所在的内存空间)，所以引用类型在 <strong>栈内存</strong> 中存储的是地址(内存指针)，而引用类型中的数据(方法或属性)是存储在 <strong>堆内存</strong> 中</li>\n<li>保存引用类型的变量是 <strong>按引用 (by reference) 访问</strong> ，实际上操作的是对该对象的引用而非实际的对象本身</li>\n<li>复制引用类型时只会复制内存指针</li>\n</ul>\n</div>\n</div>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">栈内存和堆内存</p>\n<ul>\n<li><strong>栈内存</strong>\n<ul>\n<li>存储基本数据类型和堆内存地址</li>\n<li>是连续的内存空间</li>\n</ul>\n</li>\n<li><strong>堆内存</strong>\n<ul>\n<li>存储引用数据类型和闭包中的变量</li>\n<li>不是连续的内存空间</li>\n</ul>\n</li>\n<li>了解更多请点击 <a href=\"https://github.com/chenqf/frontEndBlog/issues/9\" target=\"_blank\" rel=\"noopener noreferrer\">JS 中的栈内存和堆内存</a></li>\n</ul>\n</div>\n<h2> 类型判断</h2>\n<p>常见的五种判断方式</p>\n<ul>\n<li><strong><code>typeof</code></strong></li>\n<li><strong><code>instanceof</code></strong></li>\n<li><strong><code>constructor</code></strong></li>\n<li><strong><code>Array.isArray()</code></strong></li>\n<li><strong><code>Object.prototype.toString</code></strong></li>\n</ul>\n<h3> typeof</h3>\n<ul>\n<li>除 <strong><code>null</code></strong> 外的基本类型都能准确判断</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">为什么 typeof null === 'object' 在 `JavaScript` 最初的实现中，`JavaScript` 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 `0`。由于 `null` 代表的是空指针（大多数平台下值为 `0x00`），因此`null` 的类型标签是 `0`，`typeof null` 也因此返回 `\"object\"` —— [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#typeof_null) :::</p>\n<ul>\n<li>除 <strong><code>function</code></strong> 外的引用类型均返回 <code>object</code></li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> instanceof</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof\" target=\"_blank\" rel=\"noopener noreferrer\"><code>instanceof</code></a> 用于检测构造函数的 <code>prototype</code> 属性是否存在于实例对象的原型链上</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">instanceof 总结</p>\n<ul>\n<li><code>instanceof</code> 不能判断基本类型，对于引用类型只能判断原型链上的从属关系</li>\n<li><code>instanceof</code> 并不完全可靠，因为构造函数的 <code>prototype</code> 属性可能会被修改\n<ul>\n<li>修改原型的方法\n<ul>\n<li>使用 <code>ES6</code> 提供的 <a href=\"https://es6.ruanyifeng.com/?search=%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B&amp;x=0&amp;y=0#docs/reflect#Reflect-setPrototypeOfobj-newProto\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Reflect.setPrototypeOf()</code></a> 方法</li>\n<li>借助于非标准的 <code>__proto__</code> 伪属性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n</div>\n<h3> constructor</h3>\n<p>实例对象可以通过 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor\" target=\"_blank\" rel=\"noopener noreferrer\"><code>constructor</code></a> 属性去访问它的构造函数</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">constructor 总结</p>\n<ul>\n<li><code>constructor</code> 可以判断除 <code>undefined</code> 和 <code>null</code> 外的所有基本类型和引用类型(<code>undefined</code> 和 <code>null</code> 不存在构造函数)</li>\n<li><code>constructor</code> 并不完全可靠，因为构造函数的 <code>prototype</code> 属性可能会被修改，从而造成 <code>constructor</code> 属性指向不准确</li>\n</ul>\n</div>\n<h3> Array.isArray()</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Array.isArray()</code></a> 用于判断一个值是否是数组 (<code>Array</code>)</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Object.prototype.toString</h3>\n<ul>\n<li>每个对象都有一个 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\" target=\"_blank\" rel=\"noopener noreferrer\"><code>toString()</code></a> 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用，默认情况下 <code>toString()</code> 方法被每个 <code>Object</code> 对象继承。如果此方法在自定义对象中未被覆盖 <code>toString()</code> 返回 <code>\"[object type]\"</code> 其中 <code>type</code> 是对象的类型</li>\n<li>为了每个对象都能通过 <code>Object.prototype.toString()</code> 来检测，需要以 <code>Function.prototype.call()</code> 或者 <code>Function.prototype.apply()</code> 的形式来调用</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>toString</code> 方法的在 <a href=\"https://es5.github.io/#x15.2.4.2\" target=\"_blank\" rel=\"noopener noreferrer\"><code>ECMAScript 5</code></a> 下的大致执行过程</p>\n<ol>\n<li>如果 <code>this</code> 是 <code>undefined</code> 返回 <code>[object Undefined]</code></li>\n<li>如果 <code>this</code> 是 <code>null</code> 返回 <code>[object Null]</code></li>\n<li>让 <code>O</code> 成为 <code>ToObject(this)</code> 的结果</li>\n<li>让 <code>class</code> 成为 <code>O</code> 的内部属性 <code>[[Class]]</code> 的值</li>\n<li>返回由 <strong><code>\"[object \"</code></strong> <strong><code>class</code></strong> <strong><code>\"]\"</code></strong> 三个部分组成的字符串</li>\n</ol>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意点</p>\n<p>不同 <code>ECMAScript</code> 版本对 <code>toString</code> 方法的规范都有所不同</p>\n<p><a href=\"https://juejin.cn/post/6972878737582850062#heading-27\" target=\"_blank\" rel=\"noopener noreferrer\">Object.prototype.toString 方法的原理</a></p>\n</div>\n",
      "date_published": "2019-08-16T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript 数据类型"
      ]
    },
    {
      "title": "JavaScript 变量、作用域、内存",
      "url": "https://www.h7ml.cn/posts/javascript/basic/variable.html",
      "id": "https://www.h7ml.cn/posts/javascript/basic/variable.html",
      "summary": "JavaScript 变量、作用域、内存 原始值与引用值 ECMAScript 分为两种数据类型： 1、原始值：最简单的数据（undefined null boolean number string symbol）。 2、引用值：由多个值构成的对象，保存在内存中的对象（js 不能直接访问内存地址，也就不能操作对象所在内存空间，所以实际操作只是对该对象的引用操作）。",
      "content_html": "<h1> JavaScript 变量、作用域、内存</h1>\n<h2> 原始值与引用值</h2>\n<p>ECMAScript 分为两种数据类型： 1、原始值：最简单的数据（<code>undefined</code> <code>null</code> <code>boolean</code> <code>number</code> <code>string</code> <code>symbol</code>）。 2、引用值：由多个值构成的对象，保存在内存中的对象（js 不能直接访问内存地址，也就不能操作对象所在内存空间，所以实际操作只是对该对象的<strong>引用</strong>操作）。</p>\n<h3> 原始值不能有属性</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 复制值</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 函数传参</h3>\n<ul>\n<li>原始值传递</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>引用值传递</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>例 2：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 上下文</h2>\n<p>“上下文”在 js 中非常重要。它决定了变量和函数访问的数据以及行为，上下文储存在<code>variable object</code>对象上，但无法通过代码访问，后台处理时会用到它。</p>\n<p>全局上下文：在 ECMA 所述的宿主环境，全局上下文对象可能不一样，浏览器中为<code>window</code>对象，<code>node.js</code>环境下则是<code>global</code>对象。通过<code>var</code>声明的全局变量都会成为<code>window</code>对象的属性或方法。let、const 则不会，但是在作用域链效果是一样的。</p>\n<p>eval()调用内部存在第三种上下文。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 改变作用域</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>with</code>语句将<code>Promise</code>作为当前作用域的上下文。这里的<code>all</code>访问的就是<code>Promise</code>中的实例对象（不能是原型对象上的属性或方法）。</p>\n<h3> 变量声明</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 标识符查找</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 垃圾回收</h2>\n<p>JavaScript 通过自动内存管理内存的分配和闲置资源的回收：确定哪个变量不会再使用，释放它的内存。这个过程每隔一段时间或预定时间就会自动运行。但这个过程是不完美的方案，在一个代码块内哪些变量是否还有用是一个“无法判定”的问题。</p>\n<p>以一个函数作用域周期为例，执行函数时，会分配该函数到栈或堆内存中保存对应的值，函数内部使用了变量，退出。此时就可以释放局部的变量了。但并不会这么明显，垃圾回收需要跟踪哪些变量还会继续使用：在浏览器的发展史上，用到过标记清理和引用计数。</p>\n<h3> 标记清理</h3>\n<p>当变量在进入上下文时，从逻辑上讲只要在上下文中就不应该释放它们的内存，只要上下文在运行就可能用到它。当离开上下文时就会被加上离开上下文的标记。如“在上下文中”和“不在上下文中”两个列表。</p>\n<p>在垃圾回收程序运行时，它会将所有在当前上下文中变量及被上下文中引用的变量标记去掉，之后再被加上标记的变量就是待删除了，原因是在任何上下文中的变量都访问不到它们了。之后垃圾回收程序会做一次清理，清除带有标记的值并回收它们的内存。</p>\n<h3> 引用计数</h3>\n<p>引用计数没有标记清理那么常用。在声明一个变量时，这个值引用次数为 1。如果这个值被赋值到另一个值，引用数就会加 1。相反，这个值被新的值覆盖，引用数就会减 1。但引用数为 0 时就没办法访问这个值了。等待垃圾回收程序运行时就会释放引用数为 0 的值。</p>\n<p>但引用计数有一个严重的问题：循环引用</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的两个变量互相引用，引用数都是 2。在标记清理策略下会被回收，但在引用计数下，这两个值还会存在。他们的引用数永远不会变成 0。这个函数被调用多次就会造成很多内存不会释放。因此，早期的网景浏览器就放弃了引用计数。</p>\n<p>但引用计数的问题在 IE8 之前也有许多问题，BOM 和 DOM 对象是 C++实现的，并非 js 引擎的标记清理，只要设计了 DOM 和 BOM 对象就无法避开引用的问题。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 IE9 中把 BOM 和 DOM 对象都改成了 js 对象，从而避免了两套垃圾回收算法与内存泄露的问题。</p>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">警告在 IE 中`window.CollectGarbage()`方法会立即触发垃圾回收。在 Opera 7 及更高版本中，调用`window.opera.collect()`也会启动垃圾回收程序。这些方法有可能触发垃圾回收（不推荐）。 :::</p>\n<h2> 内存管理</h2>\n<p>在系统中，分配给浏览器的内存一般比桌面软件要少很多。</p>\n<p>如果数据不再需要，那么把它赋值为<code>null</code>。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用<code>const</code>与<code>let</code>可以更早的让垃圾回收程序处理。</p>\n<h3> 隐藏类</h3>\n<p>在<code>chrome</code>的 V8 JavaScript 引擎解释 js 时会利用隐藏类。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>o1</code>和<code>o2</code>共享相同的隐藏类、构造函数以及原型。</p>\n<p>如果后续代码做了添加操作：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>此时两个类的实例就会对应不同的隐藏类。</p>\n<p>解决方案（避免先创建再新增）：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果后续代码做了删除操作：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>此时两个类的实例就会对应不同的隐藏类（与动态添加的后果是一样的）。</p>\n<p>解决方案（把不想要的属性设置为<code>null</code>）：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 内存泄露</h3>\n<ul>\n<li>没有加声明关键字会导致属性被添加到<code>window</code>上，只要<code>window</code>没有被清除属性就不会消失。</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>定时器也会导致内存泄漏</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定时器一直执行就会导致<code>name</code>一直被引用。</p>\n<ul>\n<li>闭包也会造成内存泄漏</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>调用<code>globalFun</code>方法返回的函数只要一直引用它，内部的<code>obj</code>也不会被清理掉。</p>\n</div>\n",
      "date_published": "2023-01-11T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "JavaScript BOM 常用方法",
      "url": "https://www.h7ml.cn/posts/javascript/bom/BOM%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.html",
      "id": "https://www.h7ml.cn/posts/javascript/bom/BOM%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.html",
      "summary": "JavaScript BOM 常用方法 BOM 系统对话框 alert('hello'); confirm('确定？'); // 返回 true false prompt('输入文本', '默认文本'); // 返回输入的值，取消返回 null window.print(); // 打印对话框 window.find(); // 查找对话框",
      "content_html": "<h1> JavaScript BOM 常用方法</h1>\n<figure><figcaption>BOM</figcaption></figure>\n<h2> 系统对话框</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> console.time()</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>测试从上一个 test1 到这行代码运行所用的时间</p>\n<h2> open 及 close</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "javascript Bom",
      "url": "https://www.h7ml.cn/posts/javascript/bom/",
      "id": "https://www.h7ml.cn/posts/javascript/bom/",
      "content_html": "",
      "date_published": "2022-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "JavaScript history 历史记录",
      "url": "https://www.h7ml.cn/posts/javascript/bom/history.html",
      "id": "https://www.h7ml.cn/posts/javascript/bom/history.html",
      "summary": "JavaScript history 历史记录 history.go(-1); // 后退一页 history.go(0); // 刷新当前页面 history.go(2); // 前进两页 history.go('wrox.com'); // 跳转到最近 wrox.com 的页面 history.back(); // 后退一页 history.forward(); // 前进一页 history.length == 0; // 这是用户打开宽口后的第一个页面",
      "content_html": "<h1> JavaScript history 历史记录</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript location URL 地址对象",
      "url": "https://www.h7ml.cn/posts/javascript/bom/location.html",
      "id": "https://www.h7ml.cn/posts/javascript/bom/location.html",
      "summary": "JavaScript location URL 地址对象 完整的 URL 地址： 协议：// 主机名：端口号 /路径/ ？查询字符串 #锚点 如：https://127.0.0.1:5500/javascript.html/?a=ssa&amp;bd=asd#aaa location.hash // #aaa 哈希值 location.host // 127.0.0.1:5500 域名+端口 location.hostname // 127.0.0.1 域名 location.href // https:127.0.0.1:5500/?a=ssa&amp;bd=asd#aaa url 地址 toString() 也能返回这个值 location.origin // https:127.0.0.1:5500 文件来源地址 location.pathname // /JavaScript.html 文件路径 location.port // 5500 端口 location.protocol // https: 协议 location.search // ?a=ssa&amp;bd=asd 表单提交的数据 location.port = 8080; // 可以用这样的方法修改上面的值，除了 hash 值外，页面都会以新的 URL 重新加载 location = 'http:// www.163.com'; location.assign(url)// 在当前窗口跳转到这个URL location.replace(\"http:// baidu.com\"); *// 在当前窗口替换成新的 URL 用户将不能回到前一个页面* location.reload();// 重新加载（可能从缓存中加载） location.reload(true);// 重新加载（从服务器重新加载）",
      "content_html": "<h1> JavaScript location URL 地址对象</h1>\n<p>完整的 URL 地址：</p>\n<p>协议：// 主机名：端口号 /路径/ ？查询字符串 #锚点</p>\n<p>如：<a href=\"https://127.0.0.1:5500/javascript.html/?a=ssa&amp;bd=asd#aaa\" target=\"_blank\" rel=\"noopener noreferrer\">https://127.0.0.1:5500/javascript.html/?a=ssa&amp;bd=asd#aaa</a></p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript navigator 浏览器信息",
      "url": "https://www.h7ml.cn/posts/javascript/bom/navigator.html",
      "id": "https://www.h7ml.cn/posts/javascript/bom/navigator.html",
      "summary": "JavaScript navigator 浏览器信息 navigator.appCodeName; //浏览器代号 navigator.appName; // 浏览名称 navigator.appVersion; // 浏览器版本 navigator.cookieEnabled; // 是否启用 cookie navigator.language; // 系统语言：标准 navigator.systemLanguage; // 系统语言：ie navigator.platform; // 操作系统 navigator.userAgent; // 用户代理",
      "content_html": "<h1> JavaScript navigator 浏览器信息</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript client、client、scroll 窗口位置",
      "url": "https://www.h7ml.cn/posts/javascript/bom/%E7%AA%97%E5%8F%A3%E4%BD%8D%E7%BD%AE.html",
      "id": "https://www.h7ml.cn/posts/javascript/bom/%E7%AA%97%E5%8F%A3%E4%BD%8D%E7%BD%AE.html",
      "summary": "JavaScript client、client、scroll 窗口位置 p.clientWidth; // 可视宽度 width + padding p.clientTop; // 上边框宽度 p.clientLeft; // 左边框宽度 p.offsetParent; // 获取上一个带有定位的父元素 p.offsetWidth; // 占位宽度 width + padding + border p.offsetLeft; // 距上一个具有定位元素边框的距离 document.documentElement.clientWidth || document.body.clientWidth; // 宽口宽度 document.documentElement.scrollTop / Left; // 已滚动出的距离",
      "content_html": "<h1> JavaScript client、client、scroll 窗口位置</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><figcaption>javascript 获取 client、offset值</figcaption></figure>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "javascript Dom",
      "url": "https://www.h7ml.cn/posts/javascript/dom/",
      "id": "https://www.h7ml.cn/posts/javascript/dom/",
      "content_html": "",
      "date_published": "2022-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "JavaScript attribute 属性操作",
      "url": "https://www.h7ml.cn/posts/javascript/dom/attribute.html",
      "id": "https://www.h7ml.cn/posts/javascript/dom/attribute.html",
      "summary": "JavaScript attribute 属性操作 div.getAttribute('className'); // 获取属性 div.setAttribute('class', 'ft'); // 设置属性 div.removeAttribute('class'); // 删除属性 div.attributes; // 获取 div 所有的属性 返回集合",
      "content_html": "<h1> JavaScript attribute 属性操作</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript classList 属性",
      "url": "https://www.h7ml.cn/posts/javascript/dom/classList.html",
      "id": "https://www.h7ml.cn/posts/javascript/dom/classList.html",
      "summary": "JavaScript classList 属性 div.classList.remove('user'); // 删除 user 类 div.classList.add('current'); // 添加 current 类 div.classList.toggle('user'); // 切换 user 类 div.classList.contains('d'); // 判断是否有 d 类 btn.onfocus(); // 获取焦点 btn.onblur(); // 取消焦点 // 兼容模式 document.compatMode; // 标准模式下 CSS1Compat 混杂模式下 BackCompat // data- 属性 var name = div.dataset.name; // 123 取得自定义 data 属性的值 div.dataset.name = '222'; // 设置 data 属性的值",
      "content_html": "<h1> JavaScript classList 属性</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript 获取 CSS 样式",
      "url": "https://www.h7ml.cn/posts/javascript/dom/%E6%A0%B7%E5%BC%8F%E6%93%8D%E4%BD%9C.html",
      "id": "https://www.h7ml.cn/posts/javascript/dom/%E6%A0%B7%E5%BC%8F%E6%93%8D%E4%BD%9C.html",
      "summary": "JavaScript 获取 CSS 样式 // 兼容所有浏览器 function getStyle(node, cssStyle) { // IE获取 标准浏览器 return node.currentStyle ? node.currentStyle[cssStyle] : getComputedStyle(node)[cssStyle]; } getComputedStyle(div)['width']; // 标准浏览器 div.currentStyle['width']; // 兼容 IE 浏览器 // div.style 只能获取到行间的 css 样式 div.style.cssText = 'width: 200px;height: 30px;'; // 设置 css 样式 div.style.getPropertyValue('width'); // 200px 取得宽度值 div.style.removeProperty('width'); // 删除 width 属性 // 取得计算后的 css 样式 div.style.cssText = 'width:200px'; div.style.getPropertyValue('width'); // 取得设置 cssText 的样式",
      "content_html": "<h1> JavaScript 获取 CSS 样式</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript 获取节点，操作节点",
      "url": "https://www.h7ml.cn/posts/javascript/dom/%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C.html",
      "id": "https://www.h7ml.cn/posts/javascript/dom/%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C.html",
      "summary": "JavaScript 获取节点，操作节点 获取节点 父节点.childNodes 获取子节点（包含一切节点） p.nodeType == 1// true 判断是否存在节点 是不是一个元素 // 1 元素节点 2 属性节点 3 文本节点 p.nodeName // #text 文本节点的名字 // P 元素节点的元素名 大写 // #comment 注释节点的名字 p.nodeValue // 文本节点的内容 // 必须是文本节点，元素节点会返回 null 父元素.children 获取子节点 // IE9+ 正常 // IE8-中 会获取 注释和元素节点 // 父节点 p.parentNode;// 获取直系父元素 p.offsetParent;// 获取上一个带有定位的父元素，position:stalic不算 /* 兼容方法 firstchild 都有值，firstElementChild IE 会 undefined 短路运算 firstElementChild || firstchild; */ // 子节点 p.firstChild;// 标准浏览器获取第一个 文本或换行 节点，IE 只获取第一个元素 p.firstElementChild;// 标准浏览器只获取第一个元素，IE 为 undefined lastElementChild || lastChild; 最后一个子节点 // 兄弟节点 p.previousElementSibling || p.previousSibling;// 上一个兄弟节点 p.nextElementSibling || p.nextSibling;// 下一个兄弟节点",
      "content_html": "<h1> JavaScript 获取节点，操作节点</h1>\n<h2> 获取节点</h2>\n<p>父节点.childNodes 获取子节点（包含一切节点）</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 操作节点</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript document 获取元素（选择符）",
      "url": "https://www.h7ml.cn/posts/javascript/dom/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0.html",
      "id": "https://www.h7ml.cn/posts/javascript/dom/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0.html",
      "summary": "JavaScript document 获取元素（选择符） document.querySelector('css选择器'); // 只选择符合的第一个，静态获取，后添加的元素不会加进来 document.querySelectorAll('css选择器'); // 取得 span 伪数组集合 document.body.MatchesSelector('body.page'); // 这个方法能够判断能否 被以上两个方法选择返回 document.getElementsByTagName('标签名'); // 获取标签名 集合 document.getElementsByClassName('class名'); // 获取 class 集合 document.getElementsByName('name属性值'); // 使用在表单元素 div.namedItem('aa'); // div 中 name 属性为 aa 的集合 div['aa']; // div 中 name 属性为 aa 的集合 div.tagName; // DIV 在 HTML 中始终以大写表示 document.title; // 取得文档标题 document.URL; // 取得地址栏显示的 URL 不能修改 document.domain; // 域 p2p.wrox.com 修改成 wrox.com 可以成功 修改成其他跨域会出错 document.referrer; // 取得来源此页面的URL // 特殊集合 document.anchors; // 所有带 name 特性的 a 标签 document.forms; // 所有 form 元素 document.images; // 所有 img 元素 document.links; // 所有带 href 特性的 a元素",
      "content_html": "<h1> JavaScript document 获取元素（选择符）</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">注意 querySelector 系列是静态的，在获取元素之后新添加的节点不会加进来 :::</p>\n</div>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript 表格操作",
      "url": "https://www.h7ml.cn/posts/javascript/dom/%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C.html",
      "id": "https://www.h7ml.cn/posts/javascript/dom/%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C.html",
      "summary": "JavaScript 表格操作 var tab = document.getElementById('table'); tab.tHead; // 表头 tab.tBodies[0]; // 表体 多个tbody tab.tFoot; // 表尾 tab.tBodies[0].rows[1]; // tr 一行 tab.tBodies[0].rows[1].cells[1]; // td 单元格",
      "content_html": "<h1> JavaScript 表格操作</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "javascript 动画",
      "url": "https://www.h7ml.cn/posts/javascript/event/",
      "id": "https://www.h7ml.cn/posts/javascript/event/",
      "content_html": "",
      "date_published": "2022-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "JavaScript UI 事件",
      "url": "https://www.h7ml.cn/posts/javascript/event/UI%E4%BA%8B%E4%BB%B6.html",
      "id": "https://www.h7ml.cn/posts/javascript/event/UI%E4%BA%8B%E4%BB%B6.html",
      "summary": "JavaScript UI 事件 属性/方法 类型 说明 bubbles Boolean 事件是否冒泡 stopPropagation() Function Firefox chrome 取消捕捉/冒泡，bubbles 为 true cancelable Boolean IE8 chrome 取消默认行为 preventDefault() Function Firefox chrome 取消默认行为。cancelable 为 true， currentTarget Element 全等 === this defaultPrevented Boolean 是否调用 preventDefalt() detail integer Firefox 滚动滚轮相关信息 eventPhase integer 调用事件处理程序阶段：1 表示捕捉阶段 2 表示处于目标 3 表示冒泡阶段 stopImmediatePropagation() Function 取消捕捉/冒泡，同时阻止任何事件处理程序被调用 target Element 当前触发的元素 trusted Boolean 为 true 表示事件是浏览器生成的，false 表示 js 生成写的 type String 被触发事件的类型 view AbstractView 与事件关联的抽象视图。等同于发生事件的 window 对象",
      "content_html": "<h1> JavaScript UI 事件</h1>\n<table>\n<thead>\n<tr>\n<th>属性/方法</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bubbles</td>\n<td>Boolean</td>\n<td>事件是否冒泡</td>\n</tr>\n<tr>\n<td>stopPropagation()</td>\n<td>Function</td>\n<td>Firefox chrome 取消捕捉/冒泡，bubbles 为 true</td>\n</tr>\n<tr>\n<td>cancelable</td>\n<td>Boolean</td>\n<td>IE8 chrome 取消默认行为</td>\n</tr>\n<tr>\n<td>preventDefault()</td>\n<td>Function</td>\n<td>Firefox chrome 取消默认行为。cancelable 为 true，</td>\n</tr>\n<tr>\n<td>currentTarget</td>\n<td>Element</td>\n<td>全等 === this</td>\n</tr>\n<tr>\n<td>defaultPrevented</td>\n<td>Boolean</td>\n<td>是否调用 preventDefalt()</td>\n</tr>\n<tr>\n<td>detail</td>\n<td>integer</td>\n<td>Firefox 滚动滚轮相关信息</td>\n</tr>\n<tr>\n<td>eventPhase</td>\n<td>integer</td>\n<td>调用事件处理程序阶段：1 表示捕捉阶段 2 表示处于目标 3 表示冒泡阶段</td>\n</tr>\n<tr>\n<td>stopImmediatePropagation()</td>\n<td>Function</td>\n<td>取消捕捉/冒泡，同时阻止任何事件处理程序被调用</td>\n</tr>\n<tr>\n<td>target</td>\n<td>Element</td>\n<td>当前触发的元素</td>\n</tr>\n<tr>\n<td>trusted</td>\n<td>Boolean</td>\n<td>为 true 表示事件是浏览器生成的，false 表示 js 生成写的</td>\n</tr>\n<tr>\n<td>type</td>\n<td>String</td>\n<td>被触发事件的类型</td>\n</tr>\n<tr>\n<td>view</td>\n<td>AbstractView</td>\n<td>与事件关联的抽象视图。等同于发生事件的 window 对象</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript event 事件对象",
      "url": "https://www.h7ml.cn/posts/javascript/event/event%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1.html",
      "id": "https://www.h7ml.cn/posts/javascript/event/event%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1.html",
      "summary": "JavaScript event 事件对象 早期火狐不兼容 event 需要传参 ev var ev = ev || event;",
      "content_html": "<h1> JavaScript event 事件对象</h1>\n<p>早期火狐不兼容 event 需要传参 ev</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>鼠标按下/单击：mousedown，支持\n<ul>\n<li>e.button：0 左键 1 滚轮 2 右键</li>\n</ul>\n</li>\n<li>鼠标位置：鼠标事件支持\n<ul>\n<li>e.offsetX/Y：距离当前触发元素的 left/top 值</li>\n<li>e.clientX/Y：可视区 left/top 值</li>\n<li>e.pageX/Y：页面文档的 top/left 值</li>\n<li>e.screenX/Y：屏幕左上角 left/top 值</li>\n</ul>\n</li>\n<li>热键：keydown 支持，按下为 true\n<ul>\n<li>e.shiftkey：Boolean</li>\n<li>e.altKey：Boolean</li>\n<li>e.ctrlKey：Boolean</li>\n<li>e.metakey：windows ---&gt; windows 键，macos ---&gt; command 键</li>\n</ul>\n</li>\n<li>键盘按下：keydown/keyup 支持\n<ul>\n<li>e.which/e.keycode：返回按下的 ascll 码值，不区分大小写</li>\n<li>enter：13</li>\n<li>shift：16</li>\n<li>ctrl：17</li>\n<li>alt：18</li>\n<li>a：65</li>\n<li>上下左右：37 38 39 40</li>\n</ul>\n</li>\n<li>键盘按下：keypress 仅支持字符键（DOM3 被弃用）\n<ul>\n<li>e.which/e.charCode：返回按下的 ascll 码值，区分大小写</li>\n</ul>\n</li>\n<li>滚动\n<ul>\n<li>e.wheelDelta：chrome IE 向下 -120 向上 120</li>\n<li>e.datail：firefox 向下 3 向上 -3</li>\n</ul>\n</li>\n</ul>\n<p>兼容:</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript 鼠标事件、键盘事件、表单事件、window 事件",
      "url": "https://www.h7ml.cn/posts/javascript/event/%E4%BA%8B%E4%BB%B6%E5%88%86%E7%B1%BB.html",
      "id": "https://www.h7ml.cn/posts/javascript/event/%E4%BA%8B%E4%BB%B6%E5%88%86%E7%B1%BB.html",
      "summary": "JavaScript 鼠标事件、键盘事件、表单事件、window 事件 鼠标事件 click：单击 dblclick：双击 mouseover：移入（子节点会触发） mouseout：移出（子节点会触发） mousemove：移动（会不停的触发） mouseenter：移入（子节点不会触发）IE8+ mouseleave：移出（子节点不会触发）IE8+ mousedown：按下（左右键） mouseup：抬起（左右键） contextmenu：右键单击（上下文环境菜单） onmousewheel：chrome ie 滚轮滚动 e.wheelDalta：向下 -120 向上 120 DOMMouseScroll：firefox 只能事件绑定 滚轮滚动 e.detail：向下 3 向上 -3",
      "content_html": "<h1> JavaScript 鼠标事件、键盘事件、表单事件、window 事件</h1>\n<h2> 鼠标事件</h2>\n<ul>\n<li>click：单击</li>\n<li>dblclick：双击</li>\n<li>mouseover：移入（子节点会触发）</li>\n<li>mouseout：移出（子节点会触发）</li>\n<li>mousemove：移动（会不停的触发）</li>\n<li>mouseenter：移入（子节点不会触发）IE8+</li>\n<li>mouseleave：移出（子节点不会触发）IE8+</li>\n<li>mousedown：按下（左右键）</li>\n<li>mouseup：抬起（左右键）</li>\n<li>contextmenu：右键单击（上下文环境菜单）</li>\n<li>onmousewheel：chrome ie 滚轮滚动\n<ul>\n<li>e.wheelDalta：向下 -120 向上 120</li>\n</ul>\n</li>\n<li>DOMMouseScroll：firefox 只能事件绑定 滚轮滚动\n<ul>\n<li>e.detail：向下 3 向上 -3</li>\n</ul>\n</li>\n</ul>\n<h2> 键盘事件</h2>\n<ul>\n<li>keydown：键盘按下（按下不动会一直触发）</li>\n<li>keyup：键盘抬起</li>\n<li>keypress：键盘按下（只支持字符键）</li>\n</ul>\n<h2> window 事件</h2>\n<ul>\n<li>load：当页面加载完成以后会触发</li>\n<li>unload：当页面解构的时候触发（刷新页面，关闭当前页面）IE 浏览器兼容</li>\n<li>scroll：页面滚动 不停的触发</li>\n<li>resize：窗口大小发生变化 不停的触发</li>\n<li>visibilitychange：标签显示或隐藏时触发</li>\n<li>blur：获取焦点时触发</li>\n<li>focus：失去焦点时触发</li>\n</ul>\n<h2> 表单事件</h2>\n<ul>\n<li>input：value 值发生改变</li>\n<li>blur：失去焦点</li>\n<li>focus：获取焦点</li>\n<li>select：输入框中文本被选中触发</li>\n<li>change：当输入框被修改且失去焦点必须添加到 form 表单元素上</li>\n<li>submit：点击 submit 按钮才触发</li>\n<li>reset：点击 reset 按钮才触发</li>\n</ul>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript 事件委托",
      "url": "https://www.h7ml.cn/posts/javascript/event/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98.html",
      "id": "https://www.h7ml.cn/posts/javascript/event/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98.html",
      "summary": "JavaScript 事件委托 e.target：chrome e.srcElement：IE8- 兼容： e.target || e.srcElement;",
      "content_html": "<h1> JavaScript 事件委托</h1>\n<ul>\n<li>e.target：chrome</li>\n<li>e.srcElement：IE8-</li>\n</ul>\n<p>兼容：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>利用 e.target.nodeName 或当前节点的 id 来委托事件</p>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript IE、chrome 事件监听",
      "url": "https://www.h7ml.cn/posts/javascript/event/%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC.html",
      "id": "https://www.h7ml.cn/posts/javascript/event/%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC.html",
      "summary": "JavaScript IE、chrome 事件监听 绑定事件 chrome addEventListener('click', fn, false);",
      "content_html": "<h1> JavaScript IE、chrome 事件监听</h1>\n<h2> 绑定事件</h2>\n<p>chrome</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>事件（不带 on），函数</li>\n<li>默认 false 冒泡触发，true 捕捉阶段触发</li>\n</ul>\n<p>IE</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>事件（带 on），函数</li>\n</ul>\n<h2> 解绑事件</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>区别：</p>\n<ul>\n<li>事件：chrome 不带 on IE 带 on</li>\n<li>函数执行顺序：chrome 顺序执行 IE 逆序执行</li>\n<li>是否支持捕捉触发：chrome 支持 IE 只支持冒泡</li>\n<li>this 指向：chrome 调用对象 IE window 对象</li>\n</ul>\n<p>兼容</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript 阻止冒泡及默认行为",
      "url": "https://www.h7ml.cn/posts/javascript/event/%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E5%8F%8A%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA.html",
      "id": "https://www.h7ml.cn/posts/javascript/event/%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E5%8F%8A%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA.html",
      "summary": "JavaScript 阻止冒泡及默认行为 阻止冒泡 e.cancalBubble = true：IE8- chrome e.stopPropagation()：firefox chrome 兼容： e.stopPropagation ? e.stopPropagation() : (e.cancalBubble = true);",
      "content_html": "<h1> JavaScript 阻止冒泡及默认行为</h1>\n<h2> 阻止冒泡</h2>\n<ul>\n<li>e.cancalBubble = true：IE8- chrome</li>\n<li>e.stopPropagation()：firefox chrome</li>\n</ul>\n<p>兼容：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 阻止默认行为</h2>\n<ul>\n<li>普通函数: return false</li>\n<li>addEventListener：e.preventDefault() // chrome</li>\n<li>attachEvent：e.returnValue = false // IE</li>\n</ul>\n<p>兼容：</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 阻止 IE 选择事件</h2>\n<ul>\n<li>onmousedown：setCapture() 设置捕获</li>\n<li>onkeydown：releaseCapture() 释放捕获</li>\n</ul>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript 表单属性、方法",
      "url": "https://www.h7ml.cn/posts/javascript/form/%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95%E4%BA%8B%E4%BB%B6.html",
      "id": "https://www.h7ml.cn/posts/javascript/form/%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95%E4%BA%8B%E4%BB%B6.html",
      "summary": "JavaScript 表单属性、方法 对象属性，方法 acceptCharset：服务器能够处理的字符集，等价于 HTML 中的 accept-charset action：接受请求的 URL，等价于 HTML 中的 action 特性 elements：表单中所有控件（HTMLCollection） enctype：请求编码类型 length：表单中控件的数量 method：要发送的 HTTP 请求类型，通常是 get、post name：表单名称 target：用于发送请求和接收响应的窗口名称 reset()：讲所有表单域重置为默认值 submit()：提交表单",
      "content_html": "<h1> JavaScript 表单属性、方法</h1>\n<h2> 对象属性，方法</h2>\n<ul>\n<li>acceptCharset：服务器能够处理的字符集，等价于 HTML 中的 accept-charset</li>\n<li>action：接受请求的 URL，等价于 HTML 中的 action 特性</li>\n<li>elements：表单中所有控件（HTMLCollection）</li>\n<li>enctype：请求编码类型</li>\n<li>length：表单中控件的数量</li>\n<li>method：要发送的 HTTP 请求类型，通常是 get、post</li>\n<li>name：表单名称</li>\n<li>target：用于发送请求和接收响应的窗口名称</li>\n<li>reset()：讲所有表单域重置为默认值</li>\n<li>submit()：提交表单</li>\n</ul>\n<div class=\"language-html line-numbers-mode\" data-ext=\"html\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 获取元素</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 事件</h2>\n<p>事件也对应的有方法，form.submit() 为提交</p>\n<ul>\n<li>表单事件\n<ul>\n<li>input：value 值发生改变</li>\n<li>onpropertychange: IE value 值改变时</li>\n<li>blur：失去焦点</li>\n<li>focus：获取焦点</li>\n<li>select：输入框中文本被选中触发</li>\n<li>change：当输入框被修改 且 失去焦点</li>\n</ul>\n</li>\n</ul>\n<p>必须添加到 form 表单元素上</p>\n<ul>\n<li>submit：点击 submit 按钮才触发</li>\n<li>reset：点击 reset 按钮才触发</li>\n</ul>\n<h2> 字段属性</h2>\n<p>共有字段属性</p>\n<ul>\n<li>disabled：布尔值，表示当前字段是否被禁用</li>\n<li>form：指向当前字段所在的表单，只读</li>\n<li>name：当前字段名称</li>\n<li>readOnly：布尔值，表示当前字段是否只读</li>\n<li>tabIndex：表示当前字段 tab 序号</li>\n<li>type：当前字段类型</li>\n<li>value：当前字段将被提交给服务器的值</li>\n</ul>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript 文本选中检测",
      "url": "https://www.h7ml.cn/posts/javascript/form/%E6%96%87%E6%9C%AC%E9%80%89%E4%B8%AD%E6%A3%80%E6%B5%8B.html",
      "id": "https://www.h7ml.cn/posts/javascript/form/%E6%96%87%E6%9C%AC%E9%80%89%E4%B8%AD%E6%A3%80%E6%B5%8B.html",
      "summary": "JavaScript 文本选中检测 选中文本 inp.select(); // 选中文本框中的所有文字 function getSelectedText(text){ if(typeof text.selectionStart == 'number'){ ​ // 选择文字的起始，结束下标 return text.value.substring(text.selectionStart,text.selectionEnd); }else if(document.selecttion){// IE 取得 IE 中的选择文本代码 调用 document.selecttion 不需要考虑 text 参数 return document.selecttion.createRang().text; ​ } }",
      "content_html": "<h1> JavaScript 文本选中检测</h1>\n<h2> 选中文本</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 输入检测</h2>\n<p>检测浏览器是否支持 pattern 属性</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>customError：如果设置了 setCustomValidity()，则为 true，否则返回 false</li>\n<li>patternMismatch：如果值与指定的 pattern 属性不匹配，返回 true</li>\n<li>reangeOverflow：如果值比 max 值大，返回 true</li>\n<li>rangeUnderflow：如果值比 min 值小，返回 true</li>\n<li>stepMisMatch：如果 min 和 max 直接的步长值不合理，返回 true</li>\n<li>tooLong：值的长度超过了 maxlenght 属性指定的长度，返回 true。火狐会自动约束字符数量，所以会永远返回 true</li>\n<li>typeMismatch：如果值不是 'mail' 或 'url' 要求的格式，返回 true</li>\n<li>valid：如果这里的属性都是 false，返回 true。checkValidity() 也要求相同的值</li>\n<li>valueMissing：如果标注为 required 的字段中没有值，返回 true</li>\n</ul>\n<h2> 选择框脚本</h2>\n<ul>\n<li>add（new option, relOption）：向控件中插入行的 &lt;option&gt;</li>\n<li>multiple：布尔值，是否允许多选</li>\n<li>options：控件中所有 &lt;option&gt; 元素的 HTMLCollection</li>\n<li>remove(index)：移除给定位置的选项</li>\n<li>selectedIndex：选中的索引，从 0 开始，没有则是 -1</li>\n<li>size：选择框可见的行数</li>\n</ul>\n<p>每个 &lt;option&gt; 都有一个 HTMLOptionElement 对象</p>\n<ul>\n<li>index：当前选项在 option 集合中的索引</li>\n<li>label：当前选择的标签；等价于 html 中 label 的特性</li>\n<li>selected：布尔值，表示当前选项是否被选中，设为 true 可以选中当前选项</li>\n<li>text：选项的文本</li>\n<li>value：选项的值</li>\n</ul>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript audio 音频 API",
      "url": "https://www.h7ml.cn/posts/javascript/media/audio.html",
      "id": "https://www.h7ml.cn/posts/javascript/media/audio.html",
      "summary": "JavaScript audio 音频 API 标签相关属性 src：要播放的音频/视频的 URL controls：显示音频/视频播放控件 loop：音频/视频结束后重新播放 muted：音频/视频静音 只读属性 duration：文件的播放时长，单位 s，无法获取则 NaN，当触发 canplay 事件后可以获取 paused：是否暂停，返回 true/false ended：是否播放完毕 true/false error：发现错误后返回错误代码 currentSrc：返回字符串形式正在播放或已加载文件，对应浏览器 source 元素中选择的文件 buffered：获取当前缓冲区大小，返回 TimeRanges 对象",
      "content_html": "<h1> JavaScript audio 音频 API</h1>\n<h2> 标签相关属性</h2>\n<ul>\n<li>src：要播放的音频/视频的 URL</li>\n<li>controls：显示音频/视频播放控件</li>\n<li>loop：音频/视频结束后重新播放</li>\n<li>muted：音频/视频静音</li>\n</ul>\n<h2> 只读属性</h2>\n<ul>\n<li>duration：文件的播放时长，单位 s，无法获取则 NaN，当触发 canplay 事件后可以获取</li>\n<li>paused：是否暂停，返回 true/false</li>\n<li>ended：是否播放完毕 true/false</li>\n<li>error：发现错误后返回错误代码</li>\n<li>currentSrc：返回字符串形式正在播放或已加载文件，对应浏览器 source 元素中选择的文件</li>\n<li>buffered：获取当前缓冲区大小，返回 TimeRanges 对象</li>\n</ul>\n<h2> 可控制属性</h2>\n<ul>\n<li>src：指定音频文件位置</li>\n<li>autoplay：是否自动播放</li>\n<li>preload：是否预加载</li>\n<li>loop：是否循环播放</li>\n<li>controls：显示/隐藏用户控制界面</li>\n<li>muted：设置是否静音</li>\n<li>volume：当前音量值，0-1 之间</li>\n<li>currentTime：返回/设置当前播放的时间，单位 s</li>\n</ul>\n<h2> 方法</h2>\n<ul>\n<li>load()：加载视频、音频软件</li>\n<li>play()：播放</li>\n<li>pause()：暂停</li>\n<li>canPlayType(obj)：测试播放后指定的 Mime 类型文件</li>\n</ul>\n<h2> 事件</h2>\n<ul>\n<li>loadstart：客户端开始请求数据</li>\n<li>progress：正在播放的时候不停触发，暂停不会触发，触发事件间隔较大</li>\n<li>play：play() 和 autoplay 时触发，类似 onplaying</li>\n<li>pause：pause() 方法时触发</li>\n<li>ended：结束播放时触发</li>\n<li>timeupdate：播放时间发生改变时触发，暂停不触发，触发事件间隔较小</li>\n<li>canplaythrough：歌曲载入完成</li>\n<li>canplay：缓存至可播放状态，类似事件 onloadedmetadata</li>\n<li>onloadedmetadata：当元数据（如分辨率和时长）被加载时触发</li>\n</ul>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript video 视频 API",
      "url": "https://www.h7ml.cn/posts/javascript/media/video.html",
      "id": "https://www.h7ml.cn/posts/javascript/media/video.html",
      "summary": "JavaScript video 视频 API 标签属性 src：要播放的音频/视频的 URL。 controls：显示音频/视频播放控件 loop：音频/视频结束后重新播放 muted：音频/视频静音 width：播放区宽度 height：播放区高度 poster：预览图片 属性 audioTracks：返回可用音频轨道的 Audio TrackList 对象 autoplay：设置/返回是否在加载完成后播放视频/音频 buffered：返回音频/视频已缓存部分的 timeRanges 对象 controller：返回音频/视频当前媒体控制器的 MediaController 对象 controls：设置/返回音频/视频是否显示控件 crossOrigin：设置/返回音频/视频的 CORS 设置 curretSrc：返回当前音频/视频的 URL currentTime：设置/返回音频/视频中当前播放位置（以秒） defaultMuted：设置/返回音频/视频默认是否静音 defaultPlaybackRate：设置/返回音频/视频的默认播放速度 duration：返回当前音频/视频的长度 s ended：返回音频/视频是否播放结束 error：返回音频/视频发生错误状态的 MediaError 对象 loop：设置/返回是否应在结束时重新播放 mediaGroup：设置/返回音频/视频所属的组合 muted：设置/返回是否静音 networkState：返回当前音频/视频网络状态 paused：设置/返回是否暂停 playbackRate：设置/返回音频/视频播放速度 palyed：返回音频/视频已播放部分 TimeRanges 对象 repload：设置/返回是否在页面加载后加载 readyState：返回音频/视频当前的就绪状态 seekable：返回音频/视频可寻址部分的 TimeRanges 对象 seeking：返回用户是否在音频/视频中进行查找 src：设置/返回当前来源 startDate：返回当前时间偏移的 date 对象 textTracks：返回可用文本轨道的 TextTrackList 对象 videoTracks:返回可用视频轨道的 VideoTrackList 对象 volume:设置/返回音量",
      "content_html": "<h1> JavaScript video 视频 API</h1>\n<h2> 标签属性</h2>\n<ul>\n<li>src：要播放的音频/视频的 URL。</li>\n<li>controls：显示音频/视频播放控件</li>\n<li>loop：音频/视频结束后重新播放</li>\n<li>muted：音频/视频静音</li>\n<li>width：播放区宽度</li>\n<li>height：播放区高度</li>\n<li>poster：预览图片</li>\n</ul>\n<h2> 属性</h2>\n<ul>\n<li>audioTracks：返回可用音频轨道的 Audio TrackList 对象</li>\n<li>autoplay：设置/返回是否在加载完成后播放视频/音频</li>\n<li>buffered：返回音频/视频已缓存部分的 timeRanges 对象</li>\n<li>controller：返回音频/视频当前媒体控制器的 MediaController 对象</li>\n<li>controls：设置/返回音频/视频是否显示控件</li>\n<li>crossOrigin：设置/返回音频/视频的 CORS 设置</li>\n<li>curretSrc：返回当前音频/视频的 URL</li>\n<li>currentTime：设置/返回音频/视频中当前播放位置（以秒）</li>\n<li>defaultMuted：设置/返回音频/视频默认是否静音</li>\n<li>defaultPlaybackRate：设置/返回音频/视频的默认播放速度</li>\n<li>duration：返回当前音频/视频的长度 s</li>\n<li>ended：返回音频/视频是否播放结束</li>\n<li>error：返回音频/视频发生错误状态的 MediaError 对象</li>\n<li>loop：设置/返回是否应在结束时重新播放</li>\n<li>mediaGroup：设置/返回音频/视频所属的组合</li>\n<li>muted：设置/返回是否静音</li>\n<li>networkState：返回当前音频/视频网络状态</li>\n<li>paused：设置/返回是否暂停</li>\n<li>playbackRate：设置/返回音频/视频播放速度</li>\n<li>palyed：返回音频/视频已播放部分 TimeRanges 对象</li>\n<li>repload：设置/返回是否在页面加载后加载</li>\n<li>readyState：返回音频/视频当前的就绪状态</li>\n<li>seekable：返回音频/视频可寻址部分的 TimeRanges 对象</li>\n<li>seeking：返回用户是否在音频/视频中进行查找</li>\n<li>src：设置/返回当前来源</li>\n<li>startDate：返回当前时间偏移的 date 对象</li>\n<li>textTracks：返回可用文本轨道的 TextTrackList 对象</li>\n<li>videoTracks:返回可用视频轨道的 VideoTrackList 对象</li>\n<li>volume:设置/返回音量</li>\n</ul>\n<h2> 方法</h2>\n<ul>\n<li>addTextTrack()：向音频/视频添加新的文本轨道</li>\n<li>canPlayType()：检测浏览器是够能播放指定的音频/视频类型</li>\n<li>load()：重新加载音频/视频</li>\n<li>play()：开始播放音频/视频</li>\n<li>pause()：暂停音频/视频</li>\n</ul>\n<h2> 事件</h2>\n<ul>\n<li>abort：当音频/视频的加载已放弃时触发</li>\n<li>canplay：当浏览器可以开始播放音频/视频时触发</li>\n<li>canplaythrough：当浏览器在不因缓冲而停顿的视口下进行播放时触发</li>\n<li>durationchange：音频/视频的时长发生改变时触发</li>\n<li>emptied：目前播放列表为空时触发</li>\n<li>ended：播放列表结束时触发</li>\n<li>error：音频/视频加载期间发生错误时触发</li>\n<li>loadeddata：当音频/视频已加载当前帧时触发</li>\n<li>loadedmetadata：当浏览器已加载音频/视频的元数据时触发</li>\n<li>loadstart：当浏览器开始查找音频/视频时触发</li>\n<li>pause：音频/视频暂停时触发</li>\n<li>play：音频/视频一开始或不在暂停时触发</li>\n<li>playing：音频/视频因缓冲而暂停或停止后已就绪时触发</li>\n<li>progress：当浏览器正在下载音频/视频时触发</li>\n<li>ratechange：音频/视频的播放速度已更改时触发</li>\n<li>seeked：用户开始移动/跳跃到音频/视频新的位置时触发</li>\n<li>seeking：开始移动到/跳跃到音频/视频新的位置时触发</li>\n<li>stalled：当浏览器尝试获取媒体数据，但数据不可用时触发</li>\n<li>suspend：浏览器刻意不获取媒体数据时触发</li>\n<li>timeupdate：当目前播放位置已更改时触发</li>\n<li>volumechange：当音量已更改时触发</li>\n<li>waiting：当视频由于需要缓冲下一帧而停止时触发</li>\n</ul>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "javascript 面向对象",
      "url": "https://www.h7ml.cn/posts/javascript/object-oriented/",
      "id": "https://www.h7ml.cn/posts/javascript/object-oriented/",
      "content_html": "",
      "date_published": "2022-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "JavaScript cookie",
      "url": "https://www.h7ml.cn/posts/javascript/store/cookie.html",
      "id": "https://www.h7ml.cn/posts/javascript/store/cookie.html",
      "summary": "JavaScript cookie 存储格式 name=value;[expires=date];[path=path];[domain=somewhere.com];[secure]，",
      "content_html": "<h1> JavaScript cookie</h1>\n<h2> 存储格式</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>键 = 值; 后续中括号的内容，都是可选项。</p>\n<p>火狐支持缓存 cookie，谷歌只支持服务器缓存 cookie</p>\n<ul>\n<li>[expires=date]：'expires=过期时间'</li>\n<li>[path=path]：设置的 cookie 的路径\n<ul>\n<li>如果不设置，默认是加载当前.html 文件的路径</li>\n<li>设置的 cookie 的路径，和加载当前文件的路径，必须一致，如果不一致，cookie 访问失败。</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>[<a href=\"http://domain=somewhere.com\" target=\"_blank\" rel=\"noopener noreferrer\">domain=somewhere.com</a>]：domain 限制访问域名\n<ul>\n<li>如果不去设置，默认是加载当前 .html 文件的服务器域名 /ip</li>\n<li>如果加载当前文件域名和设置的域名不一致，设置 cookie 失败。不能设置</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>secure\n<ul>\n<li>如果不设置，设置 cookie，可以通过 http/https 协议加载文件设置</li>\n<li>设置字段后，只能 https 协议加载 cookie.</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 获取 cookie</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 设置 cookie</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 转码储存</h2>\n<ul>\n<li>encodeURIComponent()：将中文编译成对应的字符</li>\n<li>decodeURIComponent()：将对应的字符编译成中文</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 转码获取</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 删除 cookie</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> setCookie 封装</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> getCookie 封装</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> removeCookie 封装</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> cookie 封装</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript localStorage",
      "url": "https://www.h7ml.cn/posts/javascript/store/localStorage.html",
      "id": "https://www.h7ml.cn/posts/javascript/store/localStorage.html",
      "summary": "JavaScript localStorage 存储时间 localStorage（IE8 以下不兼容） 永久存储 最大存储 5M 客户端的微型数据库 只能存储 string cookie 可以设置过期时间 最大存 4KB 每一个域名下面最多可以存储 50 条数据 sessionStorage（结合后台使用、关闭窗口存储的数据清空）",
      "content_html": "<h1> JavaScript localStorage</h1>\n<h2> 存储时间</h2>\n<ul>\n<li>\n<p>localStorage（IE8 以下不兼容）</p>\n<ul>\n<li>永久存储</li>\n<li>最大存储 5M 客户端的微型数据库</li>\n<li>只能存储 string</li>\n</ul>\n</li>\n<li>\n<p>cookie</p>\n<ul>\n<li>可以设置过期时间</li>\n<li>最大存 4KB</li>\n<li>每一个域名下面最多可以存储 50 条数据</li>\n</ul>\n</li>\n<li>\n<p>sessionStorage（结合后台使用、关闭窗口存储的数据清空）</p>\n</li>\n</ul>\n<h2> localStorage 对象</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript sessionStorage",
      "url": "https://www.h7ml.cn/posts/javascript/store/sessionStorage.html",
      "id": "https://www.h7ml.cn/posts/javascript/store/sessionStorage.html",
      "summary": "JavaScript sessionStorage 常用于后台服务端控制前端存储数据 或用户登录信息，但与 localstore 主要不同的是只在会话期间有效 // 设置键 值 sessionStorage.setItem('key', 'value'); sessionStorage.key = 'value'; // 获取对应键值 变量 = sessionStorage.getItem('key'); 变量 = sessionStorage.key; // 删除键值 sessionStorage.removeItem(name); // 删除对应键 sessionStorage.clear();",
      "content_html": "<h1> JavaScript sessionStorage</h1>\n<ul>\n<li>常用于后台服务端控制前端存储数据</li>\n<li>或用户登录信息，但与 localstore 主要不同的是只在会话期间有效</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript Array 数组对象-数据类型",
      "url": "https://www.h7ml.cn/posts/javascript/types/Array.html",
      "id": "https://www.h7ml.cn/posts/javascript/types/Array.html",
      "summary": "JavaScript Array 数组对象-数据类型 创建 new Array(10); // 一个值是数组的长度，值为 empty（空 new Array('1', '3'); // 多个值与字面量一样",
      "content_html": "<h1> JavaScript Array 数组对象-数据类型</h1>\n<h2> 创建</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>利用 length 可以在末尾添加一项</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>转换方法</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 改变原数组（7 个方法）</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 不改变原数组</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 数组迭代</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>reduce 计算数组总和</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>利用 reduce 第二个参数，计算对象下某个值的总和</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果没有 reduce 第二个参数，prev 初始值会是数组的第一项，设置初始值为 0 与下一项累加即可</p>\n<h2> 类数组</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>条件:</p>\n<ol>\n<li>键为 0 1 2 3 的数字字符串（数组 0 1 2 也会被默认调用 tostring 以字符串存储为键）</li>\n<li>有 length 属性</li>\n<li>绑定 splice 为 Array 原型上的方法此时输出的 obj 为数组</li>\n</ol>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript Date 时间对象-数据类型",
      "url": "https://www.h7ml.cn/posts/javascript/types/Date.html",
      "id": "https://www.h7ml.cn/posts/javascript/types/Date.html",
      "summary": "JavaScript Date 时间对象-数据类型 创建日期 ​new Date(); // 英文 星期几 月 日 年 时:分:秒 地区 ​new Date(Date.parse(\"may 25 , 2004\")) // 以传入的时间为起始 ​new Date(Date.UTC(2005 , 4 , 5 , 17 , 5, 55)) // UTC时间 ​new Date(\"2005,4,5,5,17,5,55\") // 本地时间 年月日 ​var start = Date.now() // 取得开始时间，调用函数 ​var stop = Date.now() // 取得结束时间 ​var start1 = new Date(); // 取得开始时间，调用函数 ​var stop1 = new Date();// 取得结束时间 ​Date.parse(\"2020-1-3\");// 取得传入时间的时间戳",
      "content_html": "<h1> JavaScript Date 时间对象-数据类型</h1>\n<h2> 创建日期</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果直接把表示日期的字符串传给<code>Date</code>构造函数，那么<code>Date</code>会在后台调用<code>Date.parse()</code></p>\n<h2> 时间格式化</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 时间组件</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 利用 Date 对象获取某个月有多少天</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>获取 2021 年 9 月份有多少天，字符串 10 月，天数 -1 时会退回至 9 月，getDate 获取当前天数即可，而不再是使用 switch</p>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript Error 错误对象-数据类型",
      "url": "https://www.h7ml.cn/posts/javascript/types/Error.html",
      "id": "https://www.h7ml.cn/posts/javascript/types/Error.html",
      "summary": "JavaScript Error 错误对象-数据类型 EvalError：eval()的使用与定义不一致 RangeError：数值越界 一个数字超出它的边界时抛出。该错误在正常的代码执行中非常罕见 ReferenceError：非法或不能识别的引用 期望的对象不存在时抛出 SyntaxError：有语法错误时抛出 TypeError：变量不是期望的类型时抛出 URIError：URI 处理函数使用不当给 encodeURI(), encodeURIComponent(), decodeURI() 或者 decodeURIComponent() 等函数传递格式非法的 URI 字符串时抛出",
      "content_html": "<h1> JavaScript Error 错误对象-数据类型</h1>\n<ul>\n<li>EvalError：eval()的使用与定义不一致</li>\n<li>RangeError：数值越界 一个数字超出它的边界时抛出。该错误在正常的代码执行中非常罕见</li>\n<li>ReferenceError：非法或不能识别的引用 期望的对象不存在时抛出</li>\n<li>SyntaxError：有语法错误时抛出</li>\n<li>TypeError：变量不是期望的类型时抛出</li>\n<li>URIError：URI 处理函数使用不当给 encodeURI(), encodeURIComponent(), decodeURI() 或者 decodeURIComponent() 等函数传递格式非法的 URI 字符串时抛出</li>\n</ul>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript function 函数对象-数据类型",
      "url": "https://www.h7ml.cn/posts/javascript/types/Function.html",
      "id": "https://www.h7ml.cn/posts/javascript/types/Function.html",
      "summary": "JavaScript function 函数对象-数据类型 函数分类 普通命名函数 通过名字调用执行 function fn() {}",
      "content_html": "<h1> JavaScript function 函数对象-数据类型</h1>\n<ul>\n<li>函数分类\n<ul>\n<li>普通命名函数</li>\n<li>通过名字调用执行</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>事件处理函数\n<ul>\n<li>可以是匿名函数也可以是匿名函数，通过元素对象的事件触发来执行</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>构造函数\n<ul>\n<li>通过 new 运算符来执行</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>回调函数\n<ul>\n<li>在主函数中满足一定条件调用执行 匿名函数也可以是命名函数</li>\n</ul>\n</li>\n<li>表达式函数：将一个函数 赋值给一个变量 通过函数名的调用执行</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>匿名函数：闭包</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> callee 与 caller</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 改变 this 指向</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">注意第一个参数传 null 为不改变 this 指向 :::</p>\n<h2> 函数的 length 属性</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> name 属性</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></div>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript Math 数学对象-数据类型",
      "url": "https://www.h7ml.cn/posts/javascript/types/Math.html",
      "id": "https://www.h7ml.cn/posts/javascript/types/Math.html",
      "summary": "JavaScript Math 数学对象-数据类型 最大最小值 Math.max(1, 3, 4, 5, 9); // 最大值 Math.min(1, 3, 4, 5, 9); // 最小值 Math.max.apply(Math, [2, 3, 6]); // 最大值 Math.min.apply(Math, [2, 3, 6]); // 最小值",
      "content_html": "<h1> JavaScript Math 数学对象-数据类型</h1>\n<h2> 最大最小值</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 舍入</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 其他方法</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> ES6 扩展方法</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript Number 数字对象-数据类型",
      "url": "https://www.h7ml.cn/posts/javascript/types/Number.html",
      "id": "https://www.h7ml.cn/posts/javascript/types/Number.html",
      "summary": "JavaScript Number 数字对象-数据类型 let intNum = 55; // 整数 // 八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值0~7） let octalNum1 = 070; // 八进制的56 let octalNum2 = 079; // 无效的八进制值，当成79 处理 let octalNum3 = 08; // 无效的八进制值，当成8 处理 // 十六进制字面量，必须让真正的数值前缀0x（区分大小写），然后是十六进制数字（0~9 以及A~F） let hexNum1 = 0xa; // 十六进制10 let hexNum2 = 0x1f; // 十六进制31",
      "content_html": "<h1> JavaScript Number 数字对象-数据类型</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>浮点值</li>\n</ul>\n<p>科学记数法的格式跟一个大写或小写的字母 e，再加上一个要乘的 10 的多少次幂，浮点值的精确度最高可达 17 位小数</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>方法</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>NaN</li>\n</ul>\n<p>分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 Infinity 或-Infinity</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>isNaN 首先会调用对象的 valueOf() 方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 toString() 方法，并测试其返回值</p>\n<h2> Number.isFinite()</h2>\n<ul>\n<li>没有隐式的 Number() 类型转换，所有非数值都返回 false</li>\n<li>检查一个数值是否为有限的（ finite ），即不是 Infinity</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Number.isInteger()</h2>\n<ul>\n<li>判断一个数是不是整数</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 数值转换</h2>\n<ul>\n<li>null，返回 0。</li>\n<li>undefined，返回 NaN。</li>\n<li>字符串：\n<ul>\n<li>Number(\"1\")返回 1，Number(\"123\")返回 123，Number(\"011\")返回 11</li>\n<li>浮点数同样忽略前面的 0</li>\n<li>16 进制转换为对应的 10 进制整数值</li>\n</ul>\n</li>\n<li>对象，调用 valueOf()方法，再执行上面的规则。如果是 NaN，则调用 toString()方法，再按照字符串的规则转换。</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>parseInt()\n<ul>\n<li>字符串最前面的空格会被忽略</li>\n<li>第一个字符不是数值、加号或减号，立即返回 NaN</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>parseInt()也接收第二个参数，指定进制数</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>parseFloat 解析到一个无效的浮点数值字符为止\n<ul>\n<li>始终忽略字符串开头的零</li>\n<li>十六进制数值始终会返回 0，因为 parseFloat() 只解析十进制值</li>\n</ul>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript Object 对象-数据类型",
      "url": "https://www.h7ml.cn/posts/javascript/types/Object.html",
      "id": "https://www.h7ml.cn/posts/javascript/types/Object.html",
      "summary": "JavaScript Object 对象-数据类型 Object.create() Object.create(prototype, [descriptors]);",
      "content_html": "<h1> JavaScript Object 对象-数据类型</h1>\n<h2> Object.create()</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>返回一个新对象</li>\n<li>新对象的<strong>proto</strong>指向第一个参数。参数可以为 null,即没有原型对象</li>\n<li>要添加的属性以及配置</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Object.defineProperty()</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>直接操作参数 1 obj 地址</li>\n<li>propName: 添加的键名[两个参数时 = 配置选项的 value 值]</li>\n<li>descriptor: 配置选项</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ol>\n<li>可以多次调用 Object.defineProperty() 方法修改同一个属性，但把 configurable 设置为 false 之后就会报错。</li>\n<li>当使用了 getter 或 setter 方法，不允许使用 writable 和 value 这两个属性。如果使用，会直接报错</li>\n</ol>\n<h2> Object.defineProperties()</h2>\n<p>Object.defineProperties(obj, props)</p>\n<ul>\n<li>obj：要修改的对象</li>\n<li>props：属性值</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Object.assign()</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ul>\n<li>后面的 sources 源对象 拷贝到 target 目标对象上</li>\n<li>返回 target 对象</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>会调用源对象的 [[Get]]</li>\n<li>和目标对象的 [[Set]]</li>\n</ul>\n<h2> Object.keys()</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Object.values()</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Object.entries()</h2>\n<ul>\n<li>\n<p>遍历键和值</p>\n</li>\n<li>\n<p>以二维数组的形式，将对象中的每个键名和键值，进行数组分解。</p>\n</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Object.getOwnPropertyNames()</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>包含 constructor</p>\n<p>不包含 Symbol 属性</p>\n<h2> Object.getOwnPropertySymbols()</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Object.getOwnPropertyDescriptors()</h2>\n<p>返回同时包含常规和符号(symbol)属性描述符的对象，都没有则返回空对象</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> <a href=\"http://Object.is\" target=\"_blank\" rel=\"noopener noreferrer\">Object.is</a>()</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Object.getPrototypeOf()</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Object.freeze()</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Object.seal()</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Object.hasOwnProperty()</h2>\n<p>返回属性名是否在实例属性上</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "javascript 数据类型",
      "url": "https://www.h7ml.cn/posts/javascript/types/",
      "id": "https://www.h7ml.cn/posts/javascript/types/",
      "content_html": "",
      "date_published": "2022-03-30T00:00:00.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [
        {
          "name": "h7ml"
        }
      ],
      "tags": [
        "javascript"
      ]
    },
    {
      "title": "JavaScript RegExp 正则表达式对象-数据类型",
      "url": "https://www.h7ml.cn/posts/javascript/types/RegExp.html",
      "id": "https://www.h7ml.cn/posts/javascript/types/RegExp.html",
      "summary": "JavaScript RegExp 正则表达式对象-数据类型 修饰符 g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。 i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。 m：多行模式，表示查找到一行文本末尾时会继续查找。 y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。 u：Unicode 模式，启用 Unicode 匹配。 s：dotAll 模式，表示元字符,匹配任何字符（包括\\n 或\\r）。",
      "content_html": "<h1> JavaScript RegExp 正则表达式对象-数据类型</h1>\n<p>修饰符</p>\n<ul>\n<li>g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</li>\n<li>i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。</li>\n<li>m：多行模式，表示查找到一行文本末尾时会继续查找。</li>\n<li>y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。</li>\n<li>u：Unicode 模式，启用 Unicode 匹配。</li>\n<li>s：dotAll 模式，表示元字符,匹配任何字符（包括\\n 或\\r）。</li>\n</ul>\n<h2> 实例属性</h2>\n<ul>\n<li>global：布尔值，表示是否设置了 g 标记。</li>\n<li>ignoreCase：布尔值，表示是否设置了 i 标记。</li>\n<li>unicode：布尔值，表示是否设置了 u 标记。</li>\n<li>sticky：布尔值，表示是否设置了 y 标记。</li>\n<li>lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。</li>\n<li>multiline：布尔值，表示是否设置了 m 标记。</li>\n<li>dotAll：布尔值，表示是否设置了 s 标记。</li>\n<li>source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。</li>\n<li>flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。</li>\n</ul>\n<h2> 方法</h2>\n<h3> test()</h3>\n<ul>\n<li>test：检测字符串是否匹配正则 如果匹配 返回 true 不匹配返回 false 表单验证的返回值</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> macth()</h3>\n<ul>\n<li>全局 返回所有匹配字符串组成的一个数组。</li>\n<li>非全局 返回匹配到的第一个字符串数组，且会返回该字符串的下标及相关信息。</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> exec()</h3>\n<ul>\n<li>全局模式 有一个自己的 lastIndex 值 引导下次进行 exec 匹配的起始位置。</li>\n<li>非全局模式下进行字符串的匹配 结果和 macth 一样</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 正则预查询</h3>\n<p>判断括号内表达式</p>\n<p>返回 ---&gt; 括号外表达式</p>\n<ul>\n<li>正向肯定</li>\n</ul>\n<p>(?=):</p>\n<p>表达式 1(?= 表达式 2)</p>\n<p>返回 --&gt; 前面是表达式 1</p>\n<p>后面是表达式 2</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>正向否定</li>\n</ul>\n<p>(?!):</p>\n<p>表达式 1(?!表达式 2)</p>\n<p>返回 ---&gt; 前面是表达式 1</p>\n<p>后面不是表达式 2</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>反向肯定</li>\n</ul>\n<p>(?&lt;=):</p>\n<p>(?&lt;=表达式 2)表达式 1</p>\n<p>前面是表达式 2</p>\n<p>返回 ---&gt; 后面是表达式 1</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>反向否定</li>\n</ul>\n<p>(?&lt;!):</p>\n<p>(?&lt;!表达式 2)表达式 1</p>\n<p>前面不是表达式 2</p>\n<p>返回 ----&gt; 表达式 1</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 元字符</h2>\n<ul>\n<li>\n<p>单个字符</p>\n<ul>\n<li>. 匹配除换行外单个的任意字符</li>\n<li>[范围] 匹配单个范围内的字符</li>\n<li>[0-9] 匹配单个 数字</li>\n<li>[^范围] 匹配单个范围内除括号内的字符</li>\n<li>[^0-9] 匹配单个 非数字</li>\n<li>[a-zA-Z0-9_] 匹配单个 数字、字母、下划线_</li>\n<li>\\w 匹配单个 数字、字母、下划线 等价于 [a-zA-Z0-9_]</li>\n<li>\\W 匹配单个 非数字、字母、下划线</li>\n<li>\\d 匹配单个 数字 等价于 [0-9]</li>\n<li>\\D 匹配单个 非数字 等价于 [^0-9]</li>\n</ul>\n</li>\n<li>\n<p>重复字符</p>\n<ul>\n<li>x 代表任意的单个字符</li>\n<li>x? 匹配 0 个或 1 个 x /goog?le/ 要么是 google 要么是 goole</li>\n<li>x+ 匹配最少 1 个字符</li>\n<li>x* 匹配任意个 x 字符</li>\n<li>x{m,n} 匹配至少 m 个，最多 n 个（包括 n</li>\n<li>x{n} 必须匹配 n 个字符</li>\n<li>(xyz)+ 小括号括起来的部分是当做单个字符处理</li>\n</ul>\n</li>\n<li>\n<p>空白字符</p>\n<ul>\n<li>\\s 匹配任意单个空白字符（空格 制表 回车</li>\n<li>\\S 匹配任意单个非空白字符</li>\n<li>\\b 单词边界</li>\n<li>\\B 非单词边界</li>\n</ul>\n</li>\n<li>\n<p>锚字符</p>\n<ul>\n<li>^ 行首匹配/^google/</li>\n<li>$ 行尾匹配/google$/</li>\n</ul>\n</li>\n<li>\n<p>替代字符</p>\n<ul>\n<li>| 或 /google|baidu|bing/</li>\n</ul>\n</li>\n<li>\n<p>转义字符</p>\n<ul>\n<li>\\.</li>\n<li>\\*</li>\n</ul>\n</li>\n<li>\n<p>验证字符串是否存中文</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div></li>\n</ul>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript String 字符串对象-数据类型",
      "url": "https://www.h7ml.cn/posts/javascript/types/String.html",
      "id": "https://www.h7ml.cn/posts/javascript/types/String.html",
      "summary": "JavaScript String 字符串对象-数据类型 '\\u03a3'.length; // 1 // 转义序列表示一个字符，所以只算一个字符。如果包含双节字符可能导致 length 不准确",
      "content_html": "<h1> JavaScript String 字符串对象-数据类型</h1>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>字符串是不可变的，一旦创建，值就不能变了。字符串的方法都是返回新的值。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>刚开始 lang 包含字符串\"Java\"，接着，lang 被重新定义为包含\"Java\"和\"Script\"的组合\"JavaScript\"。整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上\"Java\"和\"Script\"。最后销毁原始的字符串\"Java\"和字符串\"Script\"，所有处理都是在后台发生的。</p>\n<h2> 转换为字符串</h2>\n<p>几乎所有值都有的 toString()方法，字符串 toString()方法只是简单地返回自身的一个副本，null 和 undefined 值没有</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>String()</li>\n</ul>\n<p>因为 null 和 undefined 没有 toString()方法，就直接返回了字面量文本。</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">注意用加号操作符给一个值加上一个空字符串\"\"也可以将其转换为字符串 :::</p>\n<h2> 取值</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 截取</h2>\n<ul>\n<li>不会对原始字符串修改，返回值的副本</li>\n<li>只有一个参数，截取到字符结束</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol>\n<li>起始下标，结束下标 -1</li>\n<li>起始大于结束，会互换</li>\n<li>起始为负数，默认变 0</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol>\n<li>起始下标，结束下标-1</li>\n<li>起始大于结束，不换位，返回空字符串</li>\n<li>出现负值，为倒数 = length + 负数</li>\n</ol>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><ol>\n<li>起始下标，截取位数</li>\n<li>出现负值，为倒数 = length + 负数</li>\n</ol>\n<h2> 位置查询</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 分隔/拼接</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 编辑/替换</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 大小写转换</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>带 Locale 是针对地区的转换，Unicode 码可能存在不同，如土耳其地区需要对应的特殊规则才能转换，所以最好使用地区特定的转换方法。</p>\n<h2> URI 编码方法</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> eval()</h2>\n<ul>\n<li>解析字符串 js 代码</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>当开启严格模式后 eval 会存在作用域</p>\n</div>\n</div>\n<h2> localeCompare()</h2>\n<ul>\n<li>比较字符串在字母表的前后</li>\n<li>在前面返回 1</li>\n<li>在后面返回 -1</li>\n</ul>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript 数组去重排序",
      "url": "https://www.h7ml.cn/posts/javascript/types/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%8E%92%E5%BA%8F.html",
      "id": "https://www.h7ml.cn/posts/javascript/types/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%8E%92%E5%BA%8F.html",
      "summary": "JavaScript 数组去重排序 数组去重 var arr = [9, 9, 0, 0, 2, 3, 2, 3, 5]; var a = []; arr.forEach(function (item, index, arr) { if (a.indexOf(item) == -1) { // if(a.includes(item)){ // 或 a.push(item); } });",
      "content_html": "<h1> JavaScript 数组去重排序</h1>\n<h2> 数组去重</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 冒泡排序</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 选择排序</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 递归排序</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "JavaScript 数据类型分类",
      "url": "https://www.h7ml.cn/posts/javascript/types/%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB.html",
      "id": "https://www.h7ml.cn/posts/javascript/types/%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB.html",
      "summary": "JavaScript 数据类型分类 变量声明分为字面量创建和构造函数（实例化）创建 构造函数创建 typeof 检测数据类型都为 object 原生对象：String，Number，Boolean，Function，object，Array，Date，Error，RegExp，global，Math 内置对象：global，Math 宿主对象：DOM，BOM 全局对象：window（document 属于 window 下） 事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成 Global 对象的属性。（包括isNaN()、isFinite()、parseInt()和 parseFloat()）",
      "content_html": "<h1> JavaScript 数据类型分类</h1>\n<ol>\n<li>变量声明分为字面量创建和构造函数（实例化）创建</li>\n<li>构造函数创建 typeof 检测数据类型都为 object</li>\n<li>原生对象：String，Number，Boolean，Function，object，Array，Date，Error，RegExp，global，Math</li>\n<li>内置对象：global，Math</li>\n<li>宿主对象：DOM，BOM</li>\n<li>全局对象：window（document 属于 window 下）</li>\n</ol>\n<p>事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成 Global 对象的属性。（包括<code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code>和 <code>parseFloat()</code>）</p>\n",
      "date_published": "2023-05-03T04:52:44.000Z",
      "date_modified": "2023-05-03T04:52:44.000Z",
      "authors": [],
      "tags": []
    }
  ]
}